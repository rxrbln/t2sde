#!/bin/bash
#
# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: scripts/Create-ErrList
# Copyright (C) 2004 - 2007 The T2 SDE Project
# Copyright (C) 1998 - 2003 ROCK Linux Project
# 
# More information can be found in the files COPYING and README.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License. A copy of the
# GNU General Public License can be found in the file COPYING.
# --- T2-COPYRIGHT-NOTE-END ---

config=default
repstat=0
showerr=0
showtree=0
showdepc=0
delete=0
remove=0
fulldelete=0
newdelete=0
newremove=0
onlyupdated=0

repository=""
stages="[0123456789]"
copydir=""
movedir=""
logdir=""

# uninstall sysroot package
uninstall_pkg()
{
	pushd $1 > /dev/null
	cut -d ' ' -f 2- var/adm/flists/$2 | tac | while read fn; do
		if [ -d "$fn" ]; then rmdir "$fn" 
		else rm -f "$fn"; fi
	done
	popd > /dev/null
}

while [ "$1" ] ; do
        case "$1" in
	    -cfg)
		config=$2     ; shift ; shift ;;

	    -repstat)
		repstat=1     ; shift ;;

	    -showerr)
		showerr=1     ; shift ;;

	    -showtree)
		showtree=1    ; shift ;;

	    -showdepc)
		showdepc=1    ; shift ;;

	    -repository)
		if [ $2 != '!' ] ; then
			repository=" $2 " ; shift ; shift
			while [ "$1" -a -d "package/$1" ] ; do
				repository="$repository $1 " ; shift
			done
		else
			shift ; shift ; repository=""
			for x in $( ls package/ ) ; do
				[ -d "package/$x" ] &&
					repository="$repository $x"
			done
			repository="$repository "
			while [ "$1" -a -d "package/$1" ] ; do
				repository="${repository// $1 / }" ; shift
			done
		fi
		;;

	    -stage)
		stages="[$2]" ; shift ; shift ;;

	    -logdir)
		logdir=$2     ; shift ; shift ;;

	    -copydir)
		copydir=$2    ; shift ; shift ;;

	    -movedir)
		movedir=$2    ; shift ; shift ;;

	    -delete)
		delete=1      ; shift ;;

	    -remove)
		remove=1      ; shift ;;

	    -fulldelete)
		fulldelete=1  ; shift ;;

	    -newdelete)
		newdelete=1   ; shift ;;

	    -newremove)
		newremove=1   ; shift ;;

	    -updated)
		onlyupdated=1 ; shift ;;

	    -dry-run)
	        dryrun=1      ; shift ;;

	    -*)
x="${0//?/ }" ; x="${x#         }"
echo "Usage: $0 [ -cfg config ] [ -repository repository ] \\"
echo "  $x [ -copydir copydir | -movedir movedir ] [ -repstat ] \\"
echo "  $x [ -stage stage ] [ -logdir logdir ] [ -remove ] [ -[full]delete -new[remove|delete] \\"
echo "  $x [ -updated ] [ -showerr ] [ -showtree ] [ -showdepc ] \\"
echo "  $x [ -dry-run ] [ <package> ]"
		exit 1 ;;

	    *)
		break ;;
        esac
done

. scripts/parse-config
. scripts/functions.in

logdir="${logdir:-build/$SDECFG_ID/var/adm/logs}"

if [ "$newdelete" = 1 -o "$newremove" = 1 ]; then
	while read pkg cksum1
	do
		cksum2=$( pkgchksum package/*/$pkg/ )
		if [ "$cksum1" != "$cksum2" ]; then
			if [ "$newdelete" = 1 ]; then
				echo "Removing package '$pkg' ..."
				[ "$dryrun" = "1" ] || uninstall_pkg build/$SDECFG_ID $pkg
				[ "$dryrun" = "1" ] || rm -f build/$SDECFG_ID/var/adm/*/?-$pkg.*
			else
				echo "Scheduling package '$pkg' for rebuild ..."
				[ "$dryrun" = "1" ] || rm -f build/$SDECFG_ID/var/adm/*/?-$pkg.*
			fi
		fi
	done < <(
		grep -R '^\(ROCK Linux\|T2\) Package Source Checksum: ' \
		     build/$SDECFG_ID/var/adm/packages/ |
		sed 's,.*/\([^:]*\):.*:,\1,'
	)
	exit 0
fi

if [ "$repstat" = 1 ] ; then
    {
	echo
	echo -e "Repository\tPkg Total\tPkg OK\tPkg Error"
	echo
	total_pkgt=0 ; total_pkgo=0 ; total_pkge=0
	for x in $( cd package ; echo [a-z0-9]* ) ; do
		pkgt=0 ; pkgo=0 ; pkge=0
		for y in $( cd package/$x ; echo [a-z0-9]* ) ; do
			if [ "$( ls $logdir/$stages-$y.err 2> /dev/null )" ]
				then (( pkge++ )) ; (( total_pkge++ ))
			elif [ "$( ls $logdir/$stages-$y.log 2> /dev/null )" ]
				then (( pkgo++ )) ; (( total_pkgo++ ))
			fi
		done
		(( pkgt = pkgo + pkge )) ; (( total_pkgt += pkgt ))
		[ $pkgt != 0 ] && echo -e "$x\t$pkgt\t$pkgo\t$pkge"
	done
	echo
	echo -e "total\t$total_pkgt\t$total_pkgo\t$total_pkge"
	echo
    } | {
	expand -t20,35,50 | sed 's,^,      ,'
    }
    exit 0
fi

if [ "$1" ] ; then
	if [ "$fulldelete" = 1 ] ; then
		for x ; do
			rm -vf "$logdir"/$stages-$x.{err,log,out}
			rm -vf "$logdir"/../*/$x
		done
	elif [ "$remove" = 1 ] ; then
		for x ; do  
			echo "Scheduling package '$x' for rebuild ..."
			uninstall_pkg build/$SDECFG_ID $x
			rm -f build/$SDECFG_ID/var/adm/*/$stages-$x.{err,log,out}
		done
	elif [ "$delete" = 1 ] ; then
		for x ; do rm -vf "$logdir"/$stages-$x.{err,log,out} ; done
	else
		for x ; do less "$logdir"/$stages-$x.err ; done
	fi
	exit 0
fi

echo
echo "Error logs from $SDECFG_ID:"
[ $showerr = 0 ] && echo

count_pkg=0
count_err=0
count_log=0

for stagelevel in $( echo "$stages" | tr -d '[]' | sed 's,.,& ,g' ) ; do
	while read x x x tree pkg x ; do
		[ "$repository" -a \
			"${repository/ $tree /}" = "$repository" ] && continue

		this_is_error=0
		if [ $onlyupdated != 0 ] ; then
			[ "$( bash scripts/xfind.sh package/*/$pkg -newer "$logdir/$stagelevel-$pkg.err" -o -newer "$logdir/$stagelevel-$pkg.log" )" ] && this_is_error=1
		elif [ -f "$logdir/$stagelevel-$pkg.err" ] ; then
			this_is_error=1
		fi

		if [ $this_is_error = 1 ] ; then
			if [ $showerr = 0 ] ; then
				if [ $showdepc != 0 ]; then
					d=$( ./scripts/Check-Deps-3 $stagelevel \
						$pkg config/$config/packages | \
						cut -f3 -d' ' | sort -u | wc -l )
					d="$( printf " %3d" $d )"
				else
					d=""
				fi
				echo "[$stagelevel]$d ${tree:0:13}/${pkg:0:18}"
			else
			  echo ; echo "== $stagelevel-$pkg.* =="
			  tail -n 20 "$logdir/$stagelevel-$pkg".* | \
			  tac | perl -e '
			    my @lines;
			    my $counter;
			    while (<>) {
				chomp;
				$lines[$#lines+1] = $_;
			    }
			    for ($counter=0; $counter <= $#lines; $counter++) {
				$_=$lines[$counter];
				if ( /^checking for .*\.\.\. *Package / ||
				     /configure: error:/ ) {
					for ($_=1; $_ <= $counter; $_++) {
						print "$lines[$_]\n";
					}
					exit 0;
				}
			    }
			    for ($counter=0; $counter <= $#lines; $counter++) {
				$_=$lines[$counter];
				if ( /^(make\S*): / ) {
					my $makeprefix=$1;
					my $output="$_\n";
					while ( defined
						    ($_=$lines[$counter++]) ) {
						last unless /^(make\S*): /;
						$output="" if $1 ne $makeprefix;
						$makeprefix=$1;
						$output.="$_\n";
					}
					print $output; exit 0;
				}
			    }
			    foreach (@lines) {
				print "$_\n";
			    }
			  ' | tac | fold -s -w79
			  depcheck() {
				echo "${1}\`---> $3"
				for x in `grep -lwi $3 $logdir/*.err | \
					sed 's,.*/.-,,; s,\.err,,' | sort -u`
				do
					[ "$x" = "$3" ] && continue
					[ "${2/ $x /}" != "$2" ] && continue
					depcheck "${1}  " "$2 $3 " $x
				done
			  }
			  [ $showtree = 1 ] && depcheck "" "" $pkg
			fi
			if [ "$copydir" ] ; then
				mkdir -p "$copydir"
				cp "$logdir/$stagelevel-$pkg.err" "$copydir"
			fi
			if [ "$movedir" ] ; then
				mkdir -p "$movedir"
				mv "$logdir/$stagelevel-$pkg.err" "$movedir"
			fi
			if [ "$fulldelete" -eq 1 ] ; then
				rm -f "$logdir"/$stages-$pkg.{err,log,out}
				rm -f "$logdir"/../*/$pkg
			elif [ "$delete" -eq 1 ] ; then
				rm -f "$logdir/$stagelevel-$pkg.err"
			fi
			count_err=$(( $count_err + 1 ))
		elif [ -f "$logdir/$stagelevel-$pkg.log" ] ; then
			count_log=$(( $count_log + 1 ))
		fi
		count_pkg=$(( $count_pkg + 1 ))
	done < <( grep "^X [0-9-]*$stagelevel" config/$config/packages )
done > >(
	if [ $showerr = 0 ] ; then
		paste - - | expand -t40 | sed 's,^, ,'
	else cat ; fi
)

sleep 1
echo
echo "$count_pkg builds total, $count_log completed fine," \
     "$count_err with errors, $(( count_pkg - count_log - count_err )) to go."
echo

