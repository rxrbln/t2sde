#!/bin/sh
# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: scripts/functions
# Copyright (C) 2004 - 2005 The T2 SDE Project
# Copyright (C) 1998 - 2003 ROCK Linux Project
# 
# More information can be found in the files COPYING and README.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License. A copy of the
# GNU General Public License can be found in the file COPYING.
# --- T2-COPYRIGHT-NOTE-END ---

# This function returns a "uniqe id" as output
#
get_unique() {
	local hostsum=`hostname`
	if [ -z "$hostsum" -a -x /sbin/ip ]; then
		hostsum=`/sbin/ip link show eth0 |
		sed -e '/link\//!d' -e 's,.*link[^ ]* \([^ ]*\) .*,\1,'`
	fi
	if [ -z "$hostsum" -a -f /sbin/ifconfig ]; then
		hostsum=`/sbin/ifconfig eth0 |
		sed -e '/HWaddr/!d' -e 's/.* HWaddr \([^ ]*\)/\1/'`
	fi
	if [ -z "$hostsum" -a -x /usr/bin/hostid ]; then
		hostsum=`/usr/bin/hostid`
	fi
	date "+%Y%m%d.%H%M%S.$$.$hostsum"
}

# bz2filename [<filename>]
# outputs filename converted to .bz2. stdin and $1 inputs are accepted
#
bz2filename() {
	local pattern='-e s,\.\(t\?\)\(gz\|Z\)$,.\1bz2,'
	pattern="-e s,\.gpg$,, $pattern"
	if [ -n "$1" ]; then
		echo "$1" | sed $pattern
	else
		sed $pattern
	fi
}

# Hook variables
#
unset hook_functions hook_fcounter
declare -a hook_functions='()'
hook_fcounter=0

# This function adds a code fragment to a named hook with the named priority
#
# hook_add hook_name priority code
#
hook_add() {
	hook_functions[hook_fcounter]="$3" # declare -a hookidx_$1
	eval "hookidx_$1[\${#hookidx_$1[@]}]=\"$2 $hook_fcounter\""
	eval "(( hookdirty_$1++ ))" || true ; (( hook_fcounter++ )) || true
}

# This function executes all code fragments from the named hook
#
# hook_eval hook_name
#
hook_eval() {
	while read pri fnr ; do
		[ "$pri" ] && eval "${hook_functions[fnr]}"
	done < <( IFS=$'\n' ; eval "echo \"\${hookidx_$1[*]}\"" | sort )
	eval "unset hookdirty_$1"
}

# This function prints all hooks and their current contents
#
# hook_dump
#
hook_dump() {
	for hook in ${!hookidx_*} ; do
		hook=${hook#hookidx_}
		echo ; echo "Contents of hook $hook:"
		
		while read pri fnr ; do
			echo ; echo "    $pri ($fnr)"
			echo "${hook_functions[fnr]}" | sed 's,^,	,'
		done < <( IFS=$'\n'
		          eval "echo \"\${hookidx_$hook[*]}\"" | sort )
		if eval "[ -n \"\$hookdirty_\$hook\" ]"; then
			echo ; echo -n "    Hook is marked as dirty: "
			eval "echo \"\${hookdirty_$hook}\""
		fi
	done
	echo
}

# This functions append, insert or remove values in variables:
#
#	var_append PATH ":" "$HOME/bin"
#	var_insert CC_WRAPPER_INSERT " " "-O3"
#	var_remove CC_WRAPPER_INSERT " " "-O3"
#
#	var_remove_regex CC_WRAPPER_INSERT " " "-O.*"
#
#	var_insert_before_regex patchfiles " " "mypatch.diff" ".*\/foo.diff"
#
# 1st Parameter: Variable Name
# 2nd Parameter: Delimiter Text
# 3rd Parameter: Value (or regex)
# 4th Parameter: regex for insert_before
#
var_append() {
	eval "[ \"\$$1\" ] && $1=\"\${$1}$2\"" || true
	eval "$1=\"\${$1}\$3\""
}
var_insert() {
	eval "[ \"\$$1\" ] && $1=\"$2\$$1\"" || true
	eval "$1=\"\$3\$$1\""
}
var_remove() {
	local a=${2//\/\\/}
	local b=${3//\/\\/}
	eval '[ "$'$1'" = "$3" ] && '$1'="" || true'
	eval $1'="${'$1'//$a$b$a/$2}"'
	eval $1'="${'$1'%$a$b}"'
	eval $1'="${'$1'#$b$a}"'
}
var_remove_regex() {
	eval "$1=\"\`echo \"\$$1\" | awk -- ' { split(\$0, a, \"$2\"); for (c1=c2=1; c1 in a; c1++) if ( a[c1] !~ /^$3\\\$/ ) b[c2++]=a[c1]; for (c1=1; c1 in b; c1++) printf \"%s%s\", (c1 > 0 ? \"$2\" : \"\"), b[c1]; }'\`\""
}
var_insert_before_regex() {
	eval "$1=\"\`echo \"\$$1\" | awk -- '{ split(\$0, a, \"$2\"); for (d=c1=c2=1; c1 in a; c1++) { if ( d && a[c1] ~ /^$4\\\$/ ) { b[c2++]=\"$3\"; d=0; } b[c2++]=a[c1]; } if (d) b[c2++]=\"$3\"; for (c1=1; c1 in b; c1++) printf \"%s%s\", (c1 > 0 ? \"$2\" : \"\"), b[c1]; }'\`\""
}

# This function can be used to duplicate a shell-function. E.g. when
# overwriting a shell-function but the old one should stay available under
# a new name:
#
#	copy_function set_confopt set_confopt_foobar_old
#
#	set_confopt() {
#		....
#		set_confopt_foobar_old "$@"
#		....
#	}
#
copy_function() {
	eval "$( declare -f $1 | sed "1 s,$1,$2," )"
}

# | column_clean |
#
# convert tabs to spaces, transform multiple consecutive spaces to one,
# remove leading and trailing spaces
column_clean() {
	tr '\t' ' ' | tr -s ' ' | sed -e 's,^[ ]*,,; s,[ ]*$,,;'
}

# | column_clean_tab |
#
# see column_clean, but with tabs
column_clean_tab() {
	tr ' ' '\t' | tr -s '\t' | sed -e 's,^[\t]*,,; s,[\t]*$,,;'
}

# This function sets the 'confopt' and some other variables.
# Re-run it in the package .conf file if you modify $prefix
#
set_confopt() {
	local x= z=
	prefix=${prefix#/}

	[ $stagelevel -eq 0 ] && z="$root"

	confopt="--prefix=$z/$prefix"

	for x in bindir sbindir libdir datadir includedir \
	    docdir infodir mandir sysconfdir localstatedir
	do
		# bindir=/usr/bin
		eval "$x=`pkggetdir $x`"
		# --bindir=$root\$bindir
		[ "$x" != docdir ] &&
			confopt="$confopt --$x=$z\$$x"	

	done

	if [ "$SDECFG_CONFIGURE_OPTS" ] ; then
		confopt="$confopt $SDECFG_CONFIGURE_OPTS"
	fi

	if [ "$SDECFG_DEBUG" = 0 ] ; then
		confopt="$confopt --disable-debug"
	fi

	if [ "$stagelevel" -le 1 -o "$SDECFG_DISABLE_NLS" = 1 ] ; then
		confopt="${confopt//--enable-nls/} --disable-nls"
	fi

	confopt="$confopt \$extraconfopt"
	if [ "$stagelevel" -eq 0 ]; then
		confopt="$confopt --target=\$arch_target --host=\$arch_build"
	else
		confopt="$confopt --build=\$arch_build --host=\$arch_target"
	fi
}

#
# eval_config_command $( eval echo $confopt )
#
function eval_config_command() {
	local config_command

	for x in /usr/share/automake/*
	do
		[ -x "$x" -a -f "$x" ] || continue
		x="$( basename "$x" )"
		if [ -L $x -a ! -e $x ] ; then
			echo "Fixing dead symlink $x."
			ln -sf /usr/share/automake/$x .
		fi
	done

	if [ $stagelevel -le 1 ] ; then
		create_config_cache >> config.cache
		grep -q '.--cache-file=' $configscript &&
			set -- "$@" "--cache-file=./config.cache"
		export cache_file=./config.cache
	fi

	config_command="$configprefix $configscript"
	sub_scripts="$( find $( dirname $configscript ) -name configure )"

	# remove unsupported config script options
	for x ; do
		if grep -q "[[ ]${x%%=*}[]= ):]" $configscript $sub_scripts ; then
			config_command="$config_command $x"
		elif [[ $x = --*able-* ]] && egrep -q "\-\-(en|dis)able-\*" $configscript ; then
			echo "Autodetection for option impossible: " \
			     "$x passed thru."
			config_command="$config_command $x"
		else
			echo "Removing unsupported '$x' from" \
			     "configure option string."
		fi
	done

	echo Running "$config_command"
	eval "$config_command"
}

# run 'make check' if Makefile supports it.
#
function run_check() {
	if grep -q -e "^check:" ./Makefile; then
		echo "Running make check ..."
		$MAKE check
	fi
	if grep -q -e "^test:" ./Makefile; then
		echo "Running make test ..."
		$MAKE test
	fi
}

# move the static libs from lib to usr/lib and correct the libdir used
# inside the .la file
#
postflist_static_lib() {
	echo "Processing static lib corrections ..."
	egrep '^(lib|lib64)/.*\.(a|la)$' $builddir/flist.txt |
	while read fn ; do
		[ -e $root/$fn -o -L $root/$fn ] || continue
		if [[ $fn = *.a ]] ; then
			mv -fv $root/$fn $root/usr/$fn
		else
			sed "s,\([ =']\)/lib\(.*\),\1/usr/lib\2,g" \
				$root/$fn > $root/usr/$fn
			rm $root/$fn
		fi
		add_flist $root/usr/$fn
	done

	# this check might be removed in the future when we decide this is not
	# an issue anymore ...
	echo "Verifing the .la files ..."
	defect_la="`egrep '(lib|lib64)/.*\.la$' $builddir/flist.txt |
	            xargs egrep 'dependency_libs=.*-pthread.*' |
	            cut -d : -f1 | sort -u | tr '\n' ' '`"
	if [ "$defect_la" ] ; then
		abort "-pthread in: $defect_la!"
	fi
}

# Parse the *.desc file. Use the description from PKG-DESC-FORMAT and
# save the tag data in $desc_*.
#
parse_desc() {
	tag="`grep '^\[' $base/misc/share/PKG-DESC-FORMAT |
	      sed 's, (\*),,; s,\] \[,|,g; s,\[,,; s,\],,;'`"

	for tag in $tag ; do
		tagdata="`egrep "^\[($tag)\]" $confdir/$1.desc |
		          cut -f2- -d']' | sed 's,^ ,,'`"
		tag="`echo $tag | cut -f1 -d'|' | tr - _`"
		eval "desc_$tag=\"\$tagdata\""
	done

	ver="`echo "$desc_V" | tail -n 1 | cut -f1 -d' '`"
	extraver="`echo "$desc_V" | tail -n 1 | cut -s -f2- -d' '`"
	[ -z "$extraver" ] && extraver="${sdever//DEV-*/DEV}"
}

# This function is used for forcing a file to be in the flist
#
add_flist() {
	for addfile ; do
		echo "$addfile" | fl_wrparse -D -r "$xroot/" \
			>> $builddir/flist.txt
	done
}

# This function is used for forcing a package to be in the dependency list
#
add_dependency() {
	for addpackage ; do
		echo "$addpackage: add_dependency()" \
					>> $builddir/dependencies.debug
	done
}

# This function is used to subsitute some important variables
# using a D_ prefix thru m4 ...
rock_substitute() {
	sed -e s,D_prefix,$prefix,g   -e s,D_sysconfdir,$sysconfdir,g \
	    -e s,D_docdir,$docdir,g   -e s,D_localstatedir,$localstatedir,g \
	    -e s,D_datadir,$datadir,g -e s,D_infodir,$infodir,g \
	    -e s,D_bindir,$bindir,g   -e s,D_sbindir,$sbindir,g \
	    -e s,D_libdir,$libdir,g   -e s,D_mandir,$mandir,g \
	    -e s,D_ver,$ver,g          $1
}

# This outputs a predefined config.cache file as it needed by some
# packages to cross-build correctly in stages 0 and 1.
#
create_config_cache() {
	cat $base/scripts/config.cache
	echo -e "\n# Architecture specific stuff\n"
	echo "ac_cv_sizeof_short=$arch_sizeof_short"
	echo "ac_cv_sizeof_int=$arch_sizeof_int"
	echo "ac_cv_sizeof_long=$arch_sizeof_long"
	echo "ac_cv_sizeof_long_long=$arch_sizeof_long_long"
	echo "ac_cv_sizeof_char_p=$arch_sizeof_char_p"
	echo "ac_cv_c_bigendian=$arch_bigendian"
	echo "ac_cv_prog_CC=$CC"
}

# Abort build before actual build starts
# (is overwritten in Build-Pkg)
#
abort() {
	echo -e "The package build aborted with the following config" \
	     "error:\n$*" > $root/var/adm/logs/$stagelevel-$xpkg.err
	echo_errorquote "`cat $root/var/adm/logs/$stagelevel-$xpkg.err`"
	echo_pkg_abort $stagelevel $repository $xpkg
	exit 1
}

# Dump Environment
#
dump_env() {

	# Dump $base - only set if there is not already an older value.
	#
	echo "base=\"\${base:-$base}\""

	# Dump all variables including their flags, but skip read-only
	# variables and $base.
	#
	# Substitute base directory with ${base}.
	#
	for name in ${!a*} ${!b*} ${!c*} ${!d*} ${!e*} ${!f*} ${!g*} ${!h*} \
	            ${!i*} ${!j*} ${!k*} ${!l*} ${!m*} ${!n*} ${!o*} ${!p*} \
	            ${!q*} ${!r*} ${!s*} ${!t*} ${!u*} ${!v*} ${!w*} ${!x*} \
	            ${!y*} ${!z*}					    \
	            ${!A*} ${!B*} ${!C*} ${!D*} ${!E*} ${!F*} ${!G*} ${!H*} \
	            ${!I*} ${!J*} ${!K*} ${!L*} ${!M*} ${!N*} ${!O*} ${!P*} \
	            ${!Q*} ${!R*} ${!S*} ${!T*} ${!U*} ${!V*} ${!W*} ${!X*} \
	            ${!Y*} ${!Z*} ${!_*}
	do
		[ $name = base -o $name = PWD ] && continue
		if declare -p $name | head -n 1 | grep -qv '^declare -[a-z]*r'
		then
			declare -p $name | sed "s,\\(^\\|[\"=:]\\)$base\\([\"=:/]\\|\$\\),\\1\${base}\\2,g"
		fi
	done

	# Dump functions
	#
	declare -f | sed 's/^declare -f //; s/<<(/< <(/;'

	# Dump aliases
	#
	alias
}

# Check if a package is already installed
#
# It does check the build-list if not in the rebuild stage - and
# the really installed package data for rebuilds (and so manual builds).
#
pkginstalled() {
	if [ "$stagelevel" -le 8 ] ; then
		local pattern="$1"; pattern="${pattern//+/\\+}"
		egrep -q "^X.* ($pattern) " $base/config/$config/packages
	else
		[ -f $root/var/adm/packages/$1 ]
	fi
}

# pkgprefix [-t] [<type>] <package>
# returns the prefix or the location of a 'type' of an already build package
#
pkgprefix() {
	local type= pkg=
	local dotest= abortmsg=
	local prefix= value=

	# -t : only see if it's possible to get the values
	if [ "$1" = "-t" ]; then
		dotest=1; shift
	fi
	
	if [ $# -eq 2 ]; then
		type="$1"; shift
	fi
	pkg="$1"

	# test usual error causes
	if [ -z "$pkg" ]; then
		abortmsg="you must specify a package"
	elif [ ! -f "$root/var/adm/packages/$pkg" ]; then
		abortmsg="package $pkg is not present"
	elif grep -q "^Prefix:" "$root/var/adm/packages/$pkg"; then
		prefix=$( grep "^Prefix: " "$root/var/adm/packages/$pkg" | cut -d' ' -f2- )
	else
			abortmsg="$pkg record is old, please rebuild"
	fi

	if [ "$dotest" ]; then
		# test mode: abort or continue
		if [ "$abortmsg" ]; then
			abort "pkgprefix: $abortmsg"
		else
			return 0
		fi
	elif [ "$abortmsg" ]; then
		echo "pkgprefix: $abortmsg" 1>&2
	elif [ -z "$type" -o "$type" = "prefix" ]; then
		value="$prefix"
	else
		value=$( grep "^Location $type: " "$root/var/adm/packages/$pkg" | cut -d' ' -f3- )
		if [ -z "$value" ]; then
			# try default location for that $prefix
			value=$( xpkg="$pkg"; pkggetdir "$type" )
		fi
	fi
	echo "${value:-PKGPREFIX_ERROR}"
}

# pkggetdir <type>     (needs $prefix and $xpkg)
# returns the location for the file of a 'type' considering it's prefix
#
pkggetdir() {
	case "$1" in
		bindir)  echo "/$prefix/bin"	;;
		sbindir) echo "/$prefix/sbin"	;;
		libdir)
		  case $arch in
			powerpc64|sparc64|x86-64)
				echo "/$prefix/lib64"	;;
			*)
				echo "/$prefix/lib"	;;
		  esac
		  ;;
		datadir) if [ -z "$prefix" ]; then
				echo "/usr/share"
			 else
				echo "/$prefix/share"
			 fi	;;
		infodir) if [ -z "$prefix" ]; then
				echo "/usr/info"
			 else
				echo "/$prefix/info"
			 fi	;;
		mandir) if [ -z "$prefix" ]; then
				echo "/usr/man"
			 else
				echo "/$prefix/man"
			 fi	;;
		docdir) if [ -z "$prefix" ]; then
				echo "/usr/doc/$xpkg"
			 else
				echo "/$prefix/doc/$xpkg"
			 fi	;;

		includedir) if [ -z "$prefix" ]; then
				echo "/usr/include"
			    else
				echo "/$prefix/include"
			    fi	;;

		sysconfdir)
			case "$prefix" in
				opt/*)	echo "/etc/$prefix"	;;
				usr)	echo "/etc"		;;
				*)	echo "${prefix:+/$prefix}/etc"	;;
			esac	;;
		localstatedir)
			case "$prefix" in
				opt/*)	echo "/var/$prefix"	;;
				usr)	echo "/var"		;;
				*)	echo "${prefix:+/$prefix}/var"	;;
			esac	;;
	esac
}


# This function generates the T2 package checksum of $confdir.
# The checksum includes the filenames and content (except of the .cache),
# including subdirs but without whitespaces and comments and some tag lines
# that are not vital for rebuilds during update checks.
#
# pkgchksum package-name | full-patch
#
pkgchksum() {
  (
	# expand to full patch if only a package name was specified
	[[ $1 == */* ]] || set $base/package/*/$1/
	cd $1
	# find all files (without hidden (e.g. .svn) files)
	find . ! -path '*/.*' ! -name '*.cache' -print -exec cat \{\} \; \
	2>/dev/null |
	# strip some unimportant stuff (e.g. comments, whitespaces, ...)
	sed \
	-e '/^[ ]*#.*/d' \
	-e '/^\[COPY\]/d' \
	-e '/^\[CV-*\]/d' \
	-e '/^\[[T,I,U,A,M,L,S,C]\]/d' \
	-e 's/[\t ]*//g' \
	-e '/^ *$/d' |
	md5sum | cut -d ' ' -f 1
  )
}

# Register a window-manager
#
register_wm() {
	[ -e $root/usr/share/rock-registry/wm ] ||
		mkdir -p $root/usr/share/rock-registry/wm
	echo -e "name=\"$2\"\nexec=\"$3\"\n" > $root/usr/share/rock-registry/wm/$1
}

# Register an application
#
register_application() {
	[ -e $root/usr/share/rock-registry/app ] ||
		mkdir -p $root/usr/share/rock-registry/app
	echo -e "name=\"$2\"\nexec=\"$3\"\n" > $root/usr/share/rock-registry/app/$1
}

# Register a xdm - display manager
#
register_xdm() {
	[ -e $root/usr/share/rock-registry/xdm ] ||
		mkdir -p $root/usr/share/rock-registry/xdm
	echo -e "name=\"$2\"\nexec=\"$3\"\n" > $root/usr/share/rock-registry/xdm/$1
}

# Create Package Database for gasgui install tool
#
create_package_db() {
	rm -f $3.tmp
	for file in $( ls -dr $1/descs/?* ) ; do
		pkg="${file##*/}"
		# only include the package if a binary file is available

		if [ "$SDECFG_PKGFILE_VER" = 1 ] ; then
			v=-$(grep '^Package Name and Version' \
                                $1/packages/$pkg | cut -f6 -d' ')
		else
			v=""
		fi
		if [ "$SDECFG_CREATE_GEM" = 1 ] ; then
			bfile=${pkg}${v}.gem
		else
			bfile=${pkg}${v}.tar.bz2
		fi

		if [ -e $2/$bfile ] ; then
			[ "$pkg" = TRANS.TBL ] && continue

			( echo -e "$pkg"
			  echo -e "\027"

			  cat $1/descs/$pkg
			  echo -e "\027"

			  cat $1/dependencies/$pkg
			  echo -e "\027"

			  cat $1/cksums/$pkg
			  echo -e "\027"

			  echo -e "\004"
			) >> $3.tmp
		else
			echo_error "Binary file for $bfile not present." \
			           "Skipped in package database."
		fi
	done
	gzip -c $3.tmp > $3 ; rm -f $3.tmp
}

# Add files to the 'badfiles' list
#
register_badfiles() {
	local x desc="$1"
	shift

	for x in "$@"; do
		var_append badfiles $'\n' " $x\$"
		badfiles_desc[$badfiles_nr]=" $x\$"$'\n'"$desc"
		(( badfiles_nr++ ))
	done
}

# Detect the available patchfiles
#
detect_patchfiles()
{
	patchfiles="`ls $confdir/*.patch $confdir/*.patch.$arch \
	             $confdir/*.patch_$xpkg $confdir/*.patch_$xpkg.$arch \
	             $targetdir/pkg_$pkg.patch $targetdir/pkg_$pkg.patch.$arch \
	             $targetdir/xpkg_$xpkg.patch \
	             $targetdir/xpkg_$xpkg.patch.$arch 2>/dev/null |
	             tr '\n' ' '`"
}

# Apply the given $patchfiles
#
apply_patchfiles() {
	for x in $patchfiles; do
		# correct the abolute path - e.g  for patchfiles supplied
		# in the .desc file
		# we assume relative path patches are mirrorables //mnemoc
		if [ ! -e "$x" -a -n "${x##*/*}" ] ; then
			x="$base/download/mirror/${x:0:1}/$x"
		fi

		echo "Apply patch $x ..."

		if [[ $x = *.bz2 ]] ; then
			bzcat $x | patch $patchopt
		else
			patch $patchopt < $x
		fi
		eval "$@"
        done
}

# Main program for building a package
#
build_this_package() {
	if [ ".$desc_SRC" == "." ] ; then
		# Autodetect source tar and extract it
		#
		if [ "$srctar" = auto ] ; then
			xsourceballs=$( echo "$desc_D" | head -n 1 | tr ' ' '\t' | tr -s '\t' |
				cut -f2 | bz2filename )
			if [ -z "$xsourceballs" ] ; then
				echo "Can't auto-detect srctar for package '$xpkg'!"
				false
			fi
		else
			xsourceballs="$srctar"
		fi
	elif [ "$srctar" = auto ] ; then
		sourceballs=$( echo "$desc_D" | tr ' ' '\t' | tr -s '\t' |
			cut -f2 | bz2filename )
		xsrcpattern=$( echo "$desc_SRC" | tr ' ' '\t' | tr -s '\t' | tr '\t' '\n' )
		xsourceballs=$( echo "$sourceballs" | grep -F "$xsrcpattern" )
	else
		xsourceballs="$srctar"
	fi
	for xsrctar in $xsourceballs; do
		saved_patchfiles="$patchfiles"
		var_append patchfiles " " \
		           "`ls $confdir/*.patch.${xsrctar/-[v0-9]*/} 2> /dev/null`"
		if [ $autoextract = 1 ]; then
			echo "Extracting $xsrctar ($taropt) ... "
			cd $builddir
			tar -v $taropt $archdir/$xsrctar | tee untar.txt |
				sed 's,^\./,,' | cut -f1 -d/ |
				sort -u > xsrcdir.txt
			#
			if [ "$srcdir" = auto ]; then
				xsrcdir=${xsrctar%.tar.bz2}
				xsrcdir=${xsrcdir%.tbz2}
				if [ ! -d $xsrcdir ] ; then
					for x in $pkg-$ver ${pkg}_$ver $pkg \
					         $xpkg-$ver ${xpkg}_$ver $xpkg \
					         "$( cat xsrcdir.txt )"
					do
						[ -d "$x" ] && xsrcdir="$x"
					done
				fi
			else
				xsrcdir="$srcdir"
			fi
			#
			if [ "$chownsrcdir" = 1 ]; then
				echo "Fixing ownership and permissions ..."
				chown -R 0:0 $builddir/$xsrcdir
			fi
			#
			if [ "$nocvsinsrcdir" = 1 ]; then
				echo "Removing CVS, .svn, {arch} and .arch-ids directories ..."
				egrep '(^|/)(CVS|\.svn|\{arch\}|\.arch-ids)(/|$)' untar.txt |
				while read x; do
					echo "Removing $x ..."
					rm -rf "$x"
				done
			fi
			#
			echo "Changeing into $builddir/$xsrcdir ..."
			cd $builddir/$xsrcdir

			# Apply patches
			#		
			if [ $autopatch = 1 ]; then
				hook_eval prepatch
				apply_patchfiles	
				hook_eval postpatch
			fi

		else
			cd $builddir
		fi

		if [ "$createprefix" = 1 ]; then
			echo "Creating $root/$prefix/<..> if required ..."
			for x in $root/$docdir $root/$prefix/{bin,lib,share} \
			         $root/$sysconfdir $root/$localstatedir
			do
				if [ ! -e $x ]; then
					mkdir -p $x
					rmemptydir="$rmemptydir $x"
				fi
			done
		fi
		
		if [ ".$custmain" = "." ]
		then
			hook_eval preconf

			# Maybe generate a configure first
			#
			if [ $autogen -eq 1 -o \
			     \( -f autogen.sh -a ! -f configure \) ] ; then
				if [ -f autogen.sh ] ; then
					echo "Running package autogen script."
					sh autogen.sh
				else
					echo "Running builtin autogen script."
					libtoolize --force --automake ; aclocal
					if grep AM_INIT_AUTOMAKE \
					   configure.[ia][nc]
					then automake ; fi
					autoconf
				fi
			fi
			# Run configure scripts etc.
			#
			if [ $runconf = 1 ]; then 
			  if [ -n "$( type -p $configscript )" -o $autogen = 1 ]
			  then
				eval_config_command $( eval echo $confopt )
			  fi
			fi

			# automated package build

			# styles without make run first:
			if [ -f setup.py -a $runpysetup = 1 ] ; then
				pyconfopt="${pyconfopt:=--prefix $root/$prefix}"
				hook_eval premake
				eval python setup.py build install $pyconfopt
				hook_eval postmake
			else # styles that include a make run
				if [ ! -f Makefile -a ! -f makefile -a \
				     -f Makefile.PL -a $runmkpl = 1 ]; then
					perl Makefile.PL ${plconfopt:-INSTALLDIRS=perl}
				fi
				#
				if [ ! -f Makefile -a ! -f makefile -a \
				     -f Imakefile -a $runxmkmf = 1 ]; then
					xmkmf -a
				fi
				#
				# Build it
				#
				hook_eval premake
				if [ "$makeopt" ]; then
					eval echo "Running $MAKE $makeopt."
					eval "$MAKE $makeopt"
				fi
				hook_eval inmake
				if [ "$makeinstopt" ]; then
					eval echo "Running $MAKE $makeinstopt."
					eval "$MAKE $makeinstopt"
				fi
				hook_eval postmake
			fi
		else
			eval "$custmain"
			for x in preconf premake inmake postmake; do
				if eval "[ -n \"\$hookdirty_$x\" ]"; then
					echo "Hook $x is still marked as dirty ..."
					hook_eval $x
				fi
			done
		fi

		if [ "$createdocs" != 0 ]; then
			if [ ! -e $root/$docdir ]; then
				mkdir -p $docdir
				rmemptydir="$rmemptydir $root/$docdir"
			fi
			[ -z "$createdocs" ] && createdocs="$SDECFG_CREATE_DOCS"
		fi

		for file in $confdir/*.desktop ; do 
			[ -f $file ] || continue
	
			echo -n "Install desktop file '$file': "

			mkdir -p $root/usr/share/rock-registry/app

			rock_substitute $file > \
			  $root/usr/share/rock-registry/app/`basename $file`
		done


		echo "Trying to copy the default documentation ..."
		for x in [A-Z][A-Z]* *.lsm ChangeLog*; do
			[ "${x#*.[cho0-9]}" ] || continue
			[ "${x#*.info*}"    ] || continue
			[ "${x#*.TAR*}"     ] || continue
			[ "${x#*akefile*}"     ] || continue
                        [ -f $x ] && cp -v $x $root/$docdir/$x
		done

		if [ "$createdocs" = 1 ]; then
			echo "Trying to copy even more documentation ..."
			[ -d $builddir/$xsrcdir ] && cd $builddir/$xsrcdir
			for x in `find -type d \( -name 'doc' -o -name 'docs' \
			               -o -name '[Dd]ocumentation' \) ! -empty`
			do
				if [ -d "$x" -a "`echo $x/*`" != "$x/*" ]
				then cp -rLv $x/* $root/$docdir || true ; fi
			done
			for x in $confdir/*.doc; do
				if [ -f $x ]
				then cp -v $x $root/$docdir/${x%.doc}; fi
			done
			find $root/$docdir/ -name '*.[0-9]' -o -name '*.info*' \
				-o -name '[Mm]akefile*' |
				xargs -r rm -f 2> /dev/null || true
			find $root/$docdir/* -type d -empty 2> /dev/null |
				xargs -r rmdir 2> /dev/null || true
		fi

		hook_eval postdoc
		if [ $stagelevel -ge 2 -a -f /sbin/ldconfig ] ; then
			echo "Running ldconfig ..."
			ldconfig
		fi
		patchfiles="$saved_patchfiles"
	done
  
	if [ "$rmemptydir" ]; then
		rmdir $rmemptydir 2> /dev/null || true
	fi

	return 0
}

# source_file cksum file url
#
# Create the file path from 'file' and 'url'.
# cksum and url are ignored
# ([D] tag compatible format)
#
source_file() {
	local pre="" file="$2" url="$3" mirror="mirror"

	# '-' as $url prefix means, nomirrorable
	[ "${url:0:1}" == "-" ] && mirror="local"
	
	# inside Build-Pkg $archdir is set
	if [ -n "$archdir" ]; then
		pre=$base/; file="$( bz2filename $file )"
	fi
    
	echo ${pre}download/${mirror}/${file:0:1}/$file
}

# match_source_file [-p] pattern [[package] ...]
#
# returns path and name of a downloaded file from a list of packages, matching a grep pattern
# without -p it only returns it's name, not the path.
#
match_source_file() {
	local pattern= package= showpath=0
	local x= file= url= mirror=
	local found=1

	if [ "$1" == "-p" ]; then
		showpath=1; shift
	fi
	pattern="$1"; shift

	for package in ${*:-$pkg}; do
		while read x x file url x; do
			file="$( bz2filename $file )"
			found=0

			if [ $showpath -eq 0 ]; then
				echo $file
			else
				[ "${url:0:1}" == "-" ] && mirror="local" || mirror="mirror"
				echo $base/download/${mirror}/${file:0:1}/$file
			fi
		done < <( grep -e "^\[D\].*$pattern" $base/package/*/$package/$package.desc )
	done
	return $found
}

# create the virtual $archdir symlinks
#
populate_archdir()
{
	while read l_cksum l_srctar l_url l_flags ; do
		[ -z "$l_cksum" ] && continue
		x=`source_file l_cksum $l_srctar $l_url $l_flags`
		if [ ! -f $x ]; then
			echo "File not found: ${x#$base/}"
			echo "Did you run ./scripts/Download for this package?"
			false
		fi
		[ -e $builddir/archdir/"`basename $x`" ] \
			|| ln -vs $x $builddir/archdir/
	done < <( echo "$desc_D" | column_clean )
}

# search for the package confdir
#
detect_confdir()
{
	confdir=""
	if [ -z "$pkgdir" ] ; then
	  for x in package/*/$pkg/$pkg.desc ; do
		if [ -f "$x" ] ; then
		  if [ "$confdir" ] ; then
			echo_pkg_deny $stagelevel $pkg "in multiple trees"
			echo "Package in multiple trees: $pkg !" \
			  > $root/var/adm/logs/$stagelevel-$xpkg.err
			exit 1
		  fi
		  x=${x#package/}; x=${x%%/*}
		  confdir="$base/package/$x/$pkg"
		  repository=$x
		fi
	  done
	else
	  if [ -f "$pkgdir/$pkg.desc" ] ; then
		confdir="$pkgdir"
		repository=extern
	  fi
	fi
}

# initialize standard vars and hooks
#
init_vars_and_hooks()
{
	makeopt='CC="$CC" CPP="$CPP" CXX="$CXX"'

	if [ $stagelevel = 0 ] ; then
		makeopt="$makeopt"' prefix="$root/$prefix"'
	else
		makeopt="$makeopt"' prefix="/$prefix"'
	fi

	if [ $stagelevel -le 1 ] ; then
		makeopt="$makeopt"' CC_FOR_BUILD="$BUILDCC"'
		makeopt="$makeopt"' BUILDCC="$BUILDCC" BUILD_CC="$BUILD_CC"'
		makeopt="$makeopt"' HOSTCC="$HOSTCC"   HOST_CC="$HOST_CC"'
		makeopt="$makeopt"' STRIP="$STRIP" AR="$AR" LD="$LD"'
		makeopt="$makeopt"' RANLIB="$RANLIB" NM="$NM"'
	fi

	if [ $stagelevel -gt 1 ] ; then
		flistdel="$flistdel|`echo $base | sed s,^/,,`/.*"
	fi

	if [ $stagelevel -eq 1 ] ; then
		makeinstopt="$makeopt"' DESTDIR="$root" DEST_DIR="$root"'
		makeinstopt="$makeinstopt"' INSTROOT="$root" install'
	else
		makeinstopt="$makeopt"' install'
	fi

	custmain=""

	[ "$SDECFG_DO_CHECK" = 1 ] && hook_add inmake 6 'run_check'
	hook_add postflist 3 'postflist_static_lib'

	configprefix="" ; autogen=0
	configscript="./configure" ; extraconfopt=""

	srcdir=auto ; srctar=auto
	taropt="--use-compress-program=bzip2 -xf"

	mainfunction="build_this_package"
	runconf=1 ; runxmkmf=1 ; runmkpl=1 ; runpysetup=1 ; autopatch=1
	autoextract=1 ; chownsrcdir=1 ; nocvsinsrcdir=1;
	patchopt="-bfp1 -z .orig"
	createprefix=1 ; createdocs="" ; rmemptydir=""

	check_shared=1
	check_usrlocal=1
	check_badfiles=1

	badfiles="" badfiles_nr=0
	declare -a badfiles_desc
}

# this is a 2nd lightweight and modular "build this package" implementation
# currently only used for the postlinux stuff - later maybe for more -ReneR
#
build_package()
{
  (
	pushd $base

	pkg="$1" ; xpkg="$pkg"
	conffile="$2" ; [ "$conffile" ] || conffile="$pkg.conf"

	unset hook_functions hook_fcounter
	declare -a hook_functions='()'
	hook_fcounter=0
	init_vars_and_hooks

	detect_confdir
	detect_patchfiles

	parse_desc $pkg

	# Erase positional parameters to prevent unintended parameter 
	# passing. We do not want to pass the current positional parameters
	# to the loaded script.
	set --
	eval "$desc_O"

	if [ -f $targetdir/pkg_$pkg.conf ] ; then
	  echo_status "Reading package configuration from target directory."
	  . $targetdir/pkg_$pkg.conf

	elif [ -f $confdir/$conffile ] ; then
	  echo_status "Reading package configuration ($conffile) from package directory."
	  . $confdir/$conffile
	fi

	# short path - to not abort on missing downloads of postlinux.conf
	# packages that are not built anyway -ReneR
	if [ "$custmain" = "true" ] ; then
		echo "Nothing is going to be done ayway - returning quickly."
		return
	fi

	populate_archdir
	popd

	echo "Running main build function '$mainfunction' ..."
	cd $builddir ; eval "$mainfunction"
  )
}

