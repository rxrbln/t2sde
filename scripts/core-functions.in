#!/bin/bash
# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: scripts/core-functions.in
# Copyright (C) 2004 - 2007 The T2 SDE Project
# Copyright (C) 1998 - 2003 ROCK Linux Project
# 
# More information can be found in the files COPYING and README.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License. A copy of the
# GNU General Public License can be found in the file COPYING.
# --- T2-COPYRIGHT-NOTE-END ---

# mktemp alias if the host-system does require -t
__mktemp=`mktemp 2>/dev/null`
if [ -z "${__mktemp}" ]; then
	mktemp() {
		`which mktemp` -t tmp "$@"
	}
else
	rm -f ${__mktemp}
fi
unset __mktemp

# translates a architecture name as of uname into the verbose t2 name
#
uname2arch()
{
	sed -e s/i.86/x86/ -e s/ppc/powerpc/ -e s/x86_64/x86-64/ -e s/sh.$/superh/
}

# translates a architecture name os of t2 into the short uname name
#
arch2uname()
{
	sed -e s/x86$/i386/ -e s/powerpc/ppc/ -e s/x86-64/x86_64/ -e s/blackfin/bfin/ -e s/superh/sh/
}

# translate a architecture to the 32bit subset
#
arch2arch32()
{
	sed -e s/[-_]*64// -e s/x86/i686/
}

# revert the order of the tokens
get_reverted() {
	local queue=
	while [ $# -gt 0 ]; do
		queue="$1 $queue"
		shift
	done
	echo $queue
}

# This functions append, insert or remove values in variables:
#
#	var_append PATH ":" "$HOME/bin"
#	var_insert CC_WRAPPER_INSERT " " "-O3"
#	var_remove CC_WRAPPER_INSERT " " "-O3"
#
#	var_remove_regex CC_WRAPPER_INSERT " " "-O.*"
#
#	var_insert_before_regex patchfiles " " "mypatch.diff" ".*\/foo.diff"
#
# 1st Parameter: Variable Name
# 2nd Parameter: Delimiter Text
# 3rd Parameter: Value (or regex)
# 4th Parameter: regex for insert_before
#
var_append() {
	eval "[ \"\$$1\" ] && $1=\"\${$1}$2\"" || true
	eval "$1=\"\${$1}\$3\""
}
var_insert() {
	eval "[ \"\$$1\" ] && $1=\"$2\$$1\"" || true
	eval "$1=\"\$3\$$1\""
}
var_remove() {
	local a=${2//\/\\/}
	local b=${3//\/\\/}
	eval '[ "$'$1'" = "$3" ] && '$1'="" || true'
	eval $1'="${'$1'//$a$b$a/$2}"'
	eval $1'="${'$1'%$a$b}"'
	eval $1'="${'$1'#$b$a}"'
}
var_remove_regex() {
	eval "$1=\"\`echo \"\$$1\" | awk -- ' { split(\$0, a, \"$2\"); for (c1=c2=1; c1 in a; c1++) if ( a[c1] !~ /^$3\\\$/ ) b[c2++]=a[c1]; for (c1=1; c1 in b; c1++) printf \"%s%s\", (c1 > 0 ? \"$2\" : \"\"), b[c1]; }'\`\""
}
var_insert_before_regex() {
	eval "$1=\"\`echo \"\$$1\" | awk -- '{ split(\$0, a, \"$2\"); for (d=c1=c2=1; c1 in a; c1++) { if ( d && a[c1] ~ /^$4\\\$/ ) { b[c2++]=\"$3\"; d=0; } b[c2++]=a[c1]; } if (d) b[c2++]=\"$3\"; for (c1=1; c1 in b; c1++) printf \"%s%s\", (c1 > 0 ? \"$2\" : \"\"), b[c1]; }'\`\""
}

