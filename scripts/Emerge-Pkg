#!/usr/bin/env bash
#
# --- T2-COPYRIGHT-BEGIN ---
# t2/scripts/Emerge-Pkg
# Copyright (C) 2004 - 2026 The T2 SDE Project
# Copyright (C) 2004 - 2025 Ren√© Rebe <rene@exactco.de>
# SPDX-License-Identifier: GPL-2.0
# --- T2-COPYRIGHT-END ---

# TODO:
# - trap C-c and end pkg builds, too

exec 2>&1

options=
dloptions=
config='default'
deps='indirect2'
debug=0
downloadonly=0
verbose=1
ignore_chksum=1
backup=1
dryrun=0
force=0
rebuild=1
repositories=
system=
depth=0
updates=
optional='ask'
maxdepth=9
parallel=

deptree=
esttime=0

#
# ----  Functions
#

. scripts/functions.in

help_msg() {
	local spacer="                 "
	echo
	echo "Usage: Emerge-Pkg [ -cfg <config> ] [ -dry-run ] [ -force ] [ -nobackup ]"
	echo "$spacer [ -consider-chksum ] [ -norebuild ] [ -deps=none|fast|indirect ]"
	echo "$spacer [ -updates ] [ -optional-deps=yes|no|ask ] [ -download ]"
	echo "$spacer [ -system | -repository repo | repo/* | CV-GROUPs | pkgs ]"
	echo
}

#
# ---- Parse options + config
#

if [ $# = 0 ]; then
	help_msg
	exit 1
fi

declare -A excludes

while [ "$1" ]; do
	case "$1" in
		-cfg)     options="$options $1 $2" config="$2"; shift ;;
		-deps=*)  deps=${1/-deps=/} ;;
		-e|-exclude) excludes[$2]=1; shift ;;
		-updates) updates=1 ;;
		-optional-deps=*) optional=${1/-optional-deps=/} ;;
		-dry-run) dryrun=1 ;;
		-f|-force) force=1 ;;
		-debug)   debug=1 ;;
		-nobackup) backup=0 ;;
		-consider-chksum) ignore_chksum=0 ;;
		-norebuild) rebuild=0 ;;
		-download|-download-only) downloadonly=1 ;;
		-repository) repositories="$repositories $2"; shift ;;
		-prefix) options="$options -prefix $2"; shift ;;
		-v) options="$options -v" ;;
		-noclearsrc) options="$options -noclearsrc" ;;
		-xtrace) options="$options -xtrace" ;;
		-system) system=1 deps=none ;;
		-parallel) parallel=1 ;;
		-*) help_msg; exit 1 ;;
		*/\*) repositories="$repositories ${1%/*}" ;;
		*)  break ;;
	esac
	shift
done

case "$deps" in
  fast|indirect*|none) : ;;
  *)
	echo "Unknown dependency resolution mode. Valid are none, fast and indirect."
	exit 1
esac

if [ ! -f config/$config/config -a $config = "default" ]; then
	scripts/Config -oldconfig
fi

. scripts/parse-config

noautolist=" 00-dirtree $SDECFG_DEFAULT_CC $SDECFG_LIBC ${SDECFG_LIBC}32 python "
declare -A packages
declare -A alternatives
declare -A deplist
declare -A dependencies

read_packages() {
	local sel pkg _
	while read sel _ _ _ pkg _; do
		packages[$pkg]=$sel
	done < <(cat config/$config/packages)
}

read_alternatives() {
	local pkg alt
	while read pkg alt; do
		alternatives[$pkg]=$alt
	done < <(cat misc/share/PKG-ALTERNATIVES)
}

add_pkg() {
	local pkg="$1"
	deplist[$pkg]=y
	dependencies["$pkg"]=$(grep -a '\[\(DEP\|OPT\)\]' package/*/$pkg/$pkg.cache | cut -d' ' -f 2 | tr '\n' ' ')
	esttime=$((esttime + buildtime))
	[ "$deps" = indirect ] && deferred[$pkg]=1
	[ "$deps" = indirect2 -a $depth -le $maxdepth ] && deferred[$pkg]=1
}

add_if_req() {
	local pkg=$1 msg="$2" typ=$3
	local buildtime=$(pkgbuildtime $pkg)
	[ "$verbose" = 1 ] && echo -n "$msg"

	# do not auto-update vital no-update packages
	if [ -e /var/adm/packages/$pkg -a $depth != 0 -a "$noautolist" != "${noautolist/ $pkg /}" ]; then
		[ $verbose = 1 ] && echo " Vital, skipped by default."
		return
	fi

	if [ $depth -gt 0 ]; then
		# optional dep, not yet installed?
		if [ "$typ" = '[OPT]' ]; then
			if [ "$optional" = ask ]; then
				echo -n " Add optional dep? (y/N$(fmt_time $buildtime)) "
				read in
				# force further updates? TODO: limit input validation
				[[ "$in" = *\* ]] && optional=$in
			else
				in="$optional"
				[[ "$in" = y* ]] &&
					echo " Optional added. $(fmt_time $buildtime)" ||
					echo " Optional, skipped."
			fi

			if [[ "$in" = y* ]]; then
				add_pkg $pkg
				
			else
				deplist[$pkg]=o
			fi
			return
		fi

		# installed, updates requested?
		if [ ! -f /var/adm/packages/$pkg ] ||
		   grep -a -q '\[BUILDTIME\] .* ERROR' /var/adm/cache/$pkg 2>/dev/null; then
			:
		elif [ ! "$updates" ]; then
			[ $verbose = 1 ] && echo " No updates selected, skipped."
			return
		fi
	fi

	[ $verbose = 1 ] && echo " Added.$(fmt_time $buildtime)"
	add_pkg $pkg
}

add_if_updated() {
    local typ
    declare -A deferred

    for pkg; do
	# type arg?
	[[ $pkg = \[*\] ]] && typ=$pkg && continue

	local scanned=${deplist[$pkg]}
	if [ "$scanned" ]; then
		[ $debug = 1 ] && echo "already been at $pkg ..."

		# if previously only an unselected opt dep, re-check if hard dep now
		[ "$scanned" = o -a "$typ" != "[OPT]" ] || continue
	else
		deplist[$pkg]=n # not yet, but been here marker
	fi

	# read in pkg list?
	[ ${#packages[@]} = 0 ] && read_packages && read_alternatives

	[ $verbose = 1 ] && echo -n "$deptree$pkg:"
	local confdir=
	for x in package/*/$pkg/$pkg.desc; do
	    if [ -f "$x" ]; then
		confdir=${x/$pkg.desc/}
		break # use 1st match, let other code check for duplicate dirs
	    fi
	done
	if [ -z "$confdir" ]; then
	    if [ $depth = 0 ]; then
		# is it a CV-GROUP?
		local pkgs=$(grep "^\[CV-GROUP\] $pkg" package/*/*/*.desc | cut -d / -f 3)
		if [ "$pkgs" ]; then
			add_if_updated $pkgs
			continue
		fi

		local pkg="$(pkgsimilar $pkg)"
		if [ "$pkg" ]; then
			echo " Error: No such package. Did you mean: $pkg?"
		else
			echo " Error: No such package."
		fi
		exit 1
	    else
		echo " Warning: No such package."
		continue
	    fi
	fi

	if [ ${excludes[$pkg]} ]; then
		echo " Excluded."
		continue
	fi

	# TODO: keep unselected in the config, to avoid re-config for masked pkgs
	if [ -z "${packages[$pkg]}" ]; then
	    if [ $depth = 0 ]; then
		local desc=$confdir/$pkg.desc
		if [ -e "$desc" ]; then
		    echo " Package not cached, re-reading config:"
		    scripts/Config -oldconfig -cfg $config
		    read_packages
		fi

		if [ -z "${packages[$pkg]}" ]; then
		    echo " Error: No such package."
		    exit 1
		fi
	    else
		echo " Warning: No such package."
		continue
	    fi
	fi

	if [ "${packages[$pkg]}" != X ]; then
		# switch to alternative pkg, if selected
		local alt="${alternatives[$pkg]}"
		if [ "$alt" ] && [ "${packages[$alt]}" = X ]; then
			echo -ne "\b($alt):"
			pkg=$alt
			confdir=package/*/$pkg
		else
			echo " Not selected."
			continue
		fi
	fi

	# we avoid parse_desc here, because it is ~50x slower
	local n_ver=$(grep -a '^\[V\] ' $confdir/$pkg.desc \
	              architecture/$SDECFG_ARCH/package/$pkg/$pkg.desc \
	              target/$SDECFG_TARGET/package/$pkg/$pkg.desc \
	        2>/dev/null | cut -f2- -d' ' | tail -n 1)

	if [ ! -f /var/adm/packages/$pkg ]; then
		if [ "$typ" = "[OPT]" ]; then
			add_if_req $pkg " Not installed ($n_ver)." $typ
		else
			add_if_req $pkg " Not installed ($n_ver)."
		fi
		continue
	fi

	local o_ver=$(sed -n '/Package Name and Version: [^ ]* /{s///p; q}' /var/adm/packages/$pkg)
	case "$o_ver" in
	*' '*-svn|*' '*.*) o_ver=${o_ver% *} ;;
	esac
	if [ "$o_ver" != "$n_ver" -a "$n_ver" != "0000" ]; then
		add_if_req $pkg " New version ($o_ver -> $n_ver)."
		continue
	fi

	o_ck=$(grep -a '^\(ROCK Linux\|T2\) Package Source Checksum' /var/adm/packages/$pkg | sed 's,.*: ,,')
	n_ck=$(pkgchksum $confdir)
	if [ $ignore_chksum = 0 -a "$o_ck" != "$n_ck" ]; then
		add_if_req $pkg " New source checksum."
		continue
	fi

	if [ -f /var/adm/cache/$pkg ] &&
	   grep -a -q '\[BUILDTIME\] .* ERROR' /var/adm/cache/$pkg; then
		[ $verbose = 1 ] && echo -n " Former build was broken ($n_ver)."
		if [ $rebuild = 1 ]; then
			add_if_req $pkg
		else
			[ $verbose = 1 ] && echo " Skipped."
		fi
		continue
	fi

	if [ $force = 1 -a $depth = 0 ]; then
		add_if_req $pkg " Build forced ($n_ver)."
		continue
	fi

	if [ $debug = 1 ]; then
		echo " Installed and up-to-date."
	else
		echo -ne \
"\r                                                                          \r"
	fi
    done

    # all deferred, indirect deps
    for pkg in "${!deferred[@]}"; do dep4pkg $pkg; done
}

dep4pkg() {
	local depth=$((++depth))
	local deptree="$deptree$1|"

	add_if_updated $(grep -a '\[\(DEP\|OPT\)\]' package/*/$1/$1.cache 2>/dev/null)
}

# the remaining arguments are packages to be built
add_if_updated $*

# packages from repositories
for x in $repositories; do
	add_if_updated $(egrep -a "^X .* $x .*" config/$config/packages | cut -d ' ' -f 5)
done

# all installed packages if a system update
if [ "$system" ]; then
	depth=-1
	add_if_updated $(cd /var/adm/packages/; ls *)
	depth=0
fi

# deplist is unsorted: remove unselected and sort by priority
for pkg in ${!deplist[@]}; do [ ${deplist[$pkg]} != y ] && unset deplist[$pkg]; done
targets=${!deplist[@]}
targets=$(grep -a "^. .* .* .* \\(${targets// /\\|}\\) " config/$config/packages |
	sort -k 3 | cut -d ' ' -f 5 | tr '\n' ' ')

if [ "$targets" ]; then
	echo "$(echo "$targets" |
		wc -w) packages scheduled to build$(fmt_time $esttime): $targets" | fold -s
	echo
else
	echo "No package scheduled to build."
fi

[ $dryrun = 1 ] && exit
[ $backup = 1 ] && options="$options -update"

i=0 pkgs=$(echo "$targets" | wc -w) # build progress

if [ ! "$parallel" ]; then
  for pkg in $targets; do
    if scripts/Download -cfg $config $dloptions $pkg; then
	if [ $downloadonly != 1 ] &&
	   ! scripts/Build-Pkg $options -progress $((++i))/$pkgs $pkg; then
	    if [ $SDECFG_CONTINUE_ON_ERROR_AFTER -gt 8 ]; then
		echo "Aborting further builds due to config setting CONTINUE_ON_ERROR_AFTER."
		exit 1
	    fi
	fi
    fi
  done
  exit 0
fi

JOBS="$SDECFG_PARALLEL"

# Build command per component (could also be a single function with a case)
build() {
	local pkg=$1
	if ! scripts/Download -cfg $config $dloptions $pkg; then
		echo "The download for package $pkg failed!"
		exit 1
	fi

	if [ $downloadonly != 1 ] && ! scripts/Build-Pkg $options -progress $i/$pkgs $pkg; then
		if [ $SDECFG_CONTINUE_ON_ERROR_AFTER -gt 8 ]; then
			echo "Aborting further builds due to config setting CONTINUE_ON_ERROR_AFTER."
		fi
		exit 1 # TODO: config
	fi
}

# -------------------------------------
# 2) Scheduler: run when deps complete
# -------------------------------------
declare -A state pid_of target_of # state: pending | running | done | failed

# clean/sync deps w/ actually built targets
for t in ${!deplist[@]}; do
	state["$t"]=pending
	deps=
	for d in ${dependencies["$t"]}; do
		[ "${deplist["$d"]}" ] && deps="$deps $d"
	done
	dependencies[$t]="$deps "
done

is_ready() {
  local ready=0
  #echo -n "$1 ready?"
  for d in ${dependencies["$1"]}; do
    # echo -n " $d ${state["$d"]}"
    [[ "${state["$d"]}" != "done" ]] && ready=1 && break
  done
  #echo " $ready"
  return $ready
}

running_count() {
  local n=0
  for t in ${!deplist[@]}; do
    [[ "${state["$t"]}" == "running" ]] && ((n++)) || true
  done
  echo "$n"
}

start_target() {
  local t="$1"
  #echo "==> START $t"

  [ $((++i)) = 1 ] &&
	scripts/Build-Tools -9 -cfg $config
  build "$t" &

  local p=$!
  pid_of["$t"]=$p
  target_of["$p"]=$t
  state["$t"]=running

  [ "${dloptions/-quiet-mirror/}" != "$dloptions" ] || var_append dloptions ' ' -quiet-mirror
}

end_target() {
  local p="$1" rc="$2"
  local t="${target_of["$p"]}"

  if [[ "$rc" -eq 0 ]]; then
    #echo "==> DONE  $t"
    state["$t"]=done

    # remove target t from dependencies
    targets=" $targets "
    targets="${targets/ $t/ }"

    unset deplist[$t] dependencies[$t]
    for d in ${!deplist[@]}; do
	dependencies[$d]="${dependencies["$d"]/ $t / }"
    done
  else
    #echo "==> FAIL  $t (rc=$rc)" >&2
    state["$t"]=failed
  fi
}

# Main loop
while :; do
  # If any failed, stop early
  for t in ${!deplist[@]}; do
    if [[ "${state["$t"]}" == "failed" ]]; then
      echo "Aborting due to failure." >&2
      wait
      exit 1
    fi
  done

  # Launch as many ready jobs as possible up to JOBS
  for t in ${!deplist[@]}; do
      [[ "$(running_count)" -gt "$JOBS" ]] && break

      if [[ "${state["$t"]}" == "pending" ]] && is_ready "$t"; then
        start_target "$t"
        progress=1
        [[ "$(running_count)" -ge "$JOBS" ]] && break
      fi
  done

  # Are we finished?
  all_done=1
  for t in ${!deplist[@]}; do
    [[ "${state["$t"]}" == "done" ]] || { all_done=0; break; }
  done
  [[ "$all_done" -eq 1 ]] && {
	# echo "All components built."
	exit 0
  }

  # No running jobs but not all done => dependency cycle or missing target
  if [[ "$(running_count)" -eq 0 ]]; then
    echo "No runnable targets. Check for cycles or missing deps:" >&2
    echo "States:" >&2
    first=
    for t in $targets; do
	if [ ${state["$t"]} = pending ]; then
		 echo "  $t: ${state["$t"]} (deps: ${dependencies["$t"]})" >&2
		 [ "$first" ] || first=$t
	fi
    done

    echo "Starting 1st: $first"
    start_target "$first"
  fi

  # Wait for one job to finish, then continue scheduling
  # Requires bash >= 4.3 for wait -n
  set +e
  wait -n
  rc=$?
  set -e

  # Determine which PID finished by checking running PIDs
  # (bash doesn't directly tell you which one with wait -n)
  for t in ${!deplist[@]}; do
    if [[ "${state["$t"]}" == "running" ]]; then
      p="${pid_of["$t"]}"
      if ! kill -0 "$p" 2>/dev/null; then
        # Reap it to get real rc
        set +e
        wait "$p"
        rc2=$?
        set -e
	end_target "$p" "$rc2"
      fi
    fi
  done
done
