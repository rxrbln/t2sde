#!/bin/bash
#
# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: scripts/Emerge-Pkg
# Copyright (C) 2004 - 2005 The T2 SDE Project
# Copyright (C) 1998 - 2003 ROCK Linux Project
# 
# More information can be found in the files COPYING and README.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License. A copy of the
# GNU General Public License can be found in the file COPYING.
# --- T2-COPYRIGHT-NOTE-END ---

exec 2>&1

options=''
config=default
builddep=0
debug=0
ignore_chksum=0
update=1
dryrun=0
force=0
rebuild=1
repositories=""

#
# ----  Functions
#

. scripts/functions

help_msg() {
	spacer="                           "
	echo
	echo "Usage: ./scripts/Emerge-Pkg" \
	             "[ -cfg <config> ] [ -dep ] [ -dry-run ] [ -debug ]"
	echo "$spacer [ -ignore-chksum ] [ -norebuild ] [ -force ] [ -noupdate ]"
	echo "$spacer [ -repository repository-name ] [ pkg-name(s) ]"
	echo "pkg-name(s) are only optional if a repository is specified!"
	echo
	echo "Type './scripts/Help Emerge-Pkg' for details."
	echo
}

#
# ---- Parse options + config
#

if [ $# = 0 ]; then
	help_msg
	exit 1
fi

while [ "$1" ] ; do
	case "$1" in
		-cfg)     options="$options $1 $2" ; config="$2"   ; shift ;;
		-debug)   debug=1 ;;
		-dep)     builddep=1 ;;
		-dry-run) dryrun=1 ;;
		-force)	  force=1 ;;
		-noupdate) update=0 ;;
		-ignore-chksum) ignore_chksum=1 ;;
		-norebuild) rebuild=0 ;;
		-repository) repositories="$repositories $2" ; shift ;;
		-*) help_msg ; exit 1 ;;
		*)  break ;;
	esac
	shift
done

. ./scripts/parse-config
. ./scripts/functions

check4update()
{
  addlist=""
  for package in $deplist ; do
	[ "$debug" = 1 ] && echo "checking $package ..."
	confdir=""
        for x in package/*/$package/$package.desc ; do
            if [ -f "$x" ] ; then
		if [ -z "$confdir" ] ; then
		  confdir=${x/$package.desc/}
		else
		  confdir=X
		fi
            fi
        done

        if [ -z "$confdir" ] ; then
                [ $debug = 1 ] && \
		  echo "  $package: No such package."
        elif [ "$confdir" = X ] ; then
                [ $debug = 1 ] && \
		  echo "  $package: Package in multiple trees."
        elif [ ! -f /var/adm/packages/$package ] ; then
                [ $debug = 1 ] && \
		  echo "  $package: Not installed. Added."
		addlist="$addlist $package"
        else
                o_ver=$(grep '^Package Name and Version' \
                                /var/adm/packages/$package | cut -f6 -d' ')
                n_ver=$(grep '^\[V\] ' $confdir/$package.desc | cut -f2 -d' ')
                if [ "$o_ver" != "$n_ver" -a "$n_ver" != "0000" ] ; then
                        [ $debug = 1 ] && \
			  echo "  $package: New version ($o_ver -> $n_ver). Added."
			addlist="$addlist $package"
                else
                        o_ck=$(grep '^\(ROCK Linux\|T2\) Package Source Checksum' \
                                /var/adm/packages/$package | sed 's,.*: ,,')
                        n_ck=$( pkgchksum package/*/$package )
                        if [ $ignore_chksum = 0 -a "$o_ck" != "$n_ck" ] ; then
                                [ $debug = 1 ] && \
				  echo "  $package: New source checksum ($n_ck). Added."
				addlist="$addlist $package"
			else
				if [ -f /var/adm/cache/$package ] ; then
				  if grep -q '\[BUILDTIME\] .* ERROR' \
				          /var/adm/cache/$package ; then
				    [ $debug = 1 ] && \
				      echo -n "  $package: Former build was broken."
				    if [ $rebuild = 1 ] ; then

					[ $debug = 1 ] && echo " Added."
					addlist="$addlist $package"
				    else
					[ $debug = 1 ] && echo " Skipped."
				    fi
					
				  fi
				else
				  [ $debug = 1 ] && \
				    echo "  $package: Equal source checksum ($n_ck), skipped."
				fi
                        fi
                fi
        fi

  done
  deplist="$addlist"
}

dep4pkg() {
    gawk -v package=$1 '
function check_package() {

	found_new = 0;

	for ( package in build_list ) {
		if ( debug )
			print "#DEBUG PACKAGE: " package;

		if ( ! package in database ) {
			if (debug)
				print "#  " package " not in database";
		}
		else {
			if (debug)
				print "#  " package " in database";

			split(database[package], a);

			for (d in a) {
				# if ( a[c] == package  ) continue;
				if ( strtonum(d) <= 3 ) continue;
				dep = a[d];
				if ( debug && 0)
					print "#    dep: " dep;
				if ( dep in build_list ) {
					if ( debug && 0)
					print "#    dep: " dep " already parsed";
				}
				else {
					if (debug)
						print "#    dep: " dep " now added";
					build_list [ dep ] = (package);
					found_new = 1;
				}
			}
		}
	}
	if (found_new)
		check_package();
}

BEGIN {
	config="'$config'"; debug='$debug';
	depdb_file = "scripts/dep_db.txt";

	while ( (getline depline < depdb_file) > 0 )
		{ $0 = depline; sub(/:/, "", $1); database[$1]=$0; }
	close(depdb_file);

	build_list [ package ] = 1;

	check_package();

	if (debug) {
		for ( bp in build_list ) {
			print "# " bp " (" build_list[bp] ")"
		}
	}
	for ( bp in build_list ) {
		print bp
	}
}

'
}

# all packages
deplist="$deplist $@"

# packages from repositories
for x in $repositories ; do
	deplist="$deplist ` egrep "^X .* $x .*" config/$config/packages | \
	         cut -d ' ' -f 5`"
done

if [ $builddep = 1 ] ; then
        # we have to create a complete dependency graph ...
	tmp="`mktemp`"
	for x in $deplist ; do
        	dep4pkg $x >> $tmp
	done
	[ "$debug" = 1 ] && grep '^#' $tmp
	deplist="$deplist `grep -v '^#' $tmp`"
	rm $tmp
fi

# only build packages that need an update
[ $force -eq 0 ] && check4update

echo "Packages scheduled to build: $deplist"

[ $dryrun = 1 ] && exit

# the deplist is quite unsorted (in alphabetically sorted chunks)
# so we need to work arround this here ...

[ $update = 1 ] && options="$options -update"

for package in $deplist ; do
	if ./scripts/Download $package ; then
		./scripts/Build-Pkg $options $package
	else
		echo "The download for package $package failed!"
		exit -1
	fi
done

