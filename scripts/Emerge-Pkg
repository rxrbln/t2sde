#!/bin/bash
#
# --- ROCK-COPYRIGHT-NOTE-BEGIN ---
# 
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# Please add additional copyright information _after_ the line containing
# the ROCK-COPYRIGHT-NOTE-END tag. Otherwise it might get removed by
# the ./scripts/Create-CopyPatch script. Do not edit this copyright text!
# 
# ROCK Linux: rock-src/scripts/Emerge-Pkg
# ROCK Linux is Copyright (C) 1998 - 2003 Clifford Wolf
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version. A copy of the GNU General Public
# License can be found at Documentation/COPYING.
# 
# Many people helped and are helping developing ROCK Linux. Please
# have a look at http://www.rocklinux.org/ and the Documentation/TEAM
# file for details.
# 
# --- ROCK-COPYRIGHT-NOTE-END ---

exec 2>&1

options=''
config=default
builddep=0
debug=0
ignore_chksum=0
update=1
recursive=0

#
# ----  Functions
#

. scripts/functions

help_msg() {
	spacer="                           "
	echo
	echo "Usage: ./scripts/Emerge-Pkg" \
	             "[ -cfg <config> ] [ -dep ]"
	echo "$spacer [ -recursive ] [ -noupdate ] [ -debug ] pkg-name(s)"
	echo
	echo "Type './scripts/Help Emerge-Pkg' for details."
	echo
}

dep4pkg()
{
	grep "$1:" scripts/dep_db.txt | cut -d ' ' -f 4-
}

fill_deplist()
{
	local addlist=''

	echo "Parsing dependencies for $1"

	for package in `dep4pkg $1` ; do

	# make sure it is a valid package (and not a group)

	if [ "`echo $alllist | grep +$package+`" = "" ] ; then
		[ $debug = 1 ] && \
		  echo "  $package: not in target configuration (e.g. meta flag) - skipped."
		continue
	fi

	if [ "`echo $deplist | grep +$package+`" ] ; then
		[ $debug = 1 ] && \
		  echo "  $package: allready processed - skipped."
		continue
	fi

	confdir=""
        for x in package/* ; do
            if [ -d "$x/$package" ] ; then
                if [ "$confdir" ] ; then confdir=X
                else confdir="$x/$package" ; fi
            fi
        done

        if [ -z "$confdir" ] ; then
                [ $debug = 1 ] && \
		  echo "  $package: No such package."
        elif [ "$confdir" = X ] ; then
                [ $debug = 1 ] && \
		  echo "  $package: Package in multiple trees."
        elif [ ! -f /var/adm/packages/$package ] ; then
                [ $debug = 1 ] && \
		  echo "  $package: Not installed."
		addlist="$addlist $package"
        else
                o_ver=$(grep '^Package Name and Version' \
                                /var/adm/packages/$package | cut -f6 -d' ')
                n_ver=$(grep '^\[V\] ' $confdir/$package.desc | cut -f2 -d' ')
                if [ "$o_ver" != "$n_ver" -a "$n_ver" != "0000" ] ; then
                        [ $debug = 1 ] && \
			  echo "  $package: New version ($o_ver -> $n_ver)."
			addlist="$addlist $package"
                else
                  if [ $ignore_chksum = 0 ] ; then
                        o_ck=$(grep '^ROCK Linux Package Source Checksum' \
                                /var/adm/packages/$package | cut -f6 -d' ')
                        n_ck=$(md5sum package/*/$package/* 2> /dev/null | \
                                grep -v '\.cache$' | md5sum | cut -f1 -d' ')
                        if [ "$o_ck" != "$n_ck" ] ; then
                                [ $debug = 1 ] && \
				  echo "  $package: New source checksum ($n_ck)."
				addlist="$addlist $package"
			else
				if [ -f /var/adm/cache/$package ] ; then
				  if ! grep -q BUILDTIME /var/adm/cache/$package ; then
				    [ $debug = 1 ] && \
				      echo "  $package: Former build was broken."
				    addlist="$addlist $package"
				  fi
				else
				  [ $debug = 1 ] && \
				    echo "  $package: Equal source checksum ($n_ck), skipped."
				fi
                        fi
                  fi
                fi
        fi

	done

	for package in $addlist ; do
		deplist="$deplist +$package+"
	done

	if [ $recursive = 1 ] ; then 
		for package in $addlist ; do
			fill_deplist $package
		done
	fi
}

#
# ---- Parse options + config
#

while [ "$1" ] ; do
	case "$1" in
		-cfg)     options="$options $1 $2" ; config="$2"   ; shift ;;
		-debug)   debug=1 ;;
		-dep)     builddep=1 ;;
		-noupdate) update=0 ;;
		-recursive) recursive=1 ;;
		-*) help_msg ; exit 1 ;;
		*)  break ;;
	esac
	shift
done

. ./scripts/parse-config

deplist=''
alllist=`./scripts/Create-PkgList $arch | grep ^X | cut -d ' ' -f 5 | \
  sed -e 's/$/+/' -e 's/^/+/'`

if [ $builddep = 1 ] ; then
	# build a complete dependency graph
	fill_deplist $1
else
	deplist=$1
fi

echo "Packages scheduled to build: $deplist"

# the deplist is quite unsorted (in alphabetically sorted chunks)
# so we need to work arround this here ...

[ $update = 1 ] && options="$options -update"

for package in $alllist ; do
	if [ "`echo $deplist | grep $package`" ] ; then
		package="` echo $package | sed -e s/^+// -e s/+$//`"
		./scripts/Download -package $package
		./scripts/Build-Pkg $options $package
	fi
done

