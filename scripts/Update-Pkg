#!/usr/bin/env bash
# --- T2-COPYRIGHT-BEGIN ---
# t2/scripts/Update-Pkg
# Copyright (C) 2004 - 2025 The T2 SDE Project
# SPDX-License-Identifier: GPL-2.0
# --- T2-COPYRIGHT-END ---

# Extract packagename and version number from the script arguments.
pkg="$1"; shift
ver="$1"; shift

# Remote URL
#
if [[ "$pkg" == http*://* ]]; then
	curl $pkg/ | tr '"' '\n' | grep "tar.[^.<>]*$"| sort -u |
		sed 's/\.tar.*//'|
	while read p; do
		scripts/Update-Pkg $p
	done

	exit	# TODO: return any update download error
fi

# The script also supports the package name and version separated by a '-',
# '_' or '.'. In this case they have to be separated from each other.
if [ -z "$ver" ]; then
    ver=${pkg/*-/}
    pkg=${pkg%-$ver}
    if [ "$ver" == "$pkg" ]; then
	ver=${pkg/*_/}
	pkg=${pkg%_$ver}
    fi
    if [ "$ver" == "$pkg" ]; then
	pkg=${pkg/.*/}
	ver=${ver#$pkg.}
    fi
    [ "$ver" == "$pkg" ] && unset ver
fi

# Check if both package name and version have been extracted from the
# commandline arguments. If not the script was called with invalid
# arguments, show the usage.
if [ -z "$pkg" -o -z "$ver" ]; then
	echo "Usage: $0 pkg ver, pkg-ver, pkg_ver or pkg.ver, or URL"
	echo ""
	echo "Updating a package to a new versions."
	echo ""
	echo "  pkg	Packagename to be updated"
	echo "  ver	New version number for the package"
	echo "  	ver=refresh makes it just add checksums"
	echo "  url	extract pkg and version from tarballs"
	echo ""
	echo "For detailed information on how to update packages"
	echo "to new versions, please have a look at the online"
	echo "T2 documentaion."
	exit
fi

# Make sure any diff files from previous runs are removed.
rm -f $$.diff

# Only package names in lowercase are supported. As an additional
# service any package names supplied in capitols will be converted
# to lowercase.
pkg=`echo "$pkg" | tr A-Z a-z`

update_pkg() {
	local pkg="$1"
	local ver="$2"

	if [ "$ver" != "refresh" ]; then
		# The package exists so now update the package descriptor
		# for the given package to the new version. Luckily we have
		# a script for that too :-)
		scripts/Create-PkgUpdPatch "$pkg" "$ver" | tee $$.diff
		patch -p1 < $$.diff
		rm -f $$.diff
	fi

	# Step 2: Use the modified package descriptor to download
	# the package. Again, nothing more that calling an existing
	# script.
	scripts/Download $pkg || exit 1

	# Third and final step is updating the checksum for the
	# new download.
	scripts/Create-CkSumPatch "$pkg" | patch -p0
}

# check if pkg exists
if [ -d package/*/$pkg ]; then
	update_pkg $pkg $ver
else
	# is it a CV-GROUP?
	pkgs=$(grep "^\[CV-GROUP\] $pkg" package/*/*/*.desc | cut -d / -f 3)
	if [ "$pkgs" ]; then
		for p in $pkgs; do
			update_pkg $p $ver
		done
	else
		echo "ERROR: package $pkg doesn't exist"
		# As an extra service for the user a list possibilities is
		# presented with packages closely matching the given package
		# name. TODO: re-use and share Emerge-Pkg similar code!
		pkg=`echo "$pkg" | tr '\-_.' '***'`
		echo `echo package/*/*$pkg*/ | tr ' ' '\n' | grep -v '*' | cut -d'/' -f3`
	fi
fi
