#!/usr/bin/perl -w
# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: scripts/Check-Deps-2
# Copyright (C) 2004 - 2005 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License. A copy of the
# GNU General Public License can be found in the file COPYING.
# --- T2-COPYRIGHT-NOTE-END ---

use strict;
use English;

my (@pkg, %opr, %pri, %dep, %rep, %rdp, %ign, %lop);
my @useddeps;	# deps used for visualization of cross dependencies
my %pkg_redone; # packages built in stages 6-8

foreach (@ARGV) { $ign{$_} = 1; }

print "Reading package priorities ...\n";
open(F, "./scripts/Create-PkgList |") || die $!;
while (<F>) {
	@_ = split /\s+/;
	next if $_[1] =~ /[1234]/ or $_[1] !~ /5/;
	$pkg_redone{$_[4]}  = 1 if $_[1] =~ /[678]/;
	next if defined $ign{$_[3]} || defined $ign{$_[4]};
	$opr{$_[4]} = $_[2];
	$pri{$_[4]} = $_[2];
	$rep{$_[4]} = $_[3];
	$pkg[$#pkg+1] = $_[4];
}
close F;

print "Reading package dependencies ...\n";
open(F, "scripts/dep_db.txt") || die $!;
while (<F>) {
	chomp;
	if ( ! /^(\S+): \d+ \d+ (.*)$/ ) {
		print "Format Error: $_\n";
		exit 1;
	}
	next if defined $pkg_redone{$1};
	@{$dep{$1}} = split /\s+/, $2;
	foreach ( @{$dep{$1}} ) {
		$rdp{$_} = () unless defined $rdp{$_};
		push @{$rdp{$_}}, $1;
	}
}
close F;

sub count_errs($) {
	my $package = $_[0];
	my $dependency;
	my $errors = 0;

	foreach $dependency (@{$dep{$package}}) {
		next unless defined $pri{$dependency};
		$errors++ if $pri{$package} < $pri{$dependency};
	}
	foreach $dependency (@{$rdp{$package}}) {
		next unless defined $pri{$dependency};
		$errors++ if $pri{$package} > $pri{$dependency};
	}

	return $errors;
}

my ($iteration, $package, $dependency, $a, $b);
my $did_something=0;

print "\nLoop    Old/New Errors  Package                   Dependency\n".
"------------------------------------------------------------------------\n";

for $iteration (1..99) {
  my $looplog = '';
  foreach $package (@pkg) {
    foreach $dependency (@{$dep{$package}}) {
	next unless defined $pri{$dependency};
	if ( $pri{$package} < $pri{$dependency} ) {
		$a = count_errs($package) + count_errs($dependency);
		$_ = $pri{$dependency};
		$pri{$dependency} = $pri{$package};
		$pri{$package} = $_;
		$b = count_errs($package) + count_errs($dependency);

		$looplog.="[$package,$dependency]";

		$_ = sprintf "[%02d]    %-7d %-7d %-25s %s\n",
		       $iteration, $a, $b, $pri{$dependency}." ".$package,
			$pri{$package}." ".$dependency;
		$useddeps[$iteration]{$package}{$dependency} = 1;
		s/   / . /g; s/\.  /.. /g; s/\.  /.. /g;
		s/\. (\s*)\./..$1./g; s/\. (\s*)\./..$1./g;
		print; $did_something=1;
	}
    }
  }
  last if $looplog eq "";
  if (defined $lop{$looplog}) {
	my %crossdeps;

	print "[XX] Detected endless-loop ".
	      "(cross-dependency) -> Aborting now.\n";
	print "[XX] Debug graph printed to dependencies.dot.\n";

	foreach my $i ($lop{$looplog} .. $iteration) {
		foreach my $p (keys %{$useddeps[$i]}) {
			foreach my $d (keys %{$useddeps[$i]{$p}}) {
				$crossdeps{$d}{$p} = 1;
			}
		}
	}

	open(F, ">dependencies.dot") || die $!;
	print F "# run this thru e.g. 'dot -Tps dependencies.dot -o dependencies.ps'\n";
	print F "digraph \"Cross-Dependencies Graph\" {\n";
	foreach my $p (sort keys %crossdeps) {
		foreach my $d (sort keys %{$crossdeps{$p}}) {
			my $p_ = $p; $p_ =~ s/[^a-z0-9]/_/g;
			my $d_ = $d; $d_ =~ s/[^a-z0-9]/_/g;
			print F "\t$p_ -> $d_;\n";
		}
	}
	print F "}\n";
	close F;

	open(F, ">dependencies.dbg") || die $!;
	foreach my $p (sort keys %crossdeps) {
		foreach my $d (sort keys %{$crossdeps{$p}}) {
			print F "$p $d\n";
		}
	}
	close F;

	last;
  }
  $lop{$looplog} = $iteration;
}

if ( $did_something ) {
	print "\nCreate dependencies.patch ...\n";
	my $tmpfile = `mktemp`; chomp $tmpfile;
	unlink "dependencies.patch";

	foreach $package (@pkg) {
	  if ($pri{$package} != $opr{$package}) {
		my $descfile = "package/$rep{$package}/".
			       "$package/$package.desc";
		open(IN, $descfile) || die $!;
		open(OUT, ">$tmpfile") || die $!;
		$did_something = 0;
		my $re1 = "(\\[P\\] . \\S+) $opr{$package}";
		my $re2 = "\$1 $pri{$package}";
		while (<IN>) {
			$did_something = 1 if eval "s/$re1/$re2/";
			print OUT;
		}
		close IN; close OUT;
		if (not $did_something) {
			print "ERROR: Can't patch $descfile!\n";
			print "ERROR: Regex was s/$re1/$re2/\n";
		}
		system("diff -u0 ./$descfile $tmpfile >> dependencies.patch");
	  }
	}
	unlink $tmpfile;
	print "Done. Please check moves manually bofore applying the patch.\n";
} else {
	print "No unresolved dependencies found.\n";
}
