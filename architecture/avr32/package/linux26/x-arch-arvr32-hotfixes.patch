# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: architecture/avr32/package/.../x-arch-arvr32-hotfixes.patch
# Copyright (C) 2007 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

--- linux-2.6.20/sound/avr32/at73c213.c	2007-03-07 09:47:57.912233190 +0100
+++ linux-2.6.20-hacked-up/sound/avr32/at73c213.c	2007-03-05 17:05:24.027438893 +0100
@@ -116,7 +116,7 @@
 static int gclk_div;
 static int ssc_div;
 static int spi = 0;
-static int ssc = 1;
+static int ssc = 0;
 
 module_param(spi, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
 MODULE_PARM_DESC(spi, "Which SPI interface to use to communicate with the at73c213");
@@ -1040,9 +1040,11 @@
 	if (irq < 0)
 		return irq;
 
-	ssc_clk = clk_get(&pdev->dev, "mck");
-	if (IS_ERR(ssc_clk))
+	ssc_clk = clk_get(&pdev->dev, "ssc_clk");
+	if (IS_ERR(ssc_clk)) {
+		printk ("ReneR: failed to get clock\n");
 		return PTR_ERR(ssc_clk);
+	}
 	clk_enable(ssc_clk);
 	chip->ssc_clk = ssc_clk;
 
@@ -1093,15 +1095,37 @@
 	return retval;
 }
 
+//#define INTERNAL
+
+#ifdef INTERNAL
+static struct spi_board_info ssc0_board_info __devinitdata = {
+        /* AT73C213 audio codec */
+        .max_speed_hz   = 200000,
+        .chip_select    = 0,
+};
+#else
+extern struct bus_type spi_bus_type;
+#endif
+
+static struct device *next_device(struct klist_iter *i)
+{
+       struct klist_node * n = klist_next(i);
+       return n ? container_of(n, struct device, knode_parent) : NULL;
+}
+
 static int __devinit snd_at73c213_probe(struct platform_device *pdev)
 {
 	static int dev;
+#ifdef INTERNAL
 	struct spi_board_info *binfo;
+#endif
 	struct spi_master *smaster;
 	struct snd_at73c213 *chip;
 	snd_card_t *card;
 	int retval;
 
+	printk ("ReneR ALSA probe\n");
+
 	if (dev >= SNDRV_CARDS)
 		return -ENODEV;
 	if (!enable[dev]) {
@@ -1123,11 +1147,13 @@
 	retval = -ENODEV;
 
 	/* Get the SPI bus */
-	binfo = pdev->dev.platform_data;
+#ifdef INTERNAL
+	binfo = &ssc0_board_info; // pdev->dev.platform_data;
 	if (!binfo) {
 		printk(KERN_WARNING "at73c213: could not get platform data\n");
 		goto out;
 	}
+#endif
 
 	smaster = spi_busnum_to_master(spi);
 	if (!smaster) {
@@ -1141,10 +1167,69 @@
 			goto out;
 		}
 	}
-
+#ifdef INTERNAL
 	chip->spi = spi_new_device(smaster, binfo);
+#else
+	/* Find the slave */
+        chip->spi = NULL;
+	{
+	//struct spi_boardinfo    *bi;
+        struct device           *dev;
+	//struct class		*class = smaster->cdev.class;
+
+	//const struct spi_device *spi = to_spi_device(dev);
+	//const char* malias = spi->modalias;
+
+	struct klist_iter i;
+	//klist_iter_init(&spi_bus_type.klist_devices, &i);
+	klist_iter_init(&smaster->cdev.dev->klist_children, &i);
+        while ((dev = next_device(&i))) {
+                struct spi_device *spi = to_spi_device(dev);
+		const char* malias = spi ? spi->modalias: NULL;
+		printk ("alias: %s\n", malias);
+		if (malias && strcmp (malias, "at73c213") == 0) {
+			chip->spi = spi;
+			goto found;
+		}
+// 
+//                 /* work-around for 715/64 and others which have parent 
+//                    at path [5] and children at path [5/0/x] */
+//                 if (padev->id.hw_type == HPHW_FAULTY)
+//                         return gsc_fixup_irqs(padev, ctrl, choose_irq);
+//                 choose_irq(padev, ctrl);
+         }
+found:
+         klist_iter_exit(&i);
+	
+//extern void klist_iter_init(struct klist * k, struct klist_iter * i);
+//extern void klist_iter_init_node(struct klist * k, struct klist_iter * i,
+//                                 struct klist_node * n);
+//extern void klist_iter_exit(struct klist_iter * i);
+//extern struct klist_node * klist_next(struct klist_iter * i);
+
+
+#if 0
+
+        list_for_each_entry(bi, &board_list, list) {
+                struct spi_board_info   *schip = bi->board_info;
+                unsigned                n;
+
+                for (n = bi->n_board_info; n > 0; n--, chip++) {
+                        if (chip->chip_select >= smaster->num_chipselect
+                                        && smaster->num_chipselect) {
+                                dev_dbg(dev, "cs%d > max %d\n",
+                                        chip->chip_select,
+                                        smaster->num_chipselect);
+                                continue;
+                        }
+                        chip->spi = schip;
+                }
+#endif
+        }
+#endif
+
 	if (!chip->spi) {
-		printk(KERN_WARNING "at73c213: could not get SPI device %d\n", spi);
+		printk(KERN_WARNING "at73c213: could not get SPI device on BUS %d\n", spi);
 		goto out;
 	}
 
@@ -1268,7 +1353,7 @@
 	.probe		= snd_at73c213_probe,
 	.remove		= __devexit_p(snd_at73c213_remove),
 	.driver		= {
-		.name	= "at73c213",
+		.name	= "ssc",
 	}
 #ifdef CONFIG_PM
 	.resume		= snd_at73c213_resume,
@@ -1278,6 +1363,7 @@
 
 static int __init at73c213_init(void)
 {
+	printk ("ReneR ALSA init\n");
 	return platform_driver_register(&at73c213_driver);
 }
 
--- linux-2.6.20/arch/avr32/boards/atstk1000/atstk1002.c	2007-03-07 09:47:58.204249831 +0100
+++ linux-2.6.20-hacked-up/arch/avr32/boards/atstk1000/atstk1002.c	2007-03-05 16:32:04.117470519 +0100
@@ -36,17 +36,25 @@
 extern struct lcdc_platform_data atstk1000_fb0_data;
 
 static struct cf_platform_data __initdata cf0_data = {
-	.detect_pin	= GPIO_PIN_PB(15),
+	// .detect_pin	= GPIO_PIN_PB(15),
 	.reset_pin	= GPIO_PIN_PB(30),
 };
 
 static struct spi_board_info spi0_board_info[] __initdata = {
+#if 1	// do it here to wire GPIO pins up
 	{
-		/* QVGA display */
-		.modalias	= "ltv350qv",
-		.max_speed_hz	= 16000000,
-		.chip_select	= 1,
+		/* AT73C213 audio codec */
+		.modalias	= "at73c213",
+		.max_speed_hz   = 200000,
+		.chip_select    = 0,
 	},
+#endif
+	{
+                /* QVGA display */
+                .modalias       = "ltv350qv",
+                .max_speed_hz   = 16000000,
+                .chip_select    = 1,
+        },
 };
 
 static struct mci_platform_data __initdata mci0_data = {
@@ -163,6 +171,7 @@
 	at32_add_device_lcdc(0, &atstk1000_fb0_data);
 	at32_add_device_usba(0);
 	at32_add_device_abdac(0);
+	at32_add_device_ssc(0);
 	at32_add_device_cf(0, 3, &cf0_data);
 
 	return 0;
--- linux-2.6.20/arch/avr32/mach-at32ap/at32ap7000.c	2007-03-07 09:47:58.192249147 +0100
+++ linux-2.6.20-hacked-up/arch/avr32/mach-at32ap/at32ap7000.c	2007-03-05 16:31:52.048782764 +0100
@@ -1079,6 +1079,42 @@
 }
 
 /* --------------------------------------------------------------------
+ *  SSC
+ * -------------------------------------------------------------------- */
+
+struct resource ssc0_resource[] = {
+        PBMEM(0xffe01c00),
+        IRQ(10),
+};
+DEFINE_DEV(ssc, 0);
+DEV_CLK(ssc_clk, ssc0, pba, 7);
+
+struct platform_device *__init
+at32_add_device_ssc(unsigned int id)
+{
+        struct platform_device *pdev;
+
+        switch (id) {
+        case 0:
+                pdev = &ssc0_device;
+
+		select_peripheral(PA(21), PERIPH_A, 0);	/* RX_FSYNC     */
+		select_peripheral(PA(22), PERIPH_A, 0);	/* RX_CLOCK     */
+		select_peripheral(PA(26), PERIPH_A, 0);	/* RX_DATA      */
+		select_peripheral(PA(24), PERIPH_A, 0);	/* TX_FSYNC     */
+		select_peripheral(PA(23), PERIPH_A, 0);	/* TX_CLOCK     */
+		select_peripheral(PA(25), PERIPH_A, 0); /* TX_DATA      */
+
+                break;
+        default:
+                return NULL;
+        }
+
+        platform_device_register(pdev);
+        return pdev;
+}
+
+/* --------------------------------------------------------------------
  *  DAC
  * -------------------------------------------------------------------- */
 static struct resource abdac0_resource[] = {
@@ -1321,6 +1357,7 @@
 	&usba0_pclk,
 	&usba0_hclk,
 	&atmel_ac97c0_pclk,
+	&ssc0_ssc_clk,
 	&abdac0_pclk,
 	&abdac0_sample_clk,
 	&gclk0,
--- linux-2.6.20/arch/avr32/mm/init.c	2007-02-04 19:44:54.000000000 +0100
+++ linux-2.6.20-hacked-up/arch/avr32/mm/init.c	2007-03-04 15:46:33.082182287 +0100
@@ -371,7 +371,7 @@
 		low = pgdat->bdata->node_low_pfn;
 
 		memset(zones_size, 0, sizeof(zones_size));
-		zones_size[ZONE_NORMAL] = low - start_pfn;
+		zones_size[ZONE_DMA] = low - start_pfn;
 
 		printk("Node %u: start_pfn = 0x%lx, low = 0x%lx\n",
 		       nid, start_pfn, low);
