--- a/arch/powerpc/include/asm/ps3stor.h	2012-01-03 19:41:27.000000000 +0100
+++ b/arch/powerpc/include/asm/ps3stor.h	2012-01-05 16:38:31.006804326 +0100
@@ -30,6 +30,7 @@
 	unsigned int id;
 	u64 start;
 	u64 size;
+	u64 flags;
 };

 struct ps3_storage_device {
@@ -50,7 +51,6 @@

 	unsigned int num_regions;
 	unsigned long accessible_regions;
-	unsigned int region_idx;		/* first accessible region */
 	struct ps3_storage_region regions[0];	/* Must be last */
 };

@@ -62,8 +62,8 @@
 extern int ps3stor_setup(struct ps3_storage_device *dev,
 			 irq_handler_t handler);
 extern void ps3stor_teardown(struct ps3_storage_device *dev);
-extern u64 ps3stor_read_write_sectors(struct ps3_storage_device *dev, u64 lpar,
-				      u64 start_sector, u64 sectors,
+extern u64 ps3stor_read_write_sectors(struct ps3_storage_device *dev, u64 lpar, unsigned int region_idx,
+				      u64 start_sector, u64 sectors, u64 flags,
 				      int write);
 extern u64 ps3stor_send_command(struct ps3_storage_device *dev, u64 cmd,
 				u64 arg1, u64 arg2, u64 arg3, u64 arg4);
--- a/drivers/ps3/ps3stor_lib.c	2012-01-05 16:42:51.670823329 +0100
+++ b/drivers/ps3/ps3stor_lib.c	2012-01-05 16:44:22.208906179 +0100
@@ -101,9 +101,8 @@
 			"%s:%u: checking accessibility of region %u\n",
 			__func__, __LINE__, i);

-		dev->region_idx = i;
-		res = ps3stor_read_write_sectors(dev, dev->bounce_lpar, 0, 1,
-						 0);
+		res = ps3stor_read_write_sectors(dev, dev->bounce_lpar, i, 0, 1,
+						 dev->regions[i].flags, 0);
 		if (res) {
 			dev_dbg(&dev->sbd.core, "%s:%u: read failed, "
 				"region %u is not accessible\n", __func__,
@@ -115,6 +114,10 @@
 			__func__, __LINE__, i);
 		set_bit(i, &dev->accessible_regions);

+		dev_info(&dev->sbd.core,
+			 "accessible region %u start %llu size %llu\n",
+			 i, dev->regions[i].start, dev->regions[i].size);
+
 		/* We can access at least one region */
 		error = 0;
 	}
@@ -124,14 +127,8 @@
 	n = hweight_long(dev->accessible_regions);
 	if (n > 1)
 		dev_info(&dev->sbd.core,
-			 "%s:%u: %lu accessible regions found. Only the first "
-			 "one will be used\n",
+			 "%s:%u: %lu accessible regions found\n",
 			 __func__, __LINE__, n);
-	dev->region_idx = __ffs(dev->accessible_regions);
-	dev_info(&dev->sbd.core,
-		 "First accessible region has index %u start %llu size %llu\n",
-		 dev->region_idx, dev->regions[dev->region_idx].start,
-		 dev->regions[dev->region_idx].size);

 	return 0;
 }
@@ -265,17 +262,19 @@
  *	ps3stor_read_write_sectors - read/write from/to a storage device
  *	@dev: Pointer to a struct ps3_storage_device
  *	@lpar: HV logical partition address
+ *	@region_idx: Region index
  *	@start_sector: First sector to read/write
  *	@sectors: Number of sectors to read/write
+ *	@flags: Flags
  *	@write: Flag indicating write (non-zero) or read (zero)
  *
  *	Returns 0 for success, -1 in case of failure to submit the command, or
  *	an LV1 status value in case of other errors
  */
-u64 ps3stor_read_write_sectors(struct ps3_storage_device *dev, u64 lpar,
-			       u64 start_sector, u64 sectors, int write)
+u64 ps3stor_read_write_sectors(struct ps3_storage_device *dev, u64 lpar, unsigned int region_idx,
+			       u64 start_sector, u64 sectors, u64 flags, int write)
 {
-	unsigned int region_id = dev->regions[dev->region_idx].id;
+	unsigned int region_id = dev->regions[region_idx].id;
 	const char *op = write ? "write" : "read";
 	int res;

@@ -284,10 +283,10 @@

 	init_completion(&dev->done);
 	res = write ? lv1_storage_write(dev->sbd.dev_id, region_id,
-					start_sector, sectors, 0, lpar,
+					start_sector, sectors, flags, lpar,
 					&dev->tag)
 		    : lv1_storage_read(dev->sbd.dev_id, region_id,
-				       start_sector, sectors, 0, lpar,
+				       start_sector, sectors, flags, lpar,
 				       &dev->tag);
 	if (res) {
 		dev_dbg(&dev->sbd.core, "%s:%u: %s failed %d\n", __func__,
--- a/drivers/block/ps3disk.c	2013-02-14 11:22:05.716017676 +0100
+++ b/drivers/block/ps3disk.c	2013-02-14 11:19:47.200033102 +0100
@@ -32,7 +32,8 @@

 #define BOUNCE_SIZE		(64*1024)

-#define PS3DISK_MAX_DISKS	16
+#define PS3DISK_MAX_NUM_REGS	8
+
 #define PS3DISK_MINORS		16


@@ -41,13 +42,14 @@
 
 struct ps3disk_private {
 	spinlock_t lock;		/* Request queue spinlock */
-	struct request_queue *queue;
 	struct blk_mq_tag_set tag_set;
-	struct gendisk *gendisk;
 	unsigned int blocking_factor;
 	struct request *req;
 	u64 raw_capacity;
 	unsigned char model[ATA_ID_PROD_LEN+1];
+	struct gendisk *gendisk[PS3DISK_MAX_NUM_REGS];
+	struct request_queue *queue[PS3DISK_MAX_NUM_REGS];
+	int next_queue;
 };
 
 
@@ -88,6 +90,13 @@
 	.owner		= THIS_MODULE,
 };

+static unsigned int region_flags[] =
+{
+	0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+};
+module_param_array(region_flags, uint, NULL, S_IRUGO);
+MODULE_PARM_DESC(region_flags, "Region flags");
+

 static void ps3disk_scatter_gather(struct ps3_storage_device *dev,
 				   struct request *req, int gather)
@@ -126,7 +135,9 @@
 	int write = rq_data_dir(req), res;
 	const char *op = write ? "write" : "read";
 	u64 start_sector, sectors;
-	unsigned int region_id = dev->regions[dev->region_idx].id;
+	unsigned int region_idx = MINOR(disk_devt(req->rq_disk)) / PS3DISK_MINORS;
+	unsigned int region_id = dev->regions[region_idx].id;
+	unsigned int region_flags = dev->regions[region_idx].flags;

 #ifdef DEBUG
 	unsigned int n = 0;
@@ -149,11 +160,11 @@
 		ps3disk_scatter_gather(dev, req, 1);

 		res = lv1_storage_write(dev->sbd.dev_id, region_id,
-					start_sector, sectors, 0,
+					start_sector, sectors, region_flags,
 					dev->bounce_lpar, &dev->tag);
 	} else {
 		res = lv1_storage_read(dev->sbd.dev_id, region_id,
-				       start_sector, sectors, 0,
+				       start_sector, sectors, region_flags,
 				       dev->bounce_lpar, &dev->tag);
 	}
 	if (res) {
@@ -232,6 +243,8 @@
 	int res, read, error;
 	u64 tag, status;
 	const char *op;
+	struct request_queue *q;
+	int old_queue;

 	res = lv1_storage_get_async_status(dev->sbd.dev_id, &tag, &status);

@@ -279,7 +292,20 @@
 	spin_lock(&priv->lock);
 	priv->req = NULL;
 	blk_mq_end_request(req, error);
+	old_queue = priv->next_queue;
+	do {
+		q = priv->queue[priv->next_queue];
+
+		priv->next_queue++;
+		if (priv->next_queue >= dev->num_regions)
+			priv->next_queue = 0;
+
+		if (q) {
+			ps3disk_do_request(dev, blk_fetch_request(q));
+			if (priv->req)
+				break;
+		}
+	} while (old_queue != priv->next_queue);
 	spin_unlock(&priv->lock);

-	blk_mq_run_hw_queues(priv->queue, true);
 	return IRQ_HANDLED;
@@ -397,23 +423,21 @@
 	return 0;
 }

-static unsigned long ps3disk_mask;
-
-static DEFINE_MUTEX(ps3disk_mask_mutex);
-
 static const struct blk_mq_ops ps3disk_mq_ops = {
 	.queue_rq	= ps3disk_queue_rq,
 };
 
 static int ps3disk_probe(struct ps3_system_bus_device *_dev)
 {
 	struct ps3_storage_device *dev = to_ps3_storage_device(&_dev->core);
 	struct ps3disk_private *priv;
 	int error;
-	unsigned int devidx;
+	unsigned int regidx, devidx;
 	struct request_queue *queue;
 	struct gendisk *gendisk;

+	BUG_ON(dev->num_regions > PS3DISK_MAX_NUM_REGS);
+
 	if (dev->blk_size < 512) {
 		dev_err(&dev->sbd.core,
 			"%s:%u: cannot handle block size %llu\n", __func__,
@@ -417,18 +441,6 @@
 		return -EINVAL;
 	}

-	BUILD_BUG_ON(PS3DISK_MAX_DISKS > BITS_PER_LONG);
-	mutex_lock(&ps3disk_mask_mutex);
-	devidx = find_first_zero_bit(&ps3disk_mask, PS3DISK_MAX_DISKS);
-	if (devidx >= PS3DISK_MAX_DISKS) {
-		dev_err(&dev->sbd.core, "%s:%u: Too many disks\n", __func__,
-			__LINE__);
-		mutex_unlock(&ps3disk_mask_mutex);
-		return -ENOSPC;
-	}
-	__set_bit(devidx, &ps3disk_mask);
-	mutex_unlock(&ps3disk_mask_mutex);
-
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv) {
 		error = -ENOMEM;
@@ -446,6 +446,9 @@
 		error = -ENOMEM;
 		goto fail_free_priv;
 	}
+	
+	for (regidx = 0; regidx < dev->num_regions; regidx++)
+		dev->regions[regidx].flags = region_flags[regidx];
 
 	error = ps3stor_setup(dev, ps3disk_interrupt);
 	if (error)
@@ -453,60 +456,68 @@
 
 	ps3disk_identify(dev);
 
-	queue = blk_mq_init_sq_queue(&priv->tag_set, &ps3disk_mq_ops, 1,
+	for (devidx = 0; devidx < dev->num_regions; devidx++)
+	{
+		if (test_bit(devidx, &dev->accessible_regions) == 0)
+			continue;
+		queue = blk_mq_init_sq_queue(&priv->tag_set, &ps3disk_mq_ops, 1,
 					BLK_MQ_F_SHOULD_MERGE);
-	if (IS_ERR(queue)) {
-		dev_err(&dev->sbd.core, "%s:%u: blk_mq_init_queue failed\n",
-			__func__, __LINE__);
-		error = PTR_ERR(queue);
-		goto fail_teardown;
+		if (!queue) {
+			dev_err(&dev->sbd.core, "%s:%u: blk_init_queue failed\n",
+				__func__, __LINE__);
+			error = -ENOMEM;
+			goto fail_cleanup;
+		}
+		priv->queue[devidx] = queue;
+		queue->queuedata = dev;
+		blk_queue_max_hw_sectors(queue, dev->bounce_size >> 9);
+		blk_queue_segment_boundary(queue, -1UL);
+		blk_queue_dma_alignment(queue, dev->blk_size-1);
+		blk_queue_logical_block_size(queue, dev->blk_size);
+
+		blk_queue_write_cache(queue, true, false);
+
+		blk_queue_max_segments(queue, -1);
+		blk_queue_max_segment_size(queue, dev->bounce_size);
+
+		gendisk = alloc_disk(PS3DISK_MINORS);
+		if (!gendisk) {
+			dev_err(&dev->sbd.core, "%s:%u: alloc_disk failed\n", __func__,
+				__LINE__);
+			error = -ENOMEM;
+			goto fail_cleanup;
+		}
+		priv->gendisk[devidx] = gendisk;
+		gendisk->major = ps3disk_major;
+		gendisk->first_minor = devidx * PS3DISK_MINORS;
+		gendisk->fops = &ps3disk_fops;
+		gendisk->queue = queue;
+		gendisk->private_data = dev;
+		snprintf(gendisk->disk_name, sizeof(gendisk->disk_name), PS3DISK_NAME,
+			 devidx+'a');
+		priv->blocking_factor = dev->blk_size >> 9;
+		set_capacity(gendisk,
+			     dev->regions[devidx].size*priv->blocking_factor);
+
+		dev_info(&dev->sbd.core,
+			 "%s is a %s (%llu MiB total, %lu MiB region)\n",
+			 gendisk->disk_name, priv->model, priv->raw_capacity >> 11,
+			 get_capacity(gendisk) >> 11);
+		device_add_disk(&dev->sbd.core, gendisk, NULL);
 	}
-
-	priv->queue = queue;
-	queue->queuedata = dev;
-
-	blk_queue_max_hw_sectors(queue, dev->bounce_size >> 9);
-	blk_queue_segment_boundary(queue, -1UL);
-	blk_queue_dma_alignment(queue, dev->blk_size-1);
-	blk_queue_logical_block_size(queue, dev->blk_size);
-
-	blk_queue_write_cache(queue, true, false);
-
-	blk_queue_max_segments(queue, -1);
-	blk_queue_max_segment_size(queue, dev->bounce_size);
-
-	gendisk = alloc_disk(PS3DISK_MINORS);
-	if (!gendisk) {
-		dev_err(&dev->sbd.core, "%s:%u: alloc_disk failed\n", __func__,
-			__LINE__);
-		error = -ENOMEM;
-		goto fail_cleanup_queue;
-	}
-
-	priv->gendisk = gendisk;
-	gendisk->major = ps3disk_major;
-	gendisk->first_minor = devidx * PS3DISK_MINORS;
-	gendisk->fops = &ps3disk_fops;
-	gendisk->queue = queue;
-	gendisk->private_data = dev;
-	snprintf(gendisk->disk_name, sizeof(gendisk->disk_name), PS3DISK_NAME,
-		 devidx+'a');
-	priv->blocking_factor = dev->blk_size >> 9;
-	set_capacity(gendisk,
-		     dev->regions[dev->region_idx].size*priv->blocking_factor);
-
-	dev_info(&dev->sbd.core,
-		 "%s is a %s (%llu MiB total, %lu MiB for OtherOS)\n",
-		 gendisk->disk_name, priv->model, priv->raw_capacity >> 11,
-		 get_capacity(gendisk) >> 11);
-
-	device_add_disk(&dev->sbd.core, gendisk, NULL);
 	return 0;
-
-fail_cleanup_queue:
-	blk_cleanup_queue(queue);
-	blk_mq_free_tag_set(&priv->tag_set);
-fail_teardown:
+fail_cleanup:
+	for (devidx = 0; devidx < dev->num_regions; devidx++)
+	{
+		if (priv->gendisk[devidx]) {
+			del_gendisk(priv->gendisk[devidx]);
+			put_disk(priv->gendisk[devidx]);
+		}
+		if (priv->queue[devidx]) {
+			blk_cleanup_queue(priv->queue[devidx]);
+			blk_mq_free_tag_set(&priv->tag_set);
+		}
+	}
 	ps3stor_teardown(dev);
 fail_free_bounce:
 	kfree(dev->bounce_buf);
@@ -513,9 +543,6 @@
 	kfree(priv);
 	ps3_system_bus_set_drvdata(_dev, NULL);
 fail:
-	mutex_lock(&ps3disk_mask_mutex);
-	__clear_bit(devidx, &ps3disk_mask);
-	mutex_unlock(&ps3disk_mask_mutex);
 	return error;
 }

@@ -523,15 +550,21 @@
 {
 	struct ps3_storage_device *dev = to_ps3_storage_device(&_dev->core);
 	struct ps3disk_private *priv = ps3_system_bus_get_drvdata(&dev->sbd);
+	unsigned int devidx;
+
+	for (devidx = 0; devidx < dev->num_regions; devidx++)
+	{
+		if (priv->gendisk[devidx]) {
+			del_gendisk(priv->gendisk[devidx]);
+			put_disk(priv->gendisk[devidx]);
+		}
+
+		if (priv->queue[devidx]) {
+			blk_cleanup_queue(priv->queue[devidx]);
+			blk_mq_free_tag_set(&priv->tag_set);
+		}
+	}

-	mutex_lock(&ps3disk_mask_mutex);
-	__clear_bit(MINOR(disk_devt(priv->gendisk)) / PS3DISK_MINORS,
-		    &ps3disk_mask);
-	mutex_unlock(&ps3disk_mask_mutex);
-	del_gendisk(priv->gendisk);
-	blk_cleanup_queue(priv->queue);
-	blk_mq_free_tag_set(&priv->tag_set);
-	put_disk(priv->gendisk);
 	dev_notice(&dev->sbd.core, "Synchronizing disk cache\n");
 	ps3disk_sync_cache(dev);
 	ps3stor_teardown(dev);
--- a/drivers/scsi/ps3rom.c	2012-01-03 19:41:27.000000000 +0100
+++ b/drivers/scsi/ps3rom.c	2012-01-05 16:38:58.103891705 +0100
@@ -72,6 +72,14 @@
 };


+static unsigned int region_flags[] =
+{
+	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+};
+module_param_array(region_flags, uint, NULL, S_IRUGO);
+MODULE_PARM_DESC(region_flags, "Region flags");
+
+
 static int ps3rom_slave_configure(struct scsi_device *scsi_dev)
 {
 	struct ps3rom_private *priv = shost_priv(scsi_dev->host);
@@ -172,12 +180,13 @@
 			       u32 sectors)
 {
 	int res;
+	unsigned int region_idx = 0;

 	dev_dbg(&dev->sbd.core, "%s:%u: read %u sectors starting at %u\n",
 		__func__, __LINE__, sectors, start_sector);

 	res = lv1_storage_read(dev->sbd.dev_id,
-			       dev->regions[dev->region_idx].id, start_sector,
+			       dev->regions[region_idx].id, start_sector,
 			       sectors, 0, dev->bounce_lpar, &dev->tag);
 	if (res) {
 		dev_err(&dev->sbd.core, "%s:%u: read failed %d\n", __func__,
@@ -193,6 +202,7 @@
 				u32 sectors)
 {
 	int res;
+	unsigned int region_idx = 0;

 	dev_dbg(&dev->sbd.core, "%s:%u: write %u sectors starting at %u\n",
 		__func__, __LINE__, sectors, start_sector);
@@ -200,7 +210,7 @@
 	scsi_sg_copy_to_buffer(cmd, dev->bounce_buf, dev->bounce_size);

 	res = lv1_storage_write(dev->sbd.dev_id,
-				dev->regions[dev->region_idx].id, start_sector,
+				dev->regions[region_idx].id, start_sector,
 				sectors, 0, dev->bounce_lpar, &dev->tag);
 	if (res) {
 		dev_err(&dev->sbd.core, "%s:%u: write failed %d\n", __func__,
@@ -362,6 +372,7 @@
 {
 	struct ps3_storage_device *dev = to_ps3_storage_device(&_dev->core);
 	int error;
+	unsigned int regidx;
 	struct Scsi_Host *host;
 	struct ps3rom_private *priv;

@@ -377,6 +388,9 @@
 	if (!dev->bounce_buf)
 		return -ENOMEM;

+	for (regidx = 0; regidx < dev->num_regions; regidx++)
+		dev->regions[regidx].flags = region_flags[regidx];
+
 	error = ps3stor_setup(dev, ps3rom_interrupt);
 	if (error)
 		goto fail_free_bounce;
