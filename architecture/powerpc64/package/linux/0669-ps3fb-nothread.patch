# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by scripts/Create-CopyPatch.
# 
# T2 SDE: architecture/powerpc64/package/.../0669-ps3fb-nothread.patch
# Copyright (C) 2020 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

Free system memory, bandwidth and simply the code by drawing into the
RSX DDR frame-buffer directly. Read-back is very slow, so just don't
do that, and use RSX accelerated X anyway ;-)

Signed-off-by: Ren√© Rebe <rene@exactcode.de>

--- linux-5.8/drivers/video/fbdev/ps3fb.c.vanilla	2020-08-22 20:13:32.532303812 +0200
+++ linux-5.8/drivers/video/fbdev/ps3fb.c	2020-08-22 20:19:25.384299632 +0200
@@ -37,7 +37,6 @@
 #include <linux/interrupt.h>
 #include <linux/console.h>
 #include <linux/ioctl.h>
-#include <linux/kthread.h>
 #include <linux/freezer.h>
 #include <linux/uaccess.h>
 #include <linux/fb.h>
@@ -165,8 +164,6 @@
 	atomic_t ext_flip;	/* on/off flip with vsync */
 	atomic_t f_count;	/* fb_open count */
 	int is_blanked;
-	int is_kicked;
-	struct task_struct *task;
 };
 static struct ps3fb_priv ps3fb;
 static int ps3fb_gpu_major;
@@ -750,27 +747,10 @@
 	return id;
 }
 
-static void ps3fb_sync_image(struct device *dev, u64 frame_offset,
-			     u64 dst_offset, u64 src_offset, u32 width,
-			     u32 height, u32 dst_line_length,
-			     u32 src_line_length)
+static void ps3fb_sync_image(struct device *dev, u64 frame_offset)
 {
 	int status;
 
-	src_offset += GPU_FB_START;
-
-	mutex_lock(&ps3_gpu_mutex);
-	status = ps3fb_fb_blit(&ps3fb.fifo,
-			       dst_offset,
-			       GPU_IOIF + src_offset,
-			       width, height,
-			       dst_line_length, src_line_length,
-			       L1GPU_FB_BLIT_WAIT_FOR_COMPLETION);
-	mutex_unlock(&ps3_gpu_mutex);
-
-	if (status)
-		dev_err(dev, "%s: ps3fb_fb_blit failed: %d\n", __func__,
-			status);
 #ifdef HEAD_A
 	status = lv1_gpu_display_flip(ps3fb.context_handle, 0, frame_offset);
 	if (status)
@@ -800,13 +780,9 @@
 		goto out;
 	}
 
-	xdr_base = frame * par->xdr_frame_size;
 	ddr_base = frame * par->ddr_frame_size;
 
-	ps3fb_sync_image(info->device, ddr_base + par->full_offset,
-			 ddr_base + par->fb_offset, xdr_base + par->pan_offset,
-			 par->width, par->height, par->ddr_line_length,
-			 info->fix.line_length);
+	ps3fb_sync_image(info->device, ddr_base + par->full_offset);
 
 out:
 	return error;
@@ -959,21 +935,10 @@
 		par->mode_id = par->new_mode_id;
 	}
 
-	/* Clear XDR frame buffer memory */
-	memset((void __force *)info->screen_base, 0, info->fix.smem_len);
-
 	/* Clear DDR frame buffer memory */
-	lines = vmode->yres * par->num_frames;
-	if (par->full_offset)
-		lines++;
-	maxlines = info->fix.smem_len / ddr_line_length;
-	for (dst = 0; lines; dst += maxlines * ddr_line_length) {
-		unsigned int l = min(lines, maxlines);
-		ps3fb_sync_image(info->device, 0, dst, 0, vmode->xres, l,
-				 ddr_line_length, ddr_line_length);
-		lines -= l;
-	}
+	memset((void __force *)info->screen_base, 0, info->fix.smem_len);
 
+	ps3fb_sync_image(info->device, 0);
 
 	/* test cursor init here */
 	int status = lv1_gpu_context_attribute(ps3fb.context_handle, 0x10b, 0/*head*/, 1, 0, 0); /* init */
@@ -1276,25 +1241,6 @@
 	return retval;
 }
 
-static int ps3fbd(void *arg)
-{
-	struct fb_info *info = arg;
-
-	set_freezable();
-	while (!kthread_should_stop()) {
-		try_to_freeze();
-		set_current_state(TASK_INTERRUPTIBLE);
-		if (ps3fb.is_kicked) {
-			ps3fb.is_kicked = 0;
-			console_lock();
-			ps3fb_sync(info, 0);	/* single buffer */
-			console_unlock();
-		}
-		schedule();
-	}
-	return 0;
-}
-
 static void ps3fb_print_graph_exception_info(struct device *dev,
 					     struct gpu_graph_exception_info *info)
 {
@@ -1345,11 +1291,6 @@
 	if (v1 & (1 << GPU_INTR_STATUS_VSYNC_1)) {
 		/* VSYNC */
 		ps3fb.vblank_count = head->vblank_count;
-		if (ps3fb.task && !ps3fb.is_blanked &&
-		    !atomic_read(&ps3fb.ext_flip)) {
-			ps3fb.is_kicked = 1;
-			wake_up_process(ps3fb.task);
-		}
 		wake_up_interruptible(&ps3fb.wait_vsync);
 	}
 
@@ -1471,7 +1412,6 @@
 	struct gpu_driver_info *dinfo;
 	void *fb_start;
 	int status;
-	struct task_struct *task;
 	unsigned long max_ps3fb_size;
 
 	if (ps3fb_videomemory.size < GPU_CMD_BUF_SIZE) {
@@ -1660,10 +1600,10 @@
 	 * frame buffer at offset GPU_FB_START and save some precious XDR
 	 * memory
 	 */
-	fb_start = ioremap_wc(ps3fb.vram_lpar, ps3fb_videomemory.size); //ps3fb_videomemory.address + GPU_FB_START;
+	fb_start = ioremap_wc(ps3fb.vram_lpar, 16*1024*1024); //ps3fb_videomemory.address + GPU_FB_START;
 	info->screen_base = (char __force __iomem *)fb_start;
 	info->fix.smem_start = ps3fb.vram_lpar; //__pa(fb_start);
-	info->fix.smem_len = ps3fb_videomemory.size - GPU_FB_START;
+	info->fix.smem_len = 16*1024*1024; // ps3fb_videomemory.size - GPU_FB_START;
 
 	info->pseudo_palette = par->pseudo_palette;
 	info->flags = FBINFO_DEFAULT | // FBINFO_READS_FAST |
@@ -1693,14 +1633,6 @@
 		 dev_driver_string(info->dev), dev_name(info->dev),
 		 info->fix.smem_len >> 10);
 
-	task = kthread_run(ps3fbd, info, DEVICE_NAME);
-	if (IS_ERR(task)) {
-		retval = PTR_ERR(task);
-		goto err_unregister_framebuffer;
-	}
-
-	ps3fb.task = task;
-
 	/* FIFO access */
 	status = register_chrdev(ps3fb_gpu_major, DEVICE_NAME, &ps3fb_gpu_fops);
 	if (status < 0) {
@@ -1757,11 +1689,6 @@
 	atomic_inc(&ps3fb.ext_flip);	/* flip off */
 	ps3fb.dinfo->irq.mask = 0;
 
-	if (ps3fb.task) {
-		struct task_struct *task = ps3fb.task;
-		ps3fb.task = NULL;
-		kthread_stop(task);
-	}
 	if (ps3fb.irq_no) {
 		free_irq(ps3fb.irq_no, &dev->core);
 		ps3_irq_plug_destroy(ps3fb.irq_no);
