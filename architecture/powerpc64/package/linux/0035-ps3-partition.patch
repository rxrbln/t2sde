# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by scripts/Create-CopyPatch.
# 
# T2 SDE: architecture/powerpc64/package/.../0035-ps3-partition.patch
# Copyright (C) 2019 - 2020 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

--- a/block/partitions/Kconfig
+++ b/block/partitions/Kconfig
@@ -262,6 +262,12 @@ config SYSV68_PARTITION
 	  sysv68).
 	  Otherwise, say N.
 
+config PS3_PARTITION
+	bool "PS3 Partition support"
+	depends on PARTITION_ADVANCED
+	help
+	  Say Y here if you would like to use PS3 hard disks under Linux.
+
 config CMDLINE_PARTITION
 	bool "Command line partition support" if PARTITION_ADVANCED
 	select BLK_CMDLINE_PARSER
--- a/block/partitions/Makefile
+++ b/block/partitions/Makefile
@@ -21,3 +21,4 @@ obj-$(CONFIG_IBM_PARTITION) += ibm.o
 obj-$(CONFIG_EFI_PARTITION) += efi.o
 obj-$(CONFIG_KARMA_PARTITION) += karma.o
 obj-$(CONFIG_SYSV68_PARTITION) += sysv68.o
+obj-$(CONFIG_PS3_PARTITION) += ps3.o
--- a/block/partitions/core.c
+++ b/block/partitions/core.c
@@ -11,6 +11,7 @@
 #include <linux/blktrace_api.h>
 #include <linux/raid/detect.h>
 #include "check.h"
+#include "ps3.h"
 
 static int (*check_part[])(struct parsed_partitions *) = {
 	/*
@@ -81,6 +82,9 @@ static int (*check_part[])(struct parsed_partitions *) = {
 #endif
 #ifdef CONFIG_SYSV68_PARTITION
 	sysv68_partition,
+#endif
+#ifdef CONFIG_PS3_PARTITION
+	ps3_partition,
 #endif
 	NULL
 };
--- /dev/null
+++ b/block/partitions/ps3.c
@@ -0,0 +1,98 @@
+/*
+ *  fs/partitions/ps3.c
+ *
+ *  Copyright (C) 2012 glevand <geoffrey.levand@mail.ru>
+ */
+
+#include "check.h"
+#include "ps3.h"
+
+#define SECTOR_SIZE		512
+#define MAX_ACL_ENTRIES		8
+#define MAX_PARTITIONS		8
+
+#define MAGIC1			0x0FACE0FFULL
+#define MAGIC2			0xDEADFACEULL
+
+struct p_acl_entry {
+	__be64 laid;
+	__be64 rights;
+};
+
+struct d_partition {
+	__be64 p_start;
+	__be64 p_size;
+	struct p_acl_entry p_acl[MAX_ACL_ENTRIES];
+};
+
+struct disklabel {
+	u8 d_res1[16];
+	__be64 d_magic1;
+	__be64 d_magic2;
+	__be64 d_res2;
+	__be64 d_res3;
+	struct d_partition d_partitions[MAX_PARTITIONS];
+	u8 d_pad[0x600 - MAX_PARTITIONS * sizeof(struct d_partition)- 0x30];
+};
+
+static bool ps3_read_disklabel(struct parsed_partitions *state, struct disklabel *label)
+{
+	Sector sect;
+	unsigned char *data;
+	int i;
+
+	for (i = 0; i < sizeof(struct disklabel) / SECTOR_SIZE; i++) {
+		data = read_part_sector(state, i, &sect);
+		if (!data)
+			return (false);
+
+		memcpy((unsigned char *) label + i * SECTOR_SIZE, data, SECTOR_SIZE);
+
+		put_dev_sector(sect);
+	}
+
+	return (true);
+}
+
+int ps3_partition(struct parsed_partitions *state)
+{
+	struct disklabel *label = NULL;
+	int slot = 1;
+	int result = -1;
+	int i;
+
+	label = kmalloc(sizeof(struct disklabel), GFP_KERNEL);
+	if (!label)
+		goto out;
+
+	if (!ps3_read_disklabel(state, label))
+		goto out;
+
+	result = 0;
+
+	if ((be64_to_cpu(label->d_magic1) != MAGIC1) ||
+	    (be64_to_cpu(label->d_magic2) != MAGIC2))
+		goto out;
+
+	for (i = 0; i < MAX_PARTITIONS; i++) {
+		if (label->d_partitions[i].p_start && label->d_partitions[i].p_size) {
+			put_partition(state, slot,
+				be64_to_cpu(label->d_partitions[i].p_start),
+				be64_to_cpu(label->d_partitions[i].p_size));
+			slot++;
+		}
+	}
+
+	strlcat(state->pp_buf, "\n", PAGE_SIZE);
+
+	kfree(label);
+
+	return (1);
+
+out:
+
+	if (label)
+		kfree(label);
+
+	return (result);
+}
--- /dev/null
+++ b/block/partitions/ps3.h
@@ -0,0 +1,5 @@
+/*
+ *  fs/partitions/ps3.h
+ */
+
+int ps3_partition(struct parsed_partitions *state);
