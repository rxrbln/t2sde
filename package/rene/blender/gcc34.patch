# --- ROCK-COPYRIGHT-NOTE-BEGIN ---
# 
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# Please add additional copyright information _after_ the line containing
# the ROCK-COPYRIGHT-NOTE-END tag. Otherwise it might get removed by
# the ./scripts/Create-CopyPatch script. Do not edit this copyright text!
# 
# ROCK Linux: rock-src/package/rene/blender/gcc34.patch
# ROCK Linux is Copyright (C) 1998 - 2004 Clifford Wolf
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# 
# --- ROCK-COPYRIGHT-NOTE-END ---

Well blender needs some more gcc-3.4 adaptions :-(

  - Rene Rebe <rene@rocklinux.org>

diff -ur blender-2.33-orig/extern/solid/include/MT/Interval.h blender-2.33/extern/solid/include/MT/Interval.h
--- blender-2.33-orig/extern/solid/include/MT/Interval.h	2004-02-16 16:59:03.000000000 +0100
+++ blender-2.33/extern/solid/include/MT/Interval.h	2004-05-13 11:39:04.073503624 +0200
@@ -111,7 +111,7 @@
 	inline std::ostream& 
 	operator<<(std::ostream& os, const Interval<Scalar>& z)
 	{
-		return os << '[' << x.lower() << ", " << x.upper() << ']';
+		return os << '[' << z.lower() << ", " << z.upper() << ']';
 	}
 
 	template <typename Scalar>
diff -ur blender-2.33-orig/extern/solid/include/MT/Quaternion.h blender-2.33/extern/solid/include/MT/Quaternion.h
--- blender-2.33-orig/extern/solid/include/MT/Quaternion.h	2004-02-16 16:59:03.000000000 +0100
+++ blender-2.33/extern/solid/include/MT/Quaternion.h	2004-05-13 11:39:25.245285024 +0200
@@ -84,19 +84,19 @@
   
 		Quaternion<Scalar>& operator+=(const Quaternion<Scalar>& q)
 		{
-			m_co[0] += q[0]; m_co[1] += q[1]; m_co[2] += q[2]; m_co[3] += q[3];
+			this->m_co[0] += q[0]; this->m_co[1] += q[1]; this->m_co[2] += q[2]; this->m_co[3] += q[3];
 			return *this;
 		}
 		
 		Quaternion<Scalar>& operator-=(const Quaternion<Scalar>& q) 
 		{
-			m_co[0] -= q[0]; m_co[1] -= q[1]; m_co[2] -= q[2]; m_co[3] -= q[3];
+			this->m_co[0] -= q[0]; this->m_co[1] -= q[1]; this->m_co[2] -= q[2]; this->m_co[3] -= q[3];
 			return *this;
 		}
 
 		Quaternion<Scalar>& operator*=(const Scalar& s)
 		{
-			m_co[0] *= s; m_co[1] *= s; m_co[2] *= s; m_co[3] *= s;
+			this->m_co[0] *= s; this->m_co[1] *= s; this->m_co[2] *= s; this->m_co[3] *= s;
 			return *this;
 		}
 		
@@ -108,16 +108,16 @@
   
 		Quaternion<Scalar>& operator*=(const Quaternion<Scalar>& q)
 		{
-			setValue(m_co[3] * q[0] + m_co[0] * q[3] + m_co[1] * q[2] - m_co[2] * q[1],
-					 m_co[3] * q[1] + m_co[1] * q[3] + m_co[2] * q[0] - m_co[0] * q[2],
-					 m_co[3] * q[2] + m_co[2] * q[3] + m_co[0] * q[1] - m_co[1] * q[0],
-					 m_co[3] * q[3] - m_co[0] * q[0] - m_co[1] * q[1] - m_co[2] * q[2]);
+			setValue(this->m_co[3] * q[0] + this->m_co[0] * q[3] + this->m_co[1] * q[2] - this->m_co[2] * q[1],
+					 this->m_co[3] * q[1] + this->m_co[1] * q[3] + this->m_co[2] * q[0] - this->m_co[0] * q[2],
+					 this->m_co[3] * q[2] + this->m_co[2] * q[3] + this->m_co[0] * q[1] - this->m_co[1] * q[0],
+					 this->m_co[3] * q[3] - this->m_co[0] * q[0] - this->m_co[1] * q[1] - this->m_co[2] * q[2]);
 			return *this;
 		}
 	
 		Scalar dot(const Quaternion<Scalar>& q) const
 		{
-			return m_co[0] * q[0] + m_co[1] * q[1] + m_co[2] * q[2] + m_co[3] * q[3];
+			return this->m_co[0] * q[0] + this->m_co[1] * q[1] + this->m_co[2] * q[2] + this->m_co[3] * q[3];
 		}
 
 		Scalar length2() const
@@ -149,7 +149,7 @@
    
 		Quaternion<Scalar> conjugate() const 
 		{
-			return Quaternion<Scalar>(-m_co[0], -m_co[1], -m_co[2], m_co[3]);
+			return Quaternion<Scalar>(- this->m_co[0], - this->m_co[1], - this->m_co[2], this->m_co[3]);
 		}
 
 		Quaternion<Scalar> inverse() const
@@ -165,10 +165,10 @@
 				Scalar d = Scalar(1.0) / Scalar_traits<Scalar>::sin(theta);
 				Scalar s0 = Scalar_traits<Scalar>::sin((Scalar(1.0) - t) * theta);
 				Scalar s1 = Scalar_traits<Scalar>::sin(t * theta);   
-				return Quaternion<Scalar>((m_co[0] * s0 + q[0] * s1) * d,
-										  (m_co[1] * s0 + q[1] * s1) * d,
-										  (m_co[2] * s0 + q[2] * s1) * d,
-										  (m_co[3] * s0 + q[3] * s1) * d);
+				return Quaternion<Scalar>((this->m_co[0] * s0 + q[0] * s1) * d,
+										  (this->m_co[1] * s0 + q[1] * s1) * d,
+										  (this->m_co[2] * s0 + q[2] * s1) * d,
+										  (this->m_co[3] * s0 + q[3] * s1) * d);
 			}
 			else
 			{
diff -ur blender-2.33-orig/extern/solid/include/MT/Vector3.h blender-2.33/extern/solid/include/MT/Vector3.h
--- blender-2.33-orig/extern/solid/include/MT/Vector3.h	2004-02-16 16:59:03.000000000 +0100
+++ blender-2.33/extern/solid/include/MT/Vector3.h	2004-05-13 11:49:17.590234904 +0200
@@ -45,19 +45,19 @@
 		
 		Vector3<Scalar>& operator+=(const Vector3<Scalar>& v)
 		{
-			m_co[0] += v[0]; m_co[1] += v[1]; m_co[2] += v[2];
+			this->m_co[0] += v[0]; this->m_co[1] += v[1]; this->m_co[2] += v[2];
 			return *this;
 		}
 		
 		Vector3<Scalar>& operator-=(const Vector3<Scalar>& v) 
 		{
-			m_co[0] -= v[0]; m_co[1] -= v[1]; m_co[2] -= v[2];
+			this->m_co[0] -= v[0]; this->m_co[1] -= v[1]; this->m_co[2] -= v[2];
 			return *this;
 		}
 
 		Vector3<Scalar>& operator*=(const Scalar& s)
 		{
-			m_co[0] *= s; m_co[1] *= s; m_co[2] *= s;
+			this->m_co[0] *= s; this->m_co[1] *= s; this->m_co[2] *= s;
 			return *this;
 		}
 		
@@ -69,7 +69,7 @@
   
 		Scalar dot(const Vector3<Scalar>& v) const
 		{
-			return m_co[0] * v[0] + m_co[1] * v[1] + m_co[2] * v[2];
+			return this->m_co[0] * v[0] + this->m_co[1] * v[1] + this->m_co[2] * v[2];
 		}
 
 		Scalar length2() const
@@ -111,33 +111,33 @@
    
 		Vector3<Scalar> absolute() const 
 		{
-			return Vector3<Scalar>(Scalar_traits<Scalar>::abs(m_co[0]), 
-								   Scalar_traits<Scalar>::abs(m_co[1]), 
-								   Scalar_traits<Scalar>::abs(m_co[2]));
+			return Vector3<Scalar>(Scalar_traits<Scalar>::abs(this->m_co[0]), 
+								   Scalar_traits<Scalar>::abs(this->m_co[1]), 
+								   Scalar_traits<Scalar>::abs(this->m_co[2]));
 		}
 
 		Vector3<Scalar> cross(const Vector3<Scalar>& v) const
 		{
-			return Vector3<Scalar>(m_co[1] * v[2] - m_co[2] * v[1],
-								   m_co[2] * v[0] - m_co[0] * v[2],
-								   m_co[0] * v[1] - m_co[1] * v[0]);
+			return Vector3<Scalar>(this->m_co[1] * v[2] - this->m_co[2] * v[1],
+								   this->m_co[2] * v[0] - this->m_co[0] * v[2],
+								   this->m_co[0] * v[1] - this->m_co[1] * v[0]);
 		}
 		
 		Scalar triple(const Vector3<Scalar>& v1, const Vector3<Scalar>& v2) const
 		{
-			return m_co[0] * (v1[1] * v2[2] - v1[2] * v2[1]) + 
-				   m_co[1] * (v1[2] * v2[0] - v1[0] * v2[2]) + 
-				   m_co[2] * (v1[0] * v2[1] - v1[1] * v2[0]);
+			return this->m_co[0] * (v1[1] * v2[2] - v1[2] * v2[1]) + 
+				   this->m_co[1] * (v1[2] * v2[0] - v1[0] * v2[2]) + 
+				   this->m_co[2] * (v1[0] * v2[1] - v1[1] * v2[0]);
 		}
 
 		int minAxis() const
 		{
-			return m_co[0] < m_co[1] ? (m_co[0] < m_co[2] ? 0 : 2) : (m_co[1] < m_co[2] ? 1 : 2);
+			return this->m_co[0] < this->m_co[1] ? (this->m_co[0] < this->m_co[2] ? 0 : 2) : (this->m_co[1] < this->m_co[2] ? 1 : 2);
 		}
 
 		int maxAxis() const 
 		{
-			return m_co[0] < m_co[1] ? (m_co[1] < m_co[2] ? 2 : 1) : (m_co[0] < m_co[2] ? 2 : 0);
+			return this->m_co[0] < this->m_co[1] ? (this->m_co[1] < this->m_co[2] ? 2 : 1) : (this->m_co[0] < this->m_co[2] ? 2 : 0);
 		}
 
 		int furthestAxis() const
@@ -152,9 +152,9 @@
 
 		Vector3<Scalar> lerp(const Vector3<Scalar>& v, const Scalar& t) const 
 		{
-			return Vector3<Scalar>(m_co[0] + (v[0] - m_co[0]) * t,
-								   m_co[1] + (v[1] - m_co[1]) * t,
-								   m_co[2] + (v[2] - m_co[2]) * t);
+			return Vector3<Scalar>(this->m_co[0] + (v[0] - this->m_co[0]) * t,
+								   this->m_co[1] + (v[1] - this->m_co[1]) * t,
+								   this->m_co[2] + (v[2] - this->m_co[2]) * t);
 		}
     
 		static Vector3<Scalar> random() 
diff -ur blender-2.33-orig/extern/solid/src/complex/DT_BBoxTree.h blender-2.33/extern/solid/src/complex/DT_BBoxTree.h
--- blender-2.33-orig/extern/solid/src/complex/DT_BBoxTree.h	2004-02-16 16:59:05.000000000 +0100
+++ blender-2.33/extern/solid/src/complex/DT_BBoxTree.h	2004-05-13 11:54:17.481644480 +0200
@@ -136,7 +136,7 @@
       : DT_Pack<Shape1, Shape2>(a, b),
         m_margin(margin)
     {
-        m_b_cbox += computeCBox(margin, m_a.m_inv_xform);
+        this->m_b_cbox += computeCBox(margin, this->m_a.m_inv_xform);
     }
     
     MT_Scalar m_margin;
@@ -185,7 +185,7 @@
 
     if (a.m_type == DT_BBoxTree::LEAF) 
     { 
-        return ::ray_cast(rd, a.m_index, source, target, lambda, normal); 
+        return ray_cast(rd, a.m_index, source, target, lambda, normal); 
     }
     else 
     {
diff -ur blender-2.33-orig/intern/iksolver/intern/TNT/vec.h blender-2.33/intern/iksolver/intern/TNT/vec.h
--- blender-2.33-orig/intern/iksolver/intern/TNT/vec.h	2002-11-20 15:43:09.000000000 +0100
+++ blender-2.33/intern/iksolver/intern/TNT/vec.h	2004-05-13 11:17:34.770507472 +0200
@@ -296,11 +296,11 @@
 {
     Subscript N=A.dim();
 
-    s <<  N << endl;
+    s <<  N << std::endl;
 
     for (Subscript i=0; i<N; i++)
-        s   << A[i] << " " << endl;
-    s << endl;
+        s   << A[i] << " " << std::endl;
+    s << std::endl;
 
     return s;
 }
