Use of tainted arguments in exec is deprecated at /var/www/cgi-bin/cvsweb.cgi line 2043.
===================================================================
RCS file: /home2/webcvs/mirror/kdepim/libkdenetwork/kmime_codec_qp.cpp,v
retrieving revision 1.12
retrieving revision 1.13
diff -u -p -r1.12 -r1.13
--- kdepim/libkdenetwork/kmime_codec_qp.cpp	2003/07/26 14:51:52	1.12
+++ kdepim/libkdenetwork/kmime_codec_qp.cpp	2003/10/30 14:15:30	1.13
@@ -189,6 +189,20 @@ public:
   bool finish( char* & dcursor, const char * const dend );
 };
 
+// this doesn't access any member variables, so it can be defined static
+// but then we can't call it from virtual functions
+static int QuotedPrintableDecoder_maxDecodedSizeFor( int insize, bool withCRLF ) {
+  // all chars unencoded:
+  int result = insize;
+  // but maybe all of them are \n and we need to make them \r\n :-o
+  if ( withCRLF )
+    result += insize;
+
+  // there might be an accu plus escape
+  result += 2;
+
+  return result;
+}
 
 Encoder * QuotedPrintableCodec::makeEncoder( bool withCRLF ) const {
   return new QuotedPrintableEncoder( withCRLF );
@@ -198,6 +212,10 @@ Decoder * QuotedPrintableCodec::makeDeco
   return new QuotedPrintableDecoder( withCRLF );
 }
 
+int QuotedPrintableCodec::maxDecodedSizeFor( int insize, bool withCRLF ) const {
+    return QuotedPrintableDecoder_maxDecodedSizeFor(insize, withCRLF);
+}
+
 Encoder * Rfc2047QEncodingCodec::makeEncoder( bool withCRLF ) const {
   return new Rfc2047QEncodingEncoder( withCRLF );
 }
@@ -206,6 +224,10 @@ Decoder * Rfc2047QEncodingCodec::makeDec
   return new QuotedPrintableDecoder( withCRLF, true );
 }
 
+int Rfc2047QEncodingCodec::maxDecodedSizeFor( int insize, bool withCRLF ) const {
+    return QuotedPrintableDecoder_maxDecodedSizeFor(insize, withCRLF);
+}
+
 Encoder * Rfc2231EncodingCodec::makeEncoder( bool withCRLF ) const {
   return new Rfc2047QEncodingEncoder( withCRLF, '%' );
 }
@@ -214,12 +236,14 @@ Decoder * Rfc2231EncodingCodec::makeDeco
   return new QuotedPrintableDecoder( withCRLF, true, '%' );
 }
 
+int Rfc2231EncodingCodec::maxDecodedSizeFor( int insize, bool withCRLF ) const {
+    return QuotedPrintableDecoder_maxDecodedSizeFor(insize, withCRLF);
+}
 
   /********************************************************/
   /********************************************************/
   /********************************************************/
 
-
 bool QuotedPrintableDecoder::decode( const char* & scursor, const char * const send,
 				     char* & dcursor, const char * const dend ) {
   if ( mWithCRLF )
@@ -402,7 +426,7 @@ bool QuotedPrintableEncoder::processNext
     bufferFill += 16;
 
   assert( bufferFill >=0 && bufferFill <= 15 );
-  
+
   if ( !mFinishing && !mSawLineEnd &&
        bufferFill < minBufferFillWithoutLineEnd )
     return false;
@@ -424,7 +448,7 @@ bool QuotedPrintableEncoder::processNext
   else
     // never needs encoding
     mAccuNeedsEncoding = Never;
-  
+
   return true;
 }
 
@@ -485,7 +509,7 @@ bool QuotedPrintableEncoder::encode( con
     // fill input buffer until eol has been reached or until the
     // buffer is full, whatever comes first:
     fillInputBuffer( scursor, send );
-    
+
     if ( processNextChar() )
       // there was one...
       createOutputBuffer( dcursor, dend );
@@ -506,7 +530,7 @@ bool QuotedPrintableEncoder::encode( con
   if ( mOutputBufferCursor ) flushOutputBuffer( dcursor, dend );
 
   return (scursor == send);
-   
+
 } // encode
 
 bool QuotedPrintableEncoder::finish( char* & dcursor,
