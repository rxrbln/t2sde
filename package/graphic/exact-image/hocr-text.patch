--- ./frontends/hocr2pdf.cc	(.../tags/0.6.1)	(revision 1402)
+++ ./frontends/hocr2pdf.cc	(.../trunk)	(revision 1402)
@@ -39,8 +39,9 @@
 int res = 300;
 bool sloppy = false;
 PDFCodec* pdfContext = 0;
+std::ofstream* txtStream = 0;
+std::string txtString;
 
-
 std::string lowercaseStr(const std::string& _s)
 {
   std::string s(_s);
@@ -95,6 +96,9 @@
   
   while ((i = s.find("&gt;")) != std::string::npos)
     s.replace(i, 4, ">");
+
+  while ((i = s.find("&quot;")) != std::string::npos)
+    s.replace(i, 6, "\"");
   
   // TODO: '&8212;' and more - when implemented, best locked on
   // each '&' and matched to the next ';'
@@ -184,11 +188,25 @@
       yavg /= n;
     
     int height = (int)round(std::abs(y2 - y1) * 72. / res);
-    if (height < 8)
+    if (height < 8) // TODO: allow configuration?
       height = 8;
     
     //std::cerr << "drawing with height: " << height << std::endl;
     
+    // remove trailing whitespace
+    for (span_iterator it = spans.end(); it != spans.begin(); --it)
+      {
+	span_iterator it2 = it; --it2;
+	for (int i = it2->text.size() - 1; i >= 0; --i) {
+	  if (isMyBlank(it2->text[i]))
+	    it2->text.erase(i);
+	  else
+	    goto whitespace_cleaned;
+	}
+      }
+  
+  whitespace_cleaned:
+    
     for (span_iterator it = spans.begin(); it != spans.end(); ++it, ++n)
       {
 	// escape decoding, TODO: maybe change our SAX parser to emmit a single
@@ -234,7 +252,12 @@
 	//std::cerr << "(" << text << ") ";
 	pdfContext->textTo(72. * bbox.x1 / res, 72. * yavg / res);
 	pdfContext->showText(font, text, height);
+	
+	if (txtStream)
+	  txtString += text;
       }
+    if (txtStream)
+      txtString += "\n";
     //std::cerr << std::endl;
   }
   
@@ -380,6 +405,11 @@
 				 "sloppily place text, group words, do not draw single glyphs",
 				 0, 0, true, true);
   arglist.Add(&arg_sloppy_text);
+
+  Argument<std::string> arg_text("t", "text",
+				 "extract text, including trying to remove hyphens",
+				 0, 1, true, true);
+  arglist.Add(&arg_text);
   
   // parse the specified argument list - and maybe output the Usage
   if (!arglist.Read(argc, argv) || arg_help.Get() == true)
@@ -413,6 +443,10 @@
   res = image.xres;
   sloppy = arg_sloppy_text.Get();
   
+  if (arg_text.Size()) {
+    txtStream = new std::ofstream(arg_text.Get().c_str());
+  }
+  
   std::ofstream s(arg_output.Get().c_str());
   pdfContext = new PDFCodec(&s);
   pdfContext->beginPage(72. * image.w / res, 72. * image.h / res);
@@ -516,5 +550,38 @@
     pdfContext->showImage(image, 0, 0, 72. * image.w / res, 72. * image.h / res);
   
   delete pdfContext;
+  if (txtStream) {
+    // for now hypenation compensator, later to be inserted to the
+    // generic code-flow to detect and write out soft-hypens on-the-go
+    
+    // regex: ([a-z])-\n([a-z]) -> \1\2
+    // + insert \n at next space of next line
+    for (std::string::iterator it = txtString.begin();
+	 it != txtString.end();)
+      {
+	if ((*it == '\n') && // lock on newlines
+	    (it != txtString.begin() && it[-1] == '-') && // hyphen in front
+	    (it != txtString.end() - 1 && islower(it[+1])) // and the next is lower case
+	    )
+	  {
+	    it = txtString.erase(it -1, it + 1); // erase "\n-"
+	    
+	    // so, newline removed, insert a break at the next word, same line
+	    for (; it != txtString.end() && *it != '\n'; ++it) {
+	      if (*it == ' ') {
+		*it = '\n';
+		++it;
+		break;
+	      }
+	    }
+	  }
+	else
+	  ++it;
+      }
+    
+    *txtStream << txtString;
+    txtStream->close();
+    delete txtStream;
+  }
   return 0;
 }
