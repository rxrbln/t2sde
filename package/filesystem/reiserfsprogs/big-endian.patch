# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../reiserfsprogs/big-endian.patch
# Copyright (C) 2007 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

Tested to work, including resizing and --rebuild-tree on powerpc (G4 Cube)
and powerpc64 (dual G5).

Please give credit, as this took some hours to hunt down, ...

  - Rene Rebe <rene@exactcode.de>

--- ./include/misc/swab.h
+++ ./include/misc/swab.h
@@ -7,36 +7,30 @@
 #define MISC_SWAB_H
 
 #define __swab16(x) \
-({ \
-        __u16 __x = (x); \
-        ((__u16)( \
-                (((__u16)(__x) & (__u16)0x00ffU) << 8) | \
-                (((__u16)(__x) & (__u16)0xff00U) >> 8) )); \
-})
+(       ((__u16)( \
+                (((__u16)(x) & (__u16)0x00ffU) << 8) | \
+                (((__u16)(x) & (__u16)0xff00U) >> 8) )) \
+)
 
 #define __swab32(x) \
-({ \
-        __u32 __x = (x); \
-        ((__u32)( \
-                (((__u32)(__x) & (__u32)0x000000ffUL) << 24) | \
-                (((__u32)(__x) & (__u32)0x0000ff00UL) <<  8) | \
-                (((__u32)(__x) & (__u32)0x00ff0000UL) >>  8) | \
-                (((__u32)(__x) & (__u32)0xff000000UL) >> 24) )); \
-})
+(       ((__u32)( \
+                (((__u32)(x) & (__u32)0x000000ffUL) << 24) | \
+                (((__u32)(x) & (__u32)0x0000ff00UL) <<  8) | \
+                (((__u32)(x) & (__u32)0x00ff0000UL) >>  8) | \
+                (((__u32)(x) & (__u32)0xff000000UL) >> 24) )) \
+)
 
 #define __swab64(x) \
-({ \
-        __u64 __x = (x); \
-        ((__u64)( \
-                (__u64)(((__u64)(__x) & (__u64)0x00000000000000ffULL) << 56) | \
-                (__u64)(((__u64)(__x) & (__u64)0x000000000000ff00ULL) << 40) | \
-                (__u64)(((__u64)(__x) & (__u64)0x0000000000ff0000ULL) << 24) | \
-                (__u64)(((__u64)(__x) & (__u64)0x00000000ff000000ULL) <<  8) | \
-                (__u64)(((__u64)(__x) & (__u64)0x000000ff00000000ULL) >>  8) | \
-                (__u64)(((__u64)(__x) & (__u64)0x0000ff0000000000ULL) >> 24) | \
-                (__u64)(((__u64)(__x) & (__u64)0x00ff000000000000ULL) >> 40) | \
-                (__u64)(((__u64)(__x) & (__u64)0xff00000000000000ULL) >> 56) )); \
-})
+(       ((__u64)( \
+                (__u64)(((__u64)(x) & (__u64)0x00000000000000ffULL) << 56) | \
+                (__u64)(((__u64)(x) & (__u64)0x000000000000ff00ULL) << 40) | \
+                (__u64)(((__u64)(x) & (__u64)0x0000000000ff0000ULL) << 24) | \
+                (__u64)(((__u64)(x) & (__u64)0x00000000ff000000ULL) <<  8) | \
+                (__u64)(((__u64)(x) & (__u64)0x000000ff00000000ULL) >>  8) | \
+                (__u64)(((__u64)(x) & (__u64)0x0000ff0000000000ULL) >> 24) | \
+                (__u64)(((__u64)(x) & (__u64)0x00ff000000000000ULL) >> 40) | \
+                (__u64)(((__u64)(x) & (__u64)0xff00000000000000ULL) >> 56) )) \
+)
 
 
 #ifndef WORDS_BIGENDIAN

--- reiserfsprogs-3.6.20/include/misc/types.h.vanilla	2007-11-06 09:36:58.000000000 +0100
+++ reiserfsprogs-3.6.20/include/misc/types.h	2007-11-06 09:37:09.000000000 +0100
@@ -7,11 +7,7 @@
 #define MISC_TYPES_H
 
 #include <string.h>
+#include <linux/types.h>
 
-typedef unsigned char           __u8;
-typedef unsigned short int      __u16;
-typedef unsigned int            __u32;
-typedef unsigned long long int  __u64;
-
 #define INVAL_PTR	(void *)-1
 #define MAX_INT		2147483647
diff -ur reiserfsprogs-3.6.20/include/reiserfs/types.h reiserfsprogs-3.6.20-big-endian/include/reiserfs/types.h
--- reiserfsprogs-3.6.20/include/reiserfs/types.h	2006-03-28 14:40:23.000000000 +0200
+++ reiserfsprogs-3.6.20-big-endian/include/reiserfs/types.h	2007-11-10 15:11:07.000000000 +0100
@@ -227,15 +227,7 @@
 } __attribute__ ((__packed__));
 
 struct reiserfs_koff_v2 {
-#if __BYTE_ORDER == __LITTLE_ENDIAN
-    __u64 k_offset:60;
-    __u64 k_type: 4;
-#elif __BYTE_ORDER == __BIG_ENDIAN
-    __u64 k_type: 4;
-    __u64 k_offset:60;
-#else
-# error "nuxi/pdp-endian archs are not supported"
-#endif
+    __u64 v; /* 4 bit type, 60 bit offset */
 } __attribute__ ((__packed__));
 
 /* Key of the object determines object's location in the tree, 
diff -ur reiserfsprogs-3.6.20/libreiserfs/key.c reiserfsprogs-3.6.20-big-endian/libreiserfs/key.c
--- reiserfsprogs-3.6.20/libreiserfs/key.c	2006-03-28 14:40:23.000000000 +0200
+++ reiserfsprogs-3.6.20-big-endian/libreiserfs/key.c	2007-11-10 22:02:53.000000000 +0100
@@ -8,6 +8,7 @@
 #endif
 
 #include "reiserfs/libreiserfs.h"
+#include "reiserfs/types.h"
 #include "misc/unaligned.h"
 
 const reiserfs_key_t root_dir_key = 
@@ -38,56 +39,35 @@
     memcpy (to, from, REISERFS_KEY_SHSIZE);
 }
 
-#if __BYTE_ORDER == __LITTLE_ENDIAN
-# define get_key_offset_v2(key)     (__u64)((key->u.k2_offset_v2.k_offset))
-# define set_key_offset_v2(key,val) (void)(key->u.k2_offset_v2.k_offset = (val))
-# define get_key_type_v2(key)       (__u16)((key->u.k2_offset_v2.k_type))
-# define set_key_type_v2(key,val)   (void)(key->u.k2_offset_v2.k_type = (val))
-#elif __BYTE_ORDER == __BIG_ENDIAN
-typedef union {
-    struct offset_v2 offset_v2;
-    __u64 linear;
-} __attribute__ ((__packed__)) offset_v2_esafe_overlay;
-
-static inline __u64 get_key_offset_v2 (const reiserfs_key_t *key)
+static inline __u16 offset_v2_k_type(const struct reiserfs_koff_v2 *v2)
 {
-    offset_v2_esafe_overlay tmp =
-                        *(offset_v2_esafe_overlay *) (&(key->u.k2_offset_v2));
-    tmp.linear = le64_to_cpu( tmp.linear );
-    return tmp.offset_v2.k_offset;
+    return le64_to_cpu(v2->v) >> 60;
 }
 
-static inline __u32 get_key_type_v2 (const reiserfs_key_t *key)
+static inline void set_offset_v2_k_type(struct reiserfs_koff_v2 *v2, int type)
 {
-    offset_v2_esafe_overlay tmp =
-                        *(offset_v2_esafe_overlay *) (&(key->u.k2_offset_v2));
-    tmp.linear = le64_to_cpu( tmp.linear );
-    return tmp.offset_v2.k_type;
+        v2->v =
+            (v2->v & cpu_to_le64(~0ULL >> 4)) | cpu_to_le64((__u64) type << 60);
 }
 
-static inline void set_key_offset_v2 (reiserfs_key_t *key, __u64 offset)
+static inline loff_t offset_v2_k_offset(const struct reiserfs_koff_v2 *v2)
 {
-    offset_v2_esafe_overlay *tmp =
-                        (offset_v2_esafe_overlay *)(&(key->u.k2_offset_v2));
-    tmp->linear = le64_to_cpu(tmp->linear);
-    tmp->offset_v2.k_offset = offset;
-    tmp->linear = cpu_to_le64(tmp->linear);
+    return le64_to_cpu(v2->v) & (~0ULL >> 4);
 }
 
-static inline void set_key_type_v2 (reiserfs_key_t *key, __u32 type)
+static inline void set_offset_v2_k_offset(struct reiserfs_koff_v2 *v2, loff_t offset)
 {
-    offset_v2_esafe_overlay *tmp =
-                        (offset_v2_esafe_overlay *)(&(key->u.k2_offset_v2));
-    if (type > 15)
-        reiserfs_panic ("set_key_type_v2: type is too big %d", type);
-
-    tmp->linear = le64_to_cpu(tmp->linear);
-    tmp->offset_v2.k_type = type;
-    tmp->linear = cpu_to_le64(tmp->linear);
+        offset &= (~0ULL >> 4);
+        v2->v = (v2->v & cpu_to_le64(15ULL << 60)) | cpu_to_le64(offset);
 }
-#else
-# error "nuxi/pdp-endian archs are not supported"
-#endif
+
+
+# define get_key_offset_v2(key)     (__u64) offset_v2_k_offset (&key->u.k2_offset_v2)
+# define set_key_offset_v2(key,val) set_offset_v2_k_offset (&key->u.k2_offset_v2, val)
+
+# define get_key_type_v2(key)       (__u16) offset_v2_k_type (&key->u.k2_offset_v2)
+# define set_key_type_v2(key,val)   set_offset_v2_k_type (&key->u.k2_offset_v2, val)
+
 
 static inline int is_key_format_1 (int type) {
     return ( (type == 0 || type == 15) ? 1 : 0);
 
diff -ur reiserfsprogs-3.6.20/libreiserfs/objmap.c reiserfsprogs-3.6.20-big-endian/libreiserfs/objmap.c
--- reiserfsprogs-3.6.20/libreiserfs/objmap.c	2006-03-28 14:40:23.000000000 +0200
+++ reiserfsprogs-3.6.20-big-endian/libreiserfs/objmap.c	2007-11-10 23:04:43.000000000 +0100
@@ -25,6 +27,7 @@
 int reiserfs_objmap_test (reiserfs_filsys_t * fs, __u32 objectid)
 {
     __u32 * objectid_map;
+    __u32 ondisk_objectid = cpu_to_le32 (objectid);
     __u32 count = reiserfs_sb_get_mapcur(fs->fs_ondisk_sb);
     int ret;
     int pos;
@@ -32,7 +35,7 @@
     objectid_map = (__u32 *)((char *)fs->fs_ondisk_sb + 
 			     reiserfs_super_size (fs->fs_ondisk_sb));
     
-    ret = misc_bin_search(&objectid, objectid_map, count, 
+    ret = misc_bin_search(&ondisk_objectid, objectid_map, count, 
 			  sizeof(__u32), &pos, comp_ids);
 
     /* if the position returned is odd, the oid is in use */
