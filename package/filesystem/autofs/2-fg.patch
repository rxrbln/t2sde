# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../autofs/2-fg.patch
# Copyright (C) 2006 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

add -f --foreground option which prevents automount from daemonizing
adapted from: http://lkml.org/lkml/2004/10/7/217 by Denis Vlasenko
		
diff -urpN autofs-4.1.4/daemon/automount.c autofs-4.1.4-fg/daemon/automount.c
--- autofs-4.1.4/daemon/automount.c	2005-03-06 06:43:55.000000000 -0300
+++ autofs-4.1.4-fg/daemon/automount.c	2006-02-12 10:21:38.000000000 -0300
@@ -60,6 +60,7 @@ static int submount = 0;
 
 int do_verbose = 0;		/* Verbose feedback option */
 int do_debug = 0;		/* Enable full debug output */
+int daemonize = 1;		/* Shall we daemonize? */
 
 sigset_t ready_sigs;		/* signals only accepted in ST_READY */
 sigset_t lock_sigs;		/* signals blocked for locking */
@@ -1282,7 +1283,7 @@ static void become_daemon(void)
 	chdir("/");
 
 	/* Detach from foreground process */
-	if (!submount) {
+	if (!submount && daemonize) {
 		pid = fork();
 		if (pid > 0)
 			exit(0);
@@ -1311,9 +1311,15 @@
 	 * ouselves from the controling tty. This ensures we don't get unexpected
 	 * signals. This call also sets us as the process group leader.
 	 */
-	if (!submount && (setsid() == -1)) {
-		crit("setsid: %m");
-		exit(1);
+	if (!submount) {
+		if (daemonize && (setsid() == -1)) {
+			crit("setsid: %m");
+			exit(1);
+		}
+		if (!daemonize && (setpgrp() == -1)) {
+			crit("setpgrp: %m");
+			exit(1);
+		}
 	}
 	my_pgrp = getpgrp();
 
@@ -1327,7 +1328,7 @@ static void become_daemon(void)
 		crit("redirecting file descriptors failed: %m");
 		exit(1);
 	}
-	close(nullfd);
+	if (nullfd > 2) close(nullfd);
 
 	/* Write pid file if requested */
 	if (pid_file) {
@@ -1379,7 +1380,19 @@ static unsigned long getnumopt(char *str
 
 static void usage(void)
 {
-	fprintf(stderr, "Usage: %s [options] path map_type [args...]\n", program);
+	fprintf(stderr,
+		"Usage: %s [options] path map_type [args...]\n"
+		"	-h --help	this text\n"
+		"	-p --pid-file f	write process id to file f\n"
+		"	-t --timeout n	auto-unmount in n seconds (0-disable)\n"
+		"	-f --foreground	do not daemonize\n"
+		"	-v --verbose	be verbose\n"
+		"	-d --debug	be even more verbose\n"
+		"	-V --version	print version and exit\n"
+		/* "	-g --ghost	\n" */
+		/* "	--submount	\n" */
+		, program
+	);
 }
 
 static void setup_signals(__sighandler_t event_handler, __sighandler_t cld_handler)
@@ -1666,6 +1679,7 @@ int main(int argc, char *argv[])
 		{"help", 0, 0, 'h'},
 		{"pid-file", 1, 0, 'p'},
 		{"timeout", 1, 0, 't'},
+		{"foreground", 0, 0, 'f'},
 		{"verbose", 0, 0, 'v'},
 		{"debug", 0, 0, 'd'},
 		{"version", 0, 0, 'V'},
@@ -1683,7 +1697,7 @@ int main(int argc, char *argv[])
 	ap.dir_created = 0; /* We haven't created the main directory yet */
 
 	opterr = 0;
-	while ((opt = getopt_long(argc, argv, "+hp:t:vdVg", long_options, NULL)) != EOF) {
+	while ((opt = getopt_long(argc, argv, "+hp:t:fvdVg", long_options, NULL)) != EOF) {
 		switch (opt) {
 		case 'h':
 			usage();
@@ -1697,6 +1711,10 @@ int main(int argc, char *argv[])
 			ap.exp_timeout = getnumopt(optarg, opt);
 			break;
 
+		case 'f':
+			daemonize = 0;
+			break;
+
 		case 'v':
 			do_verbose = 1;
 			break;
