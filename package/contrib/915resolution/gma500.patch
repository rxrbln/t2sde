# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../915resolution/gma500.patch
# Copyright (C) 2009 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

Nokia, or better their contractor, forgot to fill the native display resolution
(1280x720) into the BIOS tables, which unfortunately does not allow to select
them via basic VESA BIOS functions. Given the unfortunate GMA500 aka. Poulsbo
driver situation we'd rather like to set the mode for more stable pieces of
legacy software blitting, for now.

  - Rene Rebe <rene@exactcode.de>

--- 915resolution-0.5.3/915resolution.c	2007-04-15 10:46:56.000000000 +0000
+++ 915resolution-0.5.3-500/915resolution.c	2009-11-01 11:55:41.000000000 +0000
@@ -12,6 +12,8 @@
  *
  *   - 855resolution by Alain Poirier
  *
+ * 500, Poulsbo, support by Rene Rebe, ExactCODE, tested on Nokia Booklet 3G.
+ *
  * This source code is into the public domain.
  */
 
@@ -56,12 +58,12 @@
 
 typedef enum {
     CT_UNKWN, CT_830, CT_845G, CT_855GM, CT_865G, CT_915G, CT_915GM, CT_945G, CT_945GM,
-    CT_946GZ, CT_G965, CT_Q965
+    CT_946GZ, CT_G965, CT_Q965, CT_500
 } chipset_type;
 
 char * chipset_type_names[] = {
     "UNKNOWN", "830",  "845G", "855GM", "865G", "915G", "915GM", "945G", "945GM",
-    "946GZ",   "G965", "Q965"
+    "946GZ",   "G965", "Q965", "500"
 };
 
 typedef enum {
@@ -225,6 +227,10 @@
         type = CT_Q965;
         break;
 
+    case 0x81008086:
+	type = CT_500;
+	break;
+
     default:
         type = CT_UNKWN;
         break;
@@ -511,6 +517,7 @@
     case CT_946GZ:
     case CT_G965:
     case CT_Q965:
+    case CT_500:
         outl(0x80000090, 0xcf8);
         map->b1 = inb(0xcfd);
         map->b2 = inb(0xcfe);
@@ -551,6 +558,7 @@
     case CT_946GZ:
     case CT_G965:
     case CT_Q965:
+    case CT_500:
         outl(0x80000090, 0xcf8);
         outb(map->b1, 0xcfd);
         outb(map->b2, 0xcfe);
@@ -812,7 +820,11 @@
         else if (!strcmp(argv[index], "Q965")) {
             *forced_chipset = CT_Q965;
         }
+	else if (!strcmp(argv[index], "500")) {
+	    *forced_chipset = CT_500;
+	}
         else {
+	    printf("No match for forced chipset: %s\n", argv[index]);
             *forced_chipset = CT_UNKWN;
         }
         
@@ -891,7 +903,7 @@
     char * filename;
     chipset_type forced_chipset;
     
-    printf("Intel 800/900 Series VBIOS Hack : version %s\n\n", VERSION);
+    printf("Intel 500/800/900 Series VBIOS Hack : version %s\n\n", VERSION);
 
     if (parse_args(argc, argv, &filename, &forced_chipset, &list, &mode, &x, &y, &bp, &raw, &htotal, &vtotal) == -1) {
         usage(argv[0]);
