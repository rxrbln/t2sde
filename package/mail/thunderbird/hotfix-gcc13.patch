# --- T2-COPYRIGHT-NOTE-BEGIN ---
# T2 SDE: package/*/thunderbird/hotfix-gcc13.patch
# Copyright (C) 2023 The T2 SDE Project
# 
# This Copyright note is generated by scripts/Create-CopyPatch,
# more information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License version 2 as used by the T2 SDE.
# --- T2-COPYRIGHT-NOTE-END ---

diff --git a/dom/media/webrtc/sdp/RsdparsaSdpGlue.cpp b/dom/media/webrtc/sdp/RsdparsaSdpGlue.cpp
index 8c8a0369c3..01a1a1d817 100644
--- a/dom/media/webrtc/sdp/RsdparsaSdpGlue.cpp
+++ b/dom/media/webrtc/sdp/RsdparsaSdpGlue.cpp
@@ -4,6 +4,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 #include <string>
+#include <cstdint>
 
 #include "sdp/RsdparsaSdpInc.h"
 #include "sdp/RsdparsaSdpGlue.h"
diff --git a/gfx/2d/Rect.h b/gfx/2d/Rect.h
index 4875ad6714..f52437bbdc 100644
--- a/gfx/2d/Rect.h
+++ b/gfx/2d/Rect.h
@@ -15,6 +15,7 @@
 #include "mozilla/Maybe.h"
 
 #include <cmath>
+#include <cstdint>
 
 namespace mozilla {
 
diff --git a/toolkit/components/telemetry/pingsender/pingsender.cpp b/toolkit/components/telemetry/pingsender/pingsender.cpp
index 01fdb63c29..a61b9d3693 100644
--- a/toolkit/components/telemetry/pingsender/pingsender.cpp
+++ b/toolkit/components/telemetry/pingsender/pingsender.cpp
@@ -4,6 +4,7 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include <cstdlib>
+#include <cstdint>
 #include <cstring>
 #include <ctime>
 #include <fstream>
diff --git a/tools/profiler/core/platform.cpp b/tools/profiler/core/platform.cpp
index bd20110f12..08e38d6938 100644
--- a/tools/profiler/core/platform.cpp
+++ b/tools/profiler/core/platform.cpp
@@ -1106,7 +1106,7 @@ class ActivePS {
         continue;
       }
       ThreadRegistry::OffThreadRef::RWFromAnyThreadWithLock lockedThreadData =
-          offThreadRef.LockedRWFromAnyThread();
+          offThreadRef.GetLockedRWFromAnyThread();
       MOZ_RELEASE_ASSERT(array.append(ProfiledThreadListElement{
           profiledThreadData->Info().RegisterTime(),
           lockedThreadData->GetJSContext(), profiledThreadData}));
@@ -4050,7 +4050,7 @@ void SamplerThread::Run() {
 
             if (threadStackSampling) {
               ThreadRegistry::OffThreadRef::RWFromAnyThreadWithLock
-                  lockedThreadData = offThreadRef.LockedRWFromAnyThread();
+                  lockedThreadData = offThreadRef.GetLockedRWFromAnyThread();
               // Suspend the thread and collect its stack data in the local
               // buffer.
               mSampler.SuspendAndSampleAndResumeThread(
@@ -4764,7 +4764,7 @@ static ProfilingStack* locked_register_thread(
             aLock, aOffThreadRef.UnlockedConstReaderCRef().Info());
     if (threadProfilingFeatures != ThreadProfilingFeatures::NotProfiled) {
       ThreadRegistry::OffThreadRef::RWFromAnyThreadWithLock
-          lockedRWFromAnyThread = aOffThreadRef.LockedRWFromAnyThread();
+          lockedRWFromAnyThread = aOffThreadRef.GetLockedRWFromAnyThread();
 
       ProfiledThreadData* profiledThreadData = ActivePS::AddLiveProfiledThread(
           aLock, MakeUnique<ProfiledThreadData>(
@@ -5629,7 +5629,7 @@ static void locked_profiler_start(PSLockRef aLock, PowerOfTwo32 aCapacity,
         ActivePS::ProfilingFeaturesForThread(aLock, info);
     if (threadProfilingFeatures != ThreadProfilingFeatures::NotProfiled) {
       ThreadRegistry::OffThreadRef::RWFromAnyThreadWithLock lockedThreadData =
-          offThreadRef.LockedRWFromAnyThread();
+          offThreadRef.GetLockedRWFromAnyThread();
       ProfiledThreadData* profiledThreadData = ActivePS::AddLiveProfiledThread(
           aLock, MakeUnique<ProfiledThreadData>(info));
       lockedThreadData->SetProfilingFeaturesAndData(threadProfilingFeatures,
@@ -5853,7 +5853,7 @@ void profiler_ensure_started(PowerOfTwo32 aCapacity, double aInterval,
     }
 
     ThreadRegistry::OffThreadRef::RWFromAnyThreadWithLock lockedThreadData =
-        offThreadRef.LockedRWFromAnyThread();
+        offThreadRef.GetLockedRWFromAnyThread();
 
     lockedThreadData->ClearProfilingFeaturesAndData(aLock);
 
@@ -6196,7 +6196,7 @@ static void locked_unregister_thread(
   // thread that is in the process of disappearing.
 
   ThreadRegistration::OnThreadRef::RWOnThreadWithLock lockedThreadData =
-      aOnThreadRef.LockedRWOnThread();
+      aOnThreadRef.GetLockedRWOnThread();
 
   ProfiledThreadData* profiledThreadData =
       lockedThreadData->GetProfiledThreadData(lock);
@@ -6717,7 +6717,7 @@ void profiler_clear_js_context() {
         // The profiler mutex must be locked before the ThreadRegistration's.
         PSAutoLock lock;
         ThreadRegistration::OnThreadRef::RWOnThreadWithLock lockedThreadData =
-            aOnThreadRef.LockedRWOnThread();
+            aOnThreadRef.GetLockedRWOnThread();
 
         if (ProfiledThreadData* profiledThreadData =
                 lockedThreadData->GetProfiledThreadData(lock);
diff --git a/tools/profiler/public/ProfilerThreadRegistration.h b/tools/profiler/public/ProfilerThreadRegistration.h
index fafe06e446..3fb931987d 100644
--- a/tools/profiler/public/ProfilerThreadRegistration.h
+++ b/tools/profiler/public/ProfilerThreadRegistration.h
@@ -214,14 +214,14 @@ class ThreadRegistration {
       DataLock mDataLock;
     };
 
-    [[nodiscard]] RWOnThreadWithLock LockedRWOnThread() {
+    [[nodiscard]] RWOnThreadWithLock GetLockedRWOnThread() {
       return RWOnThreadWithLock{mThreadRegistration->mData,
                                 mThreadRegistration->mDataMutex};
     }
 
     template <typename F>
     auto WithLockedRWOnThread(F&& aF) {
-      RWOnThreadWithLock lockedData = LockedRWOnThread();
+      RWOnThreadWithLock lockedData = GetLockedRWOnThread();
       return std::forward<F>(aF)(lockedData.DataRef());
     }
 
diff --git a/tools/profiler/public/ProfilerThreadRegistry.h b/tools/profiler/public/ProfilerThreadRegistry.h
index 76e0c0a78a..4d0fd3ef68 100644
--- a/tools/profiler/public/ProfilerThreadRegistry.h
+++ b/tools/profiler/public/ProfilerThreadRegistry.h
@@ -177,14 +177,14 @@ class ThreadRegistry {
       ThreadRegistration::DataLock mDataLock;
     };
 
-    [[nodiscard]] RWFromAnyThreadWithLock LockedRWFromAnyThread() {
+    [[nodiscard]] RWFromAnyThreadWithLock GetLockedRWFromAnyThread() {
       return RWFromAnyThreadWithLock{mThreadRegistration->mData,
                                      mThreadRegistration->mDataMutex};
     }
 
     template <typename F>
     auto WithLockedRWFromAnyThread(F&& aF) {
-      RWFromAnyThreadWithLock lockedData = LockedRWFromAnyThread();
+      RWFromAnyThreadWithLock lockedData = GetLockedRWFromAnyThread();
       return std::forward<F>(aF)(lockedData.DataRef());
     }
 
diff --git a/tools/profiler/tests/gtest/GeckoProfiler.cpp b/tools/profiler/tests/gtest/GeckoProfiler.cpp
index fd0d4d2acc..c9882cb5d3 100644
--- a/tools/profiler/tests/gtest/GeckoProfiler.cpp
+++ b/tools/profiler/tests/gtest/GeckoProfiler.cpp
@@ -621,7 +621,7 @@ TEST(GeckoProfiler, ThreadRegistration_DataAccess)
       EXPECT_FALSE(TR::IsDataMutexLockedOnCurrentThread());
       {
         TR::OnThreadRef::RWOnThreadWithLock rwOnThreadWithLock =
-            aOnThreadRef.LockedRWOnThread();
+            aOnThreadRef.GetLockedRWOnThread();
         EXPECT_TRUE(TR::IsDataMutexLockedOnCurrentThread());
         TestConstLockedRWOnThread(rwOnThreadWithLock.DataCRef(),
                                   beforeRegistration, afterRegistration,
@@ -1020,7 +1020,7 @@ TEST(GeckoProfiler, ThreadRegistry_DataAccess)
         EXPECT_FALSE(TR::IsDataMutexLockedOnCurrentThread());
         {
           TRy::OffThreadRef::RWFromAnyThreadWithLock rwFromAnyThreadWithLock =
-              aOffThreadRef.LockedRWFromAnyThread();
+              aOffThreadRef.GetLockedRWFromAnyThread();
           if (profiler_current_thread_id() == testThreadId) {
             EXPECT_TRUE(TR::IsDataMutexLockedOnCurrentThread());
           }
@@ -1157,7 +1157,7 @@ TEST(GeckoProfiler, ThreadRegistration_RegistrationEdgeCases)
             PR_Sleep(PR_MillisecondsToInterval(1));
           }
           TRy::OffThreadRef::RWFromAnyThreadWithLock rwFromAnyThreadWithLock =
-              aOffThreadRef.LockedRWFromAnyThread();
+              aOffThreadRef.GetLockedRWFromAnyThread();
           ++otherThreadReads;
           if (otherThreadReads % 1000 == 0) {
             PR_Sleep(PR_MillisecondsToInterval(1));
