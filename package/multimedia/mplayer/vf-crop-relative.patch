# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../mplayer/vf-crop-relative.patch
# Copyright (C) 2006 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

It got on my nerves for some time that I have to compute the resulting width and
height manually all the itme - a task screaming for a computer. Also just
cutting off the overscan noise usually on DVB broadcasts requires multiple
parameter sets depending on the actual broadcast format (e.g. classic 4:3
vs. a real (black border-less) 16:9) transmission).

Allow relative cuts using negative values, e.g. crop="20:82:-20:-82".

  - Rene Rebe <rene@exactcode.de>

--- MPlayer-1.0pre7try2/libmpcodecs/vf_crop.c	2003-05-20 19:42:33.000000000 +0200
+++ MPlayer-1.0pre7try2-fixed/libmpcodecs/vf_crop.c	2006-02-13 12:24:41.322628250 +0100
@@ -28,6 +28,13 @@
 static int config(struct vf_instance_s* vf,
         int width, int height, int d_width, int d_height,
 	unsigned int flags, unsigned int outfmt){
+    if (vf->priv->crop_w < 0)
+      vf->priv->crop_w = width - vf->priv->crop_x + vf->priv->crop_w;
+    if (vf->priv->crop_h < 0)
+      vf->priv->crop_h = height - vf->priv->crop_y + vf->priv->crop_h;
+
+    printf ("%d %d %d %d\n",  vf->priv->crop_x, vf->priv->crop_y, vf->priv->crop_w,  vf->priv->crop_h);
+
     // calculate the missing parameters:
     if(vf->priv->crop_w<=0 || vf->priv->crop_w>width) vf->priv->crop_w=width;
     if(vf->priv->crop_h<=0 || vf->priv->crop_h>height) vf->priv->crop_h=height;
@@ -152,24 +159,24 @@
     vf->priv->crop_h=-1;
     } //if(!vf->priv)
     if(args) sscanf(args, "%d:%d:%d:%d", 
-    &vf->priv->crop_w,
-    &vf->priv->crop_h,
     &vf->priv->crop_x,
-    &vf->priv->crop_y);
-    mp_msg(MSGT_VFILTER, MSGL_INFO, "Crop: %d x %d, %d ; %d\n",
-    vf->priv->crop_w,
-    vf->priv->crop_h,
+    &vf->priv->crop_y,
+    &vf->priv->crop_w,
+    &vf->priv->crop_h);
+    mp_msg(MSGT_VFILTER, MSGL_INFO, "Crop: %d,%d ; %d,%d\n",
     vf->priv->crop_x,
-    vf->priv->crop_y);
+    vf->priv->crop_y,
+    vf->priv->crop_w,
+    vf->priv->crop_h);
     return 1;
 }
 
 #define ST_OFF(f) M_ST_OFF(struct vf_priv_s,f)
 static m_option_t vf_opts_fields[] = {
-  {"w", ST_OFF(crop_w), CONF_TYPE_INT, M_OPT_MIN,0 ,0, NULL},
-  {"h", ST_OFF(crop_h), CONF_TYPE_INT, M_OPT_MIN,0 ,0, NULL},
-  {"x", ST_OFF(crop_x), CONF_TYPE_INT, M_OPT_MIN,-1 ,0, NULL},
-  {"y", ST_OFF(crop_y), CONF_TYPE_INT, M_OPT_MIN,-1 ,0, NULL},
+  {"x", ST_OFF(crop_x), CONF_TYPE_INT, M_OPT_MIN, -1, 0, NULL},
+  {"y", ST_OFF(crop_y), CONF_TYPE_INT, M_OPT_MIN, -1, 0, NULL},
+  {"w", ST_OFF(crop_w), CONF_TYPE_INT, 0, 0, 0, NULL},
+  {"h", ST_OFF(crop_h), CONF_TYPE_INT, 0, 0, 0, NULL},
   { NULL, NULL, 0, 0, 0, 0,  NULL }
 };
 
