# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../mplayer/lzo-hotfix.patch
# Copyright (C) 2010 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

--- ./libmpcodecs/native/nuppelvideo.c	(revision 28448)
+++ ./libmpcodecs/native/nuppelvideo.c	(working copy)
@@ -56,7 +56,7 @@
 		int in_len = encodedh->packetlength;
 #ifdef KEEP_BUFFER		
 		if (!previous_buffer) 
-			previous_buffer = ( unsigned char * ) malloc ( out_len + LZO_OUTPUT_PADDING );
+			previous_buffer = ( unsigned char * ) malloc ( out_len + AV_LZO_OUTPUT_PADDING );
 #endif

 		switch(encodedh->comptype)
@@ -69,7 +69,7 @@
 			break;
 		    case '2': /* RTJpeg with LZO */
 			if (!buffer) 
-			    buffer = ( unsigned char * ) malloc ( out_len + LZO_OUTPUT_PADDING );
+			    buffer = ( unsigned char * ) malloc ( out_len + AV_LZO_OUTPUT_PADDING );
 			if (!buffer)
 			{
 			    mp_msg(MSGT_DECVIDEO, MSGL_ERR, "Nuppelvideo: error decompressing\n");


--- ./libmpcodecs/vd_lzo.c	2010-02-08 04:53:00.817032292 +0000
+++ ./libmpcodecs/vd_lzo.c	2010-02-08 04:54:40.881031783 +0000
@@ -55,7 +55,7 @@
 	return 0;
     }
     priv->bufsz = sh->bih->biSizeImage;
-    priv->buffer = malloc(priv->bufsz + LZO_OUTPUT_PADDING);
+    priv->buffer = malloc(priv->bufsz + AV_LZO_OUTPUT_PADDING);
     priv->codec = -1;
     sh->context = priv;

--- ./libmpdemux/demux_mkv.c	2010-02-08 05:03:32.569027514 +0000
+++ ./libmpdemux/demux_mkv.c	2010-02-08 05:04:47.345046193 +0000
@@ -351,12 +351,12 @@
           while (1)
             {
               int srclen = *size;
-              if (dstlen > SIZE_MAX - LZO_OUTPUT_PADDING) goto lzo_fail;
-              *dest = realloc (*dest, dstlen + LZO_OUTPUT_PADDING);
+              if (dstlen > SIZE_MAX - AV_LZO_OUTPUT_PADDING) goto lzo_fail;
+              *dest = realloc (*dest, dstlen + AV_LZO_OUTPUT_PADDING);
               result = lzo1x_decode (*dest, &dstlen, src, &srclen);
               if (result == 0)
                 break;
-              if (!(result & LZO_OUTPUT_FULL))
+              if (!(result & AV_LZO_OUTPUT_FULL))
                 {
 lzo_fail:
                   mp_msg (MSGT_DEMUX, MSGL_WARN,
@@ -859,7 +859,7 @@
 	    // audit: cheap guard against overflows later..
 	    if (num > SIZE_MAX - 1000) return 0;
             l = x + num;
-            track->private_data = malloc (num + LZO_INPUT_PADDING);
+            track->private_data = malloc (num + AV_LZO_INPUT_PADDING);
             if (stream_read(s, track->private_data, num) != (int) num)
               goto err_out;
             track->private_size = num;
@@ -2875,8 +2875,8 @@
                 case MATROSKA_ID_BLOCK:
                   block_length = ebml_read_length (s, &tmp);
                   free(block);
-                  if (block_length > SIZE_MAX - LZO_INPUT_PADDING) return 0;
-                  block = malloc (block_length + LZO_INPUT_PADDING);
+                  if (block_length > SIZE_MAX - AV_LZO_INPUT_PADDING) return 0;
+                  block = malloc (block_length + AV_LZO_INPUT_PADDING);
                   demuxer->filepos = stream_tell (s);
                   if (stream_read (s,block,block_length) != (int) block_length)
                   {

