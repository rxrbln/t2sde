# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../yaboot/link_with_new_e2fsprogs2.patch
# Copyright (C) 2015 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

diff --git a/include/nonstd.h b/include/nonstd.h
index a967380..a23f98e 100644
--- a/include/nonstd.h
+++ b/include/nonstd.h
@@ -26,6 +26,7 @@
 #define	EPERM		 1	/* Operation not permitted */
 #define	EBADF		 9	/* Bad file number */
 #define	EACCES		13	/* Permission denied */
+#define	EFAULT		14	/* Bad address */
 
 typedef int FILE;
 
@@ -37,8 +38,11 @@ typedef long long off64_t;
 typedef long off_t;
 
 struct stat;
+struct stat64;
 struct timezone;
 struct timeval;
+struct rlimit;
+struct utsname;
 
 extern FILE *stdout;
 extern FILE *stderr;
@@ -78,4 +82,14 @@ long sysconf(int name);
 int getpagesize(void);
 void qsort(void *base, size_t nmemb, size_t size,
            int(*compar)(const void *, const void *));
+ssize_t write(int fd, const void *buf, size_t count);
+int fallocate(int fd, int mode, off_t offset, off_t len);
+unsigned long long int strtoull(const char *nptr, char **endptr, int base);
+int fsync(int fd);
+int __open64_2(const char *pathname, int flags);
+int __xstat64(int vers, const char *name, struct stat64 *buf);
+int uname(struct utsname *buf);
+int getrlimit(int resource, struct rlimit *rlim);
+int setrlimit(int resource, const struct rlimit *rlim);
+int __fxstat64(int vers, int fd, struct stat64 *buf);
 #endif
diff --git a/include/stdlib.h b/include/stdlib.h
index 0b5e99a..921fc9b 100644
--- a/include/stdlib.h
+++ b/include/stdlib.h
@@ -19,6 +19,7 @@ extern void release (void *ptr);
 extern int sprintf(char * buf, const char *fmt, ...);
 extern int vsprintf(char *buf, const char *fmt, va_list args);
 extern long simple_strtol(const char *cp,char **endp,unsigned int base);
+extern unsigned long long simple_strtoull(const char *cp,char **endp,unsigned int base);
 #define strtol(x,y,z) simple_strtol(x,y,z)
 
 #endif
diff --git a/lib/nonstd.c b/lib/nonstd.c
index 6549283..129d674 100644
--- a/lib/nonstd.c
+++ b/lib/nonstd.c
@@ -115,6 +115,19 @@ int fstat64(int fd __unused, struct stat *buf __unused)
 	return EBADF;
 }
 
+int __xstat64(int vers __unused, const char *name __unused,
+              struct stat64 *buf __unused)
+{
+	DEBUG_F("Stub function called");
+	return EBADF;
+}
+
+int __fxstat64(int vers __unused, int fd __unused, struct stat64 *buf __unused)
+{
+	DEBUG_F("Stub function called");
+	return EBADF;
+}
+
 int open(const char *pathname, int flags __unused, mode_t mode __unused)
 {
 	return (int) prom_open((char *)pathname);
@@ -125,6 +138,11 @@ int open64(const char *pathname, int flags __unused, mode_t mode __unused)
 	return (int) prom_open((char *)pathname);
 }
 
+int __open64_2(const char *pathname, int flags __unused)
+{
+	return (int) prom_open((char *)pathname);
+}
+
 off_t lseek(int fd __unused, off_t offset __unused, int whence __unused)
 {
 	DEBUG_F("Stub function called");
@@ -290,3 +308,57 @@ void qsort(void *base __unused, size_t nmemb __unused, size_t size __unused,
 	/* I'm quite nervous about not implementing this.  Could we end up with
 	 * disk corruption.  Couldn't we? */
 }
+
+/* FIXME: I'd like to call prom_write here, but we can't ber certain that
+ *        we'll have "text" so just move along nothing to see here
+ */
+ssize_t write(int fd, const void *buf, size_t count)
+{
+	DEBUG_F("Stub function called");
+	return 0;
+}
+
+int fallocate(int fd __unused, int mode __unused, off_t offset __unused,
+              off_t len __unused)
+{
+	DEBUG_F("Stub function called");
+	return 0;
+}
+
+unsigned long long int strtoull(const char *nptr, char **endptr, int base)
+{
+	return simple_strtoull(nptr, endptr, base);
+}
+
+int fsync(int fd __unused)
+{
+	DEBUG_F("Stub function called");
+	return 0;
+}
+
+/* Return EFAULT here as it's too hard in yaboot to know the size of struct
+ * utsname.  If we don't touch it and return 0 bad things might happen.
+ * Lets hope the caller handles failure
+ */
+int uname(struct utsname *buf __unused)
+{
+	DEBUG_F("Stub function called");
+	return EFAULT;
+}
+
+int getrlimit(int resource __unused, struct rlimit *rlim __unused)
+{
+	DEBUG_F("Stub function called");
+	return 0;
+}
+
+int setrlimit(int resource __unused, const struct rlimit *rlim __unused)
+{
+	DEBUG_F("Stub function called");
+	return 0;
+}
+
+void __stack_chk_fail(void)
+{
+	DEBUG_F("Stub function called");
+}
