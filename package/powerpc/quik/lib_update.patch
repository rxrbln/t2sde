# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../quik/lib_update.patch
# Copyright (C) 2004 - 2005 The T2 SDE Project
# Copyright (C) 1998 - 2003 ROCK Linux Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

--- ./quik/quik.c	2002-06-05 08:04:29.000000000 -0400
+++ ./quik/quik.c	2002-12-14 19:04:12.000000000 -0500
@@ -225,7 +225,7 @@
             strcat(buffer, path + 1);
         return buffer;
     } else
-        return strdup(path);
+        return (char *) strdup(path);
 }
 
 void write_block_table(char *device, char *config_file, int partno)
--- ./second/cfg.c	2002-06-05 08:04:29.000000000 -0400
+++ ./second/cfg.c	2002-12-14 18:53:49.000000000 -0500
@@ -98,10 +98,10 @@
     va_list ap;
 
     va_start (ap, msg);
-    printf ("Config file error: ");
-    vprintf (msg, ap);
+    q_printf ("Config file error: ");
+    q_vprintf (msg, ap);
     va_end (ap);
-    printf (" near line %d in file %s\n", line_num, file_name);
+    q_printf (" near line %d in file %s\n", line_num, file_name);
     longjmp (env, 1);
 }
 
@@ -110,10 +110,10 @@
     va_list ap;
 
     va_start (ap, msg);
-    printf ("Config file warning: ");
-    vprintf (msg, ap);
+    q_printf ("Config file warning: ");
+    q_vprintf (msg, ap);
     va_end (ap);
-    printf (" near line %d in file %s\n", line_num, file_name);
+    q_printf (" near line %d in file %s\n", line_num, file_name);
 }
 
 inline int getc ()
@@ -371,8 +371,8 @@
     int len = strlen (label);
 
     if (!printl_count)
-	printf ("\n");
-    printf ("%s", label);
+	q_printf ("\n");
+    q_printf ("%s", label);
     while (len++ < 25)
 	putchar (' ');
     printl_count++;
@@ -399,7 +399,7 @@
 	if (alias)
 	    printlabel (alias);
     }
-    printf ("\nYou can also type in custom image locations, in the form\n"
+    q_printf ("\nYou can also type in custom image locations, in the form\n"
 	    "{prom_path;}partno/path_to_image or {prom_path;}{partno}[start-end]\n");
 }
 
--- ./second/disk.c	2000-03-10 15:59:28.000000000 -0500
+++ ./second/disk.c	2002-12-14 18:54:37.000000000 -0500
@@ -10,7 +10,7 @@
 {
     current_dev = call_prom("open", 1, 1, device);
     if (current_dev == (ihandle) 0 || current_dev == (ihandle) -1) {
-	printf("\nCouldn't open %s\n", device);
+	q_printf("\nCouldn't open %s\n", device);
 	return -1;
     }
     strcpy(current_devname, device);
@@ -53,7 +53,7 @@
      * just a few partitions. -- Cort
      */
     if ( is_chrp )
-	    sprintf(bootdevice, "disk:0");
+	    q_sprintf(bootdevice, "disk:0");
     if( open(bootdevice) )
     {
 	    /*
@@ -61,7 +61,7 @@
 	     * try this if disk:0 fails
 	     *   -- Cort
 	     */
-	    sprintf(bootdevice, "/pci@fee00000/scsi@c/sd@8:0");
+	    q_sprintf(bootdevice, "/pci@fee00000/scsi@c/sd@8:0");
 	    return open(bootdevice);
     }
     return 0;
--- ./second/file.c	2002-06-05 08:04:29.000000000 -0400
+++ ./second/file.c	2002-12-14 18:59:19.000000000 -0500
@@ -23,7 +23,7 @@
 #include <sys/types.h>
 #include <errno.h>
 #include "quik.h"
-typedef int FILE;
+typedef int q_FILE;
 #include <linux/ext2_fs.h>
 #include <ext2fs/ext2fs.h>
 #include <setjmp.h>
@@ -155,7 +155,7 @@
     /* check the MSDOS partition magic */
     if ( (blk[0x1fe] != 0x55) || (blk[0x1ff] != 0xaa) )
     {
-	printf("No MSDOS partition magic number on disk!\n");
+	q_printf("No MSDOS partition magic number on disk!\n");
 	return 0;
     }
     if ( part >= 4 )
@@ -167,14 +167,14 @@
     return 1;
 }
 
-int sprintf (char *buf, char *fmt,...)
+int q_sprintf (char *buf, char *fmt,...)
 {
     strcpy (buf, fmt);
 }
 
 void com_err (const char *a, long i, const char *fmt,...)
 {
-    printf ((char *) fmt);
+    q_printf ((char *) fmt);
 }
 
 static errcode_t linux_open (const char *name, int flags, io_channel * channel)
@@ -222,7 +222,7 @@
     tempb = (((long long) block) * ((long long)bs)) + doff;
     size = (count < 0) ? -count : count * bs;
     if (read (data, size, tempb) != size) {
-	printf ("\nRead error on block %d", block);
+	q_printf ("\nRead error on block %d", block);
 	return EXT2_ET_SHORT_READ;
     }
     return 0;
@@ -253,7 +253,7 @@
     static char rot[] = "\\|/-";
 
     if (!(i % freq))
-	printf ("%c\b", rot[(i / freq) % 4]);
+	q_printf ("%c\b", rot[(i / freq) % 4]);
     i++;
 }
 
@@ -314,7 +314,7 @@
     block_cnt = 0;
     retval = ext2fs_block_iterate(fs, inode, 0, 0, dump_block, 0);
     if (retval) {
-	printf ("Error %d reading %s", retval, filename);
+	q_printf ("Error %d reading %s", retval, filename);
 	return 0;
     }
     return dump_finish();
@@ -342,7 +342,7 @@
 	}
     }
     if (end == -1) {
-	printf ("\n"
+	q_printf ("\n"
 "Ranges of physical blocks are specified as {prom_path:}{partno}[xx-yy]\n"
 "where {} means optional part, partno defaults to 0 (i.e. whole disk)\n"
 "and xx is the starting block (chunk of 512 bytes) and yy end (not\n"
@@ -369,7 +369,7 @@
 	    }
 	}
     }
-    printf ("\nInternal error while loading blocks from device\n");
+    q_printf ("\nInternal error while loading blocks from device\n");
     return 0;
 }
 
@@ -406,7 +406,7 @@
     }
     type = ext2;
     if (retval = ext2fs_namei(fs, root, cwd, filename, &inode)) {
-	printf("\nInode error #%d while loading file %s.", retval, filename);
+	q_printf("\nInode error #%d while loading file %s.", retval, filename);
 	ext2fs_close(fs);
 	return 0;
     }
--- ./second/main.c	2002-06-05 08:04:29.000000000 -0400
+++ ./second/main.c	2002-12-14 18:57:18.000000000 -0500
@@ -57,14 +57,14 @@
 
 void fatal(const char *msg)
 {
-    printf("\nFatal error: %s\n", msg);
+    q_printf("\nFatal error: %s\n", msg);
 }
 
 void maintabfunc (void)
 {
     if (useconf) {
 	cfg_print_images();
-	printf("boot: %s", cbuff);
+	q_printf("boot: %s", cbuff);
     }
 }
 
@@ -217,7 +217,7 @@
 	if (useconf && (q = cfg_get_strg(0, "timeout")) != 0 && *q != 0)
 	    timeout = strtol(q, NULL, 0);
     }
-    printf("boot: ");
+    q_printf("boot: ");
     c = -1;
     if (timeout != -1) {
 	beg = get_ms();
@@ -232,14 +232,14 @@
     }
 
     if (c == '\n') {
-	printf("%s", imagename);
+	q_printf("%s", imagename);
 	if (*params)
-	    printf(" %s", *params);
-	printf("\n");
+	    q_printf(" %s", *params);
+	q_printf("\n");
     } else {
 	cmdinit();
 	cmdedit(maintabfunc, c);
-	printf("\n");
+	q_printf("\n");
 	strcpy(given_bootargs, cbuff);
 	given_bootargs_by_user = 1;
 	imagename = cbuff;
@@ -296,7 +296,7 @@
     if (!*device)
 	*device = defdevice;
     if (!*kname)
-	    printf(
+	    q_printf(
 "Enter the kernel image name as [device:][partno]/path, where partno is a\n"
 "number from 0 to 16.  Instead of /path you can type [mm-nn] to specify a\n"
 "range of disk blocks (512B)\n");
@@ -328,7 +328,7 @@
 	    device = cfg_get_strg(0, "device");
 	if (load_file(device, part, kname, TMP_BUF, TMP_END, &len, 1, 0)) {
 	    TMP_BUF[len] = 0;
-	    printf("\n%s", (char *)TMP_BUF);
+	    q_printf("\n%s", (char *)TMP_BUF);
 	}
     }
 }
@@ -377,7 +377,7 @@
 
     if ( (unsigned long)prom_entry == 0x426f6f58 )
     {
-	    printf("BootX launched us\n");
+	    q_printf("BootX launched us\n");
 	    prom_entry = (void *)id;
 	    /*
 	     * These should come from the bootx info.
@@ -391,7 +391,7 @@
 	    
     memset(&__bss_start, 0, &_end - &__bss_start);
     prom_init(prom_entry);
-    printf("Second-stage QUIK loader\n");
+    q_printf("Second-stage QUIK loader\n");
 
     if (diskinit() == -1)
 	prom_exit();
@@ -403,24 +403,24 @@
 	fileok = load_file(0, quik_conf_part, quik_conf,
 			   TMP_BUF, TMP_END, &len, 1, 0);
 	if (!fileok || (unsigned) len >= 65535)
-	    printf("\nCouldn't load %s\n", quik_conf);
+	    q_printf("\nCouldn't load %s\n", quik_conf);
 	else {
 	    char *p;
 	    if (cfg_parse(quik_conf, TMP_BUF, len) < 0)
-	        printf ("Syntax error or read error in %s.\n", quik_conf);
+	        q_printf ("Syntax error or read error in %s.\n", quik_conf);
 	    useconf = 1;
 	    p = cfg_get_strg(0, "init-code");
 	    if (p)
 		call_prom("interpret", 1, 1, p);
 	    p = cfg_get_strg(0, "init-message");
 	    if (p)
-		printf("%s", p);
+		q_printf("%s", p);
 	    p = cfg_get_strg(0, "message");
 	    if (p)
 		print_message_file(p);
 	}
     } else
-	printf ("\n");
+	q_printf ("\n");
 
     for (;;) {
 	get_params(&device, &part, &kname, &params);
@@ -431,11 +431,11 @@
 			   TMP_BUF, TMP_END, &image_len, 1, 0);
 
 	if (!fileok) {
-	    printf ("\nImage not found.... try again\n");
+	    q_printf ("\nImage not found.... try again\n");
 	    continue;
 	}
 	if (image_len > TMP_END - TMP_BUF) {
-	    printf("\nImage is too large (%u > %u)\n", image_len,
+	    q_printf("\nImage is too large (%u > %u)\n", image_len,
 		   TMP_END - TMP_BUF);
 	    continue;
 	}
@@ -448,13 +448,13 @@
 	      e->e_ident[EI_MAG1] == ELFMAG1 &&
 	      e->e_ident[EI_MAG2] == ELFMAG2 &&
 	      e->e_ident[EI_MAG3] == ELFMAG3)) {
-	    printf ("\n%s: unknown image format\n", kname);
+	    q_printf ("\n%s: unknown image format\n", kname);
 	    continue;
 	}
 
 	if (e->e_ident[EI_CLASS] != ELFCLASS32
 	    || e->e_ident[EI_DATA] != ELFDATA2MSB) {
-	    printf("Image is not a 32bit MSB ELF image\n");
+	    q_printf("Image is not a 32bit MSB ELF image\n");
 	    continue;
 	}
 	len = 0;
@@ -470,7 +470,7 @@
 		len = p->p_offset + p->p_filesz - off;
 	}
 	if (len == 0) {
-	    printf("Cannot find a loadable segment in ELF image\n");
+	    q_printf("Cannot find a loadable segment in ELF image\n");
 	    continue;
 	}
 	entry = e->e_entry & ADDRMASK;
@@ -488,9 +488,9 @@
 
     close();
     if (pause_after) {
-        printf("%s", pause_message);
+        q_printf("%s", pause_message);
 	prom_pause();
-        printf("\n");
+        q_printf("\n");
     }
 
     /*
@@ -509,12 +509,12 @@
 		    /* doesn't look like a procedure descriptor */
 		    start += entry;
     }
-    printf("Starting at %x\n", start);
+    q_printf("Starting at %x\n", start);
 #ifdef BOOTINFO    
     /* setup the bootinfo */
     binf.magic_start = bin.magic_end = BOOT_INFO_MAGIC;
-    sprintf( binf.cmd_line, "%s", params );
-    sprintf( binf.boot_loader, "Quik" );
+    q_sprintf( binf.cmd_line, "%s", params );
+    q_sprintf( binf.boot_loader, "Quik" );
     if ( is_chrp )
 	    binf._machine = _MACH_chrp;
     else
--- ./second/printf.c	2000-03-10 15:59:28.000000000 -0500
+++ ./second/printf.c	2002-12-14 18:58:02.000000000 -0500
@@ -20,23 +20,23 @@
 #include "quik.h"
 
 static void printn(long, int);
-extern void vprintf(char *, va_list);
+extern void q_vprintf(char *, va_list);
 
 /*
  * Scaled down version of C Library printf.
  * Only %c %s %u %d (==%u) %o %x %D %O are recognized.
  */
 
-void printf (char *fmt,...)
+void q_printf (char *fmt,...)
 {
     va_list x1;
 
     va_start (x1, fmt);
-    vprintf (fmt, x1);
+    q_vprintf (fmt, x1);
     va_end (x1);
 }
 
-void vprintf (char *fmt, va_list adx)
+void q_vprintf (char *fmt, va_list adx)
 {
     register c;
     char *s;
