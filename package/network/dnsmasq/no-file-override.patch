# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by scripts/Create-CopyPatch.
# 
# T2 SDE: package/*/dnsmasq/no-file-override.patch
# Copyright (C) 2020 - 2021 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

--- dnsmasq-2.85/src/rfc2131.c.orig	2021-04-07 22:39:39.000000000 +0200
+++ dnsmasq-2.85/src/rfc2131.c	2021-08-30 17:49:48.447435549 +0200
@@ -55,7 +55,8 @@
 		       time_t now,
 		       unsigned int lease_time,
 		       unsigned short fuzz,
-		       const char *pxevendor);
+		       const char *pxevendor,
+		       const char *filename);
 
 
 static void match_vendor_opts(unsigned char *opt, struct dhcp_opt *dopt); 
@@ -100,6 +101,8 @@
   struct dhcp_opt *o;
   unsigned char pxe_uuid[17];
   unsigned char *oui = NULL, *serial = NULL;
+  char filename[sizeof(((struct dhcp_packet*)0)->file)]; filename[sizeof(filename) - 1] = 0;
+
 #ifdef HAVE_SCRIPT
   unsigned char *class = NULL;
 #endif
@@ -559,6 +562,9 @@
       /* Match incoming filename field as a netid. */
       if (mess->file[0])
 	{
+	  strncpy(filename, (char*)mess->file, sizeof(filename)); filename[sizeof(filename) - 1] = 0;
+	  fprintf(stderr, "filename: %s\n", filename);
+
 	  memcpy(daemon->dhcp_buff2, mess->file, sizeof(mess->file));
 	  daemon->dhcp_buff2[sizeof(mess->file) + 1] = 0; /* ensure zero term. */
 	  id.net = (char *)daemon->dhcp_buff2;
@@ -650,7 +656,7 @@
 	      
 	      clear_packet(mess, end);
 	      do_options(context, mess, end, NULL, hostname, get_domain(mess->yiaddr), 
-			 netid, subnet_addr, 0, 0, -1, NULL, vendor_class_len, now, 0xffffffff, 0, NULL);
+			 netid, subnet_addr, 0, 0, -1, NULL, vendor_class_len, now, 0xffffffff, 0, NULL, filename);
 	    }
 	}
       
@@ -898,6 +904,7 @@
 	  else
 	    snprintf((char *)mess->file, sizeof(mess->file),
 		"%s.%d", service->basename, layer);
+	  if (filename[0]) snprintf((char *)mess->file, sizeof(mess->file), "%s", filename);
 	  
 	  option_put(mess, end, OPTION_MESSAGE_TYPE, 1, DHCPACK);
 	  option_put(mess, end, OPTION_SERVER_IDENTIFIER, INADDRSZ, htonl(context->local.s_addr));
@@ -976,6 +983,7 @@
 		      
 		      if (boot->file)
 			safe_strncpy((char *)mess->file, boot->file, sizeof(mess->file));
+		        if (filename[0]) safe_strncpy((char *)mess->file, filename,  sizeof(mess->file));
 		    }
 		  
 		  option_put(mess, end, OPTION_MESSAGE_TYPE, 1, 
@@ -1152,7 +1160,7 @@
       option_put(mess, end, OPTION_LEASE_TIME, 4, time);
       /* T1 and T2 are required in DHCPOFFER by HP's wacky Jetdirect client. */
       do_options(context, mess, end, req_options, offer_hostname, get_domain(mess->yiaddr), 
-		 netid, subnet_addr, fqdn_flags, borken_opt, pxearch, uuid, vendor_class_len, now, time, fuzz, pxevendor);
+		 netid, subnet_addr, fqdn_flags, borken_opt, pxearch, uuid, vendor_class_len, now, time, fuzz, pxevendor, filename);
       
       return dhcp_packet_size(mess, agent_id, real_end);
 	
@@ -1501,7 +1509,7 @@
 	  if (rapid_commit)
 	     option_put(mess, end, OPTION_RAPID_COMMIT, 0, 0);
 	   do_options(context, mess, end, req_options, hostname, get_domain(mess->yiaddr), 
-		     netid, subnet_addr, fqdn_flags, borken_opt, pxearch, uuid, vendor_class_len, now, time, fuzz, pxevendor);
+		     netid, subnet_addr, fqdn_flags, borken_opt, pxearch, uuid, vendor_class_len, now, time, fuzz, pxevendor, filename);
 	}
 
       return dhcp_packet_size(mess, agent_id, real_end); 
@@ -1568,7 +1576,7 @@
 	}
 
       do_options(context, mess, end, req_options, hostname, get_domain(mess->ciaddr),
-		 netid, subnet_addr, fqdn_flags, borken_opt, pxearch, uuid, vendor_class_len, now, 0xffffffff, 0, pxevendor);
+		 netid, subnet_addr, fqdn_flags, borken_opt, pxearch, uuid, vendor_class_len, now, 0xffffffff, 0, pxevendor, filename);
       
       *is_inform = 1; /* handle reply differently */
       return dhcp_packet_size(mess, agent_id, real_end); 
@@ -2367,7 +2375,8 @@
 		       time_t now,
 		       unsigned int lease_time,
 		       unsigned short fuzz,
-		       const char *pxevendor)
+		       const char *pxevendor,
+		       const char *filename)
 {
   struct dhcp_opt *opt, *config_opts = daemon->dhcp_opts;
   struct dhcp_boot *boot;
@@ -2437,9 +2446,9 @@
 	  if (!option_bool(OPT_NO_OVERRIDE) &&
 	      req_options && 
 	      in_list(req_options, OPTION_FILENAME))
-	    option_put_string(mess, end, OPTION_FILENAME, boot->file, 1);
+	    option_put_string(mess, end, OPTION_FILENAME, filename[0] ? filename : boot->file, 1);
 	  else
-	    safe_strncpy((char *)mess->file, boot->file, sizeof(mess->file));
+	    safe_strncpy((char *)mess->file, filename[0] ? filename : boot->file, sizeof(mess->file));
 	}
       
       if (boot->next_server.s_addr) 
