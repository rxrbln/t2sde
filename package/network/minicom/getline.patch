# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../minicom/getline.patch
# Copyright (C) 2009 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

Do not collide with system C library functions, ...

*** minicom-2.3/src/minicom.c.orig	2009-08-06 14:25:15.000000000 +0200
--- minicom-2.3/src/minicom.c	2009-08-06 14:25:30.000000000 +0200
***************
*** 159,165 ****
  #endif /*SIGTSTP*/
  
  /* Get a line from either window or scroll back buffer. */
! static ELM *getline(WIN *w, int no)
  {
    int i;
    static ELM outofrange[MAXCOLS] = {{0,0,0}};
--- 159,165 ----
  #endif /*SIGTSTP*/
  
  /* Get a line from either window or scroll back buffer. */
! static ELM *mygetline(WIN *w, int no)
  {
    int i;
    static ELM outofrange[MAXCOLS] = {{0,0,0}};
***************
*** 197,203 ****
  
    w->direct = 0;
    for (f = 0; f < w->ys; f++)
!     wdrawelm(w, f, getline(w, y++));
    if (r)
      wredraw(w, 1);
    w->direct = 1;
--- 197,203 ----
  
    w->direct = 0;
    for (f = 0; f < w->ys; f++)
!     wdrawelm(w, f, mygetline(w, y++));
    if (r)
      wredraw(w, 1);
    w->direct = 1;
***************
*** 219,225 ****
    tmp_line[0]='\0';
    w->direct = 0;
    for (f = 0; f < w->ys; f++) {
!     tmp_e = getline(w, y++);
  
      /* First we "accumulate" the line into a variable */
      wdrawelm_var(w, tmp_e, tmp_line);
--- 219,225 ----
    tmp_line[0]='\0';
    w->direct = 0;
    for (f = 0; f < w->ys; f++) {
!     tmp_e = mygetline(w, y++);
  
      /* First we "accumulate" the line into a variable */
      wdrawelm_var(w, tmp_e, tmp_line);
***************
*** 316,322 ****
  
    for (next_line = hit_line; next_line <= all_lines; next_line++) {
      /* we do 'something' here... :-) */
!     tmp_e = getline(w_hist, next_line);
  
      /*
       * First we "accumulate" the line into a variable.
--- 316,322 ----
  
    for (next_line = hit_line; next_line <= all_lines; next_line++) {
      /* we do 'something' here... :-) */
!     tmp_e = mygetline(w_hist, next_line);
  
      /*
       * First we "accumulate" the line into a variable.
***************
*** 371,379 ****
  static void drawcite(WIN *w, int y, int citey, int start, int end)
  {
    if (y+citey >= start && y+citey <= end)
!     wdrawelm_inverse(w, y, getline(w, y+citey));
    else
!     wdrawelm(w, y, getline(w, y+citey));
  }
  
  static void drawcite_whole(WIN *w, int y, int start, int end)
--- 371,379 ----
  static void drawcite(WIN *w, int y, int citey, int start, int end)
  {
    if (y+citey >= start && y+citey <= end)
!     wdrawelm_inverse(w, y, mygetline(w, y+citey));
    else
!     wdrawelm(w, y, mygetline(w, y+citey));
  }
  
  static void drawcite_whole(WIN *w, int y, int start, int end)
***************
*** 392,398 ****
    for (y=start; y<=end; y++) {
      vt_send('>');
      vt_send(' ');
!     tmp_e = getline(w, y);
      wdrawelm_var(w, tmp_e, tmp_line);
      tmp_line[w->xs] = 0;
      for (x = w->xs-1; x >= 0; x--) {
--- 392,398 ----
    for (y=start; y<=end; y++) {
      vt_send('>');
      vt_send(' ');
!     tmp_e = mygetline(w, y);
      wdrawelm_var(w, tmp_e, tmp_line);
      tmp_line[w->xs] = 0;
      for (x = w->xs-1; x >= 0; x--) {
***************
*** 592,598 ****
          if (citemode) {
            inverse = (y+cite_y >= cite_ystart && y+cite_y <= cite_yend);
          } else {
!           tmp_e = getline(b_us, y);
            if (wcslen(look_for) > 1) {
              /* quick scan for pattern match */
              wdrawelm_var(b_us, tmp_e, tmp_line);
--- 592,598 ----
          if (citemode) {
            inverse = (y+cite_y >= cite_ystart && y+cite_y <= cite_yend);
          } else {
!           tmp_e = mygetline(b_us, y);
            if (wcslen(look_for) > 1) {
              /* quick scan for pattern match */
              wdrawelm_var(b_us, tmp_e, tmp_line);
***************
*** 603,611 ****
          }
  
          if (inverse)
!           wdrawelm_inverse(b_us, 0, getline(b_us, y));
          else
!           wdrawelm(b_us, 0, getline(b_us, y));
          if (citemode)
            wlocate(b_us, 0, cite_y);
          wflush();
--- 603,611 ----
          }
  
          if (inverse)
!           wdrawelm_inverse(b_us, 0, mygetline(b_us, y));
          else
!           wdrawelm(b_us, 0, mygetline(b_us, y));
          if (citemode)
            wlocate(b_us, 0, cite_y);
          wflush();
***************
*** 640,646 ****
          if (citemode) {
            inverse = (y+cite_y >= cite_ystart && y+cite_y <= cite_yend);
          } else {
!           tmp_e = getline(b_us, y + b_us->ys - 1);
            if (wcslen(look_for) > 1) {
              /* quick scan for pattern match */
              wdrawelm_var(b_us, tmp_e, tmp_line);
--- 640,646 ----
          if (citemode) {
            inverse = (y+cite_y >= cite_ystart && y+cite_y <= cite_yend);
          } else {
!           tmp_e = mygetline(b_us, y + b_us->ys - 1);
            if (wcslen(look_for) > 1) {
              /* quick scan for pattern match */
              wdrawelm_var(b_us, tmp_e, tmp_line);
***************
*** 652,661 ****
  
          if (inverse)
            wdrawelm_inverse(b_us, b_us->ys - 1,
!                            getline(b_us, y + b_us->ys - 1));
          else
            wdrawelm(b_us, b_us->ys - 1,
!                    getline(b_us, y + b_us->ys - 1));
          if (citemode)
            wlocate(b_us, 0, cite_y);
          wflush();
--- 652,661 ----
  
          if (inverse)
            wdrawelm_inverse(b_us, b_us->ys - 1,
!                            mygetline(b_us, y + b_us->ys - 1));
          else
            wdrawelm(b_us, b_us->ys - 1,
!                    mygetline(b_us, y + b_us->ys - 1));
          if (citemode)
            wlocate(b_us, 0, cite_y);
          wflush();
***************
*** 745,751 ****
          wlocate(b_st, 0, 0);
          wprintf(b_st, hline);
          wredraw(b_st, 1);
!         wdrawelm_inverse(b_us, cite_y, getline(b_us, cite_ystart));
          wlocate(b_us, 0, cite_y);
          break;
        case K_ESC:
--- 745,751 ----
          wlocate(b_st, 0, 0);
          wprintf(b_st, hline);
          wredraw(b_st, 1);
!         wdrawelm_inverse(b_us, cite_y, mygetline(b_us, cite_ystart));
          wlocate(b_us, 0, cite_y);
          break;
        case K_ESC:
