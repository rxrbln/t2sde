# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../rezound/gcc41-hacky.patch
# Copyright (C) 2006 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

Well, this part is hacky, gcc41 does not seem to match against the provided
std::vector<> specialization. After some trial 'n error I decided to take
a shortpath and let the default work on any contrainer a-like type.

--- rezound-0.12.2beta/src/misc/CNestedDataFile/anytype.h.vanilla	2006-03-05 23:45:44.856469500 +0100
+++ rezound-0.12.2beta/src/misc/CNestedDataFile/anytype.h	2006-03-06 00:09:06.584072000 +0100
@@ -60,7 +60,26 @@
 // or we could leave these unimplemented to get a linker error instead (that's what I have to do with gcc>=3.4
 // 	/* the reason I haven't made string_to_anytype return a reference is because currently, it's probably not a big deal for most types.. and with string, we'd be making a copy into the ret parameter if I implemented it that way anyway.. perhaps I could remove the return type all together and always use the ret parameter to get back the data */
 template<typename Type> static const Type string_to_anytype(const string &str,Type &ret)       ;// { no_specialization_of_this_template_with_the_given_type; }
-template<typename Type> static const string anytype_to_string(const Type &any)                 ;// { no_specialization_of_this_template_with_the_given_type; }
+
+template<typename Type> static const string anytype_to_string(const Type &any)
+/*
+// I really wished that I didn't have to explicitly use 'vector' in the definition, I'd have like to use any container with an iterator interface
+template<class Type> __attribute__((always_inline)) inline const string anytype_to_string(const vector<Type> &any) */
+{
+        string s;
+        size_t l=any.size();
+        s="{";
+        for(size_t t=0;t<l;t++)
+        {
+                // leaving type in case it's not able to deduce aruments and chooses the default template implemenation
+                // if I knew how to constrain the original definition of the template, I would make it fully constrained
+                s+=anytype_to_string(any[t]);
+                if(t!=(l-1))
+                                s+=",";
+        }
+        return s+"}";
+}
+
 
 
 
@@ -146,24 +165,6 @@
 template<> static const string anytype_to_string<long double>(const long double &any)        { if(isnan(any)) return "0"; else { ostringstream ss; if(any>999999.0) {ss.setf(ios::scientific); ss.width(0); ss.precision(12); ss.fill(' '); } else {ss.setf(ios::fixed); ss.precision(6); ss.fill(' '); } ss << any; return istring(ss.str()).trim(); } }
 
 
-// I really wished that I didn't have to explicitly use 'vector' in the definition, I'd have like to use any container with an iterator interface
-template<class Type> static const string anytype_to_string(const vector<Type> &any)
-{
-	string s;
-	size_t l=any.size();
-	s="{";
-	for(size_t t=0;t<l;t++)
-	{
-		// leaving type in case it's not able to deduce aruments and chooses the default template implemenation
-		// if I knew how to constrain the original definition of the template, I would make it fully constrained
-		s+=anytype_to_string(any[t]);
-		if(t!=(l-1))
-				s+=",";
-	}
-	return s+"}";
-}
-
-
 // ----------------------------------------------------------------------------
 
 namespace s2at // s2at signifies string_to_anytype/anytype_to_string
