# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../tse3/gcc3_fixes.patch
# Copyright (C) 2004 - 2005 The T2 SDE Project
# Copyright (C) 1998 - 2003 ROCK Linux Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

--- ./src/tse3/test.cpp.orig	Wed May 15 15:56:01 2002
+++ ./src/tse3/test.cpp	Wed May 15 16:00:47 2002
@@ -31,6 +31,7 @@
 //#include "TSE3Commands/SongCommands.h"
 
 #include <fstream>
+#include <iostream>
 
 using namespace TSE3;
 
@@ -42,17 +43,17 @@
 int main()
 {
 
-  cout << "Started...\n\n";
+  std::cout << "Started...\n\n";
 /*
   // This will prove that my representation of MidiCommands is equivalent to
   // the old TSE2 word typedef.
   MidiCommand com1(MidiCommand_NoteOn, 0, 0, 0x40, 100);
-  cout << "command is " << *((int*)&com1) << "\n\n";
+  std::cout << "command is " << *((int*)&com1) << "\n\n";
 
   // Proves I can actually create these objects ;-)
   MidiScheduler s;
   Track t;
-  cout << "Created a PhraseEdit and everything else\n";
+  std::cout << "Created a PhraseEdit and everything else\n";
 
   // This will prove the Notifier framework.
   t.params.setMute(false);
@@ -68,13 +69,13 @@
   do
   {
     MidiEvent e = t.params.event();
-    cout << "Event is " << e.event.data.status << "," << e.event.data.data1
+    std::cout << "Event is " << e.event.data.status << "," << e.event.data.data1
          << "," << e.event.data.data2<< " (" << *((int*)&(e.event.data))
          << ")\n";
   } while (t.params.consume());
 
   // Try out flag tracks
-  cout << "\nCreating FlagTrack\n";
+  std::cout << "\nCreating FlagTrack\n";
   FlagTrack f;
   f.insert(Event<Flag>(Flag("Time 1"), 0));
   f.insert(Event<Flag>(Flag("Time 2"), Clock::PPQN));
@@ -84,26 +85,26 @@
   f.erase(Event<Flag>(Flag("Time X"), Clock::PPQN*3));
   for (int i = 0; i < f.size(); ++i)
   {
-    cout << "  " << i << ": " << f[i].time << " - " << f[i].data.title << "\n";
+    std::cout << "  " << i << ": " << f[i].time << " - " << f[i].data.title << "\n";
   }
 
   int pos = f.index(Clock::PPQN*2.5);
-  cout << "\nIndex at " << Clock::PPQN*2.5 << " is " << pos << "\n\n";
+  std::cout << "\nIndex at " << Clock::PPQN*2.5 << " is " << pos << "\n\n";
 
   // Test the TempoTrack
   TempoTrack tt;
   tt.insert(Event<Tempo>(100, 0));
   tt.insert(Event<Tempo>(120, 2*Clock::PPQN));
-  cout << "Playing TempoTrack...\n";
+  std::cout << "Playing TempoTrack...\n";
   play(&tt);
 */
   // Test utilities
   /*
   string str;
   NoteNumberConversion::numberToNote(60,str);
-  cout << "Note string is: '" << str << "'\n";
+  std::cout << "Note string is: '" << str << "'\n";
   int note = NoteNumberConversion::noteToNumber("C#-6");
-  cout << "Note number is: " << note << "\n\n\n";
+  std::cout << "Note number is: " << note << "\n\n\n";
   */
 
   // Test the PhraseEdit
@@ -117,9 +118,9 @@
                       Clock::PPQN*2));
   pe.insert(MidiEvent(MidiCommand(MidiCommand_ProgramChange, 0, 0, 40),
                       Clock::PPQN*3));
-  cout << "Phrase edit size is " << pe.size() << "\n";
+  std::cout << "Phrase edit size is " << pe.size() << "\n";
   Phrase *phr = pe.createPhrase();
-  cout << "New Phrase size is " << phr->size() << "\n\n";
+  std::cout << "New Phrase size is " << phr->size() << "\n\n";
   */
 
 /*
@@ -132,7 +133,7 @@
   part.setRepeat(Clock::PPQN*4);
   part.setStart(0);
   part.setEnd(Clock::PPQN*8);
-  //cout << "\n\nPlaying Part...\n";
+  //std::cout << "\n\nPlaying Part...\n";
   //play(&part);
 
   Track track;
@@ -141,12 +142,12 @@
 */
 
   Song song;
-  cout << "No Tracks in the song is: " << song.size() << "\n";
+  std::cout << "No Tracks in the song is: " << song.size() << "\n";
 /*
   song.track(0)->insert(0, Clock::PPQN*4)->setPhrase(phr);
   song.track(0)->insert(Clock::PPQN*12, Clock::PPQN*14)->setPhrase(phr);
   song.track(0)->insert(Clock::PPQN*8, Clock::PPQN*9)->setPhrase(phr);
-  cout << song.track(0)->size() << "\n\n";
+  std::cout << song.track(0)->size() << "\n\n";
 
   play(song.track(0));
 
@@ -159,7 +160,7 @@
   /*
   FileOperations_2 fo2;
   fo2.load(&song, "song.tsemdl");
-  cout << "No of tracks in the song is " << song.size() << ". Marvelous.\n\n";
+  std::cout << "No of tracks in the song is " << song.size() << ". Marvelous.\n\n";
   //play((*(song.track(0)))[0]);
   //play(song.track(0));
   //play(&song);
@@ -168,16 +169,16 @@
 
   /*
   // Load a MIDI file
-  cout << "Importing test.mid...\n";
+  std::cout << "Importing test.mid...\n";
   Song *newSong;
   try
   {
-      MidiFileImport import("test.mid", 2, cout);
+      MidiFileImport import("test.mid", 2, std::cout);
       newSong = import.import();
   }
   catch (MidiFileImportError &e)
   {
-      cout << "Exception thrown: " << *e;
+      std::cout << "Exception thrown: " << *e;
   }
   */
 
@@ -187,30 +188,30 @@
   Phrase *p = pe.createPhrase();
   p->setTitle(song.phraseList.newPhraseTitle(PhraseList_NewPhraseString));
   song.phraseList.insert(p);
-  cout << "New Phrasename: " << p->title();
+  std::cout << "New Phrasename: " << p->title();
   p = pe.createPhrase();
   p->setTitle(song.phraseList.newPhraseTitle(PhraseList_NewPhraseString));
   song.phraseList.insert(p);
-  cout << "New Phrasename: " << p->title();
+  std::cout << "New Phrasename: " << p->title();
   */
 
-  //cout << (bool)(*(song.track(0)))[0]->filter.status() << "\n";
+  //std::cout << (bool)(*(song.track(0)))[0]->filter.status() << "\n";
 
   // Test the scheduler/transport bobbins
 /*  Metronome             metronome;
   MidiSchedulerFactory  msf;
   MidiScheduler        *scheduler = msf.createScheduler();
   Transport     transport(&metronome, scheduler);
-  cout << "Scheduler type is '" << scheduler->implementationName() << "'\n";
+  std::cout << "Scheduler type is '" << scheduler->implementationName() << "'\n";
 
   // Test playing
-  cout << "Playing the song through the Transport system...\n";
+  std::cout << "Playing the song through the Transport system...\n";
   transport.play(&song, 0);
   while (transport.status() != Transport::resting) transport.poll();
 */
   // Testing saving
   /*
-  cout << "Saving Song in TSE3MDL format...\n";
+  std::cout << "Saving Song in TSE3MDL format...\n";
   TSE3MDL_File file(&song);
   ofstream o("song.tse3mdl");
   file.save(o, 0);
@@ -219,21 +220,21 @@
 
   // Testing loading
   /*
-  cout << "Loading file in TSE3MDL format...\n";
+  std::cout << "Loading file in TSE3MDL format...\n";
   TSE3MDL loader;
   Song *newSong
       = loader.load("/export/pgoodlif/work/TSE3/tse3/misc/Demo.tse3");
-  cout << newSong->title() << endl;
-  cout << "No Tracks in the song is: " << song.size() << "\n";
+  std::cout << newSong->title() << endl;
+  std::cout << "No Tracks in the song is: " << song.size() << "\n";
 
-  cout << "Writing in the XML stylee...\n";
+  std::cout << "Writing in the XML stylee...\n";
   {
       std::ofstream out("out.xml");
       TSE3::File::XmlFileWriter writer(out);
       TSE3::File::writeSong(writer, *newSong);
   }
   */
-  cout << "Loading file in XML format...\n";
+  std::cout << "Loading file in XML format...\n";
   std::ifstream in("out.xml");
   TSE3::File::XmlFileReader reader(in);
   Song *newSong = reader.load();
@@ -244,21 +245,21 @@
   /*
   CommandHistory history;
   Song_SetTitle s(newSong, "This is a new Song title");
-  cout << "Song title is " << newSong->title() << endl;
+  std::cout << "Song title is " << newSong->title() << endl;
   s.execute();
-  cout << "Song title is " << newSong->title() << endl;
+  std::cout << "Song title is " << newSong->title() << endl;
   history.add(&s);
   history.undo();
-  cout << "Song title is " << newSong->title() << endl;
+  std::cout << "Song title is " << newSong->title() << endl;
   history.redo();
-  cout << "Song title is " << newSong->title() << endl;
+  std::cout << "Song title is " << newSong->title() << endl;
   */
 
   // Testing playing a Panic object
   /*
   Panic panic;
   panic.setAllNotesOff(true);
-  cout << "Playing a Panic object...\n";
+  std::cout << "Playing a Panic object...\n";
   transport.play(&panic, 0);
   while (transport.status() != Transport::resting) transport.poll();
   */
@@ -267,18 +268,18 @@
   //FileRecogniser fr("song.tse3mdl");
   /*
   FileRecogniser fr("test.mid");
-  cout << "File format is " << fr.type() << endl;
+  std::cout << "File format is " << fr.type() << endl;
   */
 
   // Test Cakewalk .ins file import routines
   //insTest();
 
 /*
-  cout << "-----------------------------------------\n";
+  std::cout << "-----------------------------------------\n";
   Track *track = newSong->track(0);
   //play((*track)[0]);
   play(newSong);
-  cout << "-----------------------------------------\n";
+  std::cout << "-----------------------------------------\n";
 */
 
   /*
@@ -289,7 +290,7 @@
   o.close();
   */
 
-  cout << "\n\nFinishing...\n";
+  std::cout << "\n\nFinishing...\n";
 
   return 0;
 
@@ -304,21 +305,21 @@
 void play(Playable *p)
 {
 
-    cout << "Creating iterator:\n";
+    std::cout << "Creating iterator:\n";
     PlayableIterator *i = p->iterator(0);
-    cout << "Playing a playable:\n";
+    std::cout << "Playing a playable:\n";
     while (i->more())
     {
         MidiEvent e = *(*i);
         if (e.event.data.status)
-            cout << "  MidiEvent: " << e.event.time
+            std::cout << "  MidiEvent: " << e.event.time
                  << " - " << e.event.data.status << ":"
                  << e.event.data.data1
                  << ":" << e.event.data.data2 << "\n";
         ++(*i);
     }
 
-    cout << "End of playable\n\n";
+    std::cout << "End of playable\n\n";
 
 }
 
@@ -328,45 +329,45 @@
     for (int n = 0; n < s->size(); ++n)
     {
         Track *t = s->track(n);
-        cout << "-- ";
+        std::cout << "-- ";
         for (int m = 0; m < t->size(); ++m)
         {
             Part *p = (*t)[m];
-            cout << "|"<<p->phrase()->title();
-            cout << ","<<p->start()<<"-"<<p->end();
-            cout <<"| ";
+            std::cout << "|"<<p->phrase()->title();
+            std::cout << ","<<p->start()<<"-"<<p->end();
+            std::cout <<"| ";
         }
-        cout << "\n";
+        std::cout << "\n";
     }
 }
 
 /*
 void insTest()
 {
-    cout << ">> insTest\n";
+    std::cout << ">> insTest\n";
     CakewalkInstrumentFile cif("Yamaha.ins");
 
-    cout << "Created the ins file object.\n";
+    std::cout << "Created the ins file object.\n";
 
-    cout << "Instruments in this file are (" << cif.instruments().size() << "):\n";
+    std::cout << "Instruments in this file are (" << cif.instruments().size() << "):\n";
     list<string>::const_iterator i = cif.instruments().begin();
     int n = 0;
     while (i != cif.instruments().end())
     {
-        cout << n << "  " << *i << endl ;
+        std::cout << n << "  " << *i << endl ;
         ++n;
         ++i;
     }
 
-    cout << "\nTrying to create an instrument...\n";
+    std::cout << "\nTrying to create an instrument...\n";
     Instrument *ins = cif.instrument("Yamaha SY-35");
 
-    cout << "\nTrying to write an instrument...\n";
+    std::cout << "\nTrying to write an instrument...\n";
     ofstream outfile("out.ins");
     ins->write(outfile);
     outfile.close();
 
-    cout << "<< insTest\n";
+    std::cout << "<< insTest\n";
 }
 */
 #endif
