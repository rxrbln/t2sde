# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../dietlibc/pkg_patch/pkg_gawk.patch
# Copyright (C) 2004 - 2005 The T2 SDE Project
# Copyright (C) 1998 - 2004 ROCK Linux Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

--- ./configure.orig	2003-07-28 10:26:06.000000000 +0200
+++ ./configure	2003-07-28 10:28:01.000000000 +0200
@@ -12,6 +12,11 @@
 ## M4sh Initialization.  ##
 ## --------------------- ##
 
+ac_cv_header_mcheck_h=no
+ac_cv_header_stropts_h=no
+ac_cv_header_wchar_h=no
+ac_cv_header_wctype_h=no
+
 # Be Bourne compatible
 if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
   emulate sh
@@ -10821,9 +10826,9 @@
 fi
 if test $ac_cv_header_dlfcn_h = yes; then
 
-cat >>confdefs.h <<\_ACEOF
-#define DYNAMIC 1
-_ACEOF
+# cat >>confdefs.h <<\_ACEOF
+# #define DYNAMIC 1
+# _ACEOF
 
 	if test "$GCC" = yes
 	then


This part disables the useage of math.h functions since dietlibs only support
them correctly for x86.

This is a ugly hack which return 0.0 for all such function - and we should
consider working on fixing dietlibc in this regard.

  - Rene Rebe <rene@exactcode.de>


diff -ur gawk-3.1.3/builtin.c gawk-3.1.3-hacked/builtin.c
--- gawk-3.1.3/builtin.c	2003-07-07 00:08:08.000000000 +0200
+++ gawk-3.1.3-hacked/builtin.c	2003-09-07 20:48:44.000000000 +0200
@@ -153,7 +153,7 @@
 	d = force_number(tmp);
 	free_temp(tmp);
 	errno = 0;
-	res = exp(d);
+	res = 0.0i; /* exp(d); */
 	if (errno == ERANGE)
 		warning(_("exp: argument %g is out of range"), d);
 	return tmp_number((AWKNUM) res);
@@ -418,9 +418,9 @@
 double_to_int(double d)
 {
 	if (d >= 0)
-		d = Floor(d);
+		d = /*Floor(*/d/*)*/;
 	else
-		d = Ceil(d);
+		d = /*Ceil(*/d/*)*/;
 	return d;
 }
 
@@ -471,7 +471,7 @@
 	arg = (double) force_number(tmp);
 	if (arg < 0.0)
 		warning(_("log: received negative argument %g"), arg);
-	d = log(arg);
+	d = 0.0; /* log(arg); */
 	free_temp(tmp);
 	return tmp_number((AWKNUM) d);
 }
@@ -1213,7 +1213,7 @@
 	free_temp(tmp);
 	if (arg < 0.0)
 		warning(_("sqrt: called with negative argument %g"), arg);
-	return tmp_number((AWKNUM) sqrt(arg));
+	return tmp_number((AWKNUM) 0.0 /* sqrt(arg) */ );
 }
 
 /* do_substr --- do the substr function */
@@ -1707,7 +1707,7 @@
 	d2 = force_number(t2);
 	free_temp(t1);
 	free_temp(t2);
-	return tmp_number((AWKNUM) atan2(d1, d2));
+	return tmp_number((AWKNUM) 0.0 /* atan2(d1, d2) */ );
 }
 
 /* do_sin --- do the sin function */
@@ -1721,7 +1721,7 @@
 	tmp = tree_eval(tree->lnode);
 	if (do_lint && (tmp->flags & (NUMCUR|NUMBER)) == 0)
 		lintwarn(_("sin: received non-numeric argument"));
-	d = sin((double) force_number(tmp));
+	d = 0.0; /* sin((double) force_number(tmp)); */
 	free_temp(tmp);
 	return tmp_number((AWKNUM) d);
 }
@@ -1737,7 +1737,7 @@
 	tmp = tree_eval(tree->lnode);
 	if (do_lint && (tmp->flags & (NUMCUR|NUMBER)) == 0)
 		lintwarn(_("cos: received non-numeric argument"));
-	d = cos((double) force_number(tmp));
+	d = 0.0; /* cos((double) force_number(tmp)); */
 	free_temp(tmp);
 	return tmp_number((AWKNUM) d);
 }
diff -ur gawk-3.1.3/eval.c gawk-3.1.3-hacked/eval.c
--- gawk-3.1.3/eval.c	2003-06-22 10:56:04.000000000 +0200
+++ gawk-3.1.3-hacked/eval.c	2003-09-07 20:53:06.000000000 +0200
@@ -1111,7 +1111,7 @@
 					x *= x1;
 			}
 		} else
-			x = pow((double) x1, (double) x2);
+			x = 0.0; /* pow((double) x1, (double) x2); */
 		return tmp_number(x);
 
 	case Node_times:
@@ -1138,8 +1138,8 @@
 #ifdef HAVE_FMOD
 		return tmp_number(fmod(x1, x2));
 #else	/* ! HAVE_FMOD */
-		(void) modf(x1 / x2, &x);
-		return tmp_number(x1 - x * x2);
+		/* (void) modf(x1 / x2, &x); */
+		return tmp_number( 0.0 /* x1 - x * x2 */ );
 #endif	/* ! HAVE_FMOD */
 
 	case Node_plus:
@@ -1316,7 +1316,7 @@
 				*lhs = make_number(t1);
 			}
 		} else
-			*lhs = make_number((AWKNUM) pow((double) lval, (double) rval));
+			*lhs = make_number((AWKNUM) 0.0 /* pow((double) lval, (double) rval)*/);
 		break;
 
 	case Node_assign_times:
@@ -1347,8 +1347,8 @@
 #ifdef HAVE_FMOD
 		*lhs = make_number(fmod(lval, rval));
 #else	/* ! HAVE_FMOD */
-		(void) modf(lval / rval, &t1);
-		t2 = lval - rval * t1;
+		/*(void) modf(lval / rval, &t1);*/
+		t2 = 0.0; /* lval - rval * t1; */
 		*lhs = make_number(t2);
 #endif	/* ! HAVE_FMOD */
 		break;
