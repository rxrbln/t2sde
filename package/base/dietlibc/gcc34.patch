
Some fixes for compilation with gcc-3.4.

  - Rene Rebe <rene@rocklinux.org>

diff -ur dietlibc-0.25-orig/lib/alloc.c dietlibc-0.25/lib/alloc.c
--- dietlibc-0.25-orig/lib/alloc.c	2004-01-27 15:24:11.000000000 +0100
+++ dietlibc-0.25/lib/alloc.c	2004-05-05 03:14:54.000000000 +0200
@@ -44,14 +44,13 @@
 
 /* a simple mmap :) */
 
+static void*
 #ifdef __i386__
 /* regparm exists only on i386 */
-static void *do_mmap(size_t size) __attribute__((regparm(1)));
-static size_t get_index(size_t _size) __attribute__((regparm(1)));
-static void* __small_malloc(size_t _size) __attribute__((regparm(1)));
+__attribute__((regparm(1)))
 #endif
-
-static void *do_mmap(size_t size) {
+do_mmap(size_t size)
+{
   return mmap(0, size, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, (size_t)0);
 }
 
@@ -70,7 +69,13 @@
 
 static inline int __ind_shift() { return (MEM_BLOCK_SIZE==4096)?4:5; }
 
-static size_t get_index(size_t _size) {
+static size_t
+#ifdef __i386__
+/* regparm exists only on i386 */
+__attribute__((regparm(1)))
+#endif
+get_index(size_t _size)
+{
   register size_t idx=0;
   if (_size) {
     register size_t size=((_size-1)&(MEM_BLOCK_SIZE-1))>>__ind_shift();
@@ -80,9 +85,13 @@
 }
 
 /* small mem */
-static void __small_free(void*_ptr,size_t _size) __attribute__((regparm(2)));
-
-static void __small_free(void*_ptr,size_t _size) {
+static void 
+#ifdef __i386__
+/* regparm exists only on i386 */
+__attribute__((regparm(1)))
+#endif
+__small_free(void*_ptr,size_t _size)
+{
   __alloc_t* ptr=BLOCK_START(_ptr);
   size_t size=_size;
   size_t idx=get_index(size);
@@ -93,7 +102,13 @@
   __small_mem[idx]=ptr;
 }
 
-static void* __small_malloc(size_t _size) {
+static void* 
+#ifdef __i386__
+/* regparm exists only on i386 */
+__attribute__((regparm(1)))
+#endif
+__small_malloc(size_t _size)  
+{
   __alloc_t *ptr;
   size_t size=_size;
   size_t idx;
diff -ur dietlibc-0.25-orig/libpthread/pthread_internal.c dietlibc-0.25/libpthread/pthread_internal.c
--- dietlibc-0.25-orig/libpthread/pthread_internal.c	2003-09-29 16:00:59.000000000 +0200
+++ dietlibc-0.25/libpthread/pthread_internal.c	2004-05-05 03:18:08.000000000 +0200
@@ -49,10 +49,11 @@
 static inline unsigned long hash_tid(int tid) { return (tid&(NR_BUCKETS-1)); }
 
 /* O(1) */
+static void 
 #if defined(__i386__)
-static void __thread_add_tid_(_pthread_descr*root,_pthread_descr thread) __attribute__((regparm(2)));
+__attribute__((regparm(2)))
 #endif
-static void __thread_add_tid_(_pthread_descr*root,_pthread_descr thread) {
+__thread_add_tid_(_pthread_descr*root,_pthread_descr thread) {
   _pthread_descr tmp=*root;
   thread->prev=root;
   thread->next=tmp;
@@ -75,13 +76,9 @@
 
 /* find thread by thread-id O(n) (LOCK struct if found) */
 /* O(n*) linear to the number of thread in the same bucket */
-#if defined(__i386__)
-static _pthread_descr __thread_find_(int pid) __attribute__((regparm(1)));
-_pthread_descr __thread_find(int pid) { return __thread_find_(pid); }
-#else
-_pthread_descr __thread_find(int pid) __attribute__((alias("__thread_find_")));
-#endif
-static _pthread_descr __thread_find_(int pid) {
+
+static _pthread_descr
+__thread_find_(int pid) {
   _pthread_descr cur;
   if (__thread_started==PTHREAD_ONCE_INIT) { /* uninitialised */
     LOCK(&_main_thread);
@@ -96,6 +93,13 @@
   return cur;
 }
 
+#if defined(__i386__)
+_pthread_descr
+__thread_find(int pid) { return __thread_find_(pid); }
+#else
+_pthread_descr __thread_find(int pid) __attribute__((alias("__thread_find_")));
+#endif
+
 /* get thread-self descriptor O(1)/O(n*) */
 _pthread_descr __thread_self(void) {
   /* O(1) "search" */
