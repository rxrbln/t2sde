# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../dietlibc/0-libm.patch
# Copyright (C) 2018 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

diff -urN dietlibc-0.30/include/math.h dietlibc-0.30-libm/include/math.h
--- dietlibc-0.30/include/math.h	2004-08-03 22:28:46.000000000 +0000
+++ dietlibc-0.30-libm/include/math.h	2006-06-25 11:25:32.000000000 +0000
@@ -5,6 +5,75 @@
 
 __BEGIN_DECLS
 
+/* All floating-point numbers can be put in one of these categories.  */
+enum
+  {
+    FP_NAN,
+# define FP_NAN FP_NAN
+    FP_INFINITE,
+# define FP_INFINITE FP_INFINITE
+    FP_ZERO,
+# define FP_ZERO FP_ZERO
+    FP_SUBNORMAL,
+# define FP_SUBNORMAL FP_SUBNORMAL
+    FP_NORMAL
+# define FP_NORMAL FP_NORMAL
+  };
+
+# if __BYTE_ORDER == __BIG_ENDIAN
+#  define __nan_bytes           { 0x7f, 0xc0, 0, 0 }
+# endif
+# if __BYTE_ORDER == __LITTLE_ENDIAN
+#  define __nan_bytes           { 0, 0, 0xc0, 0x7f }
+# endif
+
+static union { unsigned char __c[4]; float __d; } __nan_union = { __nan_bytes };
+# define NAN    (__nan_union.__d)
+
+# define X_TLOSS        1.41484755040568800000e+16
+
+/* Types of exceptions in the `type' field.  */
+# define DOMAIN         1
+# define SING           2
+# define OVERFLOW       3
+# define UNDERFLOW      4
+# define TLOSS          5
+# define PLOSS          6
+
+/* SVID mode specifies returning this large value instead of infinity.  */
+# define HUGE           3.40282347e+38F
+
+# ifdef __cplusplus
+struct __exception
+# else
+struct exception
+# endif
+  {
+    int type;
+    char *name;
+    double arg1;
+    double arg2;
+    double retval;
+  };
+
+/* Support for various different standard error handling behaviors.  */
+typedef enum
+{
+  _IEEE_ = -1,  /* According to IEEE 754/IEEE 854.  */
+  _SVID_,       /* According to System V, release 4.  */
+  _XOPEN_,      /* Nowadays also Unix98.  */
+  _POSIX_,
+  _ISOC_        /* Actually this is ISO C99.  */
+} _LIB_VERSION_TYPE;
+
+#define _LIB_VERSION _POSIX_
+
+# ifdef __cplusplus
+extern int matherr (struct __exception *__exc) throw ();
+# else
+extern int matherr (struct exception *__exc);
+# endif
+
 #define M_E		2.7182818284590452354	/* e */
 #define M_LOG2E		1.4426950408889634074	/* log_2 e */
 #define M_LOG10E	0.43429448190325182765	/* log_10 e */
--- dietlibc-0.30/libm/README	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/README	2006-06-25 11:20:06.000000000 +0000
@@ -0,0 +1,16 @@
+The routines included in this math library are derived from the
+math library for Apple's MacOS X/Darwin math library, which was
+itself swiped from FreeBSD.  The original copyright information
+is as follows:
+
+	Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+
+	Developed at SunPro, a Sun Microsystems, Inc. business.
+	Permission to use, copy, modify, and distribute this
+	software is freely granted, provided that this notice
+	is preserved.
+
+It has been ported to work with uClibc and generally behave
+by Erik Andersen <andersen@codepoet.org>
+  22 May, 2001
+Adapted for dietlibc by Rene Rebe <rene@exactcode.de>, 2006
diff -urN dietlibc-0.30/libm/acosh.c dietlibc-0.30-libm/libm/acosh.c
--- dietlibc-0.30/libm/acosh.c	2001-07-27 20:30:34.000000000 +0000
+++ dietlibc-0.30-libm/libm/acosh.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-#include <math.h>
-
-double  acosh ( double x )
-{
-    return log ( x + sqrt (x*x - 1.) );
-}
diff -urN dietlibc-0.30/libm/asinh.c dietlibc-0.30-libm/libm/asinh.c
--- dietlibc-0.30/libm/asinh.c	2001-07-27 20:30:34.000000000 +0000
+++ dietlibc-0.30-libm/libm/asinh.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-#include <math.h>
-
-double  asinh ( double x )
-{
-    return log ( x + sqrt (x*x + 1.) );
-}
diff -urN dietlibc-0.30/libm/atanh.c dietlibc-0.30-libm/libm/atanh.c
--- dietlibc-0.30/libm/atanh.c	2001-07-27 20:30:34.000000000 +0000
+++ dietlibc-0.30-libm/libm/atanh.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,8 +0,0 @@
-#include <math.h>
-
-extern const float  __half;
-
-double  atanh ( double x )
-{
-    return __half * log ( (1.+x) / (1.-x) );
-}
diff -urN dietlibc-0.30/libm/bessel.c dietlibc-0.30-libm/libm/bessel.c
--- dietlibc-0.30/libm/bessel.c	2005-03-15 08:51:23.000000000 +0000
+++ dietlibc-0.30-libm/libm/bessel.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,171 +0,0 @@
-/*--------------------------------------------------------------------------*
-
-Name            j0, j1, jn - Bessel functions
-                y0, y1, yn - Weber functions
-
-Usage           double j0 (double x);
-                double j1 (double x);
-                double jn (int n, double x);
-                double y0 (double x);
-                double y1 (double x);
-                double yn (int n, double x);
-
-Prototype in    math.h
-
-Description     j0, j1 and jn calculate the Bessel function.
-                y0, y1 and yn calcualte the Weber function.
-
-Return value    return their return values as doubles.
-
-*---------------------------------------------------------------------------*/
-
-#include <math.h>
-
-#define M_C             0.5772156649015328
-#if 0
-#define M_1_PI          0.318309886183790671538
-#define M_2_PI          0.636619772367581343076
-#define M_PI            3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148
-#endif
-
-
-#define EXPL(x)   ((((short *)(void *)&x)[4] & 0x7FFF) >> 0)
-#define EXPD(x)   ((((short *)(void *)&x)[3] & 0x7FF0) >> 4)
-#define EXPF(x)   ((((short *)(void *)&x)[1] & 0x7F80) >> 7)
-
-#define SQUARE(x) (long) (My - (x) * (x) )
-
-
-static long double  P ( int My, double* x )
-{
-    long double   Sum  = 0.;
-    long double   Fact = 1.;
-    long double   z182 = -0.015625 / (x[0] * x[0]);
-    register int  i;
-
-    for ( i = 1; ; i += 2 ) {
-        Fact *= SQUARE(i+i-1) * SQUARE(i+i+1) * z182 / (i*(i+1));
-        if ( EXPL (Fact) < 0x3FFF-53 )
-            break;
-        Sum  += Fact;
-    }
-    return 1. + Sum;
-}
-
-static long double  Q ( int My, double* x )
-{
-    long double   Fact = (My-1) / x[0] * 0.125;
-    long double   Sum  = Fact;
-    long double   z182 = -0.015625 / (x[0]*x[0]);
-    register int  i;
-
-    for ( i = 2; ; i += 2 ) {
-        Fact *= SQUARE(i+i-1) * SQUARE(i+i+1) * z182 / (i*(i+1));
-        if ( EXPL (Fact) < 0x3FFF-53 )
-            break;
-        Sum  += Fact;
-    }
-    return Sum;
-}
-
-
-static long double  ___jn ( int n, double* x )
-{
-    long double   Sum;
-    long double   Fact;
-    long double   y;
-    register int  i;
-    double        xx;
-    long double   Xi;
-    int           My;
-
-    if ( n < 0 )
-        return n & 1 ? ___jn (-n, x) : -___jn (-n, x);
-
-    if ((x[0] >= 17.7+0.0144*(n*n))) {
-        Xi = x[0] - M_PI * (n*0.5 + 0.25);
-        My = n*n << 2;
-
-        return sqrt ( M_2_PI/x[0] ) * ( P(My,x) * cos(Xi) - Q(My,x) * sin(Xi) );
-    }
-    xx   = x[0] * 0.5;
-    Sum  = 0.;
-    Fact = 1.;
-    y    = -xx * xx;
-
-    for ( i = 1; i <= n; i++ )
-        Fact *= xx/i;
-    for ( i = 1; ; i++ ) {
-        Sum  += Fact;
-        Fact *= y / (i*(n+i));
-        if ( EXPL (Sum) - EXPL(Fact) > 53 || !EXPL(Fact) )
-            break;
-    }
-    return Sum;
-}
-
-
-static long double  ___yn ( int n, double* x )
-{
-    long double   Sum1;
-    long double   Sum2;
-    long double   Fact1;
-    long double   Fact2;
-    long double   F1;
-    long double   F2;
-    long double   y;
-    register int  i;
-    double        xx;
-    long double   Xi;
-    unsigned int  My;
-
-    if ( EXPD (x[0]) == 0 )
-        return -1./0.;	/* ignore the gcc warning, this is intentional */
-
-    if ( (x[0] >= (n>=32 ? 25.8 : (n<8 ? 17.4+0.1*n : 16.2+0.3*n))) ) {
-        Xi = x[0] - M_PI * (n*0.5+0.25);
-        My = n*n << 2;
-
-        return sqrt ( M_2_PI / x[0] ) * ( P(My,x) * sin(Xi) + Q(My,x) * cos(Xi) );
-    }
-
-    Sum1  = Sum2 = F1 = F2 = 0;
-    Fact1 = 1. / (xx = x[0] * 0.5 );
-    Fact2 = 1.;
-    y     = xx*xx;
-
-    for ( i = 1; i < n; i++ )
-        Fact1 *= (n-i) / xx;
-
-    for ( i = 1; i <= n; i++ ) {
-        Sum1  += Fact1;
-        if ( i == n )
-            break;
-        Fact1 *= y/(i*(n-i));
-    }
-
-    for (i=1; i<=n; i++) {
-        Fact2 *= xx / i;
-        F1    += 1. / i;
-    }
-
-    for ( i = 1; ; i++ ) {
-        Sum2  += Fact2 * (F1+F2);
-        Fact2 *= -y / (i*(n+i));
-        if ( EXPL (Sum2) - EXPL (Fact2) > 53 || !EXPL (Fact2) )
-            break;
-        F1 += 1. / (n+i);
-        F2 += 1. / i;
-    }
-
-    return M_1_PI * (2. * (M_C + log(xx)) * ___jn (n, x) - Sum1 - Sum2);
-}
-
-
-double  j0 ( double x )         { return ___jn ( 0,&x ); }
-double  j1 ( double x )         { return ___jn ( 1,&x ); }
-double  jn ( int n, double x )  { return ___jn ( n,&x ); }
-double  y0 ( double x )         { return ___yn ( 0,&x ); }
-double  y1 ( double x )         { return ___yn ( 1,&x ); }
-double  yn ( int n, double x )  { return ___yn ( n,&x ); }
-
diff -urN dietlibc-0.30/libm/cosh.c dietlibc-0.30-libm/libm/cosh.c
--- dietlibc-0.30/libm/cosh.c	2001-07-27 20:30:34.000000000 +0000
+++ dietlibc-0.30-libm/libm/cosh.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,9 +0,0 @@
-#include <math.h>
-
-extern const float  __half;
-
-double  cosh ( double x )
-{
-    long double  y = exp (x);
-    return (y + 1./y) * __half;
-}
diff -urN dietlibc-0.30/libm/e_acos.c dietlibc-0.30-libm/libm/e_acos.c
--- dietlibc-0.30/libm/e_acos.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_acos.c	2006-06-25 11:20:05.000000000 +0000
@@ -0,0 +1,111 @@
+/* @(#)e_acos.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: e_acos.c,v 1.9 1995/05/12 04:57:13 jtc Exp $";
+#endif
+
+/* __ieee754_acos(x)
+ * Method :
+ *	acos(x)  = pi/2 - asin(x)
+ *	acos(-x) = pi/2 + asin(x)
+ * For |x|<=0.5
+ *	acos(x) = pi/2 - (x + x*x^2*R(x^2))	(see asin.c)
+ * For x>0.5
+ * 	acos(x) = pi/2 - (pi/2 - 2asin(sqrt((1-x)/2)))
+ *		= 2asin(sqrt((1-x)/2))
+ *		= 2s + 2s*z*R(z) 	...z=(1-x)/2, s=sqrt(z)
+ *		= 2f + (2c + 2s*z*R(z))
+ *     where f=hi part of s, and c = (z-f*f)/(s+f) is the correction term
+ *     for f so that f+c ~ sqrt(z).
+ * For x<-0.5
+ *	acos(x) = pi - 2asin(sqrt((1-|x|)/2))
+ *		= pi - 0.5*(s+s*z*R(z)), where z=(1-|x|)/2,s=sqrt(z)
+ *
+ * Special cases:
+ *	if x is NaN, return x itself;
+ *	if |x|>1, return NaN with invalid signal.
+ *
+ * Function needed: __ieee754_sqrt
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+one=  1.00000000000000000000e+00, /* 0x3FF00000, 0x00000000 */
+pi =  3.14159265358979311600e+00, /* 0x400921FB, 0x54442D18 */
+pio2_hi =  1.57079632679489655800e+00, /* 0x3FF921FB, 0x54442D18 */
+pio2_lo =  6.12323399573676603587e-17, /* 0x3C91A626, 0x33145C07 */
+pS0 =  1.66666666666666657415e-01, /* 0x3FC55555, 0x55555555 */
+pS1 = -3.25565818622400915405e-01, /* 0xBFD4D612, 0x03EB6F7D */
+pS2 =  2.01212532134862925881e-01, /* 0x3FC9C155, 0x0E884455 */
+pS3 = -4.00555345006794114027e-02, /* 0xBFA48228, 0xB5688F3B */
+pS4 =  7.91534994289814532176e-04, /* 0x3F49EFE0, 0x7501B288 */
+pS5 =  3.47933107596021167570e-05, /* 0x3F023DE1, 0x0DFDF709 */
+qS1 = -2.40339491173441421878e+00, /* 0xC0033A27, 0x1C8A2D4B */
+qS2 =  2.02094576023350569471e+00, /* 0x40002AE5, 0x9C598AC8 */
+qS3 = -6.88283971605453293030e-01, /* 0xBFE6066C, 0x1B8D0159 */
+qS4 =  7.70381505559019352791e-02; /* 0x3FB3B8C5, 0xB12E9282 */
+
+#ifdef __STDC__
+	double __ieee754_acos(double x)
+#else
+	double __ieee754_acos(x)
+	double x;
+#endif
+{
+	double z,p,q,r,w,s,c,df;
+	int32_t hx,ix;
+	GET_HIGH_WORD(hx,x);
+	ix = hx&0x7fffffff;
+	if(ix>=0x3ff00000) {	/* |x| >= 1 */
+	    u_int32_t lx;
+	    GET_LOW_WORD(lx,x);
+	    if(((ix-0x3ff00000)|lx)==0) {	/* |x|==1 */
+		if(hx>0) return 0.0;		/* acos(1) = 0  */
+		else return pi+2.0*pio2_lo;	/* acos(-1)= pi */
+	    }
+	    return (x-x)/(x-x);		/* acos(|x|>1) is NaN */
+	}
+	if(ix<0x3fe00000) {	/* |x| < 0.5 */
+	    if(ix<=0x3c600000) return pio2_hi+pio2_lo;/*if|x|<2**-57*/
+	    z = x*x;
+	    p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));
+	    q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));
+	    r = p/q;
+	    return pio2_hi - (x - (pio2_lo-x*r));
+	} else  if (hx<0) {		/* x < -0.5 */
+	    z = (one+x)*0.5;
+	    p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));
+	    q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));
+	    s = __ieee754_sqrt(z);
+	    r = p/q;
+	    w = r*s-pio2_lo;
+	    return pi - 2.0*(s+w);
+	} else {			/* x > 0.5 */
+	    z = (one-x)*0.5;
+	    s = __ieee754_sqrt(z);
+	    df = s;
+	    SET_LOW_WORD(df,0);
+	    c  = (z-df*df)/(s+df);
+	    p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));
+	    q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));
+	    r = p/q;
+	    w = r*s+c;
+	    return 2.0*(df+w);
+	}
+}
diff -urN dietlibc-0.30/libm/e_acosh.c dietlibc-0.30-libm/libm/e_acosh.c
--- dietlibc-0.30/libm/e_acosh.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_acosh.c	2006-06-25 11:20:21.000000000 +0000
@@ -0,0 +1,69 @@
+/* @(#)e_acosh.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: e_acosh.c,v 1.9 1995/05/12 04:57:18 jtc Exp $";
+#endif
+
+/* __ieee754_acosh(x)
+ * Method :
+ *	Based on
+ *		acosh(x) = log [ x + sqrt(x*x-1) ]
+ *	we have
+ *		acosh(x) := log(x)+ln2,	if x is large; else
+ *		acosh(x) := log(2x-1/(sqrt(x*x-1)+x)) if x>2; else
+ *		acosh(x) := log1p(t+sqrt(2.0*t+t*t)); where t=x-1.
+ *
+ * Special cases:
+ *	acosh(x) is NaN with signal if x<1.
+ *	acosh(NaN) is NaN without signal.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+one	= 1.0,
+ln2	= 6.93147180559945286227e-01;  /* 0x3FE62E42, 0xFEFA39EF */
+
+#ifdef __STDC__
+	double __ieee754_acosh(double x)
+#else
+	double __ieee754_acosh(x)
+	double x;
+#endif
+{
+	double t;
+	int32_t hx;
+	u_int32_t lx;
+	EXTRACT_WORDS(hx,lx,x);
+	if(hx<0x3ff00000) {		/* x < 1 */
+	    return (x-x)/(x-x);
+	} else if(hx >=0x41b00000) {	/* x > 2**28 */
+	    if(hx >=0x7ff00000) {	/* x is inf of NaN */
+	        return x+x;
+	    } else
+		return __ieee754_log(x)+ln2;	/* acosh(huge)=log(2x) */
+	} else if(((hx-0x3ff00000)|lx)==0) {
+	    return 0.0;			/* acosh(1) = 0 */
+	} else if (hx > 0x40000000) {	/* 2**28 > x > 2 */
+	    t=x*x;
+	    return __ieee754_log(2.0*x-one/(x+__ieee754_sqrt(t-one)));
+	} else {			/* 1<x<2 */
+	    t = x-one;
+	    return log1p(t+sqrt(2.0*t+t*t));
+	}
+}
diff -urN dietlibc-0.30/libm/e_asin.c dietlibc-0.30-libm/libm/e_asin.c
--- dietlibc-0.30/libm/e_asin.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_asin.c	2006-06-25 11:20:06.000000000 +0000
@@ -0,0 +1,121 @@
+/* @(#)e_asin.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: e_asin.c,v 1.9 1995/05/12 04:57:22 jtc Exp $";
+#endif
+
+/* __ieee754_asin(x)
+ * Method :
+ *	Since  asin(x) = x + x^3/6 + x^5*3/40 + x^7*15/336 + ...
+ *	we approximate asin(x) on [0,0.5] by
+ *		asin(x) = x + x*x^2*R(x^2)
+ *	where
+ *		R(x^2) is a rational approximation of (asin(x)-x)/x^3
+ *	and its remez error is bounded by
+ *		|(asin(x)-x)/x^3 - R(x^2)| < 2^(-58.75)
+ *
+ *	For x in [0.5,1]
+ *		asin(x) = pi/2-2*asin(sqrt((1-x)/2))
+ *	Let y = (1-x), z = y/2, s := sqrt(z), and pio2_hi+pio2_lo=pi/2;
+ *	then for x>0.98
+ *		asin(x) = pi/2 - 2*(s+s*z*R(z))
+ *			= pio2_hi - (2*(s+s*z*R(z)) - pio2_lo)
+ *	For x<=0.98, let pio4_hi = pio2_hi/2, then
+ *		f = hi part of s;
+ *		c = sqrt(z) - f = (z-f*f)/(s+f) 	...f+c=sqrt(z)
+ *	and
+ *		asin(x) = pi/2 - 2*(s+s*z*R(z))
+ *			= pio4_hi+(pio4-2s)-(2s*z*R(z)-pio2_lo)
+ *			= pio4_hi+(pio4-2f)-(2s*z*R(z)-(pio2_lo+2c))
+ *
+ * Special cases:
+ *	if x is NaN, return x itself;
+ *	if |x|>1, return NaN with invalid signal.
+ *
+ */
+
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+one =  1.00000000000000000000e+00, /* 0x3FF00000, 0x00000000 */
+huge =  1.000e+300,
+pio2_hi =  1.57079632679489655800e+00, /* 0x3FF921FB, 0x54442D18 */
+pio2_lo =  6.12323399573676603587e-17, /* 0x3C91A626, 0x33145C07 */
+pio4_hi =  7.85398163397448278999e-01, /* 0x3FE921FB, 0x54442D18 */
+	/* coefficient for R(x^2) */
+pS0 =  1.66666666666666657415e-01, /* 0x3FC55555, 0x55555555 */
+pS1 = -3.25565818622400915405e-01, /* 0xBFD4D612, 0x03EB6F7D */
+pS2 =  2.01212532134862925881e-01, /* 0x3FC9C155, 0x0E884455 */
+pS3 = -4.00555345006794114027e-02, /* 0xBFA48228, 0xB5688F3B */
+pS4 =  7.91534994289814532176e-04, /* 0x3F49EFE0, 0x7501B288 */
+pS5 =  3.47933107596021167570e-05, /* 0x3F023DE1, 0x0DFDF709 */
+qS1 = -2.40339491173441421878e+00, /* 0xC0033A27, 0x1C8A2D4B */
+qS2 =  2.02094576023350569471e+00, /* 0x40002AE5, 0x9C598AC8 */
+qS3 = -6.88283971605453293030e-01, /* 0xBFE6066C, 0x1B8D0159 */
+qS4 =  7.70381505559019352791e-02; /* 0x3FB3B8C5, 0xB12E9282 */
+
+#ifdef __STDC__
+	double __ieee754_asin(double x)
+#else
+	double __ieee754_asin(x)
+	double x;
+#endif
+{
+	double t=0.0,w,p,q,c,r,s;
+	int32_t hx,ix;
+	GET_HIGH_WORD(hx,x);
+	ix = hx&0x7fffffff;
+	if(ix>= 0x3ff00000) {		/* |x|>= 1 */
+	    u_int32_t lx;
+	    GET_LOW_WORD(lx,x);
+	    if(((ix-0x3ff00000)|lx)==0)
+		    /* asin(1)=+-pi/2 with inexact */
+		return x*pio2_hi+x*pio2_lo;
+	    return (x-x)/(x-x);		/* asin(|x|>1) is NaN */
+	} else if (ix<0x3fe00000) {	/* |x|<0.5 */
+	    if(ix<0x3e400000) {		/* if |x| < 2**-27 */
+		if(huge+x>one) return x;/* return x with inexact if x!=0*/
+	    } else {
+		t = x*x;
+		p = t*(pS0+t*(pS1+t*(pS2+t*(pS3+t*(pS4+t*pS5)))));
+		q = one+t*(qS1+t*(qS2+t*(qS3+t*qS4)));
+		w = p/q;
+		return x+x*w;
+	    }
+	}
+	/* 1> |x|>= 0.5 */
+	w = one-fabs(x);
+	t = w*0.5;
+	p = t*(pS0+t*(pS1+t*(pS2+t*(pS3+t*(pS4+t*pS5)))));
+	q = one+t*(qS1+t*(qS2+t*(qS3+t*qS4)));
+	s = __ieee754_sqrt(t);
+	if(ix>=0x3FEF3333) { 	/* if |x| > 0.975 */
+	    w = p/q;
+	    t = pio2_hi-(2.0*(s+s*w)-pio2_lo);
+	} else {
+	    w  = s;
+	    SET_LOW_WORD(w,0);
+	    c  = (t-w*w)/(s+w);
+	    r  = p/q;
+	    p  = 2.0*s*r-(pio2_lo-2.0*c);
+	    q  = pio4_hi-2.0*w;
+	    t  = pio4_hi-(p-q);
+	}
+	if(hx>0) return t; else return -t;
+}
diff -urN dietlibc-0.30/libm/e_atan2.c dietlibc-0.30-libm/libm/e_atan2.c
--- dietlibc-0.30/libm/e_atan2.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_atan2.c	2006-06-25 11:20:24.000000000 +0000
@@ -0,0 +1,130 @@
+/* @(#)e_atan2.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: e_atan2.c,v 1.8 1995/05/10 20:44:51 jtc Exp $";
+#endif
+
+/* __ieee754_atan2(y,x)
+ * Method :
+ *	1. Reduce y to positive by atan2(y,x)=-atan2(-y,x).
+ *	2. Reduce x to positive by (if x and y are unexceptional):
+ *		ARG (x+iy) = arctan(y/x)   	   ... if x > 0,
+ *		ARG (x+iy) = pi - arctan[y/(-x)]   ... if x < 0,
+ *
+ * Special cases:
+ *
+ *	ATAN2((anything), NaN ) is NaN;
+ *	ATAN2(NAN , (anything) ) is NaN;
+ *	ATAN2(+-0, +(anything but NaN)) is +-0  ;
+ *	ATAN2(+-0, -(anything but NaN)) is +-pi ;
+ *	ATAN2(+-(anything but 0 and NaN), 0) is +-pi/2;
+ *	ATAN2(+-(anything but INF and NaN), +INF) is +-0 ;
+ *	ATAN2(+-(anything but INF and NaN), -INF) is +-pi;
+ *	ATAN2(+-INF,+INF ) is +-pi/4 ;
+ *	ATAN2(+-INF,-INF ) is +-3pi/4;
+ *	ATAN2(+-INF, (anything but,0,NaN, and INF)) is +-pi/2;
+ *
+ * Constants:
+ * The hexadecimal values are the intended ones for the following
+ * constants. The decimal values may be used, provided that the
+ * compiler will convert from decimal to binary accurately enough
+ * to produce the hexadecimal values shown.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+tiny  = 1.0e-300,
+zero  = 0.0,
+pi_o_4  = 7.8539816339744827900E-01, /* 0x3FE921FB, 0x54442D18 */
+pi_o_2  = 1.5707963267948965580E+00, /* 0x3FF921FB, 0x54442D18 */
+pi      = 3.1415926535897931160E+00, /* 0x400921FB, 0x54442D18 */
+pi_lo   = 1.2246467991473531772E-16; /* 0x3CA1A626, 0x33145C07 */
+
+#ifdef __STDC__
+	double __ieee754_atan2(double y, double x)
+#else
+	double __ieee754_atan2(y,x)
+	double  y,x;
+#endif
+{
+	double z;
+	int32_t k,m,hx,hy,ix,iy;
+	u_int32_t lx,ly;
+
+	EXTRACT_WORDS(hx,lx,x);
+	ix = hx&0x7fffffff;
+	EXTRACT_WORDS(hy,ly,y);
+	iy = hy&0x7fffffff;
+	if(((ix|((lx|-lx)>>31))>0x7ff00000)||
+	   ((iy|((ly|-ly)>>31))>0x7ff00000))	/* x or y is NaN */
+	   return x+y;
+	if(((hx-0x3ff00000)|lx)==0) return atan(y);   /* x=1.0 */
+	m = ((hy>>31)&1)|((hx>>30)&2);	/* 2*sign(x)+sign(y) */
+
+    /* when y = 0 */
+	if((iy|ly)==0) {
+	    switch(m) {
+		case 0:
+		case 1: return y; 	/* atan(+-0,+anything)=+-0 */
+		case 2: return  pi+tiny;/* atan(+0,-anything) = pi */
+		case 3: return -pi-tiny;/* atan(-0,-anything) =-pi */
+	    }
+	}
+    /* when x = 0 */
+	if((ix|lx)==0) return (hy<0)?  -pi_o_2-tiny: pi_o_2+tiny;
+
+    /* when x is INF */
+	if(ix==0x7ff00000) {
+	    if(iy==0x7ff00000) {
+		switch(m) {
+		    case 0: return  pi_o_4+tiny;/* atan(+INF,+INF) */
+		    case 1: return -pi_o_4-tiny;/* atan(-INF,+INF) */
+		    case 2: return  3.0*pi_o_4+tiny;/*atan(+INF,-INF)*/
+		    case 3: return -3.0*pi_o_4-tiny;/*atan(-INF,-INF)*/
+		}
+	    } else {
+		switch(m) {
+		    case 0: return  zero  ;	/* atan(+...,+INF) */
+		    case 1: return -zero  ;	/* atan(-...,+INF) */
+		    case 2: return  pi+tiny  ;	/* atan(+...,-INF) */
+		    case 3: return -pi-tiny  ;	/* atan(-...,-INF) */
+		}
+	    }
+	}
+    /* when y is INF */
+	if(iy==0x7ff00000) return (hy<0)? -pi_o_2-tiny: pi_o_2+tiny;
+
+    /* compute y/x */
+	k = (iy-ix)>>20;
+	if(k > 60) z=pi_o_2+0.5*pi_lo; 	/* |y/x| >  2**60 */
+	else if(hx<0&&k<-60) z=0.0; 	/* |y|/x < -2**60 */
+	else z=atan(fabs(y/x));		/* safe to do y/x */
+	switch (m) {
+	    case 0: return       z  ;	/* atan(+,+) */
+	    case 1: {
+	    	      u_int32_t zh;
+		      GET_HIGH_WORD(zh,z);
+		      SET_HIGH_WORD(z,zh ^ 0x80000000);
+		    }
+		    return       z  ;	/* atan(-,+) */
+	    case 2: return  pi-(z-pi_lo);/* atan(+,-) */
+	    default: /* case 3 */
+	    	    return  (z-pi_lo)-pi;/* atan(-,-) */
+	}
+}
diff -urN dietlibc-0.30/libm/e_atanh.c dietlibc-0.30-libm/libm/e_atanh.c
--- dietlibc-0.30/libm/e_atanh.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_atanh.c	2006-06-25 11:20:24.000000000 +0000
@@ -0,0 +1,74 @@
+/* @(#)e_atanh.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: e_atanh.c,v 1.8 1995/05/10 20:44:55 jtc Exp $";
+#endif
+
+/* __ieee754_atanh(x)
+ * Method :
+ *    1.Reduced x to positive by atanh(-x) = -atanh(x)
+ *    2.For x>=0.5
+ *                  1              2x                          x
+ *	atanh(x) = --- * log(1 + -------) = 0.5 * log1p(2 * --------)
+ *                  2             1 - x                      1 - x
+ *
+ * 	For x<0.5
+ *	atanh(x) = 0.5*log1p(2x+2x*x/(1-x))
+ *
+ * Special cases:
+ *	atanh(x) is NaN if |x| > 1 with signal;
+ *	atanh(NaN) is that NaN with no signal;
+ *	atanh(+-1) is +-INF with signal.
+ *
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double one = 1.0, huge = 1e300;
+#else
+static double one = 1.0, huge = 1e300;
+#endif
+
+#ifdef __STDC__
+static const double zero = 0.0;
+#else
+static double zero = 0.0;
+#endif
+
+#ifdef __STDC__
+	double __ieee754_atanh(double x)
+#else
+	double __ieee754_atanh(x)
+	double x;
+#endif
+{
+	double t;
+	int32_t hx,ix;
+	u_int32_t lx;
+	EXTRACT_WORDS(hx,lx,x);
+	ix = hx&0x7fffffff;
+	if ((ix|((lx|(-lx))>>31))>0x3ff00000) /* |x|>1 */
+	    return (x-x)/(x-x);
+	if(ix==0x3ff00000)
+	    return x/zero;
+	if(ix<0x3e300000&&(huge+x)>zero) return x;	/* x<2**-28 */
+	SET_HIGH_WORD(x,ix);
+	if(ix<0x3fe00000) {		/* x < 0.5 */
+	    t = x+x;
+	    t = 0.5*log1p(t+t*x/(one-x));
+	} else
+	    t = 0.5*log1p((x+x)/(one-x));
+	if(hx>=0) return t; else return -t;
+}
diff -urN dietlibc-0.30/libm/e_cosh.c dietlibc-0.30-libm/libm/e_cosh.c
--- dietlibc-0.30/libm/e_cosh.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_cosh.c	2006-06-25 11:20:06.000000000 +0000
@@ -0,0 +1,93 @@
+/* @(#)e_cosh.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: e_cosh.c,v 1.7 1995/05/10 20:44:58 jtc Exp $";
+#endif
+
+/* __ieee754_cosh(x)
+ * Method :
+ * mathematically cosh(x) if defined to be (exp(x)+exp(-x))/2
+ *	1. Replace x by |x| (cosh(x) = cosh(-x)).
+ *	2.
+ *		                                        [ exp(x) - 1 ]^2
+ *	    0        <= x <= ln2/2  :  cosh(x) := 1 + -------------------
+ *			       			           2*exp(x)
+ *
+ *		                                  exp(x) +  1/exp(x)
+ *	    ln2/2    <= x <= 22     :  cosh(x) := -------------------
+ *			       			          2
+ *	    22       <= x <= lnovft :  cosh(x) := exp(x)/2
+ *	    lnovft   <= x <= ln2ovft:  cosh(x) := exp(x/2)/2 * exp(x/2)
+ *	    ln2ovft  <  x	    :  cosh(x) := huge*huge (overflow)
+ *
+ * Special cases:
+ *	cosh(x) is |x| if x is +INF, -INF, or NaN.
+ *	only cosh(0)=1 is exact for finite x.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double one = 1.0, half=0.5, huge = 1.0e300;
+#else
+static double one = 1.0, half=0.5, huge = 1.0e300;
+#endif
+
+#ifdef __STDC__
+	double __ieee754_cosh(double x)
+#else
+	double __ieee754_cosh(x)
+	double x;
+#endif
+{
+	double t,w;
+	int32_t ix;
+	u_int32_t lx;
+
+    /* High word of |x|. */
+	GET_HIGH_WORD(ix,x);
+	ix &= 0x7fffffff;
+
+    /* x is INF or NaN */
+	if(ix>=0x7ff00000) return x*x;
+
+    /* |x| in [0,0.5*ln2], return 1+expm1(|x|)^2/(2*exp(|x|)) */
+	if(ix<0x3fd62e43) {
+	    t = expm1(fabs(x));
+	    w = one+t;
+	    if (ix<0x3c800000) return w;	/* cosh(tiny) = 1 */
+	    return one+(t*t)/(w+w);
+	}
+
+    /* |x| in [0.5*ln2,22], return (exp(|x|)+1/exp(|x|)/2; */
+	if (ix < 0x40360000) {
+		t = __ieee754_exp(fabs(x));
+		return half*t+half/t;
+	}
+
+    /* |x| in [22, log(maxdouble)] return half*exp(|x|) */
+	if (ix < 0x40862E42)  return half*__ieee754_exp(fabs(x));
+
+    /* |x| in [log(maxdouble), overflowthresold] */
+	GET_LOW_WORD(lx,x);
+	if (ix<0x408633CE ||
+	      ((ix==0x408633ce)&&(lx<=(u_int32_t)0x8fb9f87d))) {
+	    w = __ieee754_exp(half*fabs(x));
+	    t = half*w;
+	    return t*w;
+	}
+
+    /* |x| > overflowthresold, cosh(x) overflow */
+	return huge*huge;
+}
diff -urN dietlibc-0.30/libm/e_exp.c dietlibc-0.30-libm/libm/e_exp.c
--- dietlibc-0.30/libm/e_exp.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_exp.c	2006-06-25 11:20:01.000000000 +0000
@@ -0,0 +1,172 @@
+/* @(#)e_exp.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: e_exp.c,v 1.8 1995/05/10 20:45:03 jtc Exp $";
+#endif
+
+/* __ieee754_exp(x)
+ * Returns the exponential of x.
+ *
+ * Method
+ *   1. Argument reduction:
+ *      Reduce x to an r so that |r| <= 0.5*ln2 ~ 0.34658.
+ *	Given x, find r and integer k such that
+ *
+ *               x = k*ln2 + r,  |r| <= 0.5*ln2.
+ *
+ *      Here r will be represented as r = hi-lo for better
+ *	accuracy.
+ *
+ *   2. Approximation of exp(r) by a special rational function on
+ *	the interval [0,0.34658]:
+ *	Write
+ *	    R(r**2) = r*(exp(r)+1)/(exp(r)-1) = 2 + r*r/6 - r**4/360 + ...
+ *      We use a special Reme algorithm on [0,0.34658] to generate
+ * 	a polynomial of degree 5 to approximate R. The maximum error
+ *	of this polynomial approximation is bounded by 2**-59. In
+ *	other words,
+ *	    R(z) ~ 2.0 + P1*z + P2*z**2 + P3*z**3 + P4*z**4 + P5*z**5
+ *  	(where z=r*r, and the values of P1 to P5 are listed below)
+ *	and
+ *	    |                  5          |     -59
+ *	    | 2.0+P1*z+...+P5*z   -  R(z) | <= 2
+ *	    |                             |
+ *	The computation of exp(r) thus becomes
+ *                             2*r
+ *		exp(r) = 1 + -------
+ *		              R - r
+ *                                 r*R1(r)
+ *		       = 1 + r + ----------- (for better accuracy)
+ *		                  2 - R1(r)
+ *	where
+ *			         2       4             10
+ *		R1(r) = r - (P1*r  + P2*r  + ... + P5*r   ).
+ *
+ *   3. Scale back to obtain exp(x):
+ *	From step 1, we have
+ *	   exp(x) = 2^k * exp(r)
+ *
+ * Special cases:
+ *	exp(INF) is INF, exp(NaN) is NaN;
+ *	exp(-INF) is 0, and
+ *	for finite argument, only exp(0)=1 is exact.
+ *
+ * Accuracy:
+ *	according to an error analysis, the error is always less than
+ *	1 ulp (unit in the last place).
+ *
+ * Misc. info.
+ *	For IEEE double
+ *	    if x >  7.09782712893383973096e+02 then exp(x) overflow
+ *	    if x < -7.45133219101941108420e+02 then exp(x) underflow
+ *
+ * Constants:
+ * The hexadecimal values are the intended ones for the following
+ * constants. The decimal values may be used, provided that the
+ * compiler will convert from decimal to binary accurately enough
+ * to produce the hexadecimal values shown.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+one	= 1.0,
+halF[2]	= {0.5,-0.5,},
+huge	= 1.0e+300,
+twom1000= 9.33263618503218878990e-302,     /* 2**-1000=0x01700000,0*/
+o_threshold=  7.09782712893383973096e+02,  /* 0x40862E42, 0xFEFA39EF */
+u_threshold= -7.45133219101941108420e+02,  /* 0xc0874910, 0xD52D3051 */
+ln2HI[2]   ={ 6.93147180369123816490e-01,  /* 0x3fe62e42, 0xfee00000 */
+	     -6.93147180369123816490e-01,},/* 0xbfe62e42, 0xfee00000 */
+ln2LO[2]   ={ 1.90821492927058770002e-10,  /* 0x3dea39ef, 0x35793c76 */
+	     -1.90821492927058770002e-10,},/* 0xbdea39ef, 0x35793c76 */
+invln2 =  1.44269504088896338700e+00, /* 0x3ff71547, 0x652b82fe */
+P1   =  1.66666666666666019037e-01, /* 0x3FC55555, 0x5555553E */
+P2   = -2.77777777770155933842e-03, /* 0xBF66C16C, 0x16BEBD93 */
+P3   =  6.61375632143793436117e-05, /* 0x3F11566A, 0xAF25DE2C */
+P4   = -1.65339022054652515390e-06, /* 0xBEBBBD41, 0xC5D26BF1 */
+P5   =  4.13813679705723846039e-08; /* 0x3E663769, 0x72BEA4D0 */
+
+
+#ifdef __STDC__
+	double __ieee754_exp(double x)	/* default IEEE double exp */
+#else
+	double __ieee754_exp(x)	/* default IEEE double exp */
+	double x;
+#endif
+{
+	double y;
+	double hi = 0.0;
+	double lo = 0.0;
+	double c;
+	double t;
+	int32_t k=0;
+	int32_t xsb;
+	u_int32_t hx;
+
+	GET_HIGH_WORD(hx,x);
+	xsb = (hx>>31)&1;		/* sign bit of x */
+	hx &= 0x7fffffff;		/* high word of |x| */
+
+    /* filter out non-finite argument */
+	if(hx >= 0x40862E42) {			/* if |x|>=709.78... */
+            if(hx>=0x7ff00000) {
+	        u_int32_t lx;
+		GET_LOW_WORD(lx,x);
+		if(((hx&0xfffff)|lx)!=0)
+		     return x+x; 		/* NaN */
+		else return (xsb==0)? x:0.0;	/* exp(+-inf)={inf,0} */
+	    }
+	    if(x > o_threshold) return huge*huge; /* overflow */
+	    if(x < u_threshold) return twom1000*twom1000; /* underflow */
+	}
+
+    /* argument reduction */
+	if(hx > 0x3fd62e42) {		/* if  |x| > 0.5 ln2 */
+	    if(hx < 0x3FF0A2B2) {	/* and |x| < 1.5 ln2 */
+		hi = x-ln2HI[xsb]; lo=ln2LO[xsb]; k = 1-xsb-xsb;
+	    } else {
+		k  = invln2*x+halF[xsb];
+		t  = k;
+		hi = x - t*ln2HI[0];	/* t*ln2HI is exact here */
+		lo = t*ln2LO[0];
+	    }
+	    x  = hi - lo;
+	}
+	else if(hx < 0x3e300000)  {	/* when |x|<2**-28 */
+	    if(huge+x>one) return one+x;/* trigger inexact */
+	}
+	else k = 0;
+
+    /* x is now in primary range */
+	t  = x*x;
+	c  = x - t*(P1+t*(P2+t*(P3+t*(P4+t*P5))));
+	if(k==0) 	return one-((x*c)/(c-2.0)-x);
+	else 		y = one-((lo-(x*c)/(2.0-c))-hi);
+	if(k >= -1021) {
+	    u_int32_t hy;
+	    GET_HIGH_WORD(hy,y);
+	    SET_HIGH_WORD(y,hy+(k<<20));	/* add k to y's exponent */
+	    return y;
+	} else {
+	    u_int32_t hy;
+	    GET_HIGH_WORD(hy,y);
+	    SET_HIGH_WORD(y,hy+((k+1000)<<20));	/* add k to y's exponent */
+	    return y*twom1000;
+	}
+}
diff -urN dietlibc-0.30/libm/e_fmod.c dietlibc-0.30-libm/libm/e_fmod.c
--- dietlibc-0.30/libm/e_fmod.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_fmod.c	2006-06-25 11:20:07.000000000 +0000
@@ -0,0 +1,140 @@
+/* @(#)e_fmod.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: e_fmod.c,v 1.8 1995/05/10 20:45:07 jtc Exp $";
+#endif
+
+/*
+ * __ieee754_fmod(x,y)
+ * Return x mod y in exact arithmetic
+ * Method: shift and subtract
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double one = 1.0, Zero[] = {0.0, -0.0,};
+#else
+static double one = 1.0, Zero[] = {0.0, -0.0,};
+#endif
+
+#ifdef __STDC__
+	double __ieee754_fmod(double x, double y)
+#else
+	double __ieee754_fmod(x,y)
+	double x,y ;
+#endif
+{
+	int32_t n,hx,hy,hz,ix,iy,sx,i;
+	u_int32_t lx,ly,lz;
+
+	EXTRACT_WORDS(hx,lx,x);
+	EXTRACT_WORDS(hy,ly,y);
+	sx = hx&0x80000000;		/* sign of x */
+	hx ^=sx;		/* |x| */
+	hy &= 0x7fffffff;	/* |y| */
+
+    /* purge off exception values */
+	if((hy|ly)==0||(hx>=0x7ff00000)||	/* y=0,or x not finite */
+	  ((hy|((ly|-ly)>>31))>0x7ff00000))	/* or y is NaN */
+	    return (x*y)/(x*y);
+	if(hx<=hy) {
+	    if((hx<hy)||(lx<ly)) return x;	/* |x|<|y| return x */
+	    if(lx==ly)
+		return Zero[(u_int32_t)sx>>31];	/* |x|=|y| return x*0*/
+	}
+
+    /* determine ix = ilogb(x) */
+	if(hx<0x00100000) {	/* subnormal x */
+	    if(hx==0) {
+		for (ix = -1043, i=lx; i>0; i<<=1) ix -=1;
+	    } else {
+		for (ix = -1022,i=(hx<<11); i>0; i<<=1) ix -=1;
+	    }
+	} else ix = (hx>>20)-1023;
+
+    /* determine iy = ilogb(y) */
+	if(hy<0x00100000) {	/* subnormal y */
+	    if(hy==0) {
+		for (iy = -1043, i=ly; i>0; i<<=1) iy -=1;
+	    } else {
+		for (iy = -1022,i=(hy<<11); i>0; i<<=1) iy -=1;
+	    }
+	} else iy = (hy>>20)-1023;
+
+    /* set up {hx,lx}, {hy,ly} and align y to x */
+	if(ix >= -1022)
+	    hx = 0x00100000|(0x000fffff&hx);
+	else {		/* subnormal x, shift x to normal */
+	    n = -1022-ix;
+	    if(n<=31) {
+	        hx = (hx<<n)|(lx>>(32-n));
+	        lx <<= n;
+	    } else {
+		hx = lx<<(n-32);
+		lx = 0;
+	    }
+	}
+	if(iy >= -1022)
+	    hy = 0x00100000|(0x000fffff&hy);
+	else {		/* subnormal y, shift y to normal */
+	    n = -1022-iy;
+	    if(n<=31) {
+	        hy = (hy<<n)|(ly>>(32-n));
+	        ly <<= n;
+	    } else {
+		hy = ly<<(n-32);
+		ly = 0;
+	    }
+	}
+
+    /* fix point fmod */
+	n = ix - iy;
+	while(n--) {
+	    hz=hx-hy;lz=lx-ly; if(lx<ly) hz -= 1;
+	    if(hz<0){hx = hx+hx+(lx>>31); lx = lx+lx;}
+	    else {
+	    	if((hz|lz)==0) 		/* return sign(x)*0 */
+		    return Zero[(u_int32_t)sx>>31];
+	    	hx = hz+hz+(lz>>31); lx = lz+lz;
+	    }
+	}
+	hz=hx-hy;lz=lx-ly; if(lx<ly) hz -= 1;
+	if(hz>=0) {hx=hz;lx=lz;}
+
+    /* convert back to floating value and restore the sign */
+	if((hx|lx)==0) 			/* return sign(x)*0 */
+	    return Zero[(u_int32_t)sx>>31];
+	while(hx<0x00100000) {		/* normalize x */
+	    hx = hx+hx+(lx>>31); lx = lx+lx;
+	    iy -= 1;
+	}
+	if(iy>= -1022) {	/* normalize output */
+	    hx = ((hx-0x00100000)|((iy+1023)<<20));
+	    INSERT_WORDS(x,hx|sx,lx);
+	} else {		/* subnormal output */
+	    n = -1022 - iy;
+	    if(n<=20) {
+		lx = (lx>>n)|((u_int32_t)hx<<(32-n));
+		hx >>= n;
+	    } else if (n<=31) {
+		lx = (hx<<(32-n))|(lx>>n); hx = sx;
+	    } else {
+		lx = hx>>(n-32); hx = sx;
+	    }
+	    INSERT_WORDS(x,hx|sx,lx);
+	    x *= one;		/* create necessary signal */
+	}
+	return x;		/* exact output */
+}
diff -urN dietlibc-0.30/libm/e_gamma.c dietlibc-0.30-libm/libm/e_gamma.c
--- dietlibc-0.30/libm/e_gamma.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_gamma.c	2006-06-25 11:20:16.000000000 +0000
@@ -0,0 +1,34 @@
+
+/* @(#)e_gamma.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ *
+ */
+
+/* __ieee754_gamma(x)
+ * Return the logarithm of the Gamma function of x.
+ *
+ * Method: call __ieee754_gamma_r
+ */
+
+#include "math_private.h"
+
+extern int signgam;
+
+#ifdef __STDC__
+	//__private_extern__
+	double __ieee754_gamma(double x)
+#else
+	double __ieee754_gamma(x)
+	double x;
+#endif
+{
+	return __ieee754_gamma_r(x,&signgam);
+}
diff -urN dietlibc-0.30/libm/e_gamma_r.c dietlibc-0.30-libm/libm/e_gamma_r.c
--- dietlibc-0.30/libm/e_gamma_r.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_gamma_r.c	2006-06-25 11:20:20.000000000 +0000
@@ -0,0 +1,33 @@
+
+/* @(#)e_gamma_r.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ *
+ */
+
+/* __ieee754_gamma_r(x, signgamp)
+ * Reentrant version of the logarithm of the Gamma function
+ * with user provide pointer for the sign of Gamma(x).
+ *
+ * Method: See __ieee754_lgamma_r
+ */
+
+#include "math_private.h"
+
+#ifdef __STDC__
+	//__private_extern__
+	double __ieee754_gamma_r(double x, int *signgamp)
+#else
+	double __ieee754_gamma_r(x,signgamp)
+	double x; int *signgamp;
+#endif
+{
+	return __ieee754_lgamma_r(x,signgamp);
+}
diff -urN dietlibc-0.30/libm/e_hypot.c dietlibc-0.30-libm/libm/e_hypot.c
--- dietlibc-0.30/libm/e_hypot.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_hypot.c	2006-06-25 11:20:00.000000000 +0000
@@ -0,0 +1,128 @@
+/* @(#)e_hypot.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: e_hypot.c,v 1.9 1995/05/12 04:57:27 jtc Exp $";
+#endif
+
+/* __ieee754_hypot(x,y)
+ *
+ * Method :
+ *	If (assume round-to-nearest) z=x*x+y*y
+ *	has error less than sqrt(2)/2 ulp, than
+ *	sqrt(z) has error less than 1 ulp (exercise).
+ *
+ *	So, compute sqrt(x*x+y*y) with some care as
+ *	follows to get the error below 1 ulp:
+ *
+ *	Assume x>y>0;
+ *	(if possible, set rounding to round-to-nearest)
+ *	1. if x > 2y  use
+ *		x1*x1+(y*y+(x2*(x+x1))) for x*x+y*y
+ *	where x1 = x with lower 32 bits cleared, x2 = x-x1; else
+ *	2. if x <= 2y use
+ *		t1*y1+((x-y)*(x-y)+(t1*y2+t2*y))
+ *	where t1 = 2x with lower 32 bits cleared, t2 = 2x-t1,
+ *	y1= y with lower 32 bits chopped, y2 = y-y1.
+ *
+ *	NOTE: scaling may be necessary if some argument is too
+ *	      large or too tiny
+ *
+ * Special cases:
+ *	hypot(x,y) is INF if x or y is +INF or -INF; else
+ *	hypot(x,y) is NAN if x or y is NAN.
+ *
+ * Accuracy:
+ * 	hypot(x,y) returns sqrt(x^2+y^2) with error less
+ * 	than 1 ulps (units in the last place)
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+	double __ieee754_hypot(double x, double y)
+#else
+	double __ieee754_hypot(x,y)
+	double x, y;
+#endif
+{
+	double a=x,b=y,t1,t2,y1,y2,w;
+	int32_t j,k,ha,hb;
+
+	GET_HIGH_WORD(ha,x);
+	ha &= 0x7fffffff;
+	GET_HIGH_WORD(hb,y);
+	hb &= 0x7fffffff;
+	if(hb > ha) {a=y;b=x;j=ha; ha=hb;hb=j;} else {a=x;b=y;}
+	SET_HIGH_WORD(a,ha);	/* a <- |a| */
+	SET_HIGH_WORD(b,hb);	/* b <- |b| */
+	if((ha-hb)>0x3c00000) {return a+b;} /* x/y > 2**60 */
+	k=0;
+	if(ha > 0x5f300000) {	/* a>2**500 */
+	   if(ha >= 0x7ff00000) {	/* Inf or NaN */
+	       u_int32_t low;
+	       w = a+b;			/* for sNaN */
+	       GET_LOW_WORD(low,a);
+	       if(((ha&0xfffff)|low)==0) w = a;
+	       GET_LOW_WORD(low,b);
+	       if(((hb^0x7ff00000)|low)==0) w = b;
+	       return w;
+	   }
+	   /* scale a and b by 2**-600 */
+	   ha -= 0x25800000; hb -= 0x25800000;	k += 600;
+	   SET_HIGH_WORD(a,ha);
+	   SET_HIGH_WORD(b,hb);
+	}
+	if(hb < 0x20b00000) {	/* b < 2**-500 */
+	    if(hb <= 0x000fffff) {	/* subnormal b or 0 */
+	        u_int32_t low;
+		GET_LOW_WORD(low,b);
+		if((hb|low)==0) return a;
+		t1=0;
+		SET_HIGH_WORD(t1,0x7fd00000);	/* t1=2^1022 */
+		b *= t1;
+		a *= t1;
+		k -= 1022;
+	    } else {		/* scale a and b by 2^600 */
+	        ha += 0x25800000; 	/* a *= 2^600 */
+		hb += 0x25800000;	/* b *= 2^600 */
+		k -= 600;
+		SET_HIGH_WORD(a,ha);
+		SET_HIGH_WORD(b,hb);
+	    }
+	}
+    /* medium size a and b */
+	w = a-b;
+	if (w>b) {
+	    t1 = 0;
+	    SET_HIGH_WORD(t1,ha);
+	    t2 = a-t1;
+	    w  = __ieee754_sqrt(t1*t1-(b*(-b)-t2*(a+t1)));
+	} else {
+	    a  = a+a;
+	    y1 = 0;
+	    SET_HIGH_WORD(y1,hb);
+	    y2 = b - y1;
+	    t1 = 0;
+	    SET_HIGH_WORD(t1,ha+0x00100000);
+	    t2 = a - t1;
+	    w  = __ieee754_sqrt(t1*y1-(w*(-w)-(t1*y2+t2*b)));
+	}
+	if(k!=0) {
+	    u_int32_t high;
+	    t1 = 1.0;
+	    GET_HIGH_WORD(high,t1);
+	    SET_HIGH_WORD(t1,high+(k<<20));
+	    return t1*w;
+	} else return w;
+}
diff -urN dietlibc-0.30/libm/e_j0.c dietlibc-0.30-libm/libm/e_j0.c
--- dietlibc-0.30/libm/e_j0.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_j0.c	2006-06-25 11:20:13.000000000 +0000
@@ -0,0 +1,487 @@
+/* @(#)e_j0.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: e_j0.c,v 1.8 1995/05/10 20:45:23 jtc Exp $";
+#endif
+
+/* __ieee754_j0(x), __ieee754_y0(x)
+ * Bessel function of the first and second kinds of order zero.
+ * Method -- j0(x):
+ *	1. For tiny x, we use j0(x) = 1 - x^2/4 + x^4/64 - ...
+ *	2. Reduce x to |x| since j0(x)=j0(-x),  and
+ *	   for x in (0,2)
+ *		j0(x) = 1-z/4+ z^2*R0/S0,  where z = x*x;
+ *	   (precision:  |j0-1+z/4-z^2R0/S0 |<2**-63.67 )
+ *	   for x in (2,inf)
+ * 		j0(x) = sqrt(2/(pi*x))*(p0(x)*cos(x0)-q0(x)*sin(x0))
+ * 	   where x0 = x-pi/4. It is better to compute sin(x0),cos(x0)
+ *	   as follow:
+ *		cos(x0) = cos(x)cos(pi/4)+sin(x)sin(pi/4)
+ *			= 1/sqrt(2) * (cos(x) + sin(x))
+ *		sin(x0) = sin(x)cos(pi/4)-cos(x)sin(pi/4)
+ *			= 1/sqrt(2) * (sin(x) - cos(x))
+ * 	   (To avoid cancellation, use
+ *		sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
+ * 	    to compute the worse one.)
+ *
+ *	3 Special cases
+ *		j0(nan)= nan
+ *		j0(0) = 1
+ *		j0(inf) = 0
+ *
+ * Method -- y0(x):
+ *	1. For x<2.
+ *	   Since
+ *		y0(x) = 2/pi*(j0(x)*(ln(x/2)+Euler) + x^2/4 - ...)
+ *	   therefore y0(x)-2/pi*j0(x)*ln(x) is an even function.
+ *	   We use the following function to approximate y0,
+ *		y0(x) = U(z)/V(z) + (2/pi)*(j0(x)*ln(x)), z= x^2
+ *	   where
+ *		U(z) = u00 + u01*z + ... + u06*z^6
+ *		V(z) = 1  + v01*z + ... + v04*z^4
+ *	   with absolute approximation error bounded by 2**-72.
+ *	   Note: For tiny x, U/V = u0 and j0(x)~1, hence
+ *		y0(tiny) = u0 + (2/pi)*ln(tiny), (choose tiny<2**-27)
+ *	2. For x>=2.
+ * 		y0(x) = sqrt(2/(pi*x))*(p0(x)*cos(x0)+q0(x)*sin(x0))
+ * 	   where x0 = x-pi/4. It is better to compute sin(x0),cos(x0)
+ *	   by the method mentioned above.
+ *	3. Special cases: y0(0)=-inf, y0(x<0)=NaN, y0(inf)=0.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static double pzero(double), qzero(double);
+#else
+static double pzero(), qzero();
+#endif
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+huge 	= 1e300,
+one	= 1.0,
+invsqrtpi=  5.64189583547756279280e-01, /* 0x3FE20DD7, 0x50429B6D */
+tpi      =  6.36619772367581382433e-01, /* 0x3FE45F30, 0x6DC9C883 */
+ 		/* R0/S0 on [0, 2.00] */
+R02  =  1.56249999999999947958e-02, /* 0x3F8FFFFF, 0xFFFFFFFD */
+R03  = -1.89979294238854721751e-04, /* 0xBF28E6A5, 0xB61AC6E9 */
+R04  =  1.82954049532700665670e-06, /* 0x3EBEB1D1, 0x0C503919 */
+R05  = -4.61832688532103189199e-09, /* 0xBE33D5E7, 0x73D63FCE */
+S01  =  1.56191029464890010492e-02, /* 0x3F8FFCE8, 0x82C8C2A4 */
+S02  =  1.16926784663337450260e-04, /* 0x3F1EA6D2, 0xDD57DBF4 */
+S03  =  5.13546550207318111446e-07, /* 0x3EA13B54, 0xCE84D5A9 */
+S04  =  1.16614003333790000205e-09; /* 0x3E1408BC, 0xF4745D8F */
+
+#ifdef __STDC__
+static const double zero = 0.0;
+#else
+static double zero = 0.0;
+#endif
+
+#ifdef __STDC__
+	double __ieee754_j0(double x)
+#else
+	double __ieee754_j0(x)
+	double x;
+#endif
+{
+	double z, s,c,ss,cc,r,u,v;
+	int32_t hx,ix;
+
+	GET_HIGH_WORD(hx,x);
+	ix = hx&0x7fffffff;
+	if(ix>=0x7ff00000) return one/(x*x);
+	x = fabs(x);
+	if(ix >= 0x40000000) {	/* |x| >= 2.0 */
+		s = sin(x);
+		c = cos(x);
+		ss = s-c;
+		cc = s+c;
+		if(ix<0x7fe00000) {  /* make sure x+x not overflow */
+		    z = -cos(x+x);
+		    if ((s*c)<zero) cc = z/ss;
+		    else 	    ss = z/cc;
+		}
+	/*
+	 * j0(x) = 1/sqrt(pi) * (P(0,x)*cc - Q(0,x)*ss) / sqrt(x)
+	 * y0(x) = 1/sqrt(pi) * (P(0,x)*ss + Q(0,x)*cc) / sqrt(x)
+	 */
+		if(ix>0x48000000) z = (invsqrtpi*cc)/sqrt(x);
+		else {
+		    u = pzero(x); v = qzero(x);
+		    z = invsqrtpi*(u*cc-v*ss)/sqrt(x);
+		}
+		return z;
+	}
+	if(ix<0x3f200000) {	/* |x| < 2**-13 */
+	    if(huge+x>one) {	/* raise inexact if x != 0 */
+	        if(ix<0x3e400000) return one;	/* |x|<2**-27 */
+	        else 	      return one - 0.25*x*x;
+	    }
+	}
+	z = x*x;
+	r =  z*(R02+z*(R03+z*(R04+z*R05)));
+	s =  one+z*(S01+z*(S02+z*(S03+z*S04)));
+	if(ix < 0x3FF00000) {	/* |x| < 1.00 */
+	    return one + z*(-0.25+(r/s));
+	} else {
+	    u = 0.5*x;
+	    return((one+u)*(one-u)+z*(r/s));
+	}
+}
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+u00  = -7.38042951086872317523e-02, /* 0xBFB2E4D6, 0x99CBD01F */
+u01  =  1.76666452509181115538e-01, /* 0x3FC69D01, 0x9DE9E3FC */
+u02  = -1.38185671945596898896e-02, /* 0xBF8C4CE8, 0xB16CFA97 */
+u03  =  3.47453432093683650238e-04, /* 0x3F36C54D, 0x20B29B6B */
+u04  = -3.81407053724364161125e-06, /* 0xBECFFEA7, 0x73D25CAD */
+u05  =  1.95590137035022920206e-08, /* 0x3E550057, 0x3B4EABD4 */
+u06  = -3.98205194132103398453e-11, /* 0xBDC5E43D, 0x693FB3C8 */
+v01  =  1.27304834834123699328e-02, /* 0x3F8A1270, 0x91C9C71A */
+v02  =  7.60068627350353253702e-05, /* 0x3F13ECBB, 0xF578C6C1 */
+v03  =  2.59150851840457805467e-07, /* 0x3E91642D, 0x7FF202FD */
+v04  =  4.41110311332675467403e-10; /* 0x3DFE5018, 0x3BD6D9EF */
+
+#ifdef __STDC__
+	double __ieee754_y0(double x)
+#else
+	double __ieee754_y0(x)
+	double x;
+#endif
+{
+	double z, s,c,ss,cc,u,v;
+	int32_t hx,ix,lx;
+
+	EXTRACT_WORDS(hx,lx,x);
+        ix = 0x7fffffff&hx;
+    /* Y0(NaN) is NaN, y0(-inf) is Nan, y0(inf) is 0  */
+	if(ix>=0x7ff00000) return  one/(x+x*x);
+        if((ix|lx)==0) return -one/zero;
+        if(hx<0) return zero/zero;
+        if(ix >= 0x40000000) {  /* |x| >= 2.0 */
+        /* y0(x) = sqrt(2/(pi*x))*(p0(x)*sin(x0)+q0(x)*cos(x0))
+         * where x0 = x-pi/4
+         *      Better formula:
+         *              cos(x0) = cos(x)cos(pi/4)+sin(x)sin(pi/4)
+         *                      =  1/sqrt(2) * (sin(x) + cos(x))
+         *              sin(x0) = sin(x)cos(3pi/4)-cos(x)sin(3pi/4)
+         *                      =  1/sqrt(2) * (sin(x) - cos(x))
+         * To avoid cancellation, use
+         *              sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
+         * to compute the worse one.
+         */
+                s = sin(x);
+                c = cos(x);
+                ss = s-c;
+                cc = s+c;
+	/*
+	 * j0(x) = 1/sqrt(pi) * (P(0,x)*cc - Q(0,x)*ss) / sqrt(x)
+	 * y0(x) = 1/sqrt(pi) * (P(0,x)*ss + Q(0,x)*cc) / sqrt(x)
+	 */
+                if(ix<0x7fe00000) {  /* make sure x+x not overflow */
+                    z = -cos(x+x);
+                    if ((s*c)<zero) cc = z/ss;
+                    else            ss = z/cc;
+                }
+                if(ix>0x48000000) z = (invsqrtpi*ss)/sqrt(x);
+                else {
+                    u = pzero(x); v = qzero(x);
+                    z = invsqrtpi*(u*ss+v*cc)/sqrt(x);
+                }
+                return z;
+	}
+	if(ix<=0x3e400000) {	/* x < 2**-27 */
+	    return(u00 + tpi*__ieee754_log(x));
+	}
+	z = x*x;
+	u = u00+z*(u01+z*(u02+z*(u03+z*(u04+z*(u05+z*u06)))));
+	v = one+z*(v01+z*(v02+z*(v03+z*v04)));
+	return(u/v + tpi*(__ieee754_j0(x)*__ieee754_log(x)));
+}
+
+/* The asymptotic expansions of pzero is
+ *	1 - 9/128 s^2 + 11025/98304 s^4 - ...,	where s = 1/x.
+ * For x >= 2, We approximate pzero by
+ * 	pzero(x) = 1 + (R/S)
+ * where  R = pR0 + pR1*s^2 + pR2*s^4 + ... + pR5*s^10
+ * 	  S = 1 + pS0*s^2 + ... + pS4*s^10
+ * and
+ *	| pzero(x)-1-R/S | <= 2  ** ( -60.26)
+ */
+#ifdef __STDC__
+static const double pR8[6] = { /* for x in [inf, 8]=1/[0,0.125] */
+#else
+static double pR8[6] = { /* for x in [inf, 8]=1/[0,0.125] */
+#endif
+  0.00000000000000000000e+00, /* 0x00000000, 0x00000000 */
+ -7.03124999999900357484e-02, /* 0xBFB1FFFF, 0xFFFFFD32 */
+ -8.08167041275349795626e+00, /* 0xC02029D0, 0xB44FA779 */
+ -2.57063105679704847262e+02, /* 0xC0701102, 0x7B19E863 */
+ -2.48521641009428822144e+03, /* 0xC0A36A6E, 0xCD4DCAFC */
+ -5.25304380490729545272e+03, /* 0xC0B4850B, 0x36CC643D */
+};
+#ifdef __STDC__
+static const double pS8[5] = {
+#else
+static double pS8[5] = {
+#endif
+  1.16534364619668181717e+02, /* 0x405D2233, 0x07A96751 */
+  3.83374475364121826715e+03, /* 0x40ADF37D, 0x50596938 */
+  4.05978572648472545552e+04, /* 0x40E3D2BB, 0x6EB6B05F */
+  1.16752972564375915681e+05, /* 0x40FC810F, 0x8F9FA9BD */
+  4.76277284146730962675e+04, /* 0x40E74177, 0x4F2C49DC */
+};
+
+#ifdef __STDC__
+static const double pR5[6] = { /* for x in [8,4.5454]=1/[0.125,0.22001] */
+#else
+static double pR5[6] = { /* for x in [8,4.5454]=1/[0.125,0.22001] */
+#endif
+ -1.14125464691894502584e-11, /* 0xBDA918B1, 0x47E495CC */
+ -7.03124940873599280078e-02, /* 0xBFB1FFFF, 0xE69AFBC6 */
+ -4.15961064470587782438e+00, /* 0xC010A370, 0xF90C6BBF */
+ -6.76747652265167261021e+01, /* 0xC050EB2F, 0x5A7D1783 */
+ -3.31231299649172967747e+02, /* 0xC074B3B3, 0x6742CC63 */
+ -3.46433388365604912451e+02, /* 0xC075A6EF, 0x28A38BD7 */
+};
+#ifdef __STDC__
+static const double pS5[5] = {
+#else
+static double pS5[5] = {
+#endif
+  6.07539382692300335975e+01, /* 0x404E6081, 0x0C98C5DE */
+  1.05125230595704579173e+03, /* 0x40906D02, 0x5C7E2864 */
+  5.97897094333855784498e+03, /* 0x40B75AF8, 0x8FBE1D60 */
+  9.62544514357774460223e+03, /* 0x40C2CCB8, 0xFA76FA38 */
+  2.40605815922939109441e+03, /* 0x40A2CC1D, 0xC70BE864 */
+};
+
+#ifdef __STDC__
+static const double pR3[6] = {/* for x in [4.547,2.8571]=1/[0.2199,0.35001] */
+#else
+static double pR3[6] = {/* for x in [4.547,2.8571]=1/[0.2199,0.35001] */
+#endif
+ -2.54704601771951915620e-09, /* 0xBE25E103, 0x6FE1AA86 */
+ -7.03119616381481654654e-02, /* 0xBFB1FFF6, 0xF7C0E24B */
+ -2.40903221549529611423e+00, /* 0xC00345B2, 0xAEA48074 */
+ -2.19659774734883086467e+01, /* 0xC035F74A, 0x4CB94E14 */
+ -5.80791704701737572236e+01, /* 0xC04D0A22, 0x420A1A45 */
+ -3.14479470594888503854e+01, /* 0xC03F72AC, 0xA892D80F */
+};
+#ifdef __STDC__
+static const double pS3[5] = {
+#else
+static double pS3[5] = {
+#endif
+  3.58560338055209726349e+01, /* 0x4041ED92, 0x84077DD3 */
+  3.61513983050303863820e+02, /* 0x40769839, 0x464A7C0E */
+  1.19360783792111533330e+03, /* 0x4092A66E, 0x6D1061D6 */
+  1.12799679856907414432e+03, /* 0x40919FFC, 0xB8C39B7E */
+  1.73580930813335754692e+02, /* 0x4065B296, 0xFC379081 */
+};
+
+#ifdef __STDC__
+static const double pR2[6] = {/* for x in [2.8570,2]=1/[0.3499,0.5] */
+#else
+static double pR2[6] = {/* for x in [2.8570,2]=1/[0.3499,0.5] */
+#endif
+ -8.87534333032526411254e-08, /* 0xBE77D316, 0xE927026D */
+ -7.03030995483624743247e-02, /* 0xBFB1FF62, 0x495E1E42 */
+ -1.45073846780952986357e+00, /* 0xBFF73639, 0x8A24A843 */
+ -7.63569613823527770791e+00, /* 0xC01E8AF3, 0xEDAFA7F3 */
+ -1.11931668860356747786e+01, /* 0xC02662E6, 0xC5246303 */
+ -3.23364579351335335033e+00, /* 0xC009DE81, 0xAF8FE70F */
+};
+#ifdef __STDC__
+static const double pS2[5] = {
+#else
+static double pS2[5] = {
+#endif
+  2.22202997532088808441e+01, /* 0x40363865, 0x908B5959 */
+  1.36206794218215208048e+02, /* 0x4061069E, 0x0EE8878F */
+  2.70470278658083486789e+02, /* 0x4070E786, 0x42EA079B */
+  1.53875394208320329881e+02, /* 0x40633C03, 0x3AB6FAFF */
+  1.46576176948256193810e+01, /* 0x402D50B3, 0x44391809 */
+};
+
+#ifdef __STDC__
+	static double pzero(double x)
+#else
+	static double pzero(x)
+	double x;
+#endif
+{
+#ifdef __STDC__
+	const double *p = 0,*q = 0;
+#else
+	double *p,*q;
+#endif
+	double z,r,s;
+	int32_t ix;
+	GET_HIGH_WORD(ix,x);
+	ix &= 0x7fffffff;
+	if(ix>=0x40200000)     {p = pR8; q= pS8;}
+	else if(ix>=0x40122E8B){p = pR5; q= pS5;}
+	else if(ix>=0x4006DB6D){p = pR3; q= pS3;}
+	else if(ix>=0x40000000){p = pR2; q= pS2;}
+	z = one/(x*x);
+	r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
+	s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*q[4]))));
+	return one+ r/s;
+}
+
+
+/* For x >= 8, the asymptotic expansions of qzero is
+ *	-1/8 s + 75/1024 s^3 - ..., where s = 1/x.
+ * We approximate pzero by
+ * 	qzero(x) = s*(-1.25 + (R/S))
+ * where  R = qR0 + qR1*s^2 + qR2*s^4 + ... + qR5*s^10
+ * 	  S = 1 + qS0*s^2 + ... + qS5*s^12
+ * and
+ *	| qzero(x)/s +1.25-R/S | <= 2  ** ( -61.22)
+ */
+#ifdef __STDC__
+static const double qR8[6] = { /* for x in [inf, 8]=1/[0,0.125] */
+#else
+static double qR8[6] = { /* for x in [inf, 8]=1/[0,0.125] */
+#endif
+  0.00000000000000000000e+00, /* 0x00000000, 0x00000000 */
+  7.32421874999935051953e-02, /* 0x3FB2BFFF, 0xFFFFFE2C */
+  1.17682064682252693899e+01, /* 0x40278952, 0x5BB334D6 */
+  5.57673380256401856059e+02, /* 0x40816D63, 0x15301825 */
+  8.85919720756468632317e+03, /* 0x40C14D99, 0x3E18F46D */
+  3.70146267776887834771e+04, /* 0x40E212D4, 0x0E901566 */
+};
+#ifdef __STDC__
+static const double qS8[6] = {
+#else
+static double qS8[6] = {
+#endif
+  1.63776026895689824414e+02, /* 0x406478D5, 0x365B39BC */
+  8.09834494656449805916e+03, /* 0x40BFA258, 0x4E6B0563 */
+  1.42538291419120476348e+05, /* 0x41016652, 0x54D38C3F */
+  8.03309257119514397345e+05, /* 0x412883DA, 0x83A52B43 */
+  8.40501579819060512818e+05, /* 0x4129A66B, 0x28DE0B3D */
+ -3.43899293537866615225e+05, /* 0xC114FD6D, 0x2C9530C5 */
+};
+
+#ifdef __STDC__
+static const double qR5[6] = { /* for x in [8,4.5454]=1/[0.125,0.22001] */
+#else
+static double qR5[6] = { /* for x in [8,4.5454]=1/[0.125,0.22001] */
+#endif
+  1.84085963594515531381e-11, /* 0x3DB43D8F, 0x29CC8CD9 */
+  7.32421766612684765896e-02, /* 0x3FB2BFFF, 0xD172B04C */
+  5.83563508962056953777e+00, /* 0x401757B0, 0xB9953DD3 */
+  1.35111577286449829671e+02, /* 0x4060E392, 0x0A8788E9 */
+  1.02724376596164097464e+03, /* 0x40900CF9, 0x9DC8C481 */
+  1.98997785864605384631e+03, /* 0x409F17E9, 0x53C6E3A6 */
+};
+#ifdef __STDC__
+static const double qS5[6] = {
+#else
+static double qS5[6] = {
+#endif
+  8.27766102236537761883e+01, /* 0x4054B1B3, 0xFB5E1543 */
+  2.07781416421392987104e+03, /* 0x40A03BA0, 0xDA21C0CE */
+  1.88472887785718085070e+04, /* 0x40D267D2, 0x7B591E6D */
+  5.67511122894947329769e+04, /* 0x40EBB5E3, 0x97E02372 */
+  3.59767538425114471465e+04, /* 0x40E19118, 0x1F7A54A0 */
+ -5.35434275601944773371e+03, /* 0xC0B4EA57, 0xBEDBC609 */
+};
+
+#ifdef __STDC__
+static const double qR3[6] = {/* for x in [4.547,2.8571]=1/[0.2199,0.35001] */
+#else
+static double qR3[6] = {/* for x in [4.547,2.8571]=1/[0.2199,0.35001] */
+#endif
+  4.37741014089738620906e-09, /* 0x3E32CD03, 0x6ADECB82 */
+  7.32411180042911447163e-02, /* 0x3FB2BFEE, 0x0E8D0842 */
+  3.34423137516170720929e+00, /* 0x400AC0FC, 0x61149CF5 */
+  4.26218440745412650017e+01, /* 0x40454F98, 0x962DAEDD */
+  1.70808091340565596283e+02, /* 0x406559DB, 0xE25EFD1F */
+  1.66733948696651168575e+02, /* 0x4064D77C, 0x81FA21E0 */
+};
+#ifdef __STDC__
+static const double qS3[6] = {
+#else
+static double qS3[6] = {
+#endif
+  4.87588729724587182091e+01, /* 0x40486122, 0xBFE343A6 */
+  7.09689221056606015736e+02, /* 0x40862D83, 0x86544EB3 */
+  3.70414822620111362994e+03, /* 0x40ACF04B, 0xE44DFC63 */
+  6.46042516752568917582e+03, /* 0x40B93C6C, 0xD7C76A28 */
+  2.51633368920368957333e+03, /* 0x40A3A8AA, 0xD94FB1C0 */
+ -1.49247451836156386662e+02, /* 0xC062A7EB, 0x201CF40F */
+};
+
+#ifdef __STDC__
+static const double qR2[6] = {/* for x in [2.8570,2]=1/[0.3499,0.5] */
+#else
+static double qR2[6] = {/* for x in [2.8570,2]=1/[0.3499,0.5] */
+#endif
+  1.50444444886983272379e-07, /* 0x3E84313B, 0x54F76BDB */
+  7.32234265963079278272e-02, /* 0x3FB2BEC5, 0x3E883E34 */
+  1.99819174093815998816e+00, /* 0x3FFFF897, 0xE727779C */
+  1.44956029347885735348e+01, /* 0x402CFDBF, 0xAAF96FE5 */
+  3.16662317504781540833e+01, /* 0x403FAA8E, 0x29FBDC4A */
+  1.62527075710929267416e+01, /* 0x403040B1, 0x71814BB4 */
+};
+#ifdef __STDC__
+static const double qS2[6] = {
+#else
+static double qS2[6] = {
+#endif
+  3.03655848355219184498e+01, /* 0x403E5D96, 0xF7C07AED */
+  2.69348118608049844624e+02, /* 0x4070D591, 0xE4D14B40 */
+  8.44783757595320139444e+02, /* 0x408A6645, 0x22B3BF22 */
+  8.82935845112488550512e+02, /* 0x408B977C, 0x9C5CC214 */
+  2.12666388511798828631e+02, /* 0x406A9553, 0x0E001365 */
+ -5.31095493882666946917e+00, /* 0xC0153E6A, 0xF8B32931 */
+};
+
+#ifdef __STDC__
+	static double qzero(double x)
+#else
+	static double qzero(x)
+	double x;
+#endif
+{
+#ifdef __STDC__
+	const double *p=0,*q=0;
+#else
+	double *p,*q;
+#endif
+	double s,r,z;
+	int32_t ix;
+	GET_HIGH_WORD(ix,x);
+	ix &= 0x7fffffff;
+	if(ix>=0x40200000)     {p = qR8; q= qS8;}
+	else if(ix>=0x40122E8B){p = qR5; q= qS5;}
+	else if(ix>=0x4006DB6D){p = qR3; q= qS3;}
+	else if(ix>=0x40000000){p = qR2; q= qS2;}
+	z = one/(x*x);
+	r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
+	s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*(q[4]+z*q[5])))));
+	return (-.125 + r/s)/x;
+}
diff -urN dietlibc-0.30/libm/e_j1.c dietlibc-0.30-libm/libm/e_j1.c
--- dietlibc-0.30/libm/e_j1.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_j1.c	2006-06-25 11:20:13.000000000 +0000
@@ -0,0 +1,486 @@
+/* @(#)e_j1.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: e_j1.c,v 1.8 1995/05/10 20:45:27 jtc Exp $";
+#endif
+
+/* __ieee754_j1(x), __ieee754_y1(x)
+ * Bessel function of the first and second kinds of order zero.
+ * Method -- j1(x):
+ *	1. For tiny x, we use j1(x) = x/2 - x^3/16 + x^5/384 - ...
+ *	2. Reduce x to |x| since j1(x)=-j1(-x),  and
+ *	   for x in (0,2)
+ *		j1(x) = x/2 + x*z*R0/S0,  where z = x*x;
+ *	   (precision:  |j1/x - 1/2 - R0/S0 |<2**-61.51 )
+ *	   for x in (2,inf)
+ * 		j1(x) = sqrt(2/(pi*x))*(p1(x)*cos(x1)-q1(x)*sin(x1))
+ * 		y1(x) = sqrt(2/(pi*x))*(p1(x)*sin(x1)+q1(x)*cos(x1))
+ * 	   where x1 = x-3*pi/4. It is better to compute sin(x1),cos(x1)
+ *	   as follow:
+ *		cos(x1) =  cos(x)cos(3pi/4)+sin(x)sin(3pi/4)
+ *			=  1/sqrt(2) * (sin(x) - cos(x))
+ *		sin(x1) =  sin(x)cos(3pi/4)-cos(x)sin(3pi/4)
+ *			= -1/sqrt(2) * (sin(x) + cos(x))
+ * 	   (To avoid cancellation, use
+ *		sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
+ * 	    to compute the worse one.)
+ *
+ *	3 Special cases
+ *		j1(nan)= nan
+ *		j1(0) = 0
+ *		j1(inf) = 0
+ *
+ * Method -- y1(x):
+ *	1. screen out x<=0 cases: y1(0)=-inf, y1(x<0)=NaN
+ *	2. For x<2.
+ *	   Since
+ *		y1(x) = 2/pi*(j1(x)*(ln(x/2)+Euler)-1/x-x/2+5/64*x^3-...)
+ *	   therefore y1(x)-2/pi*j1(x)*ln(x)-1/x is an odd function.
+ *	   We use the following function to approximate y1,
+ *		y1(x) = x*U(z)/V(z) + (2/pi)*(j1(x)*ln(x)-1/x), z= x^2
+ *	   where for x in [0,2] (abs err less than 2**-65.89)
+ *		U(z) = U0[0] + U0[1]*z + ... + U0[4]*z^4
+ *		V(z) = 1  + v0[0]*z + ... + v0[4]*z^5
+ *	   Note: For tiny x, 1/x dominate y1 and hence
+ *		y1(tiny) = -2/pi/tiny, (choose tiny<2**-54)
+ *	3. For x>=2.
+ * 		y1(x) = sqrt(2/(pi*x))*(p1(x)*sin(x1)+q1(x)*cos(x1))
+ * 	   where x1 = x-3*pi/4. It is better to compute sin(x1),cos(x1)
+ *	   by method mentioned above.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static double pone(double), qone(double);
+#else
+static double pone(), qone();
+#endif
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+huge    = 1e300,
+one	= 1.0,
+invsqrtpi=  5.64189583547756279280e-01, /* 0x3FE20DD7, 0x50429B6D */
+tpi      =  6.36619772367581382433e-01, /* 0x3FE45F30, 0x6DC9C883 */
+	/* R0/S0 on [0,2] */
+r00  = -6.25000000000000000000e-02, /* 0xBFB00000, 0x00000000 */
+r01  =  1.40705666955189706048e-03, /* 0x3F570D9F, 0x98472C61 */
+r02  = -1.59955631084035597520e-05, /* 0xBEF0C5C6, 0xBA169668 */
+r03  =  4.96727999609584448412e-08, /* 0x3E6AAAFA, 0x46CA0BD9 */
+s01  =  1.91537599538363460805e-02, /* 0x3F939D0B, 0x12637E53 */
+s02  =  1.85946785588630915560e-04, /* 0x3F285F56, 0xB9CDF664 */
+s03  =  1.17718464042623683263e-06, /* 0x3EB3BFF8, 0x333F8498 */
+s04  =  5.04636257076217042715e-09, /* 0x3E35AC88, 0xC97DFF2C */
+s05  =  1.23542274426137913908e-11; /* 0x3DAB2ACF, 0xCFB97ED8 */
+
+#ifdef __STDC__
+static const double zero    = 0.0;
+#else
+static double zero    = 0.0;
+#endif
+
+#ifdef __STDC__
+	double __ieee754_j1(double x)
+#else
+	double __ieee754_j1(x)
+	double x;
+#endif
+{
+	double z, s,c,ss,cc,r,u,v,y;
+	int32_t hx,ix;
+
+	GET_HIGH_WORD(hx,x);
+	ix = hx&0x7fffffff;
+	if(ix>=0x7ff00000) return one/x;
+	y = fabs(x);
+	if(ix >= 0x40000000) {	/* |x| >= 2.0 */
+		s = sin(y);
+		c = cos(y);
+		ss = -s-c;
+		cc = s-c;
+		if(ix<0x7fe00000) {  /* make sure y+y not overflow */
+		    z = cos(y+y);
+		    if ((s*c)>zero) cc = z/ss;
+		    else 	    ss = z/cc;
+		}
+	/*
+	 * j1(x) = 1/sqrt(pi) * (P(1,x)*cc - Q(1,x)*ss) / sqrt(x)
+	 * y1(x) = 1/sqrt(pi) * (P(1,x)*ss + Q(1,x)*cc) / sqrt(x)
+	 */
+		if(ix>0x48000000) z = (invsqrtpi*cc)/sqrt(y);
+		else {
+		    u = pone(y); v = qone(y);
+		    z = invsqrtpi*(u*cc-v*ss)/sqrt(y);
+		}
+		if(hx<0) return -z;
+		else  	 return  z;
+	}
+	if(ix<0x3e400000) {	/* |x|<2**-27 */
+	    if(huge+x>one) return 0.5*x;/* inexact if x!=0 necessary */
+	}
+	z = x*x;
+	r =  z*(r00+z*(r01+z*(r02+z*r03)));
+	s =  one+z*(s01+z*(s02+z*(s03+z*(s04+z*s05))));
+	r *= x;
+	return(x*0.5+r/s);
+}
+
+#ifdef __STDC__
+static const double U0[5] = {
+#else
+static double U0[5] = {
+#endif
+ -1.96057090646238940668e-01, /* 0xBFC91866, 0x143CBC8A */
+  5.04438716639811282616e-02, /* 0x3FA9D3C7, 0x76292CD1 */
+ -1.91256895875763547298e-03, /* 0xBF5F55E5, 0x4844F50F */
+  2.35252600561610495928e-05, /* 0x3EF8AB03, 0x8FA6B88E */
+ -9.19099158039878874504e-08, /* 0xBE78AC00, 0x569105B8 */
+};
+#ifdef __STDC__
+static const double V0[5] = {
+#else
+static double V0[5] = {
+#endif
+  1.99167318236649903973e-02, /* 0x3F94650D, 0x3F4DA9F0 */
+  2.02552581025135171496e-04, /* 0x3F2A8C89, 0x6C257764 */
+  1.35608801097516229404e-06, /* 0x3EB6C05A, 0x894E8CA6 */
+  6.22741452364621501295e-09, /* 0x3E3ABF1D, 0x5BA69A86 */
+  1.66559246207992079114e-11, /* 0x3DB25039, 0xDACA772A */
+};
+
+#ifdef __STDC__
+	double __ieee754_y1(double x)
+#else
+	double __ieee754_y1(x)
+	double x;
+#endif
+{
+	double z, s,c,ss,cc,u,v;
+	int32_t hx,ix,lx;
+
+	EXTRACT_WORDS(hx,lx,x);
+        ix = 0x7fffffff&hx;
+    /* if Y1(NaN) is NaN, Y1(-inf) is NaN, Y1(inf) is 0 */
+	if(ix>=0x7ff00000) return  one/(x+x*x);
+        if((ix|lx)==0) return -one/zero;
+        if(hx<0) return zero/zero;
+        if(ix >= 0x40000000) {  /* |x| >= 2.0 */
+                s = sin(x);
+                c = cos(x);
+                ss = -s-c;
+                cc = s-c;
+                if(ix<0x7fe00000) {  /* make sure x+x not overflow */
+                    z = cos(x+x);
+                    if ((s*c)>zero) cc = z/ss;
+                    else            ss = z/cc;
+                }
+        /* y1(x) = sqrt(2/(pi*x))*(p1(x)*sin(x0)+q1(x)*cos(x0))
+         * where x0 = x-3pi/4
+         *      Better formula:
+         *              cos(x0) = cos(x)cos(3pi/4)+sin(x)sin(3pi/4)
+         *                      =  1/sqrt(2) * (sin(x) - cos(x))
+         *              sin(x0) = sin(x)cos(3pi/4)-cos(x)sin(3pi/4)
+         *                      = -1/sqrt(2) * (cos(x) + sin(x))
+         * To avoid cancellation, use
+         *              sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
+         * to compute the worse one.
+         */
+                if(ix>0x48000000) z = (invsqrtpi*ss)/sqrt(x);
+                else {
+                    u = pone(x); v = qone(x);
+                    z = invsqrtpi*(u*ss+v*cc)/sqrt(x);
+                }
+                return z;
+        }
+        if(ix<=0x3c900000) {    /* x < 2**-54 */
+            return(-tpi/x);
+        }
+        z = x*x;
+        u = U0[0]+z*(U0[1]+z*(U0[2]+z*(U0[3]+z*U0[4])));
+        v = one+z*(V0[0]+z*(V0[1]+z*(V0[2]+z*(V0[3]+z*V0[4]))));
+        return(x*(u/v) + tpi*(__ieee754_j1(x)*__ieee754_log(x)-one/x));
+}
+
+/* For x >= 8, the asymptotic expansions of pone is
+ *	1 + 15/128 s^2 - 4725/2^15 s^4 - ...,	where s = 1/x.
+ * We approximate pone by
+ * 	pone(x) = 1 + (R/S)
+ * where  R = pr0 + pr1*s^2 + pr2*s^4 + ... + pr5*s^10
+ * 	  S = 1 + ps0*s^2 + ... + ps4*s^10
+ * and
+ *	| pone(x)-1-R/S | <= 2  ** ( -60.06)
+ */
+
+#ifdef __STDC__
+static const double pr8[6] = { /* for x in [inf, 8]=1/[0,0.125] */
+#else
+static double pr8[6] = { /* for x in [inf, 8]=1/[0,0.125] */
+#endif
+  0.00000000000000000000e+00, /* 0x00000000, 0x00000000 */
+  1.17187499999988647970e-01, /* 0x3FBDFFFF, 0xFFFFFCCE */
+  1.32394806593073575129e+01, /* 0x402A7A9D, 0x357F7FCE */
+  4.12051854307378562225e+02, /* 0x4079C0D4, 0x652EA590 */
+  3.87474538913960532227e+03, /* 0x40AE457D, 0xA3A532CC */
+  7.91447954031891731574e+03, /* 0x40BEEA7A, 0xC32782DD */
+};
+#ifdef __STDC__
+static const double ps8[5] = {
+#else
+static double ps8[5] = {
+#endif
+  1.14207370375678408436e+02, /* 0x405C8D45, 0x8E656CAC */
+  3.65093083420853463394e+03, /* 0x40AC85DC, 0x964D274F */
+  3.69562060269033463555e+04, /* 0x40E20B86, 0x97C5BB7F */
+  9.76027935934950801311e+04, /* 0x40F7D42C, 0xB28F17BB */
+  3.08042720627888811578e+04, /* 0x40DE1511, 0x697A0B2D */
+};
+
+#ifdef __STDC__
+static const double pr5[6] = { /* for x in [8,4.5454]=1/[0.125,0.22001] */
+#else
+static double pr5[6] = { /* for x in [8,4.5454]=1/[0.125,0.22001] */
+#endif
+  1.31990519556243522749e-11, /* 0x3DAD0667, 0xDAE1CA7D */
+  1.17187493190614097638e-01, /* 0x3FBDFFFF, 0xE2C10043 */
+  6.80275127868432871736e+00, /* 0x401B3604, 0x6E6315E3 */
+  1.08308182990189109773e+02, /* 0x405B13B9, 0x452602ED */
+  5.17636139533199752805e+02, /* 0x40802D16, 0xD052D649 */
+  5.28715201363337541807e+02, /* 0x408085B8, 0xBB7E0CB7 */
+};
+#ifdef __STDC__
+static const double ps5[5] = {
+#else
+static double ps5[5] = {
+#endif
+  5.92805987221131331921e+01, /* 0x404DA3EA, 0xA8AF633D */
+  9.91401418733614377743e+02, /* 0x408EFB36, 0x1B066701 */
+  5.35326695291487976647e+03, /* 0x40B4E944, 0x5706B6FB */
+  7.84469031749551231769e+03, /* 0x40BEA4B0, 0xB8A5BB15 */
+  1.50404688810361062679e+03, /* 0x40978030, 0x036F5E51 */
+};
+
+#ifdef __STDC__
+static const double pr3[6] = {
+#else
+static double pr3[6] = {/* for x in [4.547,2.8571]=1/[0.2199,0.35001] */
+#endif
+  3.02503916137373618024e-09, /* 0x3E29FC21, 0xA7AD9EDD */
+  1.17186865567253592491e-01, /* 0x3FBDFFF5, 0x5B21D17B */
+  3.93297750033315640650e+00, /* 0x400F76BC, 0xE85EAD8A */
+  3.51194035591636932736e+01, /* 0x40418F48, 0x9DA6D129 */
+  9.10550110750781271918e+01, /* 0x4056C385, 0x4D2C1837 */
+  4.85590685197364919645e+01, /* 0x4048478F, 0x8EA83EE5 */
+};
+#ifdef __STDC__
+static const double ps3[5] = {
+#else
+static double ps3[5] = {
+#endif
+  3.47913095001251519989e+01, /* 0x40416549, 0xA134069C */
+  3.36762458747825746741e+02, /* 0x40750C33, 0x07F1A75F */
+  1.04687139975775130551e+03, /* 0x40905B7C, 0x5037D523 */
+  8.90811346398256432622e+02, /* 0x408BD67D, 0xA32E31E9 */
+  1.03787932439639277504e+02, /* 0x4059F26D, 0x7C2EED53 */
+};
+
+#ifdef __STDC__
+static const double pr2[6] = {/* for x in [2.8570,2]=1/[0.3499,0.5] */
+#else
+static double pr2[6] = {/* for x in [2.8570,2]=1/[0.3499,0.5] */
+#endif
+  1.07710830106873743082e-07, /* 0x3E7CE9D4, 0xF65544F4 */
+  1.17176219462683348094e-01, /* 0x3FBDFF42, 0xBE760D83 */
+  2.36851496667608785174e+00, /* 0x4002F2B7, 0xF98FAEC0 */
+  1.22426109148261232917e+01, /* 0x40287C37, 0x7F71A964 */
+  1.76939711271687727390e+01, /* 0x4031B1A8, 0x177F8EE2 */
+  5.07352312588818499250e+00, /* 0x40144B49, 0xA574C1FE */
+};
+#ifdef __STDC__
+static const double ps2[5] = {
+#else
+static double ps2[5] = {
+#endif
+  2.14364859363821409488e+01, /* 0x40356FBD, 0x8AD5ECDC */
+  1.25290227168402751090e+02, /* 0x405F5293, 0x14F92CD5 */
+  2.32276469057162813669e+02, /* 0x406D08D8, 0xD5A2DBD9 */
+  1.17679373287147100768e+02, /* 0x405D6B7A, 0xDA1884A9 */
+  8.36463893371618283368e+00, /* 0x4020BAB1, 0xF44E5192 */
+};
+
+#ifdef __STDC__
+	static double pone(double x)
+#else
+	static double pone(x)
+	double x;
+#endif
+{
+#ifdef __STDC__
+	const double *p=0,*q=0;
+#else
+	double *p,*q;
+#endif
+	double z,r,s;
+        int32_t ix;
+	GET_HIGH_WORD(ix,x);
+	ix &= 0x7fffffff;
+        if(ix>=0x40200000)     {p = pr8; q= ps8;}
+        else if(ix>=0x40122E8B){p = pr5; q= ps5;}
+        else if(ix>=0x4006DB6D){p = pr3; q= ps3;}
+        else if(ix>=0x40000000){p = pr2; q= ps2;}
+        z = one/(x*x);
+        r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
+        s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*q[4]))));
+        return one+ r/s;
+}
+
+
+/* For x >= 8, the asymptotic expansions of qone is
+ *	3/8 s - 105/1024 s^3 - ..., where s = 1/x.
+ * We approximate pone by
+ * 	qone(x) = s*(0.375 + (R/S))
+ * where  R = qr1*s^2 + qr2*s^4 + ... + qr5*s^10
+ * 	  S = 1 + qs1*s^2 + ... + qs6*s^12
+ * and
+ *	| qone(x)/s -0.375-R/S | <= 2  ** ( -61.13)
+ */
+
+#ifdef __STDC__
+static const double qr8[6] = { /* for x in [inf, 8]=1/[0,0.125] */
+#else
+static double qr8[6] = { /* for x in [inf, 8]=1/[0,0.125] */
+#endif
+  0.00000000000000000000e+00, /* 0x00000000, 0x00000000 */
+ -1.02539062499992714161e-01, /* 0xBFBA3FFF, 0xFFFFFDF3 */
+ -1.62717534544589987888e+01, /* 0xC0304591, 0xA26779F7 */
+ -7.59601722513950107896e+02, /* 0xC087BCD0, 0x53E4B576 */
+ -1.18498066702429587167e+04, /* 0xC0C724E7, 0x40F87415 */
+ -4.84385124285750353010e+04, /* 0xC0E7A6D0, 0x65D09C6A */
+};
+#ifdef __STDC__
+static const double qs8[6] = {
+#else
+static double qs8[6] = {
+#endif
+  1.61395369700722909556e+02, /* 0x40642CA6, 0xDE5BCDE5 */
+  7.82538599923348465381e+03, /* 0x40BE9162, 0xD0D88419 */
+  1.33875336287249578163e+05, /* 0x4100579A, 0xB0B75E98 */
+  7.19657723683240939863e+05, /* 0x4125F653, 0x72869C19 */
+  6.66601232617776375264e+05, /* 0x412457D2, 0x7719AD5C */
+ -2.94490264303834643215e+05, /* 0xC111F969, 0x0EA5AA18 */
+};
+
+#ifdef __STDC__
+static const double qr5[6] = { /* for x in [8,4.5454]=1/[0.125,0.22001] */
+#else
+static double qr5[6] = { /* for x in [8,4.5454]=1/[0.125,0.22001] */
+#endif
+ -2.08979931141764104297e-11, /* 0xBDB6FA43, 0x1AA1A098 */
+ -1.02539050241375426231e-01, /* 0xBFBA3FFF, 0xCB597FEF */
+ -8.05644828123936029840e+00, /* 0xC0201CE6, 0xCA03AD4B */
+ -1.83669607474888380239e+02, /* 0xC066F56D, 0x6CA7B9B0 */
+ -1.37319376065508163265e+03, /* 0xC09574C6, 0x6931734F */
+ -2.61244440453215656817e+03, /* 0xC0A468E3, 0x88FDA79D */
+};
+#ifdef __STDC__
+static const double qs5[6] = {
+#else
+static double qs5[6] = {
+#endif
+  8.12765501384335777857e+01, /* 0x405451B2, 0xFF5A11B2 */
+  1.99179873460485964642e+03, /* 0x409F1F31, 0xE77BF839 */
+  1.74684851924908907677e+04, /* 0x40D10F1F, 0x0D64CE29 */
+  4.98514270910352279316e+04, /* 0x40E8576D, 0xAABAD197 */
+  2.79480751638918118260e+04, /* 0x40DB4B04, 0xCF7C364B */
+ -4.71918354795128470869e+03, /* 0xC0B26F2E, 0xFCFFA004 */
+};
+
+#ifdef __STDC__
+static const double qr3[6] = {
+#else
+static double qr3[6] = {/* for x in [4.547,2.8571]=1/[0.2199,0.35001] */
+#endif
+ -5.07831226461766561369e-09, /* 0xBE35CFA9, 0xD38FC84F */
+ -1.02537829820837089745e-01, /* 0xBFBA3FEB, 0x51AEED54 */
+ -4.61011581139473403113e+00, /* 0xC01270C2, 0x3302D9FF */
+ -5.78472216562783643212e+01, /* 0xC04CEC71, 0xC25D16DA */
+ -2.28244540737631695038e+02, /* 0xC06C87D3, 0x4718D55F */
+ -2.19210128478909325622e+02, /* 0xC06B66B9, 0x5F5C1BF6 */
+};
+#ifdef __STDC__
+static const double qs3[6] = {
+#else
+static double qs3[6] = {
+#endif
+  4.76651550323729509273e+01, /* 0x4047D523, 0xCCD367E4 */
+  6.73865112676699709482e+02, /* 0x40850EEB, 0xC031EE3E */
+  3.38015286679526343505e+03, /* 0x40AA684E, 0x448E7C9A */
+  5.54772909720722782367e+03, /* 0x40B5ABBA, 0xA61D54A6 */
+  1.90311919338810798763e+03, /* 0x409DBC7A, 0x0DD4DF4B */
+ -1.35201191444307340817e+02, /* 0xC060E670, 0x290A311F */
+};
+
+#ifdef __STDC__
+static const double qr2[6] = {/* for x in [2.8570,2]=1/[0.3499,0.5] */
+#else
+static double qr2[6] = {/* for x in [2.8570,2]=1/[0.3499,0.5] */
+#endif
+ -1.78381727510958865572e-07, /* 0xBE87F126, 0x44C626D2 */
+ -1.02517042607985553460e-01, /* 0xBFBA3E8E, 0x9148B010 */
+ -2.75220568278187460720e+00, /* 0xC0060484, 0x69BB4EDA */
+ -1.96636162643703720221e+01, /* 0xC033A9E2, 0xC168907F */
+ -4.23253133372830490089e+01, /* 0xC04529A3, 0xDE104AAA */
+ -2.13719211703704061733e+01, /* 0xC0355F36, 0x39CF6E52 */
+};
+#ifdef __STDC__
+static const double qs2[6] = {
+#else
+static double qs2[6] = {
+#endif
+  2.95333629060523854548e+01, /* 0x403D888A, 0x78AE64FF */
+  2.52981549982190529136e+02, /* 0x406F9F68, 0xDB821CBA */
+  7.57502834868645436472e+02, /* 0x4087AC05, 0xCE49A0F7 */
+  7.39393205320467245656e+02, /* 0x40871B25, 0x48D4C029 */
+  1.55949003336666123687e+02, /* 0x40637E5E, 0x3C3ED8D4 */
+ -4.95949898822628210127e+00, /* 0xC013D686, 0xE71BE86B */
+};
+
+#ifdef __STDC__
+	static double qone(double x)
+#else
+	static double qone(x)
+	double x;
+#endif
+{
+#ifdef __STDC__
+	const double *p=0,*q=0;
+#else
+	double *p,*q;
+#endif
+	double  s,r,z;
+	int32_t ix;
+	GET_HIGH_WORD(ix,x);
+	ix &= 0x7fffffff;
+	if(ix>=0x40200000)     {p = qr8; q= qs8;}
+	else if(ix>=0x40122E8B){p = qr5; q= qs5;}
+	else if(ix>=0x4006DB6D){p = qr3; q= qs3;}
+	else if(ix>=0x40000000){p = qr2; q= qs2;}
+	z = one/(x*x);
+	r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
+	s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*(q[4]+z*q[5])))));
+	return (.375 + r/s)/x;
+}
diff -urN dietlibc-0.30/libm/e_jn.c dietlibc-0.30-libm/libm/e_jn.c
--- dietlibc-0.30/libm/e_jn.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_jn.c	2006-06-25 11:20:14.000000000 +0000
@@ -0,0 +1,281 @@
+/* @(#)e_jn.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: e_jn.c,v 1.9 1995/05/10 20:45:34 jtc Exp $";
+#endif
+
+/*
+ * __ieee754_jn(n, x), __ieee754_yn(n, x)
+ * floating point Bessel's function of the 1st and 2nd kind
+ * of order n
+ *
+ * Special cases:
+ *	y0(0)=y1(0)=yn(n,0) = -inf with division by zero signal;
+ *	y0(-ve)=y1(-ve)=yn(n,-ve) are NaN with invalid signal.
+ * Note 2. About jn(n,x), yn(n,x)
+ *	For n=0, j0(x) is called,
+ *	for n=1, j1(x) is called,
+ *	for n<x, forward recursion us used starting
+ *	from values of j0(x) and j1(x).
+ *	for n>x, a continued fraction approximation to
+ *	j(n,x)/j(n-1,x) is evaluated and then backward
+ *	recursion is used starting from a supposed value
+ *	for j(n,x). The resulting value of j(0,x) is
+ *	compared with the actual value to correct the
+ *	supposed value of j(n,x).
+ *
+ *	yn(n,x) is similar in all respects, except
+ *	that forward recursion is used for all
+ *	values of n>1.
+ *
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+invsqrtpi=  5.64189583547756279280e-01, /* 0x3FE20DD7, 0x50429B6D */
+two   =  2.00000000000000000000e+00, /* 0x40000000, 0x00000000 */
+one   =  1.00000000000000000000e+00; /* 0x3FF00000, 0x00000000 */
+
+#ifdef __STDC__
+static const double zero  =  0.00000000000000000000e+00;
+#else
+static double zero  =  0.00000000000000000000e+00;
+#endif
+
+#ifdef __STDC__
+	double __ieee754_jn(int n, double x)
+#else
+	double __ieee754_jn(n,x)
+	int n; double x;
+#endif
+{
+	int32_t i,hx,ix,lx, sgn;
+	double a, b, temp=0, di;
+	double z, w;
+
+    /* J(-n,x) = (-1)^n * J(n, x), J(n, -x) = (-1)^n * J(n, x)
+     * Thus, J(-n,x) = J(n,-x)
+     */
+	EXTRACT_WORDS(hx,lx,x);
+	ix = 0x7fffffff&hx;
+    /* if J(n,NaN) is NaN */
+	if((ix|((u_int32_t)(lx|-lx))>>31)>0x7ff00000) return x+x;
+	if(n<0){
+		n = -n;
+		x = -x;
+		hx ^= 0x80000000;
+	}
+	if(n==0) return(__ieee754_j0(x));
+	if(n==1) return(__ieee754_j1(x));
+	sgn = (n&1)&(hx>>31);	/* even n -- 0, odd n -- sign(x) */
+	x = fabs(x);
+	if((ix|lx)==0||ix>=0x7ff00000) 	/* if x is 0 or inf */
+	    b = zero;
+	else if((double)n<=x) {
+		/* Safe to use J(n+1,x)=2n/x *J(n,x)-J(n-1,x) */
+	    if(ix>=0x52D00000) { /* x > 2**302 */
+    /* (x >> n**2)
+     *	    Jn(x) = cos(x-(2n+1)*pi/4)*sqrt(2/x*pi)
+     *	    Yn(x) = sin(x-(2n+1)*pi/4)*sqrt(2/x*pi)
+     *	    Let s=sin(x), c=cos(x),
+     *		xn=x-(2n+1)*pi/4, sqt2 = sqrt(2),then
+     *
+     *		   n	sin(xn)*sqt2	cos(xn)*sqt2
+     *		----------------------------------
+     *		   0	 s-c		 c+s
+     *		   1	-s-c 		-c+s
+     *		   2	-s+c		-c-s
+     *		   3	 s+c		 c-s
+     */
+		switch(n&3) {
+		    case 0: temp =  cos(x)+sin(x); break;
+		    case 1: temp = -cos(x)+sin(x); break;
+		    case 2: temp = -cos(x)-sin(x); break;
+		    case 3: temp =  cos(x)-sin(x); break;
+		}
+		b = invsqrtpi*temp/sqrt(x);
+	    } else {
+	        a = __ieee754_j0(x);
+	        b = __ieee754_j1(x);
+	        for(i=1;i<n;i++){
+		    temp = b;
+		    b = b*((double)(i+i)/x) - a; /* avoid underflow */
+		    a = temp;
+	        }
+	    }
+	} else {
+	    if(ix<0x3e100000) {	/* x < 2**-29 */
+    /* x is tiny, return the first Taylor expansion of J(n,x)
+     * J(n,x) = 1/n!*(x/2)^n  - ...
+     */
+		if(n>33)	/* underflow */
+		    b = zero;
+		else {
+		    temp = x*0.5; b = temp;
+		    for (a=one,i=2;i<=n;i++) {
+			a *= (double)i;		/* a = n! */
+			b *= temp;		/* b = (x/2)^n */
+		    }
+		    b = b/a;
+		}
+	    } else {
+		/* use backward recurrence */
+		/* 			x      x^2      x^2
+		 *  J(n,x)/J(n-1,x) =  ----   ------   ------   .....
+		 *			2n  - 2(n+1) - 2(n+2)
+		 *
+		 * 			1      1        1
+		 *  (for large x)   =  ----  ------   ------   .....
+		 *			2n   2(n+1)   2(n+2)
+		 *			-- - ------ - ------ -
+		 *			 x     x         x
+		 *
+		 * Let w = 2n/x and h=2/x, then the above quotient
+		 * is equal to the continued fraction:
+		 *		    1
+		 *	= -----------------------
+		 *		       1
+		 *	   w - -----------------
+		 *			  1
+		 * 	        w+h - ---------
+		 *		       w+2h - ...
+		 *
+		 * To determine how many terms needed, let
+		 * Q(0) = w, Q(1) = w(w+h) - 1,
+		 * Q(k) = (w+k*h)*Q(k-1) - Q(k-2),
+		 * When Q(k) > 1e4	good for single
+		 * When Q(k) > 1e9	good for double
+		 * When Q(k) > 1e17	good for quadruple
+		 */
+	    /* determine k */
+		double t,v;
+		double q0,q1,h,tmp; int32_t k,m;
+		w  = (n+n)/(double)x; h = 2.0/(double)x;
+		q0 = w;  z = w+h; q1 = w*z - 1.0; k=1;
+		while(q1<1.0e9) {
+			k += 1; z += h;
+			tmp = z*q1 - q0;
+			q0 = q1;
+			q1 = tmp;
+		}
+		m = n+n;
+		for(t=zero, i = 2*(n+k); i>=m; i -= 2) t = one/(i/x-t);
+		a = t;
+		b = one;
+		/*  estimate log((2/x)^n*n!) = n*log(2/x)+n*ln(n)
+		 *  Hence, if n*(log(2n/x)) > ...
+		 *  single 8.8722839355e+01
+		 *  double 7.09782712893383973096e+02
+		 *  long double 1.1356523406294143949491931077970765006170e+04
+		 *  then recurrent value may overflow and the result is
+		 *  likely underflow to zero
+		 */
+		tmp = n;
+		v = two/x;
+		tmp = tmp*__ieee754_log(fabs(v*tmp));
+		if(tmp<7.09782712893383973096e+02) {
+	    	    for(i=n-1,di=(double)(i+i);i>0;i--){
+		        temp = b;
+			b *= di;
+			b  = b/x - a;
+		        a = temp;
+			di -= two;
+	     	    }
+		} else {
+	    	    for(i=n-1,di=(double)(i+i);i>0;i--){
+		        temp = b;
+			b *= di;
+			b  = b/x - a;
+		        a = temp;
+			di -= two;
+		    /* scale b to avoid spurious overflow */
+			if(b>1e100) {
+			    a /= b;
+			    t /= b;
+			    b  = one;
+			}
+	     	    }
+		}
+	    	b = (t*__ieee754_j0(x)/b);
+	    }
+	}
+	if(sgn==1) return -b; else return b;
+}
+
+#ifdef __STDC__
+	double __ieee754_yn(int n, double x)
+#else
+	double __ieee754_yn(n,x)
+	int n; double x;
+#endif
+{
+	int32_t i,hx,ix,lx;
+	int32_t sign;
+	double a, b, temp=0;
+
+	EXTRACT_WORDS(hx,lx,x);
+	ix = 0x7fffffff&hx;
+    /* if Y(n,NaN) is NaN */
+	if((ix|((u_int32_t)(lx|-lx))>>31)>0x7ff00000) return x+x;
+	if((ix|lx)==0) return -one/zero;
+	if(hx<0) return zero/zero;
+	sign = 1;
+	if(n<0){
+		n = -n;
+		sign = 1 - ((n&1)<<1);
+	}
+	if(n==0) return(__ieee754_y0(x));
+	if(n==1) return(sign*__ieee754_y1(x));
+	if(ix==0x7ff00000) return zero;
+	if(ix>=0x52D00000) { /* x > 2**302 */
+    /* (x >> n**2)
+     *	    Jn(x) = cos(x-(2n+1)*pi/4)*sqrt(2/x*pi)
+     *	    Yn(x) = sin(x-(2n+1)*pi/4)*sqrt(2/x*pi)
+     *	    Let s=sin(x), c=cos(x),
+     *		xn=x-(2n+1)*pi/4, sqt2 = sqrt(2),then
+     *
+     *		   n	sin(xn)*sqt2	cos(xn)*sqt2
+     *		----------------------------------
+     *		   0	 s-c		 c+s
+     *		   1	-s-c 		-c+s
+     *		   2	-s+c		-c-s
+     *		   3	 s+c		 c-s
+     */
+		switch(n&3) {
+		    case 0: temp =  sin(x)-cos(x); break;
+		    case 1: temp = -sin(x)-cos(x); break;
+		    case 2: temp = -sin(x)+cos(x); break;
+		    case 3: temp =  sin(x)+cos(x); break;
+		}
+		b = invsqrtpi*temp/sqrt(x);
+	} else {
+	    u_int32_t high;
+	    a = __ieee754_y0(x);
+	    b = __ieee754_y1(x);
+	/* quit if b is -inf */
+	    GET_HIGH_WORD(high,b);
+	    for(i=1;i<n&&high!=0xfff00000;i++){
+		temp = b;
+		b = ((double)(i+i)/x)*b - a;
+		GET_HIGH_WORD(high,b);
+		a = temp;
+	    }
+	}
+	if(sign>0) return b; else return -b;
+}
diff -urN dietlibc-0.30/libm/e_lgamma.c dietlibc-0.30-libm/libm/e_lgamma.c
--- dietlibc-0.30/libm/e_lgamma.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_lgamma.c	2006-06-25 11:20:15.000000000 +0000
@@ -0,0 +1,34 @@
+
+/* @(#)e_lgamma.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ *
+ */
+
+/* __ieee754_lgamma(x)
+ * Return the logarithm of the Gamma function of x.
+ *
+ * Method: call __ieee754_lgamma_r
+ */
+
+#include "math_private.h"
+
+extern int signgam;
+
+#ifdef __STDC__
+	//__private_extern__
+	double __ieee754_lgamma(double x)
+#else
+	double __ieee754_lgamma(x)
+	double x;
+#endif
+{
+	return __ieee754_lgamma_r(x,&signgam);
+}
diff -urN dietlibc-0.30/libm/e_lgamma_r.c dietlibc-0.30-libm/libm/e_lgamma_r.c
--- dietlibc-0.30/libm/e_lgamma_r.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_lgamma_r.c	2006-06-25 11:20:23.000000000 +0000
@@ -0,0 +1,316 @@
+/* @(#)er_lgamma.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: e_lgamma_r.c,v 1.7 1995/05/10 20:45:42 jtc Exp $";
+#endif
+
+/* __ieee754_lgamma_r(x, signgamp)
+ * Reentrant version of the logarithm of the Gamma function
+ * with user provide pointer for the sign of Gamma(x).
+ *
+ * Method:
+ *   1. Argument Reduction for 0 < x <= 8
+ * 	Since gamma(1+s)=s*gamma(s), for x in [0,8], we may
+ * 	reduce x to a number in [1.5,2.5] by
+ * 		lgamma(1+s) = log(s) + lgamma(s)
+ *	for example,
+ *		lgamma(7.3) = log(6.3) + lgamma(6.3)
+ *			    = log(6.3*5.3) + lgamma(5.3)
+ *			    = log(6.3*5.3*4.3*3.3*2.3) + lgamma(2.3)
+ *   2. Polynomial approximation of lgamma around its
+ *	minimun ymin=1.461632144968362245 to maintain monotonicity.
+ *	On [ymin-0.23, ymin+0.27] (i.e., [1.23164,1.73163]), use
+ *		Let z = x-ymin;
+ *		lgamma(x) = -1.214862905358496078218 + z^2*poly(z)
+ *	where
+ *		poly(z) is a 14 degree polynomial.
+ *   2. Rational approximation in the primary interval [2,3]
+ *	We use the following approximation:
+ *		s = x-2.0;
+ *		lgamma(x) = 0.5*s + s*P(s)/Q(s)
+ *	with accuracy
+ *		|P/Q - (lgamma(x)-0.5s)| < 2**-61.71
+ *	Our algorithms are based on the following observation
+ *
+ *                             zeta(2)-1    2    zeta(3)-1    3
+ * lgamma(2+s) = s*(1-Euler) + --------- * s  -  --------- * s  + ...
+ *                                 2                 3
+ *
+ *	where Euler = 0.5771... is the Euler constant, which is very
+ *	close to 0.5.
+ *
+ *   3. For x>=8, we have
+ *	lgamma(x)~(x-0.5)log(x)-x+0.5*log(2pi)+1/(12x)-1/(360x**3)+....
+ *	(better formula:
+ *	   lgamma(x)~(x-0.5)*(log(x)-1)-.5*(log(2pi)-1) + ...)
+ *	Let z = 1/x, then we approximation
+ *		f(z) = lgamma(x) - (x-0.5)(log(x)-1)
+ *	by
+ *	  			    3       5             11
+ *		w = w0 + w1*z + w2*z  + w3*z  + ... + w6*z
+ *	where
+ *		|w - f(z)| < 2**-58.74
+ *
+ *   4. For negative x, since (G is gamma function)
+ *		-x*G(-x)*G(x) = pi/sin(pi*x),
+ * 	we have
+ * 		G(x) = pi/(sin(pi*x)*(-x)*G(-x))
+ *	since G(-x) is positive, sign(G(x)) = sign(sin(pi*x)) for x<0
+ *	Hence, for x<0, signgam = sign(sin(pi*x)) and
+ *		lgamma(x) = log(|Gamma(x)|)
+ *			  = log(pi/(|x*sin(pi*x)|)) - lgamma(-x);
+ *	Note: one should avoid compute pi*(-x) directly in the
+ *	      computation of sin(pi*(-x)).
+ *
+ *   5. Special Cases
+ *		lgamma(2+s) ~ s*(1-Euler) for tiny s
+ *		lgamma(1)=lgamma(2)=0
+ *		lgamma(x) ~ -log(x) for tiny x
+ *		lgamma(0) = lgamma(inf) = inf
+ *	 	lgamma(-integer) = +-inf
+ *
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+two52=  4.50359962737049600000e+15, /* 0x43300000, 0x00000000 */
+half=  5.00000000000000000000e-01, /* 0x3FE00000, 0x00000000 */
+one =  1.00000000000000000000e+00, /* 0x3FF00000, 0x00000000 */
+pi  =  3.14159265358979311600e+00, /* 0x400921FB, 0x54442D18 */
+a0  =  7.72156649015328655494e-02, /* 0x3FB3C467, 0xE37DB0C8 */
+a1  =  3.22467033424113591611e-01, /* 0x3FD4A34C, 0xC4A60FAD */
+a2  =  6.73523010531292681824e-02, /* 0x3FB13E00, 0x1A5562A7 */
+a3  =  2.05808084325167332806e-02, /* 0x3F951322, 0xAC92547B */
+a4  =  7.38555086081402883957e-03, /* 0x3F7E404F, 0xB68FEFE8 */
+a5  =  2.89051383673415629091e-03, /* 0x3F67ADD8, 0xCCB7926B */
+a6  =  1.19270763183362067845e-03, /* 0x3F538A94, 0x116F3F5D */
+a7  =  5.10069792153511336608e-04, /* 0x3F40B6C6, 0x89B99C00 */
+a8  =  2.20862790713908385557e-04, /* 0x3F2CF2EC, 0xED10E54D */
+a9  =  1.08011567247583939954e-04, /* 0x3F1C5088, 0x987DFB07 */
+a10 =  2.52144565451257326939e-05, /* 0x3EFA7074, 0x428CFA52 */
+a11 =  4.48640949618915160150e-05, /* 0x3F07858E, 0x90A45837 */
+tc  =  1.46163214496836224576e+00, /* 0x3FF762D8, 0x6356BE3F */
+tf  = -1.21486290535849611461e-01, /* 0xBFBF19B9, 0xBCC38A42 */
+/* tt = -(tail of tf) */
+tt  = -3.63867699703950536541e-18, /* 0xBC50C7CA, 0xA48A971F */
+t0  =  4.83836122723810047042e-01, /* 0x3FDEF72B, 0xC8EE38A2 */
+t1  = -1.47587722994593911752e-01, /* 0xBFC2E427, 0x8DC6C509 */
+t2  =  6.46249402391333854778e-02, /* 0x3FB08B42, 0x94D5419B */
+t3  = -3.27885410759859649565e-02, /* 0xBFA0C9A8, 0xDF35B713 */
+t4  =  1.79706750811820387126e-02, /* 0x3F9266E7, 0x970AF9EC */
+t5  = -1.03142241298341437450e-02, /* 0xBF851F9F, 0xBA91EC6A */
+t6  =  6.10053870246291332635e-03, /* 0x3F78FCE0, 0xE370E344 */
+t7  = -3.68452016781138256760e-03, /* 0xBF6E2EFF, 0xB3E914D7 */
+t8  =  2.25964780900612472250e-03, /* 0x3F6282D3, 0x2E15C915 */
+t9  = -1.40346469989232843813e-03, /* 0xBF56FE8E, 0xBF2D1AF1 */
+t10 =  8.81081882437654011382e-04, /* 0x3F4CDF0C, 0xEF61A8E9 */
+t11 = -5.38595305356740546715e-04, /* 0xBF41A610, 0x9C73E0EC */
+t12 =  3.15632070903625950361e-04, /* 0x3F34AF6D, 0x6C0EBBF7 */
+t13 = -3.12754168375120860518e-04, /* 0xBF347F24, 0xECC38C38 */
+t14 =  3.35529192635519073543e-04, /* 0x3F35FD3E, 0xE8C2D3F4 */
+u0  = -7.72156649015328655494e-02, /* 0xBFB3C467, 0xE37DB0C8 */
+u1  =  6.32827064025093366517e-01, /* 0x3FE4401E, 0x8B005DFF */
+u2  =  1.45492250137234768737e+00, /* 0x3FF7475C, 0xD119BD6F */
+u3  =  9.77717527963372745603e-01, /* 0x3FEF4976, 0x44EA8450 */
+u4  =  2.28963728064692451092e-01, /* 0x3FCD4EAE, 0xF6010924 */
+u5  =  1.33810918536787660377e-02, /* 0x3F8B678B, 0xBF2BAB09 */
+v1  =  2.45597793713041134822e+00, /* 0x4003A5D7, 0xC2BD619C */
+v2  =  2.12848976379893395361e+00, /* 0x40010725, 0xA42B18F5 */
+v3  =  7.69285150456672783825e-01, /* 0x3FE89DFB, 0xE45050AF */
+v4  =  1.04222645593369134254e-01, /* 0x3FBAAE55, 0xD6537C88 */
+v5  =  3.21709242282423911810e-03, /* 0x3F6A5ABB, 0x57D0CF61 */
+s0  = -7.72156649015328655494e-02, /* 0xBFB3C467, 0xE37DB0C8 */
+s1  =  2.14982415960608852501e-01, /* 0x3FCB848B, 0x36E20878 */
+s2  =  3.25778796408930981787e-01, /* 0x3FD4D98F, 0x4F139F59 */
+s3  =  1.46350472652464452805e-01, /* 0x3FC2BB9C, 0xBEE5F2F7 */
+s4  =  2.66422703033638609560e-02, /* 0x3F9B481C, 0x7E939961 */
+s5  =  1.84028451407337715652e-03, /* 0x3F5E26B6, 0x7368F239 */
+s6  =  3.19475326584100867617e-05, /* 0x3F00BFEC, 0xDD17E945 */
+r1  =  1.39200533467621045958e+00, /* 0x3FF645A7, 0x62C4AB74 */
+r2  =  7.21935547567138069525e-01, /* 0x3FE71A18, 0x93D3DCDC */
+r3  =  1.71933865632803078993e-01, /* 0x3FC601ED, 0xCCFBDF27 */
+r4  =  1.86459191715652901344e-02, /* 0x3F9317EA, 0x742ED475 */
+r5  =  7.77942496381893596434e-04, /* 0x3F497DDA, 0xCA41A95B */
+r6  =  7.32668430744625636189e-06, /* 0x3EDEBAF7, 0xA5B38140 */
+w0  =  4.18938533204672725052e-01, /* 0x3FDACFE3, 0x90C97D69 */
+w1  =  8.33333333333329678849e-02, /* 0x3FB55555, 0x5555553B */
+w2  = -2.77777777728775536470e-03, /* 0xBF66C16C, 0x16B02E5C */
+w3  =  7.93650558643019558500e-04, /* 0x3F4A019F, 0x98CF38B6 */
+w4  = -5.95187557450339963135e-04, /* 0xBF4380CB, 0x8C0FE741 */
+w5  =  8.36339918996282139126e-04, /* 0x3F4B67BA, 0x4CDAD5D1 */
+w6  = -1.63092934096575273989e-03; /* 0xBF5AB89D, 0x0B9E43E4 */
+
+#ifdef __STDC__
+static const double zero=  0.00000000000000000000e+00;
+#else
+static double zero=  0.00000000000000000000e+00;
+#endif
+
+static
+#ifdef __GNUC__
+__inline__
+#endif
+#ifdef __STDC__
+	double sin_pi(double x)
+#else
+	double sin_pi(x)
+	double x;
+#endif
+{
+	double y,z;
+	int n,ix;
+
+	GET_HIGH_WORD(ix,x);
+	ix &= 0x7fffffff;
+
+	if(ix<0x3fd00000) return __kernel_sin(pi*x,zero,0);
+	y = -x;		/* x is assume negative */
+
+    /*
+     * argument reduction, make sure inexact flag not raised if input
+     * is an integer
+     */
+	z = floor(y);
+	if(z!=y) {				/* inexact anyway */
+	    y  *= 0.5;
+	    y   = 2.0*(y - floor(y));		/* y = |x| mod 2.0 */
+	    n   = (int) (y*4.0);
+	} else {
+            if(ix>=0x43400000) {
+                y = zero; n = 0;                 /* y must be even */
+            } else {
+                if(ix<0x43300000) z = y+two52;	/* exact */
+		GET_LOW_WORD(n,z);
+		n &= 1;
+                y  = n;
+                n<<= 2;
+            }
+        }
+	switch (n) {
+	    case 0:   y =  __kernel_sin(pi*y,zero,0); break;
+	    case 1:
+	    case 2:   y =  __kernel_cos(pi*(0.5-y),zero); break;
+	    case 3:
+	    case 4:   y =  __kernel_sin(pi*(one-y),zero,0); break;
+	    case 5:
+	    case 6:   y = -__kernel_cos(pi*(y-1.5),zero); break;
+	    default:  y =  __kernel_sin(pi*(y-2.0),zero,0); break;
+	    }
+	return -y;
+}
+
+
+#ifdef __STDC__
+	double __ieee754_lgamma_r(double x, int *signgamp)
+#else
+	double __ieee754_lgamma_r(x,signgamp)
+	double x; int *signgamp;
+#endif
+{
+	double t,y,z,nadj=0,p,p1,p2,p3,q,r,w;
+	int i,hx,lx,ix;
+
+	EXTRACT_WORDS(hx,lx,x);
+
+    /* purge off +-inf, NaN, +-0, and negative arguments */
+	*signgamp = 1;
+	ix = hx&0x7fffffff;
+	if(ix>=0x7ff00000) return x*x;
+	if((ix|lx)==0) return one/zero;
+	if(ix<0x3b900000) {	/* |x|<2**-70, return -log(|x|) */
+	    if(hx<0) {
+	        *signgamp = -1;
+	        return -__ieee754_log(-x);
+	    } else return -__ieee754_log(x);
+	}
+	if(hx<0) {
+	    if(ix>=0x43300000) 	/* |x|>=2**52, must be -integer */
+		return one/zero;
+	    t = sin_pi(x);
+	    if(t==zero) return one/zero; /* -integer */
+	    nadj = __ieee754_log(pi/fabs(t*x));
+	    if(t<zero) *signgamp = -1;
+	    x = -x;
+	}
+
+    /* purge off 1 and 2 */
+	if((((ix-0x3ff00000)|lx)==0)||(((ix-0x40000000)|lx)==0)) r = 0;
+    /* for x < 2.0 */
+	else if(ix<0x40000000) {
+	    if(ix<=0x3feccccc) { 	/* lgamma(x) = lgamma(x+1)-log(x) */
+		r = -__ieee754_log(x);
+		if(ix>=0x3FE76944) {y = one-x; i= 0;}
+		else if(ix>=0x3FCDA661) {y= x-(tc-one); i=1;}
+	  	else {y = x; i=2;}
+	    } else {
+	  	r = zero;
+	        if(ix>=0x3FFBB4C3) {y=2.0-x;i=0;} /* [1.7316,2] */
+	        else if(ix>=0x3FF3B4C4) {y=x-tc;i=1;} /* [1.23,1.73] */
+		else {y=x-one;i=2;}
+	    }
+	    switch(i) {
+	      case 0:
+		z = y*y;
+		p1 = a0+z*(a2+z*(a4+z*(a6+z*(a8+z*a10))));
+		p2 = z*(a1+z*(a3+z*(a5+z*(a7+z*(a9+z*a11)))));
+		p  = y*p1+p2;
+		r  += (p-0.5*y); break;
+	      case 1:
+		z = y*y;
+		w = z*y;
+		p1 = t0+w*(t3+w*(t6+w*(t9 +w*t12)));	/* parallel comp */
+		p2 = t1+w*(t4+w*(t7+w*(t10+w*t13)));
+		p3 = t2+w*(t5+w*(t8+w*(t11+w*t14)));
+		p  = z*p1-(tt-w*(p2+y*p3));
+		r += (tf + p); break;
+	      case 2:
+		p1 = y*(u0+y*(u1+y*(u2+y*(u3+y*(u4+y*u5)))));
+		p2 = one+y*(v1+y*(v2+y*(v3+y*(v4+y*v5))));
+		r += (-0.5*y + p1/p2);
+	    }
+	}
+	else if(ix<0x40200000) { 			/* x < 8.0 */
+	    i = (int)x;
+	    t = zero;
+	    y = x-(double)i;
+	    p = y*(s0+y*(s1+y*(s2+y*(s3+y*(s4+y*(s5+y*s6))))));
+	    q = one+y*(r1+y*(r2+y*(r3+y*(r4+y*(r5+y*r6)))));
+	    r = half*y+p/q;
+	    z = one;	/* lgamma(1+s) = log(s) + lgamma(s) */
+	    switch(i) {
+	    case 7: z *= (y+6.0);	/* FALLTHRU */
+	    case 6: z *= (y+5.0);	/* FALLTHRU */
+	    case 5: z *= (y+4.0);	/* FALLTHRU */
+	    case 4: z *= (y+3.0);	/* FALLTHRU */
+	    case 3: z *= (y+2.0);	/* FALLTHRU */
+		    r += __ieee754_log(z); break;
+	    }
+    /* 8.0 <= x < 2**58 */
+	} else if (ix < 0x43900000) {
+	    t = __ieee754_log(x);
+	    z = one/x;
+	    y = z*z;
+	    w = w0+z*(w1+y*(w2+y*(w3+y*(w4+y*(w5+y*w6)))));
+	    r = (x-half)*(t-one)+w;
+	} else
+    /* 2**58 <= x <= inf */
+	    r =  x*(__ieee754_log(x)-one);
+	if(hx<0) r = nadj - r;
+	return r;
+}
diff -urN dietlibc-0.30/libm/e_log.c dietlibc-0.30-libm/libm/e_log.c
--- dietlibc-0.30/libm/e_log.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_log.c	2006-06-25 11:20:02.000000000 +0000
@@ -0,0 +1,147 @@
+/* @(#)e_log.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: e_log.c,v 1.8 1995/05/10 20:45:49 jtc Exp $";
+#endif
+
+/* __ieee754_log(x)
+ * Return the logrithm of x
+ *
+ * Method :
+ *   1. Argument Reduction: find k and f such that
+ *			x = 2^k * (1+f),
+ *	   where  sqrt(2)/2 < 1+f < sqrt(2) .
+ *
+ *   2. Approximation of log(1+f).
+ *	Let s = f/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)
+ *		 = 2s + 2/3 s**3 + 2/5 s**5 + .....,
+ *	     	 = 2s + s*R
+ *      We use a special Reme algorithm on [0,0.1716] to generate
+ * 	a polynomial of degree 14 to approximate R The maximum error
+ *	of this polynomial approximation is bounded by 2**-58.45. In
+ *	other words,
+ *		        2      4      6      8      10      12      14
+ *	    R(z) ~ Lg1*s +Lg2*s +Lg3*s +Lg4*s +Lg5*s  +Lg6*s  +Lg7*s
+ *  	(the values of Lg1 to Lg7 are listed in the program)
+ *	and
+ *	    |      2          14          |     -58.45
+ *	    | Lg1*s +...+Lg7*s    -  R(z) | <= 2
+ *	    |                             |
+ *	Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f/2.
+ *	In order to guarantee error in log below 1ulp, we compute log
+ *	by
+ *		log(1+f) = f - s*(f - R)	(if f is not too large)
+ *		log(1+f) = f - (hfsq - s*(hfsq+R)).	(better accuracy)
+ *
+ *	3. Finally,  log(x) = k*ln2 + log(1+f).
+ *			    = k*ln2_hi+(f-(hfsq-(s*(hfsq+R)+k*ln2_lo)))
+ *	   Here ln2 is split into two floating point number:
+ *			ln2_hi + ln2_lo,
+ *	   where n*ln2_hi is always exact for |n| < 2000.
+ *
+ * Special cases:
+ *	log(x) is NaN with signal if x < 0 (including -INF) ;
+ *	log(+INF) is +INF; log(0) is -INF with signal;
+ *	log(NaN) is that NaN with no signal.
+ *
+ * Accuracy:
+ *	according to an error analysis, the error is always less than
+ *	1 ulp (unit in the last place).
+ *
+ * Constants:
+ * The hexadecimal values are the intended ones for the following
+ * constants. The decimal values may be used, provided that the
+ * compiler will convert from decimal to binary accurately enough
+ * to produce the hexadecimal values shown.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+ln2_hi  =  6.93147180369123816490e-01,	/* 3fe62e42 fee00000 */
+ln2_lo  =  1.90821492927058770002e-10,	/* 3dea39ef 35793c76 */
+two54   =  1.80143985094819840000e+16,  /* 43500000 00000000 */
+Lg1 = 6.666666666666735130e-01,  /* 3FE55555 55555593 */
+Lg2 = 3.999999999940941908e-01,  /* 3FD99999 9997FA04 */
+Lg3 = 2.857142874366239149e-01,  /* 3FD24924 94229359 */
+Lg4 = 2.222219843214978396e-01,  /* 3FCC71C5 1D8E78AF */
+Lg5 = 1.818357216161805012e-01,  /* 3FC74664 96CB03DE */
+Lg6 = 1.531383769920937332e-01,  /* 3FC39A09 D078C69F */
+Lg7 = 1.479819860511658591e-01;  /* 3FC2F112 DF3E5244 */
+
+#ifdef __STDC__
+static const double zero   =  0.0;
+#else
+static double zero   =  0.0;
+#endif
+
+#ifdef __STDC__
+	double __ieee754_log(double x)
+#else
+	double __ieee754_log(x)
+	double x;
+#endif
+{
+	double hfsq,f,s,z,R,w,t1,t2,dk;
+	int32_t k,hx,i,j;
+	u_int32_t lx;
+
+	EXTRACT_WORDS(hx,lx,x);
+
+	k=0;
+	if (hx < 0x00100000) {			/* x < 2**-1022  */
+	    if (((hx&0x7fffffff)|lx)==0)
+		return -two54/zero;		/* log(+-0)=-inf */
+	    if (hx<0) return (x-x)/zero;	/* log(-#) = NaN */
+	    k -= 54; x *= two54; /* subnormal number, scale up x */
+	    GET_HIGH_WORD(hx,x);
+	}
+	if (hx >= 0x7ff00000) return x+x;
+	k += (hx>>20)-1023;
+	hx &= 0x000fffff;
+	i = (hx+0x95f64)&0x100000;
+	SET_HIGH_WORD(x,hx|(i^0x3ff00000));	/* normalize x or x/2 */
+	k += (i>>20);
+	f = x-1.0;
+	if((0x000fffff&(2+hx))<3) {	/* |f| < 2**-20 */
+	    if(f==zero) {if(k==0) return zero;  else {dk=(double)k;
+				 return dk*ln2_hi+dk*ln2_lo;}
+	    }
+	    R = f*f*(0.5-0.33333333333333333*f);
+	    if(k==0) return f-R; else {dk=(double)k;
+	    	     return dk*ln2_hi-((R-dk*ln2_lo)-f);}
+	}
+ 	s = f/(2.0+f);
+	dk = (double)k;
+	z = s*s;
+	i = hx-0x6147a;
+	w = z*z;
+	j = 0x6b851-hx;
+	t1= w*(Lg2+w*(Lg4+w*Lg6));
+	t2= z*(Lg1+w*(Lg3+w*(Lg5+w*Lg7)));
+	i |= j;
+	R = t2+t1;
+	if(i>0) {
+	    hfsq=0.5*f*f;
+	    if(k==0) return f-(hfsq-s*(hfsq+R)); else
+		     return dk*ln2_hi-((hfsq-(s*(hfsq+R)+dk*ln2_lo))-f);
+	} else {
+	    if(k==0) return f-s*(f-R); else
+		     return dk*ln2_hi-((s*(f-R)-dk*ln2_lo)-f);
+	}
+}
diff -urN dietlibc-0.30/libm/e_log10.c dietlibc-0.30-libm/libm/e_log10.c
--- dietlibc-0.30/libm/e_log10.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_log10.c	2006-06-25 11:20:14.000000000 +0000
@@ -0,0 +1,98 @@
+/* @(#)e_log10.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: e_log10.c,v 1.9 1995/05/10 20:45:51 jtc Exp $";
+#endif
+
+/* __ieee754_log10(x)
+ * Return the base 10 logarithm of x
+ *
+ * Method :
+ *	Let log10_2hi = leading 40 bits of log10(2) and
+ *	    log10_2lo = log10(2) - log10_2hi,
+ *	    ivln10   = 1/log(10) rounded.
+ *	Then
+ *		n = ilogb(x),
+ *		if(n<0)  n = n+1;
+ *		x = scalbn(x,-n);
+ *		log10(x) := n*log10_2hi + (n*log10_2lo + ivln10*log(x))
+ *
+ * Note 1:
+ *	To guarantee log10(10**n)=n, where 10**n is normal, the rounding
+ *	mode must set to Round-to-Nearest.
+ * Note 2:
+ *	[1/log(10)] rounded to 53 bits has error  .198   ulps;
+ *	log10 is monotonic at all binary break points.
+ *
+ * Special cases:
+ *	log10(x) is NaN with signal if x < 0;
+ *	log10(+INF) is +INF with no signal; log10(0) is -INF with signal;
+ *	log10(NaN) is that NaN with no signal;
+ *	log10(10**N) = N  for N=0,1,...,22.
+ *
+ * Constants:
+ * The hexadecimal values are the intended ones for the following constants.
+ * The decimal values may be used, provided that the compiler will convert
+ * from decimal to binary accurately enough to produce the hexadecimal values
+ * shown.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+two54      =  1.80143985094819840000e+16, /* 0x43500000, 0x00000000 */
+ivln10     =  4.34294481903251816668e-01, /* 0x3FDBCB7B, 0x1526E50E */
+log10_2hi  =  3.01029995663611771306e-01, /* 0x3FD34413, 0x509F6000 */
+log10_2lo  =  3.69423907715893078616e-13; /* 0x3D59FEF3, 0x11F12B36 */
+
+#ifdef __STDC__
+static const double zero   =  0.0;
+#else
+static double zero   =  0.0;
+#endif
+
+#ifdef __STDC__
+	double __ieee754_log10(double x)
+#else
+	double __ieee754_log10(x)
+	double x;
+#endif
+{
+	double y,z;
+	int32_t i,k,hx;
+	u_int32_t lx;
+
+	EXTRACT_WORDS(hx,lx,x);
+
+        k=0;
+        if (hx < 0x00100000) {                  /* x < 2**-1022  */
+            if (((hx&0x7fffffff)|lx)==0)
+                return -two54/zero;             /* log(+-0)=-inf */
+            if (hx<0) return (x-x)/zero;        /* log(-#) = NaN */
+            k -= 54; x *= two54; /* subnormal number, scale up x */
+	    GET_HIGH_WORD(hx,x);
+        }
+	if (hx >= 0x7ff00000) return x+x;
+	k += (hx>>20)-1023;
+	i  = ((u_int32_t)k&0x80000000)>>31;
+        hx = (hx&0x000fffff)|((0x3ff-i)<<20);
+        y  = (double)(k+i);
+	SET_HIGH_WORD(x,hx);
+	z  = y*log10_2lo + ivln10*__ieee754_log(x);
+	return  z+y*log10_2hi;
+}
diff -urN dietlibc-0.30/libm/e_pow.c dietlibc-0.30-libm/libm/e_pow.c
--- dietlibc-0.30/libm/e_pow.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_pow.c	2006-06-25 11:20:02.000000000 +0000
@@ -0,0 +1,308 @@
+/* @(#)e_pow.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: e_pow.c,v 1.9 1995/05/12 04:57:32 jtc Exp $";
+#endif
+
+/* __ieee754_pow(x,y) return x**y
+ *
+ *		      n
+ * Method:  Let x =  2   * (1+f)
+ *	1. Compute and return log2(x) in two pieces:
+ *		log2(x) = w1 + w2,
+ *	   where w1 has 53-24 = 29 bit trailing zeros.
+ *	2. Perform y*log2(x) = n+y' by simulating muti-precision
+ *	   arithmetic, where |y'|<=0.5.
+ *	3. Return x**y = 2**n*exp(y'*log2)
+ *
+ * Special cases:
+ *	1.  (anything) ** 0  is 1
+ *	2.  (anything) ** 1  is itself
+ *	3.  (anything) ** NAN is NAN
+ *	4.  NAN ** (anything except 0) is NAN
+ *	5.  +-(|x| > 1) **  +INF is +INF
+ *	6.  +-(|x| > 1) **  -INF is +0
+ *	7.  +-(|x| < 1) **  +INF is +0
+ *	8.  +-(|x| < 1) **  -INF is +INF
+ *	9.  +-1         ** +-INF is NAN
+ *	10. +0 ** (+anything except 0, NAN)               is +0
+ *	11. -0 ** (+anything except 0, NAN, odd integer)  is +0
+ *	12. +0 ** (-anything except 0, NAN)               is +INF
+ *	13. -0 ** (-anything except 0, NAN, odd integer)  is +INF
+ *	14. -0 ** (odd integer) = -( +0 ** (odd integer) )
+ *	15. +INF ** (+anything except 0,NAN) is +INF
+ *	16. +INF ** (-anything except 0,NAN) is +0
+ *	17. -INF ** (anything)  = -0 ** (-anything)
+ *	18. (-anything) ** (integer) is (-1)**(integer)*(+anything**integer)
+ *	19. (-anything except 0 and inf) ** (non-integer) is NAN
+ *
+ * Accuracy:
+ *	pow(x,y) returns x**y nearly rounded. In particular
+ *			pow(integer,integer)
+ *	always returns the correct integer provided it is
+ *	representable.
+ *
+ * Constants :
+ * The hexadecimal values are the intended ones for the following
+ * constants. The decimal values may be used, provided that the
+ * compiler will convert from decimal to binary accurately enough
+ * to produce the hexadecimal values shown.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+bp[] = {1.0, 1.5,},
+dp_h[] = { 0.0, 5.84962487220764160156e-01,}, /* 0x3FE2B803, 0x40000000 */
+dp_l[] = { 0.0, 1.35003920212974897128e-08,}, /* 0x3E4CFDEB, 0x43CFD006 */
+zero    =  0.0,
+one	=  1.0,
+two	=  2.0,
+two53	=  9007199254740992.0,	/* 0x43400000, 0x00000000 */
+huge	=  1.0e300,
+tiny    =  1.0e-300,
+	/* poly coefs for (3/2)*(log(x)-2s-2/3*s**3 */
+L1  =  5.99999999999994648725e-01, /* 0x3FE33333, 0x33333303 */
+L2  =  4.28571428578550184252e-01, /* 0x3FDB6DB6, 0xDB6FABFF */
+L3  =  3.33333329818377432918e-01, /* 0x3FD55555, 0x518F264D */
+L4  =  2.72728123808534006489e-01, /* 0x3FD17460, 0xA91D4101 */
+L5  =  2.30660745775561754067e-01, /* 0x3FCD864A, 0x93C9DB65 */
+L6  =  2.06975017800338417784e-01, /* 0x3FCA7E28, 0x4A454EEF */
+P1   =  1.66666666666666019037e-01, /* 0x3FC55555, 0x5555553E */
+P2   = -2.77777777770155933842e-03, /* 0xBF66C16C, 0x16BEBD93 */
+P3   =  6.61375632143793436117e-05, /* 0x3F11566A, 0xAF25DE2C */
+P4   = -1.65339022054652515390e-06, /* 0xBEBBBD41, 0xC5D26BF1 */
+P5   =  4.13813679705723846039e-08, /* 0x3E663769, 0x72BEA4D0 */
+lg2  =  6.93147180559945286227e-01, /* 0x3FE62E42, 0xFEFA39EF */
+lg2_h  =  6.93147182464599609375e-01, /* 0x3FE62E43, 0x00000000 */
+lg2_l  = -1.90465429995776804525e-09, /* 0xBE205C61, 0x0CA86C39 */
+ovt =  8.0085662595372944372e-0017, /* -(1024-log2(ovfl+.5ulp)) */
+cp    =  9.61796693925975554329e-01, /* 0x3FEEC709, 0xDC3A03FD =2/(3ln2) */
+cp_h  =  9.61796700954437255859e-01, /* 0x3FEEC709, 0xE0000000 =(float)cp */
+cp_l  = -7.02846165095275826516e-09, /* 0xBE3E2FE0, 0x145B01F5 =tail of cp_h*/
+ivln2    =  1.44269504088896338700e+00, /* 0x3FF71547, 0x652B82FE =1/ln2 */
+ivln2_h  =  1.44269502162933349609e+00, /* 0x3FF71547, 0x60000000 =24b 1/ln2*/
+ivln2_l  =  1.92596299112661746887e-08; /* 0x3E54AE0B, 0xF85DDF44 =1/ln2 tail*/
+
+#ifdef __STDC__
+	double __ieee754_pow(double x, double y)
+#else
+	double __ieee754_pow(x,y)
+	double x, y;
+#endif
+{
+	double z,ax,z_h,z_l,p_h,p_l;
+	double y1,t1,t2,r,s,t,u,v,w;
+	int32_t i,j,k,yisint,n;
+	int32_t hx,hy,ix,iy;
+	u_int32_t lx,ly;
+
+	EXTRACT_WORDS(hx,lx,x);
+	EXTRACT_WORDS(hy,ly,y);
+	ix = hx&0x7fffffff;  iy = hy&0x7fffffff;
+
+    /* y==zero: x**0 = 1 */
+	if((iy|ly)==0) return one;
+
+    /* +-NaN return x+y */
+	if(ix > 0x7ff00000 || ((ix==0x7ff00000)&&(lx!=0)) ||
+	   iy > 0x7ff00000 || ((iy==0x7ff00000)&&(ly!=0)))
+		return x+y;
+
+    /* determine if y is an odd int when x < 0
+     * yisint = 0	... y is not an integer
+     * yisint = 1	... y is an odd int
+     * yisint = 2	... y is an even int
+     */
+	yisint  = 0;
+	if(hx<0) {
+	    if(iy>=0x43400000) yisint = 2; /* even integer y */
+	    else if(iy>=0x3ff00000) {
+		k = (iy>>20)-0x3ff;	   /* exponent */
+		if(k>20) {
+		    j = ly>>(52-k);
+		    if((j<<(52-k))==ly) yisint = 2-(j&1);
+		} else if(ly==0) {
+		    j = iy>>(20-k);
+		    if((j<<(20-k))==iy) yisint = 2-(j&1);
+		}
+	    }
+	}
+
+    /* special value of y */
+	if(ly==0) {
+	    if (iy==0x7ff00000) {	/* y is +-inf */
+	        if(((ix-0x3ff00000)|lx)==0)
+		    return  y - y;	/* inf**+-1 is NaN */
+	        else if (ix >= 0x3ff00000)/* (|x|>1)**+-inf = inf,0 */
+		    return (hy>=0)? y: zero;
+	        else			/* (|x|<1)**-,+inf = inf,0 */
+		    return (hy<0)?-y: zero;
+	    }
+	    if(iy==0x3ff00000) {	/* y is  +-1 */
+		if(hy<0) return one/x; else return x;
+	    }
+	    if(hy==0x40000000) return x*x; /* y is  2 */
+	    if(hy==0x3fe00000) {	/* y is  0.5 */
+		if(hx>=0)	/* x >= +0 */
+		return __ieee754_sqrt(x);
+	    }
+	}
+
+	ax   = fabs(x);
+    /* special value of x */
+	if(lx==0) {
+	    if(ix==0x7ff00000||ix==0||ix==0x3ff00000){
+		z = ax;			/*x is +-0,+-inf,+-1*/
+		if(hy<0) z = one/z;	/* z = (1/|x|) */
+		if(hx<0) {
+		    if(((ix-0x3ff00000)|yisint)==0) {
+			z = (z-z)/(z-z); /* (-1)**non-int is NaN */
+		    } else if(yisint==1)
+			z = -z;		/* (x<0)**odd = -(|x|**odd) */
+		}
+		return z;
+	    }
+	}
+
+    /* (x<0)**(non-int) is NaN */
+	if(((((u_int32_t)hx>>31)-1)|yisint)==0) return (x-x)/(x-x);
+
+    /* |y| is huge */
+	if(iy>0x41e00000) { /* if |y| > 2**31 */
+	    if(iy>0x43f00000){	/* if |y| > 2**64, must o/uflow */
+		if(ix<=0x3fefffff) return (hy<0)? huge*huge:tiny*tiny;
+		if(ix>=0x3ff00000) return (hy>0)? huge*huge:tiny*tiny;
+	    }
+	/* over/underflow if x is not close to one */
+	    if(ix<0x3fefffff) return (hy<0)? huge*huge:tiny*tiny;
+	    if(ix>0x3ff00000) return (hy>0)? huge*huge:tiny*tiny;
+	/* now |1-x| is tiny <= 2**-20, suffice to compute
+	   log(x) by x-x^2/2+x^3/3-x^4/4 */
+	    t = x-1;		/* t has 20 trailing zeros */
+	    w = (t*t)*(0.5-t*(0.3333333333333333333333-t*0.25));
+	    u = ivln2_h*t;	/* ivln2_h has 21 sig. bits */
+	    v = t*ivln2_l-w*ivln2;
+	    t1 = u+v;
+	    SET_LOW_WORD(t1,0);
+	    t2 = v-(t1-u);
+	} else {
+	    double s2,s_h,s_l,t_h,t_l;
+	    n = 0;
+	/* take care subnormal number */
+	    if(ix<0x00100000)
+		{ax *= two53; n -= 53; GET_HIGH_WORD(ix,ax); }
+	    n  += ((ix)>>20)-0x3ff;
+	    j  = ix&0x000fffff;
+	/* determine interval */
+	    ix = j|0x3ff00000;		/* normalize ix */
+	    if(j<=0x3988E) k=0;		/* |x|<sqrt(3/2) */
+	    else if(j<0xBB67A) k=1;	/* |x|<sqrt(3)   */
+	    else {k=0;n+=1;ix -= 0x00100000;}
+	    SET_HIGH_WORD(ax,ix);
+
+	/* compute s = s_h+s_l = (x-1)/(x+1) or (x-1.5)/(x+1.5) */
+	    u = ax-bp[k];		/* bp[0]=1.0, bp[1]=1.5 */
+	    v = one/(ax+bp[k]);
+	    s = u*v;
+	    s_h = s;
+	    SET_LOW_WORD(s_h,0);
+	/* t_h=ax+bp[k] High */
+	    t_h = zero;
+	    SET_HIGH_WORD(t_h,((ix>>1)|0x20000000)+0x00080000+(k<<18));
+	    t_l = ax - (t_h-bp[k]);
+	    s_l = v*((u-s_h*t_h)-s_h*t_l);
+	/* compute log(ax) */
+	    s2 = s*s;
+	    r = s2*s2*(L1+s2*(L2+s2*(L3+s2*(L4+s2*(L5+s2*L6)))));
+	    r += s_l*(s_h+s);
+	    s2  = s_h*s_h;
+	    t_h = 3.0+s2+r;
+	    SET_LOW_WORD(t_h,0);
+	    t_l = r-((t_h-3.0)-s2);
+	/* u+v = s*(1+...) */
+	    u = s_h*t_h;
+	    v = s_l*t_h+t_l*s;
+	/* 2/(3log2)*(s+...) */
+	    p_h = u+v;
+	    SET_LOW_WORD(p_h,0);
+	    p_l = v-(p_h-u);
+	    z_h = cp_h*p_h;		/* cp_h+cp_l = 2/(3*log2) */
+	    z_l = cp_l*p_h+p_l*cp+dp_l[k];
+	/* log2(ax) = (s+..)*2/(3*log2) = n + dp_h + z_h + z_l */
+	    t = (double)n;
+	    t1 = (((z_h+z_l)+dp_h[k])+t);
+	    SET_LOW_WORD(t1,0);
+	    t2 = z_l-(((t1-t)-dp_h[k])-z_h);
+	}
+
+	s = one; /* s (sign of result -ve**odd) = -1 else = 1 */
+	if(((((u_int32_t)hx>>31)-1)|(yisint-1))==0)
+	    s = -one;/* (-ve)**(odd int) */
+
+    /* split up y into y1+y2 and compute (y1+y2)*(t1+t2) */
+	y1  = y;
+	SET_LOW_WORD(y1,0);
+	p_l = (y-y1)*t1+y*t2;
+	p_h = y1*t1;
+	z = p_l+p_h;
+	EXTRACT_WORDS(j,i,z);
+	if (j>=0x40900000) {				/* z >= 1024 */
+	    if(((j-0x40900000)|i)!=0)			/* if z > 1024 */
+		return s*huge*huge;			/* overflow */
+	    else {
+		if(p_l+ovt>z-p_h) return s*huge*huge;	/* overflow */
+	    }
+	} else if((j&0x7fffffff)>=0x4090cc00 ) {	/* z <= -1075 */
+	    if(((j-0xc090cc00)|i)!=0) 		/* z < -1075 */
+		return s*tiny*tiny;		/* underflow */
+	    else {
+		if(p_l<=z-p_h) return s*tiny*tiny;	/* underflow */
+	    }
+	}
+    /*
+     * compute 2**(p_h+p_l)
+     */
+	i = j&0x7fffffff;
+	k = (i>>20)-0x3ff;
+	n = 0;
+	if(i>0x3fe00000) {		/* if |z| > 0.5, set n = [z+0.5] */
+	    n = j+(0x00100000>>(k+1));
+	    k = ((n&0x7fffffff)>>20)-0x3ff;	/* new k for n */
+	    t = zero;
+	    SET_HIGH_WORD(t,n&~(0x000fffff>>k));
+	    n = ((n&0x000fffff)|0x00100000)>>(20-k);
+	    if(j<0) n = -n;
+	    p_h -= t;
+	}
+	t = p_l+p_h;
+	SET_LOW_WORD(t,0);
+	u = t*lg2_h;
+	v = (p_l-(t-p_h))*lg2+t*lg2_l;
+	z = u+v;
+	w = v-(z-u);
+	t  = z*z;
+	t1  = z - t*(P1+t*(P2+t*(P3+t*(P4+t*P5))));
+	r  = (z*t1)/(t1-two)-(w+z*w);
+	z  = one-(r-z);
+	GET_HIGH_WORD(j,z);
+	j += (n<<20);
+	if((j>>20)<=0) z = scalbn(z,n);	/* subnormal output */
+	else SET_HIGH_WORD(z,j);
+	return s*z;
+}
diff -urN dietlibc-0.30/libm/e_rem_pio2.c dietlibc-0.30-libm/libm/e_rem_pio2.c
--- dietlibc-0.30/libm/e_rem_pio2.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_rem_pio2.c	2006-06-25 11:20:15.000000000 +0000
@@ -0,0 +1,183 @@
+/* @(#)e_rem_pio2.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: e_rem_pio2.c,v 1.8 1995/05/10 20:46:02 jtc Exp $";
+#endif
+
+/* __ieee754_rem_pio2(x,y)
+ *
+ * return the remainder of x rem pi/2 in y[0]+y[1]
+ * use __kernel_rem_pio2()
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+/*
+ * Table of constants for 2/pi, 396 Hex digits (476 decimal) of 2/pi
+ */
+#ifdef __STDC__
+static const int32_t two_over_pi[] = {
+#else
+static int32_t two_over_pi[] = {
+#endif
+0xA2F983, 0x6E4E44, 0x1529FC, 0x2757D1, 0xF534DD, 0xC0DB62,
+0x95993C, 0x439041, 0xFE5163, 0xABDEBB, 0xC561B7, 0x246E3A,
+0x424DD2, 0xE00649, 0x2EEA09, 0xD1921C, 0xFE1DEB, 0x1CB129,
+0xA73EE8, 0x8235F5, 0x2EBB44, 0x84E99C, 0x7026B4, 0x5F7E41,
+0x3991D6, 0x398353, 0x39F49C, 0x845F8B, 0xBDF928, 0x3B1FF8,
+0x97FFDE, 0x05980F, 0xEF2F11, 0x8B5A0A, 0x6D1F6D, 0x367ECF,
+0x27CB09, 0xB74F46, 0x3F669E, 0x5FEA2D, 0x7527BA, 0xC7EBE5,
+0xF17B3D, 0x0739F7, 0x8A5292, 0xEA6BFB, 0x5FB11F, 0x8D5D08,
+0x560330, 0x46FC7B, 0x6BABF0, 0xCFBC20, 0x9AF436, 0x1DA9E3,
+0x91615E, 0xE61B08, 0x659985, 0x5F14A0, 0x68408D, 0xFFD880,
+0x4D7327, 0x310606, 0x1556CA, 0x73A8C9, 0x60E27B, 0xC08C6B,
+};
+
+#ifdef __STDC__
+static const int32_t npio2_hw[] = {
+#else
+static int32_t npio2_hw[] = {
+#endif
+0x3FF921FB, 0x400921FB, 0x4012D97C, 0x401921FB, 0x401F6A7A, 0x4022D97C,
+0x4025FDBB, 0x402921FB, 0x402C463A, 0x402F6A7A, 0x4031475C, 0x4032D97C,
+0x40346B9C, 0x4035FDBB, 0x40378FDB, 0x403921FB, 0x403AB41B, 0x403C463A,
+0x403DD85A, 0x403F6A7A, 0x40407E4C, 0x4041475C, 0x4042106C, 0x4042D97C,
+0x4043A28C, 0x40446B9C, 0x404534AC, 0x4045FDBB, 0x4046C6CB, 0x40478FDB,
+0x404858EB, 0x404921FB,
+};
+
+/*
+ * invpio2:  53 bits of 2/pi
+ * pio2_1:   first  33 bit of pi/2
+ * pio2_1t:  pi/2 - pio2_1
+ * pio2_2:   second 33 bit of pi/2
+ * pio2_2t:  pi/2 - (pio2_1+pio2_2)
+ * pio2_3:   third  33 bit of pi/2
+ * pio2_3t:  pi/2 - (pio2_1+pio2_2+pio2_3)
+ */
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+zero =  0.00000000000000000000e+00, /* 0x00000000, 0x00000000 */
+half =  5.00000000000000000000e-01, /* 0x3FE00000, 0x00000000 */
+two24 =  1.67772160000000000000e+07, /* 0x41700000, 0x00000000 */
+invpio2 =  6.36619772367581382433e-01, /* 0x3FE45F30, 0x6DC9C883 */
+pio2_1  =  1.57079632673412561417e+00, /* 0x3FF921FB, 0x54400000 */
+pio2_1t =  6.07710050650619224932e-11, /* 0x3DD0B461, 0x1A626331 */
+pio2_2  =  6.07710050630396597660e-11, /* 0x3DD0B461, 0x1A600000 */
+pio2_2t =  2.02226624879595063154e-21, /* 0x3BA3198A, 0x2E037073 */
+pio2_3  =  2.02226624871116645580e-21, /* 0x3BA3198A, 0x2E000000 */
+pio2_3t =  8.47842766036889956997e-32; /* 0x397B839A, 0x252049C1 */
+
+#ifdef __STDC__
+	int32_t __ieee754_rem_pio2(double x, double *y)
+#else
+	int32_t __ieee754_rem_pio2(x,y)
+	double x,y[];
+#endif
+{
+	double z=0.0,w,t,r,fn;
+	double tx[3];
+	int32_t e0,i,j,nx,n,ix,hx;
+	u_int32_t low;
+
+	GET_HIGH_WORD(hx,x);		/* high word of x */
+	ix = hx&0x7fffffff;
+	if(ix<=0x3fe921fb)   /* |x| ~<= pi/4 , no need for reduction */
+	    {y[0] = x; y[1] = 0; return 0;}
+	if(ix<0x4002d97c) {  /* |x| < 3pi/4, special case with n=+-1 */
+	    if(hx>0) {
+		z = x - pio2_1;
+		if(ix!=0x3ff921fb) { 	/* 33+53 bit pi is good enough */
+		    y[0] = z - pio2_1t;
+		    y[1] = (z-y[0])-pio2_1t;
+		} else {		/* near pi/2, use 33+33+53 bit pi */
+		    z -= pio2_2;
+		    y[0] = z - pio2_2t;
+		    y[1] = (z-y[0])-pio2_2t;
+		}
+		return 1;
+	    } else {	/* negative x */
+		z = x + pio2_1;
+		if(ix!=0x3ff921fb) { 	/* 33+53 bit pi is good enough */
+		    y[0] = z + pio2_1t;
+		    y[1] = (z-y[0])+pio2_1t;
+		} else {		/* near pi/2, use 33+33+53 bit pi */
+		    z += pio2_2;
+		    y[0] = z + pio2_2t;
+		    y[1] = (z-y[0])+pio2_2t;
+		}
+		return -1;
+	    }
+	}
+	if(ix<=0x413921fb) { /* |x| ~<= 2^19*(pi/2), medium size */
+	    t  = fabs(x);
+	    n  = (int32_t) (t*invpio2+half);
+	    fn = (double)n;
+	    r  = t-fn*pio2_1;
+	    w  = fn*pio2_1t;	/* 1st round good to 85 bit */
+	    if(n<32&&ix!=npio2_hw[n-1]) {
+		y[0] = r-w;	/* quick check no cancellation */
+	    } else {
+	        u_int32_t high;
+	        j  = ix>>20;
+	        y[0] = r-w;
+		GET_HIGH_WORD(high,y[0]);
+	        i = j-((high>>20)&0x7ff);
+	        if(i>16) {  /* 2nd iteration needed, good to 118 */
+		    t  = r;
+		    w  = fn*pio2_2;
+		    r  = t-w;
+		    w  = fn*pio2_2t-((t-r)-w);
+		    y[0] = r-w;
+		    GET_HIGH_WORD(high,y[0]);
+		    i = j-((high>>20)&0x7ff);
+		    if(i>49)  {	/* 3rd iteration need, 151 bits acc */
+		    	t  = r;	/* will cover all possible cases */
+		    	w  = fn*pio2_3;
+		    	r  = t-w;
+		    	w  = fn*pio2_3t-((t-r)-w);
+		    	y[0] = r-w;
+		    }
+		}
+	    }
+	    y[1] = (r-y[0])-w;
+	    if(hx<0) 	{y[0] = -y[0]; y[1] = -y[1]; return -n;}
+	    else	 return n;
+	}
+    /*
+     * all other (large) arguments
+     */
+	if(ix>=0x7ff00000) {		/* x is inf or NaN */
+	    y[0]=y[1]=x-x; return 0;
+	}
+    /* set z = scalbn(|x|,ilogb(x)-23) */
+	GET_LOW_WORD(low,x);
+	SET_LOW_WORD(z,low);
+	e0 	= (ix>>20)-1046;	/* e0 = ilogb(z)-23; */
+	SET_HIGH_WORD(z, ix - ((int32_t)(e0<<20)));
+	for(i=0;i<2;i++) {
+		tx[i] = (double)((int32_t)(z));
+		z     = (z-tx[i])*two24;
+	}
+	tx[2] = z;
+	nx = 3;
+	while(tx[nx-1]==zero) nx--;	/* skip zero term */
+	n  =  __kernel_rem_pio2(tx,y,e0,nx,2,two_over_pi);
+	if(hx<0) {y[0] = -y[0]; y[1] = -y[1]; return -n;}
+	return n;
+}
diff -urN dietlibc-0.30/libm/e_remainder.c dietlibc-0.30-libm/libm/e_remainder.c
--- dietlibc-0.30/libm/e_remainder.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_remainder.c	2006-06-25 11:20:04.000000000 +0000
@@ -0,0 +1,80 @@
+/* @(#)e_remainder.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: e_remainder.c,v 1.8 1995/05/10 20:46:05 jtc Exp $";
+#endif
+
+/* __ieee754_remainder(x,p)
+ * Return :
+ * 	returns  x REM p  =  x - [x/p]*p as if in infinite
+ * 	precise arithmetic, where [x/p] is the (infinite bit)
+ *	integer nearest x/p (in half way case choose the even one).
+ * Method :
+ *	Based on fmod() return x-[x/p]chopped*p exactlp.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double zero = 0.0;
+#else
+static double zero = 0.0;
+#endif
+
+
+#ifdef __STDC__
+	double __ieee754_remainder(double x, double p)
+#else
+	double __ieee754_remainder(x,p)
+	double x,p;
+#endif
+{
+	int32_t hx,hp;
+	u_int32_t sx,lx,lp;
+	double p_half;
+
+	EXTRACT_WORDS(hx,lx,x);
+	EXTRACT_WORDS(hp,lp,p);
+	sx = hx&0x80000000;
+	hp &= 0x7fffffff;
+	hx &= 0x7fffffff;
+
+    /* purge off exception values */
+	if((hp|lp)==0) return (x*p)/(x*p); 	/* p = 0 */
+	if((hx>=0x7ff00000)||			/* x not finite */
+	  ((hp>=0x7ff00000)&&			/* p is NaN */
+	  (((hp-0x7ff00000)|lp)!=0)))
+	    return (x*p)/(x*p);
+
+
+	if (hp<=0x7fdfffff) x = __ieee754_fmod(x,p+p);	/* now x < 2p */
+	if (((hx-hp)|(lx-lp))==0) return zero*x;
+	x  = fabs(x);
+	p  = fabs(p);
+	if (hp<0x00200000) {
+	    if(x+x>p) {
+		x-=p;
+		if(x+x>=p) x -= p;
+	    }
+	} else {
+	    p_half = 0.5*p;
+	    if(x>p_half) {
+		x-=p;
+		if(x>=p_half) x -= p;
+	    }
+	}
+	GET_HIGH_WORD(hx,x);
+	SET_HIGH_WORD(x,hx^sx);
+	return x;
+}
diff -urN dietlibc-0.30/libm/e_scalb.c dietlibc-0.30-libm/libm/e_scalb.c
--- dietlibc-0.30/libm/e_scalb.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_scalb.c	2006-06-25 11:20:10.000000000 +0000
@@ -0,0 +1,55 @@
+/* @(#)e_scalb.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: e_scalb.c,v 1.6 1995/05/10 20:46:09 jtc Exp $";
+#endif
+
+/*
+ * __ieee754_scalb(x, fn) is provide for
+ * passing various standard test suite. One
+ * should use scalbn() instead.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef _SCALB_INT
+#ifdef __STDC__
+	double __ieee754_scalb(double x, int fn)
+#else
+	double __ieee754_scalb(x,fn)
+	double x; int fn;
+#endif
+#else
+#ifdef __STDC__
+	double __ieee754_scalb(double x, double fn)
+#else
+	double __ieee754_scalb(x,fn)
+	double x, fn;
+#endif
+#endif
+{
+#ifdef _SCALB_INT
+	return scalbn(x,fn);
+#else
+	if (isnan(x)||isnan(fn)) return x*fn;
+	if (!finite(fn)) {
+	    if(fn>0.0) return x*fn;
+	    else       return x/(-fn);
+	}
+	if (rint(fn)!=fn) return (fn-fn)/(fn-fn);
+	if ( fn > 65000.0) return scalbn(x, 65000);
+	if (-fn > 65000.0) return scalbn(x,-65000);
+	return scalbn(x,(int)fn);
+#endif
+}
diff -urN dietlibc-0.30/libm/e_sinh.c dietlibc-0.30-libm/libm/e_sinh.c
--- dietlibc-0.30/libm/e_sinh.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_sinh.c	2006-06-25 11:20:10.000000000 +0000
@@ -0,0 +1,86 @@
+/* @(#)e_sinh.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: e_sinh.c,v 1.7 1995/05/10 20:46:13 jtc Exp $";
+#endif
+
+/* __ieee754_sinh(x)
+ * Method :
+ * mathematically sinh(x) if defined to be (exp(x)-exp(-x))/2
+ *	1. Replace x by |x| (sinh(-x) = -sinh(x)).
+ *	2.
+ *		                                    E + E/(E+1)
+ *	    0        <= x <= 22     :  sinh(x) := --------------, E=expm1(x)
+ *			       			        2
+ *
+ *	    22       <= x <= lnovft :  sinh(x) := exp(x)/2
+ *	    lnovft   <= x <= ln2ovft:  sinh(x) := exp(x/2)/2 * exp(x/2)
+ *	    ln2ovft  <  x	    :  sinh(x) := x*shuge (overflow)
+ *
+ * Special cases:
+ *	sinh(x) is |x| if x is +INF, -INF, or NaN.
+ *	only sinh(0)=0 is exact for finite x.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double one = 1.0, shuge = 1.0e307;
+#else
+static double one = 1.0, shuge = 1.0e307;
+#endif
+
+#ifdef __STDC__
+	double __ieee754_sinh(double x)
+#else
+	double __ieee754_sinh(x)
+	double x;
+#endif
+{
+	double t,w,h;
+	int32_t ix,jx;
+	u_int32_t lx;
+
+    /* High word of |x|. */
+	GET_HIGH_WORD(jx,x);
+	ix = jx&0x7fffffff;
+
+    /* x is INF or NaN */
+	if(ix>=0x7ff00000) return x+x;
+
+	h = 0.5;
+	if (jx<0) h = -h;
+    /* |x| in [0,22], return sign(x)*0.5*(E+E/(E+1))) */
+	if (ix < 0x40360000) {		/* |x|<22 */
+	    if (ix<0x3e300000) 		/* |x|<2**-28 */
+		if(shuge+x>one) return x;/* sinh(tiny) = tiny with inexact */
+	    t = expm1(fabs(x));
+	    if(ix<0x3ff00000) return h*(2.0*t-t*t/(t+one));
+	    return h*(t+t/(t+one));
+	}
+
+    /* |x| in [22, log(maxdouble)] return 0.5*exp(|x|) */
+	if (ix < 0x40862E42)  return h*__ieee754_exp(fabs(x));
+
+    /* |x| in [log(maxdouble), overflowthresold] */
+	GET_LOW_WORD(lx,x);
+	if (ix<0x408633CE || ((ix==0x408633ce)&&(lx<=(u_int32_t)0x8fb9f87d))) {
+	    w = __ieee754_exp(0.5*fabs(x));
+	    t = h*w;
+	    return t*w;
+	}
+
+    /* |x| > overflowthresold, sinh(x) overflow */
+	return x*shuge;
+}
diff -urN dietlibc-0.30/libm/e_sqrt.c dietlibc-0.30-libm/libm/e_sqrt.c
--- dietlibc-0.30/libm/e_sqrt.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/e_sqrt.c	2006-06-25 11:20:12.000000000 +0000
@@ -0,0 +1,453 @@
+/* @(#)e_sqrt.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: e_sqrt.c,v 1.8 1995/05/10 20:46:17 jtc Exp $";
+#endif
+
+/* __ieee754_sqrt(x)
+ * Return correctly rounded sqrt.
+ *           ------------------------------------------
+ *	     |  Use the hardware sqrt if you have one |
+ *           ------------------------------------------
+ * Method:
+ *   Bit by bit method using integer arithmetic. (Slow, but portable)
+ *   1. Normalization
+ *	Scale x to y in [1,4) with even powers of 2:
+ *	find an integer k such that  1 <= (y=x*2^(2k)) < 4, then
+ *		sqrt(x) = 2^k * sqrt(y)
+ *   2. Bit by bit computation
+ *	Let q  = sqrt(y) truncated to i bit after binary point (q = 1),
+ *	     i							 0
+ *                                     i+1         2
+ *	    s  = 2*q , and	y  =  2   * ( y - q  ).		(1)
+ *	     i      i            i                 i
+ *
+ *	To compute q    from q , one checks whether
+ *		    i+1       i
+ *
+ *			      -(i+1) 2
+ *			(q + 2      ) <= y.			(2)
+ *     			  i
+ *							      -(i+1)
+ *	If (2) is false, then q   = q ; otherwise q   = q  + 2      .
+ *		 	       i+1   i             i+1   i
+ *
+ *	With some algebric manipulation, it is not difficult to see
+ *	that (2) is equivalent to
+ *                             -(i+1)
+ *			s  +  2       <= y			(3)
+ *			 i                i
+ *
+ *	The advantage of (3) is that s  and y  can be computed by
+ *				      i      i
+ *	the following recurrence formula:
+ *	    if (3) is false
+ *
+ *	    s     =  s  ,	y    = y   ;			(4)
+ *	     i+1      i		 i+1    i
+ *
+ *	    otherwise,
+ *                         -i                     -(i+1)
+ *	    s	  =  s  + 2  ,  y    = y  -  s  - 2  		(5)
+ *           i+1      i          i+1    i     i
+ *
+ *	One may easily use induction to prove (4) and (5).
+ *	Note. Since the left hand side of (3) contain only i+2 bits,
+ *	      it does not necessary to do a full (53-bit) comparison
+ *	      in (3).
+ *   3. Final rounding
+ *	After generating the 53 bits result, we compute one more bit.
+ *	Together with the remainder, we can decide whether the
+ *	result is exact, bigger than 1/2ulp, or less than 1/2ulp
+ *	(it will never equal to 1/2ulp).
+ *	The rounding mode can be detected by checking whether
+ *	huge + tiny is equal to huge, and whether huge - tiny is
+ *	equal to huge for some floating point number "huge" and "tiny".
+ *
+ * Special cases:
+ *	sqrt(+-0) = +-0 	... exact
+ *	sqrt(inf) = inf
+ *	sqrt(-ve) = NaN		... with invalid signal
+ *	sqrt(NaN) = NaN		... with invalid signal for signaling NaN
+ *
+ * Other methods : see the appended file at the end of the program below.
+ *---------------
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static	const double	one	= 1.0, tiny=1.0e-300;
+#else
+static	double	one	= 1.0, tiny=1.0e-300;
+#endif
+
+#ifdef __STDC__
+	double __ieee754_sqrt(double x)
+#else
+	double __ieee754_sqrt(x)
+	double x;
+#endif
+{
+	double z;
+	int32_t sign = (int)0x80000000;
+	int32_t ix0,s0,q,m,t,i;
+	u_int32_t r,t1,s1,ix1,q1;
+
+	EXTRACT_WORDS(ix0,ix1,x);
+
+    /* take care of Inf and NaN */
+	if((ix0&0x7ff00000)==0x7ff00000) {
+	    return x*x+x;		/* sqrt(NaN)=NaN, sqrt(+inf)=+inf
+					   sqrt(-inf)=sNaN */
+	}
+    /* take care of zero */
+	if(ix0<=0) {
+	    if(((ix0&(~sign))|ix1)==0) return x;/* sqrt(+-0) = +-0 */
+	    else if(ix0<0)
+		return (x-x)/(x-x);		/* sqrt(-ve) = sNaN */
+	}
+    /* normalize x */
+	m = (ix0>>20);
+	if(m==0) {				/* subnormal x */
+	    while(ix0==0) {
+		m -= 21;
+		ix0 |= (ix1>>11); ix1 <<= 21;
+	    }
+	    for(i=0;(ix0&0x00100000)==0;i++) ix0<<=1;
+	    m -= i-1;
+	    ix0 |= (ix1>>(32-i));
+	    ix1 <<= i;
+	}
+	m -= 1023;	/* unbias exponent */
+	ix0 = (ix0&0x000fffff)|0x00100000;
+	if(m&1){	/* odd m, double x to make it even */
+	    ix0 += ix0 + ((ix1&sign)>>31);
+	    ix1 += ix1;
+	}
+	m >>= 1;	/* m = [m/2] */
+
+    /* generate sqrt(x) bit by bit */
+	ix0 += ix0 + ((ix1&sign)>>31);
+	ix1 += ix1;
+	q = q1 = s0 = s1 = 0;	/* [q,q1] = sqrt(x) */
+	r = 0x00200000;		/* r = moving bit from right to left */
+
+	while(r!=0) {
+	    t = s0+r;
+	    if(t<=ix0) {
+		s0   = t+r;
+		ix0 -= t;
+		q   += r;
+	    }
+	    ix0 += ix0 + ((ix1&sign)>>31);
+	    ix1 += ix1;
+	    r>>=1;
+	}
+
+	r = sign;
+	while(r!=0) {
+	    t1 = s1+r;
+	    t  = s0;
+	    if((t<ix0)||((t==ix0)&&(t1<=ix1))) {
+		s1  = t1+r;
+		if(((t1&sign)==sign)&&(s1&sign)==0) s0 += 1;
+		ix0 -= t;
+		if (ix1 < t1) ix0 -= 1;
+		ix1 -= t1;
+		q1  += r;
+	    }
+	    ix0 += ix0 + ((ix1&sign)>>31);
+	    ix1 += ix1;
+	    r>>=1;
+	}
+
+    /* use floating add to find out rounding direction */
+	if((ix0|ix1)!=0) {
+	    z = one-tiny; /* trigger inexact flag */
+	    if (z>=one) {
+	        z = one+tiny;
+	        if (q1==(u_int32_t)0xffffffff) { q1=0; q += 1;}
+		else if (z>one) {
+		    if (q1==(u_int32_t)0xfffffffe) q+=1;
+		    q1+=2;
+		} else
+	            q1 += (q1&1);
+	    }
+	}
+	ix0 = (q>>1)+0x3fe00000;
+	ix1 =  q1>>1;
+	if ((q&1)==1) ix1 |= sign;
+	ix0 += (m <<20);
+	INSERT_WORDS(z,ix0,ix1);
+	return z;
+}
+
+/*
+Other methods  (use floating-point arithmetic)
+-------------
+(This is a copy of a drafted paper by Prof W. Kahan
+and K.C. Ng, written in May, 1986)
+
+	Two algorithms are given here to implement sqrt(x)
+	(IEEE double precision arithmetic) in software.
+	Both supply sqrt(x) correctly rounded. The first algorithm (in
+	Section A) uses newton iterations and involves four divisions.
+	The second one uses reciproot iterations to avoid division, but
+	requires more multiplications. Both algorithms need the ability
+	to chop results of arithmetic operations instead of round them,
+	and the INEXACT flag to indicate when an arithmetic operation
+	is executed exactly with no roundoff error, all part of the
+	standard (IEEE 754-1985). The ability to perform shift, add,
+	subtract and logical AND operations upon 32-bit words is needed
+	too, though not part of the standard.
+
+A.  sqrt(x) by Newton Iteration
+
+   (1)	Initial approximation
+
+	Let x0 and x1 be the leading and the trailing 32-bit words of
+	a floating point number x (in IEEE double format) respectively
+
+	    1    11		     52				  ...widths
+	   ------------------------------------------------------
+	x: |s|	  e     |	      f				|
+	   ------------------------------------------------------
+	      msb    lsb  msb				      lsb ...order
+
+
+	     ------------------------  	     ------------------------
+	x0:  |s|   e    |    f1     |	 x1: |          f2           |
+	     ------------------------  	     ------------------------
+
+	By performing shifts and subtracts on x0 and x1 (both regarded
+	as integers), we obtain an 8-bit approximation of sqrt(x) as
+	follows.
+
+		k  := (x0>>1) + 0x1ff80000;
+		y0 := k - T1[31&(k>>15)].	... y ~ sqrt(x) to 8 bits
+	Here k is a 32-bit integer and T1[] is an integer array containing
+	correction terms. Now magically the floating value of y (y's
+	leading 32-bit word is y0, the value of its trailing word is 0)
+	approximates sqrt(x) to almost 8-bit.
+
+	Value of T1:
+	static int T1[32]= {
+	0,	1024,	3062,	5746,	9193,	13348,	18162,	23592,
+	29598,	36145,	43202,	50740,	58733,	67158,	75992,	85215,
+	83599,	71378,	60428,	50647,	41945,	34246,	27478,	21581,
+	16499,	12183,	8588,	5674,	3403,	1742,	661,	130,};
+
+    (2)	Iterative refinement
+
+	Apply Heron's rule three times to y, we have y approximates
+	sqrt(x) to within 1 ulp (Unit in the Last Place):
+
+		y := (y+x/y)/2		... almost 17 sig. bits
+		y := (y+x/y)/2		... almost 35 sig. bits
+		y := y-(y-x/y)/2	... within 1 ulp
+
+
+	Remark 1.
+	    Another way to improve y to within 1 ulp is:
+
+		y := (y+x/y)		... almost 17 sig. bits to 2*sqrt(x)
+		y := y - 0x00100006	... almost 18 sig. bits to sqrt(x)
+
+				2
+			    (x-y )*y
+		y := y + 2* ----------	...within 1 ulp
+			       2
+			     3y  + x
+
+
+	This formula has one division fewer than the one above; however,
+	it requires more multiplications and additions. Also x must be
+	scaled in advance to avoid spurious overflow in evaluating the
+	expression 3y*y+x. Hence it is not recommended uless division
+	is slow. If division is very slow, then one should use the
+	reciproot algorithm given in section B.
+
+    (3) Final adjustment
+
+	By twiddling y's last bit it is possible to force y to be
+	correctly rounded according to the prevailing rounding mode
+	as follows. Let r and i be copies of the rounding mode and
+	inexact flag before entering the square root program. Also we
+	use the expression y+-ulp for the next representable floating
+	numbers (up and down) of y. Note that y+-ulp = either fixed
+	point y+-1, or multiply y by nextafter(1,+-inf) in chopped
+	mode.
+
+		I := FALSE;	... reset INEXACT flag I
+		R := RZ;	... set rounding mode to round-toward-zero
+		z := x/y;	... chopped quotient, possibly inexact
+		If(not I) then {	... if the quotient is exact
+		    if(z=y) {
+		        I := i;	 ... restore inexact flag
+		        R := r;  ... restore rounded mode
+		        return sqrt(x):=y.
+		    } else {
+			z := z - ulp;	... special rounding
+		    }
+		}
+		i := TRUE;		... sqrt(x) is inexact
+		If (r=RN) then z=z+ulp	... rounded-to-nearest
+		If (r=RP) then {	... round-toward-+inf
+		    y = y+ulp; z=z+ulp;
+		}
+		y := y+z;		... chopped sum
+		y0:=y0-0x00100000;	... y := y/2 is correctly rounded.
+	        I := i;	 		... restore inexact flag
+	        R := r;  		... restore rounded mode
+	        return sqrt(x):=y.
+
+    (4)	Special cases
+
+	Square root of +inf, +-0, or NaN is itself;
+	Square root of a negative number is NaN with invalid signal.
+
+
+B.  sqrt(x) by Reciproot Iteration
+
+   (1)	Initial approximation
+
+	Let x0 and x1 be the leading and the trailing 32-bit words of
+	a floating point number x (in IEEE double format) respectively
+	(see section A). By performing shifs and subtracts on x0 and y0,
+	we obtain a 7.8-bit approximation of 1/sqrt(x) as follows.
+
+	    k := 0x5fe80000 - (x0>>1);
+	    y0:= k - T2[63&(k>>14)].	... y ~ 1/sqrt(x) to 7.8 bits
+
+	Here k is a 32-bit integer and T2[] is an integer array
+	containing correction terms. Now magically the floating
+	value of y (y's leading 32-bit word is y0, the value of
+	its trailing word y1 is set to zero) approximates 1/sqrt(x)
+	to almost 7.8-bit.
+
+	Value of T2:
+	static int T2[64]= {
+	0x1500,	0x2ef8,	0x4d67,	0x6b02,	0x87be,	0xa395,	0xbe7a,	0xd866,
+	0xf14a,	0x1091b,0x11fcd,0x13552,0x14999,0x15c98,0x16e34,0x17e5f,
+	0x18d03,0x19a01,0x1a545,0x1ae8a,0x1b5c4,0x1bb01,0x1bfde,0x1c28d,
+	0x1c2de,0x1c0db,0x1ba73,0x1b11c,0x1a4b5,0x1953d,0x18266,0x16be0,
+	0x1683e,0x179d8,0x18a4d,0x19992,0x1a789,0x1b445,0x1bf61,0x1c989,
+	0x1d16d,0x1d77b,0x1dddf,0x1e2ad,0x1e5bf,0x1e6e8,0x1e654,0x1e3cd,
+	0x1df2a,0x1d635,0x1cb16,0x1be2c,0x1ae4e,0x19bde,0x1868e,0x16e2e,
+	0x1527f,0x1334a,0x11051,0xe951,	0xbe01,	0x8e0d,	0x5924,	0x1edd,};
+
+    (2)	Iterative refinement
+
+	Apply Reciproot iteration three times to y and multiply the
+	result by x to get an approximation z that matches sqrt(x)
+	to about 1 ulp. To be exact, we will have
+		-1ulp < sqrt(x)-z<1.0625ulp.
+
+	... set rounding mode to Round-to-nearest
+	   y := y*(1.5-0.5*x*y*y)	... almost 15 sig. bits to 1/sqrt(x)
+	   y := y*((1.5-2^-30)+0.5*x*y*y)... about 29 sig. bits to 1/sqrt(x)
+	... special arrangement for better accuracy
+	   z := x*y			... 29 bits to sqrt(x), with z*y<1
+	   z := z + 0.5*z*(1-z*y)	... about 1 ulp to sqrt(x)
+
+	Remark 2. The constant 1.5-2^-30 is chosen to bias the error so that
+	(a) the term z*y in the final iteration is always less than 1;
+	(b) the error in the final result is biased upward so that
+		-1 ulp < sqrt(x) - z < 1.0625 ulp
+	    instead of |sqrt(x)-z|<1.03125ulp.
+
+    (3)	Final adjustment
+
+	By twiddling y's last bit it is possible to force y to be
+	correctly rounded according to the prevailing rounding mode
+	as follows. Let r and i be copies of the rounding mode and
+	inexact flag before entering the square root program. Also we
+	use the expression y+-ulp for the next representable floating
+	numbers (up and down) of y. Note that y+-ulp = either fixed
+	point y+-1, or multiply y by nextafter(1,+-inf) in chopped
+	mode.
+
+	R := RZ;		... set rounding mode to round-toward-zero
+	switch(r) {
+	    case RN:		... round-to-nearest
+	       if(x<= z*(z-ulp)...chopped) z = z - ulp; else
+	       if(x<= z*(z+ulp)...chopped) z = z; else z = z+ulp;
+	       break;
+	    case RZ:case RM:	... round-to-zero or round-to--inf
+	       R:=RP;		... reset rounding mod to round-to-+inf
+	       if(x<z*z ... rounded up) z = z - ulp; else
+	       if(x>=(z+ulp)*(z+ulp) ...rounded up) z = z+ulp;
+	       break;
+	    case RP:		... round-to-+inf
+	       if(x>(z+ulp)*(z+ulp)...chopped) z = z+2*ulp; else
+	       if(x>z*z ...chopped) z = z+ulp;
+	       break;
+	}
+
+	Remark 3. The above comparisons can be done in fixed point. For
+	example, to compare x and w=z*z chopped, it suffices to compare
+	x1 and w1 (the trailing parts of x and w), regarding them as
+	two's complement integers.
+
+	...Is z an exact square root?
+	To determine whether z is an exact square root of x, let z1 be the
+	trailing part of z, and also let x0 and x1 be the leading and
+	trailing parts of x.
+
+	If ((z1&0x03ffffff)!=0)	... not exact if trailing 26 bits of z!=0
+	    I := 1;		... Raise Inexact flag: z is not exact
+	else {
+	    j := 1 - [(x0>>20)&1]	... j = logb(x) mod 2
+	    k := z1 >> 26;		... get z's 25-th and 26-th
+					    fraction bits
+	    I := i or (k&j) or ((k&(j+j+1))!=(x1&3));
+	}
+	R:= r		... restore rounded mode
+	return sqrt(x):=z.
+
+	If multiplication is cheaper then the foregoing red tape, the
+	Inexact flag can be evaluated by
+
+	    I := i;
+	    I := (z*z!=x) or I.
+
+	Note that z*z can overwrite I; this value must be sensed if it is
+	True.
+
+	Remark 4. If z*z = x exactly, then bit 25 to bit 0 of z1 must be
+	zero.
+
+		    --------------------
+		z1: |        f2        |
+		    --------------------
+		bit 31		   bit 0
+
+	Further more, bit 27 and 26 of z1, bit 0 and 1 of x1, and the odd
+	or even of logb(x) have the following relations:
+
+	-------------------------------------------------
+	bit 27,26 of z1		bit 1,0 of x1	logb(x)
+	-------------------------------------------------
+	00			00		odd and even
+	01			01		even
+	10			10		odd
+	10			00		even
+	11			01		even
+	-------------------------------------------------
+
+    (4)	Special cases (see (4) of Section A).
+
+ */
+
diff -urN dietlibc-0.30/libm/erf.c dietlibc-0.30-libm/libm/erf.c
--- dietlibc-0.30/libm/erf.c	2002-11-18 01:16:51.000000000 +0000
+++ dietlibc-0.30-libm/libm/erf.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,95 +0,0 @@
-#include "dietlibm.h"
-
-/*--------------------------------------------------------------------------*
-                                     z
-                              1      |  -x/2
-Name            erf(z)  = ---------  | e     dx
-                          sqrt(2pi)  |
-                                     0
-				     
-                                     oo
-                              1      |  -x/2
-                erfc(z) = --------   | e     dx
-                          sqrt(2pi)  |
-                                     z
-
-Usage           double erf (double x);
-                double erfc(double x);
-
-Prototype in    math.h
-
-Description     erf(x) is the probability a normal distributed event occures
-                within the range [0,x]. erfc(x) is the probability a normal
-                distributed event occures within the range [x,oo].
-
-Return value    return their respective function value.
-
-*---------------------------------------------------------------------------*/
-
-
-/* even function in (0): Coefficients for gamma(0) */
-
-static const double  tab1 [9 + 1] = {
-    0.398942280401432677926,        -0.066490380066905446321,       9.97355701003581694794E-3,      -1.18732821548045439878E-3,     1.15434687616155288764E-4,      -9.44465625950361453450E-6,     6.65969351631665127484E-7,      -4.12266741486268888409E-8,     2.27352982437280636972E-9,      -1.13011716416192129505E-10 
-};
-
-/* non even or odd function in (x), x>0: Coefficients for gamma(x), x>0 */
-
-static const double  tab2 [] [31 + 1] = {
-    { -0.158655253931457051468,     +0.241970724519143349823,       -0.120985362259571674911,        0,                             +0.0201642270432619458197,      -4.03284540865238916394E-3,     -2.01642270432619458197E-3,     +7.68161030219502697887E-4,     +1.20025160971797296538E-4,     -8.80184513793180174807E-5,     -1.86705805956129127862E-6,     +7.37124220917704609315E-6,     -4.72826391707080259142E-7,     -4.83395817951682973566E-7,     +6.57036391970156141055E-8,     +2.5544260402922190768E-8,      -5.4292285616752144141E-9,      -1.08932444506260820153E-9,     +3.44399256708718202774E-10,    +3.6021429664641554881E-11,     -1.81147204852239925966E-11,    -7.66935128389784976374E-13,    +8.19047721646461768154E-13,    -3.78144699611990981391E-15,    -3.24856460059989147863E-14,    +1.44438130842455313227E-15,    +1.14391687912824634892E-15,    -9.38053726039148625184E-17,    -3.59908648108845288945E-17,    +4.36020846676166022246E-18,    +1.01298640134330880603E-18,    -1.68640470512244526894E-19 },
-    { -0.0227501319481792072104,    +0.0539909665131880519553,      -0.0539909665131880519553,      +0.0269954832565940259776,      -4.49924720943233766301E-3,     -2.24962360471616883129E-3,     +1.34977416282970129877E-3,     -1.17837426913704081544E-4,     -1.15159303574756261652E-4,     +3.70473728554448438507E-5,     +2.82690796888936559912E-6,     -3.54513195524355369855E-6,     +3.76695631261094890352E-7,     +1.92024079214184701051E-7,     -5.22690859049557191018E-8,     -4.91799344974114749666E-9,     +3.66377919234006038965E-9,     -1.5981997209104676352E-10,     -1.73812379171063320997E-10,    +2.62403075313043113473E-11,    +5.60918720760414713346E-12,    -1.72126983666416144614E-12,    -8.63428809787622525331E-14,    +7.89441765474563834480E-14,    -3.13747960081562321348E-15,    -2.77519506625391157547E-15,    +3.29321944203493138076E-16,    +7.44375150395529134369E-17,    -1.66428523299294690222E-17,    -1.32735612757620496568E-18,    +6.24122437514304644794E-19,    +1.12471123532438919306E-21 },
-    { -1.3498980316300945272E-3,    +4.43184841193800717687E-3,     -6.64777261790701076574E-3,     +5.90913121591734290293E-3,     -3.32388630895350538287E-3,     +1.10796210298450179421E-3,     -1.10796210298450179595E-4,     -8.44161602273906129349E-5,     +4.35270826172482847927E-5,     -6.30190085030867423515E-6,     -1.9785037553294674925E-6,      +1.05520200284238266374E-6,     -1.13913852579575399458E-7,     -4.81174572974454799623E-8,     +1.78216871733806513653E-8,     -5.85637697215219690327E-10,    -9.29791350219350980904E-10,    +1.96377023046901260016E-10,    +1.58870373467897094393E-11,    -1.22699105512396660364E-11,    +1.08794270836433192571E-12,    +3.99646995170699427940E-13,    -1.01594404465456044793E-13,    -3.33469605506835759271E-15,    +4.46588935876766499879E-15,    -4.08076707607833277747E-16,    -1.17808602368979218862E-16,    +2.76224909899945482352E-17,    +1.09206599392049874162E-18,    -1.03145418746203977253E-18,    +6.79984672177279963209E-20,    +2.55831283729070534712E-20 },
-    { -3.16712418331199212695E-5,   +1.33830225764885351832E-4,     -2.67660451529770703664E-4,     +3.34575564412213379613E-4,     -2.89965489157251595673E-4,     +1.8178605666396926958E-4,      -8.25286392216793003064E-5,     +2.55180251904870680833E-5,     -3.91665839292075186649E-6,     -7.40182052221464123606E-7,     +6.44220233592652481453E-7,     -1.73701553397390201613E-7,     +9.09595464817154590424E-9,     +9.44943118114780783705E-9,     -3.29957075383376125942E-9,     +2.94920746951281580686E-10,    +1.18744773902482360274E-10,    -4.42039585809856402486E-11,    +3.61422484008923382324E-12,    +1.43638335494248833511E-12,    -4.58476794992724591068E-13,    +2.23496663226445199624E-14,    +1.57839046076890756440E-14,    -3.67258220998453293248E-15,    -1.69716269032291432153E-17,    +1.43497778353923791279E-16,    -2.14499365995613073838E-17,    -1.93255135682867953692E-18,    +1.01377499752128183701E-18,    -7.55713215369572830154E-20,    -2.25510650946079103289E-20,    +5.26633993110171917109E-21 },
-    { -2.86651571879193912033E-7,   +1.48671951473429770924E-6,     -3.7167987868357442731E-6,      +5.9468780589371908374E-6,      -6.81413110919886450076E-6,     +5.92209940035828587496E-6,     -4.02653201907205629582E-6,     +2.17108246596119665457E-6,     -9.25512396325170449452E-7,     +3.03096091545533908077E-7,     -6.92802772105295808398E-8,     +6.69226396924248971087E-9,     +2.46006252876483997508E-9,     -1.41806830376639605249E-9,     +3.44251040657349801884E-10,    -2.6965166176434937652E-11,     -1.16546962748761528049E-11,    +4.91490145086991326748E-12,    -7.55854519365765424197E-13,    -4.53988828124843593484E-14,    +4.71533558309731405623E-14,    -9.17323049919073092370E-15,    +4.35542982587998484108E-17,    +3.71238868922011013332E-16,    -7.90772907386322623053E-17,    +1.58463483904927528072E-18,    +2.61503941976309571331E-18,    -5.40699423853895351239E-19,    +6.61825040533797444037E-21,    +1.68378440730394776550E-20,    -3.01930850797704474581E-21,    -3.80658085177617928332E-23 },
-    { -9.8658764503769814198E-10,   +6.07588284982328549581E-9,     -1.82276485494698564874E-8,     +3.54426499573024987263E-8,     -5.01260335110421053478E-8,     +5.48348427196551516061E-8,     -4.81513715848495375522E-8,     +3.47446467489597046263E-8,     -2.08994095347716137282E-8,     +1.0554987922587771203E-8,      -4.4752674615729637229E-9,      +1.57746505810079893253E-9,     -4.49697115294871911476E-10,    +9.63210042443717269402E-11,    -1.16300711402336909847E-11,    -1.31070037808191623761E-12,    +1.16993345829435057496E-12,    -3.40636420312606285351E-13,    +5.23724821541706939045E-14,    +3.93541148139975862961E-16,    -2.59886413069218394637E-15,    +7.24729556829529838503E-16,    -8.51485747763574768020E-17,    -7.86503719948806184368E-18,    +5.35986191777031053618E-18,    -9.84873767617830925356E-19,    +2.93759678710573738811E-20,    +2.85458592629073152182E-20,    -7.12725445137377009753E-21,    +5.25419393758902871947E-22,    +1.24299023131490990316E-22,    -4.04419210566489645405E-23 },
-    { -1.27981254388583500631E-12,  +9.1347204083645933588E-12,     -3.19715214292760767584E-11,    +7.30777632669167468738E-11,    -1.22557498812224960902E-10,    +1.60618833847077433236E-10,    -1.71047639646627010648E-10,    +1.51926349902927316213E-10,    -1.14609023345779936276E-10,    +7.43697341394886835864E-11,    -4.18713451557949730558E-11,    +2.05606050331840905587E-11,    -8.82161466664564577599E-12,    +3.30031395277698236679E-12,    -1.06851205331295409813E-12,    +2.94333808755089195146E-13,    -6.64411715537625335642E-14,    +1.11264855981436243262E-14,    -8.52918435682649455145E-16,    -2.38837813662069487819E-16,    +1.23994634366691956599E-16,    -3.05269770279941723219E-17,    +4.34539596489459676621E-18,    -5.55819387468189608390E-20,    -1.56974672263484202926E-19,    +4.60835492190702561464E-20,    -6.61112150617493330405E-21,    +7.28424268476803924831E-23,    +2.09156005934313228089E-22,    -5.29080328670107625978E-23,    +5.61375000671507211726E-24,    +3.82199410465700894394E-25 },
-    { -6.22096057427178413283E-16,  +5.05227108353689229741E-15,    -2.02090843341475691883E-14,    +5.30488463771373691202E-14,    -1.02729512031916810045E-13,    +1.56409892294496290711E-13,    -1.94849254788406146283E-13,    +2.04064637342166989709E-13,    -1.83187931471980616892E-13,    +1.42994099344605424348E-13,    -9.8111907789286062426E-14,     +5.96545975367403288587E-14,    -3.23370114040930933005E-14,    +1.56932853967230342257E-14,    -6.83548101324218922896E-15,    +2.67410077774155118457E-15,    -9.38313996431647887562E-16,    +2.94090734842381109313E-16,    -8.16448235152204729921E-17,    +1.9758222496699617607E-17,     -4.03590262164308783690E-18,    +6.43662361965717426956E-19,    -5.93446415094778572090E-20,    -6.07164564350191039536E-21,    +4.38906686886388095825E-21,    -1.17175498170220204828E-21,    +1.98482140750318604418E-22,    -1.70803571702439545981E-23,    -1.94600332107885234554E-24,    +1.10477141319981582738E-24,    -2.31975718243847439962E-25,    +2.54148402104633283670E-26 },
-    { -1.12858840595384064928E-19,  +1.02797735716689148111E-18,    -4.62589810725101166456E-18,    +1.37063647622252197466E-17,    -3.0068337697131575822E-17,     +5.2067053140503053517E-17,     -7.40914680178037035E-17,       +8.9062000172830588611E-17,     -9.22563786210983011008E-17,    +8.35975730487397716492E-17,    -6.70372487553237232779E-17,    +4.80088566412770650047E-17,    -3.09280630297969106245E-17,    +1.8026496052333452774E-17,     -9.54924880090907168481E-18,    +4.61362333444861021959E-18,    -2.03812361224098073479E-18,    +8.24578860830779678155E-19,    -3.0572087552697254564E-19,     +1.03827313453936543577E-19,    -3.22407758977306397999E-20,    +9.12052549039695437376E-21,    -2.33541947993595580264E-21,    +5.35339963891271164659E-22,    -1.07674173853083520575E-22,    +1.82413373046113374293E-23,    -2.33864726317468746329E-24,    +1.29928813344150027051E-25,    +3.86668349205203745336E-26,    -1.63203452712600670685E-26,    +3.65165372186699607411E-27,    -5.51243539825332137371E-28 },
-    { -7.61985302416052609616E-24,  +7.69459862670641937159E-23,    -3.84729931335320968601E-22,    +1.26960877340655919637E-21,    -3.10990027829384449637E-21,    +6.02935924057670511377E-21,    -9.6342786971886625897E-21,     +1.30454744197246721374E-20,    -1.52745988785284834672E-20,    +1.57034665186695273938E-20,    -1.43457243961336621961E-20,    +1.17567385540485497556E-20,    -8.7104848256363928121E-21,     +5.87137214731944288587E-21,    -3.61951956727412561213E-21,    +2.04954715001535632502E-21,    -1.06982832733527370879E-21,    +5.1628428354196120786E-22,     -2.30885865897937993512E-22,    +9.58556229281154921137E-23,    -3.69911125531027884646E-23,    +1.32784897023484841369E-23,    -4.43433027366044567275E-24,    +1.37688611947822111040E-24,    -3.96971995397574368025E-25,    +1.06008163579031271153E-25,    -2.61149430849477426613E-26,    +5.89698164189548613154E-27,    -1.20793190886658723050E-27,    +2.20446342551066852143E-28,    -3.46061447029252398335E-29,    +4.28913922246949096952E-30 } 
-};
-
-static const double  tab3 [8] = { +1, -1, +3, -15, +105, -945, +10395, -135135.0 };
-
-
-/*
-    Calculated:               oo
-                       1      |  -x/2
-        gauss(z) = ---------  | e     dx
-                   sqrt(2pi)  |
-                              z 
-
-        gauss ( 0) = 0.5
-        gauss ( 1) ~ 0.1586
-        gauss ( 2) ~ 0.02275
-        gauss ( 4) ~ 3.17e-5
-        gauss (10) ~ 7.62e-24
-        gauss (oo) = 0
-
-        Note: only for z>0
-*/
-#include <stdio.h>
-#include <math.h>
-
-#define M_1_SQRT2PI      0.398942280401432686
-
-static long double  gauss ( double x ) 
-{ 
-    unsigned int  i = (unsigned int)(x + 0.5);
-    double        y = x * x;
-
-    if ( i > 150 ) return 0.;
-    if ( i >  10 ) return M_1_SQRT2PI * exp (-0.5*y) / x * __poly (1./y, 7, tab3);
-    if ( i >   0 ) return -__poly ((x-i), 31, tab2 [i-1]);
-    return 0.5 - x * __poly (y, 9, tab1);
-  }
-
-double  erf  ( double x ) 
-{
-    return x < 0.  ? -0.5 + gauss(-x)  :  0.5 - gauss(x);
-}
-
-double  erfc ( double x ) 
-{
-    return x < 0.  ?  1.0 - gauss(-x)  :  gauss(x);
-}
-
diff -urN dietlibc-0.30/libm/float_wrappers.c dietlibc-0.30-libm/libm/float_wrappers.c
--- dietlibc-0.30/libm/float_wrappers.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/float_wrappers.c	2006-06-25 11:20:09.000000000 +0000
@@ -0,0 +1,563 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Wrapper functions implementing all the float math functions
+ * defined by SuSv3 by actually calling the double version of
+ * each function and then casting the result back to a float
+ * to return to the user.
+ *
+ * Copyright (C) 2005 by Erik Andersen <andersen@uclibc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Library General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "math.h"
+
+/* For the time being, do _NOT_ implement these functions
+ * that are defined by SuSv3 */
+#if 0
+float       exp2f(float);
+float       fmaf(float, float, float);
+float       fmaxf(float, float);
+float       fminf(float, float);
+float       fdimf(float, float);
+long long   llrintf(float);
+long long   llroundf(float);
+long        lroundf(float);
+float       log2f(float);
+long        lrintf(float);
+float       nexttowardf(float, long double);
+float       remquof(float, float, int *);
+float       roundf(float);
+float       scalblnf(float, long);
+float       truncf(float);
+float       tgammaf(float);
+#endif
+
+/* Implement the following, as defined by SuSv3 */
+#if 0
+float       acosf(float);
+float       acoshf(float);
+float       asinf(float);
+float       asinhf(float);
+float       atan2f(float, float);
+float       atanf(float);
+float       atanhf(float);
+float       cbrtf(float);
+float       ceilf(float);
+float       copysignf(float, float);
+float       cosf(float);
+float       coshf(float);
+float       erfcf(float);
+float       erff(float);
+float       expf(float);
+float       expm1f(float);
+float       fabsf(float);
+float       floorf(float);
+float       fmodf(float, float);
+float       frexpf(float value, int *);
+float       hypotf(float, float);
+int         ilogbf(float);
+float       ldexpf(float, int);
+float       lgammaf(float);
+float       log10f(float);
+float       log1pf(float);
+float       logbf(float);
+float       logf(float);
+float       modff(float, float *);
+float       nearbyintf(float);
+float       nextafterf(float, float);
+float       powf(float, float);
+float       remainderf(float, float);
+float       rintf(float);
+float       scalbnf(float, int);
+float       sinf(float);
+float       sinhf(float);
+float       sqrtf(float);
+float       tanf(float);
+float       tanhf(float);
+#endif
+
+#ifdef L_acosf
+float acosf (float x)
+{
+	return (float) acos( (double)x );
+}
+#endif
+
+
+#ifdef L_acoshf
+float acoshf (float x)
+{
+	return (float) acosh( (double)x );
+}
+#endif
+
+
+#ifdef L_asinf
+float asinf (float x)
+{
+	return (float) asin( (double)x );
+}
+#endif
+
+
+#ifdef L_asinhf
+float asinhf (float x)
+{
+	return (float) asinh( (double)x );
+}
+#endif
+
+
+#ifdef L_atan2f
+float atan2f (float x, float y)
+{
+	return (float) atan2( (double)x, (double)y );
+}
+#endif
+
+
+#ifdef L_atanf
+float atanf (float x)
+{
+	return (float) atan( (double)x );
+}
+#endif
+
+
+#ifdef L_atanhf
+float atanhf (float x)
+{
+	return (float) atanh( (double)x );
+}
+#endif
+
+
+#ifdef L_cbrtf
+float cbrtf (float x)
+{
+	return (float) cbrt( (double)x );
+}
+#endif
+
+
+#ifdef L_ceilf
+float ceilf (float x)
+{
+	return (float) ceil( (double)x );
+}
+#endif
+
+
+#ifdef L_copysignf
+float copysignf (float x, float y)
+{
+	return (float) copysign( (double)x, (double)y );
+}
+#endif
+
+
+#ifdef L_cosf
+float cosf (float x)
+{
+	return (float) cos( (double)x );
+}
+#endif
+
+
+#ifdef L_coshf
+float coshf (float x)
+{
+	return (float) cosh( (double)x );
+}
+#endif
+
+
+#ifdef L_erfcf
+float erfcf (float x)
+{
+	return (float) erfc( (double)x );
+}
+#endif
+
+
+#ifdef L_erff
+float erff (float x)
+{
+	return (float) erf( (double)x );
+}
+#endif
+
+
+#if 0
+#ifdef L_exp2f
+float exp2f (float x)
+{
+	return (float) exp2( (double)x );
+}
+#endif
+#endif
+
+
+#ifdef L_expf
+float expf (float x)
+{
+	return (float) exp( (double)x );
+}
+#endif
+
+
+#ifdef L_expm1f
+float expm1f (float x)
+{
+	return (float) expm1( (double)x );
+}
+#endif
+
+
+#ifdef L_fabsf
+float fabsf (float x)
+{
+	return (float) fabs( (double)x );
+}
+#endif
+
+
+#if 0
+#ifdef L_fdimf
+float fdimf (float x, float y)
+{
+	return (float) fdim( (double)x, (double)y );
+}
+#endif
+#endif
+
+
+#ifdef L_floorf
+float floorf (float x)
+{
+	return (float) floor( (double)x );
+}
+#endif
+
+
+#if 0
+#ifdef L_fmaf
+float fmaf (float x, float y, float z)
+{
+	return (float) fma( (double)x, (double)y, (double)z );
+}
+#endif
+
+
+#ifdef L_fmaxf
+float fmaxf (float x, float y)
+{
+	return (float) fmax( (double)x, (double)y );
+}
+#endif
+
+
+#ifdef L_fminf
+float fminf (float x, float y)
+{
+	return (float) fmin( (double)x, (double)y );
+}
+#endif
+#endif
+
+
+#ifdef L_fmodf
+float fmodf (float x, float y)
+{
+	return (float) fmod( (double)x, (double)y );
+}
+#endif
+
+
+#ifdef L_frexpf
+float frexpf (float x, int *exp)
+{
+	return (float) frexp( (double)x, exp );
+}
+#endif
+
+
+#ifdef L_hypotf
+float hypotf (float x, float y)
+{
+	return (float) hypot( (double)x, (double)y );
+}
+#endif
+
+
+#ifdef L_ilogbf
+int ilogbf (float x)
+{
+	return (float) ilogb( (double)x );
+}
+#endif
+
+
+#ifdef L_ldexpf
+float ldexpf (float x, int exp)
+{
+	return (float) ldexp( (double)x, exp );
+}
+#endif
+
+
+#ifdef L_lgammaf
+float lgammaf (float x)
+{
+	return (float) lgamma( (double)x );
+}
+#endif
+
+
+#if 0
+#ifdef L_llrintf
+long long llrintf (float x)
+{
+	return (float) llrint( (double)x );
+}
+#endif
+
+
+#ifdef L_llroundf
+long long llroundf (float x)
+{
+	return (float) llround( (double)x );
+}
+#endif
+#endif
+
+#ifdef L_log10f
+float log10f (float x)
+{
+	return (float) log10( (double)x );
+}
+#endif
+
+
+#ifdef L_log1pf
+float log1pf (float x)
+{
+	return (float) log1p( (double)x );
+}
+#endif
+
+
+#if 0
+#ifdef L_log2f
+float log2f (float x)
+{
+	return (float) log2( (double)x );
+}
+#endif
+#endif
+
+
+#ifdef L_logbf
+float logbf (float x)
+{
+	return (float) logb( (double)x );
+}
+#endif
+
+
+#ifdef L_logf
+float logf (float x)
+{
+	return (float) log( (double)x );
+}
+#endif
+
+
+#if 0
+#ifdef L_lrintf
+long lrintf (float x)
+{
+	return (float) lrint( (double)x );
+}
+#endif
+
+
+#ifdef L_lroundf
+long lroundf (float x)
+{
+	return (float) lround( (double)x );
+}
+#endif
+#endif
+
+
+#ifdef L_modff
+float modff (float x, float *iptr)
+{
+	double y, result;
+	result = modf ( x, &y );
+	*iptr = (float)y;
+	return (float) result;
+
+}
+#endif
+
+
+#if 0
+#ifdef L_nearbyintf
+float nearbyintf (float x)
+{
+	return (float) nearbyint( (double)x );
+}
+#endif
+#endif
+
+
+#ifdef L_nextafterf
+float nextafterf (float x, float y)
+{
+	return (float) nextafter( (double)x, (double)y );
+}
+#endif
+
+
+#if 0
+#ifdef L_nexttowardf
+float nexttowardf (float x, long double y)
+{
+	return (float) nexttoward( (double)x, (double)y );
+}
+#endif
+#endif
+
+#ifdef L_powf
+float powf (float x, float y)
+{
+	return (float) pow( (double)x, (double)y );
+}
+#endif
+
+
+#ifdef L_remainderf
+float remainderf (float x, float y)
+{
+	return (float) remainder( (double)x, (double)y );
+}
+#endif
+
+
+#if 0
+#ifdef L_remquof
+float remquof (float x, float y, int *quo)
+{
+	return (float) remquo( (double)x, (double)y, quo );
+}
+#endif
+#endif
+
+
+#ifdef L_rintf
+float rintf (float x)
+{
+	return (float) rint( (double)x );
+}
+#endif
+
+
+#if 0
+#ifdef L_roundf
+float roundf (float x)
+{
+	return (float) round( (double)x );
+}
+#endif
+
+
+#ifdef L_scalblnf
+float scalblnf (float x, long exp)
+{
+	return (float) scalbln( (double)x, exp );
+}
+#endif
+#endif
+
+
+#ifdef L_scalbnf
+float scalbnf (float x, int exp)
+{
+	return (float) scalbn( (double)x, exp );
+}
+#endif
+
+
+#ifdef L_sinf
+float sinf (float x)
+{
+	return (float) sin( (double)x );
+}
+#endif
+
+
+#ifdef L_sinhf
+float sinhf (float x)
+{
+	return (float) sinh( (double)x );
+}
+#endif
+
+
+#ifdef L_sqrtf
+float sqrtf (float x)
+{
+	return (float) sqrt( (double)x );
+}
+#endif
+
+
+#ifdef L_tanf
+float tanf (float x)
+{
+	return (float) tan( (double)x );
+}
+#endif
+
+
+#ifdef L_tanhf
+float tanhf (float x)
+{
+	return (float) tanh( (double)x );
+}
+#endif
+
+
+#if 0
+#ifdef L_tgammaf
+float tgammaf (float x)
+{
+	return (float) tgamma( (double)x );
+}
+#endif
+
+
+#ifdef L_truncf
+float truncf (float x)
+{
+	return (float) trunc( (double)x );
+}
+#endif
+#endif
+
+
diff -urN dietlibc-0.30/libm/fp_private.h dietlibc-0.30-libm/libm/fp_private.h
--- dietlibc-0.30/libm/fp_private.h	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/fp_private.h	2006-06-25 11:20:24.000000000 +0000
@@ -0,0 +1,89 @@
+/*******************************************************************************
+*                                                                              *
+*      File fp_private.h,                                                      *
+*      All pack 4 dependencies for the MathLib elems plus some defines used    *
+*      throughout MathLib.                                                     *
+*                                                                              *
+*      Copyright  1991 Apple Computer, Inc.  All rights reserved.             *
+*                                                                              *
+*      Written by Ali Sazegari, started on October 1991,                       *
+*                                                                              *
+*      W A R N I N G:  This routine expects a 64 bit double model.             *
+*                                                                              *
+*******************************************************************************/
+
+#define      NoException            0
+
+/*******************************************************************************
+*                              Values of constants.                            *
+*******************************************************************************/
+
+//#define    SgnMask            0x8000
+#define      dSgnMask           0x80000000
+#define      sSgnMask           0x7FFFFFFF
+
+//#define    ExpMask            0x7FFF
+#define      dExpMask           0x7FF00000
+#define      sExpMask           0xFF000000
+
+                                          /* according to rounding BIG & SMALL are:  */
+#define      BIG               1.1e+300   /* used to deliver  or largest number,   */
+#define      SMALL             1.1e-300   /* used to deliver 0 or smallest number.  */
+#define      InfExp            0x7FF
+#define      dMaxExp           0x7FF00000
+
+#define      MaxExpP1          1024
+#define      MaxExp            1023
+
+#define      DenormLimit       -52
+
+//#define    ManMask           0x80000000
+#define      dManMask          0x00080000
+
+//#define    IsItDenorm         0x80000000
+#define      dIsItDenorm        0x00080000
+
+//#define    xIsItSNaN          0x40000000
+#define      dIsItSNaN          0x00080000
+
+#define      dHighMan           0x000FFFFF
+#define      dFirstBitSet       0x00080000
+#define      BIAS               0x3FF
+
+//#define    GetSign            0x8000
+#define      dGetSign           0x80000000
+#define      sGetSign           0x80000000
+
+//#define    Infinity(x)       ( x.hex.exponent & ExpMask ) == ExpMask
+#define      dInfinity(x)      ( x.hex.high & dExpMask ) == dExpMask
+#define      sInfinity(x)      ( ( x.hexsgl << 1 ) & sExpMask ) == sExpMask
+
+//#define    Exponent(x)       x.hex.exponent & ExpMask
+#define      dExponent(x)      x.hex.high & dExpMask
+#define      sExponent(x)      ( ( x.hexsgl << 1 ) & sExpMask )
+
+#define      sZero(x)          ( x.hexsgl & sSgnMask ) == 0
+//#define    Sign(x)           ( x.hex.exponent & SgnMask ) == SgnMask
+
+/*******************************************************************************
+*                        Types used in the auxiliary functions.                *
+*******************************************************************************/
+
+#include <stdint.h>
+
+typedef struct                   /*      Hex representation of a double.      */
+      {
+#if defined(__BIG_ENDIAN__)
+      uint32_t high;
+      uint32_t low;
+#else
+      uint32_t low;
+      uint32_t high;
+#endif
+      } dHexParts;
+
+typedef union
+      {
+      unsigned char byties[8];
+      double dbl;
+      } DblInHex;
diff -urN dietlibc-0.30/libm/fpmacros.c dietlibc-0.30-libm/libm/fpmacros.c
--- dietlibc-0.30/libm/fpmacros.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/fpmacros.c	2006-06-25 11:20:12.000000000 +0000
@@ -0,0 +1,291 @@
+/***********************************************************************
+**  File:  fpmacros.c
+**
+**  Contains:  C source code for implementations of floating-point
+**             functions which involve float format numbers, as
+**             defined in header <fp.h>.  In particular, this file
+**             contains implementations of functions
+**              __fpclassify(d,f), __isnormal(d,f), __isfinite(d,f),
+**             __isnan(d,f), and __signbit(d,f).  This file targets
+**             PowerPC platforms.
+**
+**  Written by:   Robert A. Murley, Ali Sazegari
+**
+**  Copyright:   c 2001 by Apple Computer, Inc., all rights reserved
+**
+**  Change History (most recent first):
+**
+**     07 Jul 01   ram      First created from fpfloatfunc.c, fp.c,
+**				classify.c and sign.c in MathLib v3 Mac OS9.
+**
+***********************************************************************/
+
+#include     <features.h>
+#define _GNU_SOURCE
+#include     <sys/types.h>
+#include     <math.h>
+#include     "math_private.h"
+#include     "fp_private.h"
+
+#define SIGN_MASK 0x80000000
+#define NSIGN_MASK 0x7fffffff
+#define FEXP_MASK 0x7f800000
+#define FFRAC_MASK 0x007fffff
+
+/***********************************************************************
+   int __fpclassifyf(float x) returns the classification code of the
+   argument x, as defined in <fp.h>.
+
+   Exceptions:  INVALID signaled if x is a signaling NaN; in this case,
+                the FP_QNAN code is returned.
+
+   Calls:  none
+***********************************************************************/
+
+int __fpclassifyf ( float x )
+{
+   unsigned int iexp;
+
+   union {
+      u_int32_t lval;
+      float fval;
+   } z;
+
+   z.fval = x;
+   iexp = z.lval & FEXP_MASK;                 /* isolate float exponent */
+
+   if (iexp == FEXP_MASK) {                   /* NaN or INF case */
+      if ((z.lval & 0x007fffff) == 0)
+         return FP_INFINITE;
+	return FP_NAN;
+   }
+
+   if (iexp != 0)                             /* normal float */
+      return FP_NORMAL;
+
+   if (x == 0.0)
+      return FP_ZERO;             /* zero */
+   else
+      return FP_SUBNORMAL;        /* must be subnormal */
+}
+
+
+/***********************************************************************
+      Function __fpclassify,
+      Implementation of classify of a double number for the PowerPC.
+
+   Exceptions:  INVALID signaled if x is a signaling NaN; in this case,
+                the FP_QNAN code is returned.
+
+   Calls:  none
+***********************************************************************/
+
+int __fpclassify ( double arg )
+{
+	register unsigned int exponent;
+      union
+            {
+            dHexParts hex;
+            double dbl;
+            } x;
+
+	x.dbl = arg;
+
+	exponent = x.hex.high & dExpMask;
+	if ( exponent == dExpMask )
+		{
+		if ( ( ( x.hex.high & dHighMan ) | x.hex.low ) == 0 )
+			return FP_INFINITE;
+		else
+            	return FP_NAN;
+		}
+	else if ( exponent != 0)
+		return FP_NORMAL;
+	else {
+		if ( arg == 0.0 )
+			return FP_ZERO;
+		else
+			return FP_SUBNORMAL;
+		}
+}
+
+
+/***********************************************************************
+   int __isnormalf(float x) returns nonzero if and only if x is a
+   normalized float number and zero otherwise.
+
+   Exceptions:  INVALID is raised if x is a signaling NaN; in this case,
+                zero is returned.
+
+   Calls:  none
+***********************************************************************/
+
+int __isnormalf ( float x )
+{
+   unsigned int iexp;
+   union {
+      u_int32_t lval;
+      float fval;
+   } z;
+
+   z.fval = x;
+   iexp = z.lval & FEXP_MASK;                 /* isolate float exponent */
+   return ((iexp != FEXP_MASK) && (iexp != 0));
+}
+
+
+int __isnormal ( double x )
+{
+	return ( __fpclassify ( x ) == FP_NORMAL );
+}
+
+
+/***********************************************************************
+   int __isfinitef(float x) returns nonzero if and only if x is a
+   finite (normal, subnormal, or zero) float number and zero otherwise.
+
+   Exceptions:  INVALID is raised if x is a signaling NaN; in this case,
+                zero is returned.
+
+   Calls:  none
+***********************************************************************/
+
+int __finitef ( float x )
+{
+   union {
+      u_int32_t lval;
+      float fval;
+   } z;
+
+   z.fval = x;
+   return ((z.lval & FEXP_MASK) != FEXP_MASK);
+}
+weak_alias (__finitef, finitef)
+
+int __finite ( double x )
+{
+	return ( __fpclassify ( x ) >= FP_ZERO );
+}
+weak_alias (__finite, finite)
+
+
+/***********************************************************************
+   int __signbitf(float x) returns nonzero if and only if the sign
+   bit of x is set and zero otherwise.
+
+   Exceptions:  INVALID is raised if x is a signaling NaN.
+
+   Calls:  none
+***********************************************************************/
+
+int __signbitf ( float x )
+{
+   union {
+      u_int32_t lval;
+      float fval;
+   } z;
+
+   z.fval = x;
+   return ((z.lval & SIGN_MASK) != 0);
+}
+
+
+/***********************************************************************
+      Function sign of a double.
+      Implementation of sign bit for the PowerPC.
+
+   Calls:  none
+***********************************************************************/
+
+int __signbit ( double arg )
+{
+      union
+            {
+            dHexParts hex;
+            double dbl;
+            } x;
+      int sign;
+
+      x.dbl = arg;
+      sign = ( ( x.hex.high & dSgnMask ) == dSgnMask ) ? 1 : 0;
+      return sign;
+}
+
+
+/***********************************************************************
+* int __isinff(float x) returns -1 if value represents  negative
+*	infinity,  1  if value represents positive infinity,
+*	and 0 otherwise.
+*
+* Calls:  __signbit
+* +***********************************************************************/
+int __isinff ( float x )
+{
+    int class = __fpclassifyf(x);
+    if ( class == FP_INFINITE ) {
+	return ( (__signbitf(x)) ? -1 : 1);
+    }
+    return 0;
+}
+weak_alias (__isinff, isinff)
+
+int __isinf ( double x )
+{
+    int class = __fpclassify(x);
+    if ( class == FP_INFINITE ) {
+	return ( (__signbit(x)) ? -1 : 1);
+    }
+    return 0;
+}
+weak_alias (__isinf, isinf)
+
+#if 0
+int __isinfl ( long double x )
+{
+    int class = __fpclassify(x);
+    if ( class == FP_INFINITE ) {
+	return ( (__signbit(x)) ? -1 : 1);
+    }
+    return 0;
+}
+weak_alias (__isinfl, isinfl);
+#endif
+
+/***********************************************************************
+   int __isnanf(float x) returns nonzero if and only if x is a
+   NaN and zero otherwise.
+
+   Exceptions:  INVALID is raised if x is a signaling NaN; in this case,
+                nonzero is returned.
+
+   Calls:  none
+***********************************************************************/
+
+int __isnanf ( float x )
+{
+   union {
+      u_int32_t lval;
+      float fval;
+   } z;
+
+   z.fval = x;
+   return (((z.lval&FEXP_MASK) == FEXP_MASK) && ((z.lval&FFRAC_MASK) != 0));
+}
+weak_alias (__isnanf, isnanf);
+
+int __isnan ( double x )
+{
+	int class = __fpclassify(x);
+	return ( class == FP_NAN );
+}
+weak_alias (__isnan, isnan);
+
+#if 0
+int __isnanl ( long double x )
+{
+	int class = __fpclassify(x);
+	return ( class == FP_NAN );
+}
+weak_alias (__isnanl, isnanl);
+#endif
+
diff -urN dietlibc-0.30/libm/gamma.c dietlibc-0.30-libm/libm/gamma.c
--- dietlibc-0.30/libm/gamma.c	2005-03-15 08:51:23.000000000 +0000
+++ dietlibc-0.30-libm/libm/gamma.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,115 +0,0 @@
-#include "dietlibm.h"
-
-/*--------------------------------------------------------------------------*
-
-Name            gamma, lgamma - gamma function
-
-Usage           double gamma (double x);
-                double lgamma(double x);
-                extern int signgam;
-
-Prototype in    math.h
-
-Description     gamma returns the logarithm of the absolute value of the
-                gamma function. So it is possible (x) for very large x.
-                The sign is stored in signgam, a extern variable
-                overwritten during every call to gamma(). lgamma() is
-                a synonym for gamma().
-                You can calculate (x) by the following sequence:
-
-                double gammafunction(double x)
-                  { double y=exp(gamma(x));
-
-                    return signgam ? -y : +y;
-                  }
-
-Return value    gamma returns a value in range (-0.1208, +oo). For a input
-                value of zero, it returns +oo and errno is set to:
-
-                        ERANGE  Result out of range
-
-*---------------------------------------------------------------------------*/
-
-#include <stdlib.h>
-#include <math.h>
-
-#if defined(__powerpc__)
-/* workaround http://gcc.gnu.org/bugzilla/show_bug.cgi?id=26374 */
-#define B0      +            1.0/   6/ 1/ 2
-#define B1      -            1.0/  30/ 3/ 4
-#define B2      +            1.0/  42/ 5/ 6
-#define B3      -            1.0/  30/ 7/ 8
-#define B4      +            5.0/  66/ 9/10
-#define B5      -          691.0/2730/11/12
-#define B6      +            7.0/   6/13/14
-#define B7      -         3617.0/ 510/15/16
-#define B8      +        43867.0/ 798/17/18
-#define B9      -       174611.0/ 330/19/20
-#define B10     +       854513.0/ 138/21/22
-#define B11     -    236364091.0/2730/23/24
-#define B12     +      8553103.0/   6/25/26
-#else
-#define B0      +            1.0l/   6/ 1/ 2
-#define B1      -            1.0l/  30/ 3/ 4
-#define B2      +            1.0l/  42/ 5/ 6
-#define B3      -            1.0l/  30/ 7/ 8
-#define B4      +            5.0l/  66/ 9/10
-#define B5      -          691.0l/2730/11/12
-#define B6      +            7.0l/   6/13/14
-#define B7      -         3617.0l/ 510/15/16
-#define B8      +        43867.0l/ 798/17/18
-#define B9      -       174611.0l/ 330/19/20
-#define B10     +       854513.0l/ 138/21/22
-#define B11     -    236364091.0l/2730/23/24
-#define B12     +      8553103.0l/   6/25/26
-#endif
-
-static const double  coeff[] = { B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B10 };
-int                  signgam;
-
-#define EXPL(x) (((short *)(void *)&x)[4] & 0x7FFF)
-
-static double  logfact ( long double x )
-{
-    long double   z = 2. * M_PI * x;
-    register int  e = EXPL (x);
-   
-    static unsigned char list [] = { 6, 4, 3, 3, 2, 2 };
-
-    return (log(x) - 1) * x + 0.5*log(z) + __poly (1./(x*x), e<0x4003 ? 10 : (e>0x4008 ? 1 : list [e-0x4003] ), coeff) / x;
-}
-
-
-double  lgamma ( double x )
-{
-    register int  k = floor (x);
-    long double   w;
-    long double   y;
-    long double   z;
-   
-    signgam = 0;
-
-    if ( k >= 7 )
-        return logfact (x-1);
-       
-    if ( k == x )
-        switch (k) {
-        case 1 :
-        case 2 : return 0.000000000000000000000000000l;
-        case 3 : return 0.693147180559945309432805516l;
-        case 4 : return 1.791759469228055000858148560l;
-        case 5 : return 3.178053830347945619723759592l;
-        case 6 : return 4.787491742782045994244981560l;
-        default: return 1./0.; /* ignore the gcc warning, this is intentional */
-        }
-       
-    z = logfact (y = x - k + 7.0 - 1);
-    w = 1;
-    for ( k = 7 - k; k--; )
-        w *= y, y -= 1.;
-       
-    signgam = k >= 0  ?  0  :  k & 1;
-    return z - log (w);
-}
-
-double gamma ( double val )  __attribute__ ((weak,alias("lgamma")));
diff -urN dietlibc-0.30/libm/ipow.c dietlibc-0.30-libm/libm/ipow.c
--- dietlibc-0.30/libm/ipow.c	2002-03-04 18:25:54.000000000 +0000
+++ dietlibc-0.30-libm/libm/ipow.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,29 +0,0 @@
-#define _GNU_SOURCE
-#include <math.h>
-/*
- * This is not standard, but often you only need such this function
- * which is much shorter than the generic pow() function.
- *
- *   double  ipow ( double mant, int expo );
- */
-
-double  ipow ( double mant, int expo )
-{
-    double        ret = 1.;
-    unsigned int  e   = expo;	/* Some attention is necessary for expo = 2^31 */
-   
-    if ( (int)e < 0 ) {
-        e    = -e;
-        mant = 1./mant;
-    }
-   
-    while (1) {
-        if ( e & 1 )
-            ret *= mant;
-        if ( (e >>= 1) == 0 )
-            break;
-        mant *= mant;
-    }
-   
-    return ret;
-}
diff -urN dietlibc-0.30/libm/k_cos.c dietlibc-0.30-libm/libm/k_cos.c
--- dietlibc-0.30/libm/k_cos.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/k_cos.c	2006-06-25 11:20:24.000000000 +0000
@@ -0,0 +1,96 @@
+/* @(#)k_cos.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: k_cos.c,v 1.8 1995/05/10 20:46:22 jtc Exp $";
+#endif
+
+/*
+ * __kernel_cos( x,  y )
+ * kernel cos function on [-pi/4, pi/4], pi/4 ~ 0.785398164
+ * Input x is assumed to be bounded by ~pi/4 in magnitude.
+ * Input y is the tail of x.
+ *
+ * Algorithm
+ *	1. Since cos(-x) = cos(x), we need only to consider positive x.
+ *	2. if x < 2^-27 (hx<0x3e400000 0), return 1 with inexact if x!=0.
+ *	3. cos(x) is approximated by a polynomial of degree 14 on
+ *	   [0,pi/4]
+ *		  	                 4            14
+ *	   	cos(x) ~ 1 - x*x/2 + C1*x + ... + C6*x
+ *	   where the remez error is
+ *
+ * 	|              2     4     6     8     10    12     14 |     -58
+ * 	|cos(x)-(1-.5*x +C1*x +C2*x +C3*x +C4*x +C5*x  +C6*x  )| <= 2
+ * 	|    					               |
+ *
+ * 	               4     6     8     10    12     14
+ *	4. let r = C1*x +C2*x +C3*x +C4*x +C5*x  +C6*x  , then
+ *	       cos(x) = 1 - x*x/2 + r
+ *	   since cos(x+y) ~ cos(x) - sin(x)*y
+ *			  ~ cos(x) - x*y,
+ *	   a correction term is necessary in cos(x) and hence
+ *		cos(x+y) = 1 - (x*x/2 - (r - x*y))
+ *	   For better accuracy when x > 0.3, let qx = |x|/4 with
+ *	   the last 32 bits mask off, and if x > 0.78125, let qx = 0.28125.
+ *	   Then
+ *		cos(x+y) = (1-qx) - ((x*x/2-qx) - (r-x*y)).
+ *	   Note that 1-qx and (x*x/2-qx) is EXACT here, and the
+ *	   magnitude of the latter is at least a quarter of x*x/2,
+ *	   thus, reducing the rounding error in the subtraction.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+one =  1.00000000000000000000e+00, /* 0x3FF00000, 0x00000000 */
+C1  =  4.16666666666666019037e-02, /* 0x3FA55555, 0x5555554C */
+C2  = -1.38888888888741095749e-03, /* 0xBF56C16C, 0x16C15177 */
+C3  =  2.48015872894767294178e-05, /* 0x3EFA01A0, 0x19CB1590 */
+C4  = -2.75573143513906633035e-07, /* 0xBE927E4F, 0x809C52AD */
+C5  =  2.08757232129817482790e-09, /* 0x3E21EE9E, 0xBDB4B1C4 */
+C6  = -1.13596475577881948265e-11; /* 0xBDA8FAE9, 0xBE8838D4 */
+
+#ifdef __STDC__
+	double __kernel_cos(double x, double y)
+#else
+	double __kernel_cos(x, y)
+	double x,y;
+#endif
+{
+	double a,hz,z,r,qx;
+	int32_t ix;
+	GET_HIGH_WORD(ix,x);
+	ix &= 0x7fffffff;			/* ix = |x|'s high word*/
+	if(ix<0x3e400000) {			/* if x < 2**27 */
+	    if(((int)x)==0) return one;		/* generate inexact */
+	}
+	z  = x*x;
+	r  = z*(C1+z*(C2+z*(C3+z*(C4+z*(C5+z*C6)))));
+	if(ix < 0x3FD33333) 			/* if |x| < 0.3 */
+	    return one - (0.5*z - (z*r - x*y));
+	else {
+	    if(ix > 0x3fe90000) {		/* x > 0.78125 */
+		qx = 0.28125;
+	    } else {
+	        INSERT_WORDS(qx,ix-0x00200000,0);	/* x/4 */
+	    }
+	    hz = 0.5*z-qx;
+	    a  = one-qx;
+	    return a - (hz - (z*r-x*y));
+	}
+}
diff -urN dietlibc-0.30/libm/k_rem_pio2.c dietlibc-0.30-libm/libm/k_rem_pio2.c
--- dietlibc-0.30/libm/k_rem_pio2.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/k_rem_pio2.c	2006-06-25 11:20:07.000000000 +0000
@@ -0,0 +1,320 @@
+/* @(#)k_rem_pio2.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: k_rem_pio2.c,v 1.7 1995/05/10 20:46:25 jtc Exp $";
+#endif
+
+/*
+ * __kernel_rem_pio2(x,y,e0,nx,prec,ipio2)
+ * double x[],y[]; int e0,nx,prec; int ipio2[];
+ *
+ * __kernel_rem_pio2 return the last three digits of N with
+ *		y = x - N*pi/2
+ * so that |y| < pi/2.
+ *
+ * The method is to compute the integer (mod 8) and fraction parts of
+ * (2/pi)*x without doing the full multiplication. In general we
+ * skip the part of the product that are known to be a huge integer (
+ * more accurately, = 0 mod 8 ). Thus the number of operations are
+ * independent of the exponent of the input.
+ *
+ * (2/pi) is represented by an array of 24-bit integers in ipio2[].
+ *
+ * Input parameters:
+ * 	x[]	The input value (must be positive) is broken into nx
+ *		pieces of 24-bit integers in double precision format.
+ *		x[i] will be the i-th 24 bit of x. The scaled exponent
+ *		of x[0] is given in input parameter e0 (i.e., x[0]*2^e0
+ *		match x's up to 24 bits.
+ *
+ *		Example of breaking a double positive z into x[0]+x[1]+x[2]:
+ *			e0 = ilogb(z)-23
+ *			z  = scalbn(z,-e0)
+ *		for i = 0,1,2
+ *			x[i] = floor(z)
+ *			z    = (z-x[i])*2**24
+ *
+ *
+ *	y[]	ouput result in an array of double precision numbers.
+ *		The dimension of y[] is:
+ *			24-bit  precision	1
+ *			53-bit  precision	2
+ *			64-bit  precision	2
+ *			113-bit precision	3
+ *		The actual value is the sum of them. Thus for 113-bit
+ *		precison, one may have to do something like:
+ *
+ *		long double t,w,r_head, r_tail;
+ *		t = (long double)y[2] + (long double)y[1];
+ *		w = (long double)y[0];
+ *		r_head = t+w;
+ *		r_tail = w - (r_head - t);
+ *
+ *	e0	The exponent of x[0]
+ *
+ *	nx	dimension of x[]
+ *
+ *  	prec	an integer indicating the precision:
+ *			0	24  bits (single)
+ *			1	53  bits (double)
+ *			2	64  bits (extended)
+ *			3	113 bits (quad)
+ *
+ *	ipio2[]
+ *		integer array, contains the (24*i)-th to (24*i+23)-th
+ *		bit of 2/pi after binary point. The corresponding
+ *		floating value is
+ *
+ *			ipio2[i] * 2^(-24(i+1)).
+ *
+ * External function:
+ *	double scalbn(), floor();
+ *
+ *
+ * Here is the description of some local variables:
+ *
+ * 	jk	jk+1 is the initial number of terms of ipio2[] needed
+ *		in the computation. The recommended value is 2,3,4,
+ *		6 for single, double, extended,and quad.
+ *
+ * 	jz	local integer variable indicating the number of
+ *		terms of ipio2[] used.
+ *
+ *	jx	nx - 1
+ *
+ *	jv	index for pointing to the suitable ipio2[] for the
+ *		computation. In general, we want
+ *			( 2^e0*x[0] * ipio2[jv-1]*2^(-24jv) )/8
+ *		is an integer. Thus
+ *			e0-3-24*jv >= 0 or (e0-3)/24 >= jv
+ *		Hence jv = max(0,(e0-3)/24).
+ *
+ *	jp	jp+1 is the number of terms in PIo2[] needed, jp = jk.
+ *
+ * 	q[]	double array with integral value, representing the
+ *		24-bits chunk of the product of x and 2/pi.
+ *
+ *	q0	the corresponding exponent of q[0]. Note that the
+ *		exponent for q[i] would be q0-24*i.
+ *
+ *	PIo2[]	double precision array, obtained by cutting pi/2
+ *		into 24 bits chunks.
+ *
+ *	f[]	ipio2[] in floating point
+ *
+ *	iq[]	integer array by breaking up q[] in 24-bits chunk.
+ *
+ *	fq[]	final product of x*(2/pi) in fq[0],..,fq[jk]
+ *
+ *	ih	integer. If >0 it indicates q[] is >= 0.5, hence
+ *		it also indicates the *sign* of the result.
+ *
+ */
+
+
+/*
+ * Constants:
+ * The hexadecimal values are the intended ones for the following
+ * constants. The decimal values may be used, provided that the
+ * compiler will convert from decimal to binary accurately enough
+ * to produce the hexadecimal values shown.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const int init_jk[] = {2,3,4,6}; /* initial value for jk */
+#else
+static int init_jk[] = {2,3,4,6};
+#endif
+
+#ifdef __STDC__
+static const double PIo2[] = {
+#else
+static double PIo2[] = {
+#endif
+  1.57079625129699707031e+00, /* 0x3FF921FB, 0x40000000 */
+  7.54978941586159635335e-08, /* 0x3E74442D, 0x00000000 */
+  5.39030252995776476554e-15, /* 0x3CF84698, 0x80000000 */
+  3.28200341580791294123e-22, /* 0x3B78CC51, 0x60000000 */
+  1.27065575308067607349e-29, /* 0x39F01B83, 0x80000000 */
+  1.22933308981111328932e-36, /* 0x387A2520, 0x40000000 */
+  2.73370053816464559624e-44, /* 0x36E38222, 0x80000000 */
+  2.16741683877804819444e-51, /* 0x3569F31D, 0x00000000 */
+};
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+zero   = 0.0,
+one    = 1.0,
+two24   =  1.67772160000000000000e+07, /* 0x41700000, 0x00000000 */
+twon24  =  5.96046447753906250000e-08; /* 0x3E700000, 0x00000000 */
+
+#ifdef __STDC__
+	int __kernel_rem_pio2(double *x, double *y, int e0, int nx, int prec, const int32_t *ipio2)
+#else
+	int __kernel_rem_pio2(x,y,e0,nx,prec,ipio2)
+	double x[], y[]; int e0,nx,prec; int32_t ipio2[];
+#endif
+{
+	int32_t jz,jx,jv,jp,jk,carry,n,iq[20],i,j,k,m,q0,ih;
+	double z,fw,f[20],fq[20],q[20];
+
+    /* initialize jk*/
+	jk = init_jk[prec];
+	jp = jk;
+
+    /* determine jx,jv,q0, note that 3>q0 */
+	jx =  nx-1;
+	jv = (e0-3)/24; if(jv<0) jv=0;
+	q0 =  e0-24*(jv+1);
+
+    /* set up f[0] to f[jx+jk] where f[jx+jk] = ipio2[jv+jk] */
+	j = jv-jx; m = jx+jk;
+	for(i=0;i<=m;i++,j++) f[i] = (j<0)? zero : (double) ipio2[j];
+
+    /* compute q[0],q[1],...q[jk] */
+	for (i=0;i<=jk;i++) {
+	    for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j]; q[i] = fw;
+	}
+
+	jz = jk;
+recompute:
+    /* distill q[] into iq[] reversingly */
+	for(i=0,j=jz,z=q[jz];j>0;i++,j--) {
+	    fw    =  (double)((int32_t)(twon24* z));
+	    iq[i] =  (int32_t)(z-two24*fw);
+	    z     =  q[j-1]+fw;
+	}
+
+    /* compute n */
+	z  = scalbn(z,q0);		/* actual value of z */
+	z -= 8.0*floor(z*0.125);		/* trim off integer >= 8 */
+	n  = (int32_t) z;
+	z -= (double)n;
+	ih = 0;
+	if(q0>0) {	/* need iq[jz-1] to determine n */
+	    i  = (iq[jz-1]>>(24-q0)); n += i;
+	    iq[jz-1] -= i<<(24-q0);
+	    ih = iq[jz-1]>>(23-q0);
+	}
+	else if(q0==0) ih = iq[jz-1]>>23;
+	else if(z>=0.5) ih=2;
+
+	if(ih>0) {	/* q > 0.5 */
+	    n += 1; carry = 0;
+	    for(i=0;i<jz ;i++) {	/* compute 1-q */
+		j = iq[i];
+		if(carry==0) {
+		    if(j!=0) {
+			carry = 1; iq[i] = 0x1000000- j;
+		    }
+		} else  iq[i] = 0xffffff - j;
+	    }
+	    if(q0>0) {		/* rare case: chance is 1 in 12 */
+	        switch(q0) {
+	        case 1:
+	    	   iq[jz-1] &= 0x7fffff; break;
+	    	case 2:
+	    	   iq[jz-1] &= 0x3fffff; break;
+	        }
+	    }
+	    if(ih==2) {
+		z = one - z;
+		if(carry!=0) z -= scalbn(one,q0);
+	    }
+	}
+
+    /* check if recomputation is needed */
+	if(z==zero) {
+	    j = 0;
+	    for (i=jz-1;i>=jk;i--) j |= iq[i];
+	    if(j==0) { /* need recomputation */
+		for(k=1;iq[jk-k]==0;k++);   /* k = no. of terms needed */
+
+		for(i=jz+1;i<=jz+k;i++) {   /* add q[jz+1] to q[jz+k] */
+		    f[jx+i] = (double) ipio2[jv+i];
+		    for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j];
+		    q[i] = fw;
+		}
+		jz += k;
+		goto recompute;
+	    }
+	}
+
+    /* chop off zero terms */
+	if(z==0.0) {
+	    jz -= 1; q0 -= 24;
+	    while(iq[jz]==0) { jz--; q0-=24;}
+	} else { /* break z into 24-bit if necessary */
+	    z = scalbn(z,-q0);
+	    if(z>=two24) {
+		fw = (double)((int32_t)(twon24*z));
+		iq[jz] = (int32_t)(z-two24*fw);
+		jz += 1; q0 += 24;
+		iq[jz] = (int32_t) fw;
+	    } else iq[jz] = (int32_t) z ;
+	}
+
+    /* convert integer "bit" chunk to floating-point value */
+	fw = scalbn(one,q0);
+	for(i=jz;i>=0;i--) {
+	    q[i] = fw*(double)iq[i]; fw*=twon24;
+	}
+
+    /* compute PIo2[0,...,jp]*q[jz,...,0] */
+	for(i=jz;i>=0;i--) {
+	    for(fw=0.0,k=0;k<=jp&&k<=jz-i;k++) fw += PIo2[k]*q[i+k];
+	    fq[jz-i] = fw;
+	}
+
+    /* compress fq[] into y[] */
+	switch(prec) {
+	    case 0:
+		fw = 0.0;
+		for (i=jz;i>=0;i--) fw += fq[i];
+		y[0] = (ih==0)? fw: -fw;
+		break;
+	    case 1:
+	    case 2:
+		fw = 0.0;
+		for (i=jz;i>=0;i--) fw += fq[i];
+		y[0] = (ih==0)? fw: -fw;
+		fw = fq[0]-fw;
+		for (i=1;i<=jz;i++) fw += fq[i];
+		y[1] = (ih==0)? fw: -fw;
+		break;
+	    case 3:	/* painful */
+		for (i=jz;i>0;i--) {
+		    fw      = fq[i-1]+fq[i];
+		    fq[i]  += fq[i-1]-fw;
+		    fq[i-1] = fw;
+		}
+		for (i=jz;i>1;i--) {
+		    fw      = fq[i-1]+fq[i];
+		    fq[i]  += fq[i-1]-fw;
+		    fq[i-1] = fw;
+		}
+		for (fw=0.0,i=jz;i>=2;i--) fw += fq[i];
+		if(ih==0) {
+		    y[0] =  fq[0]; y[1] =  fq[1]; y[2] =  fw;
+		} else {
+		    y[0] = -fq[0]; y[1] = -fq[1]; y[2] = -fw;
+		}
+	}
+	return n&7;
+}
diff -urN dietlibc-0.30/libm/k_sin.c dietlibc-0.30-libm/libm/k_sin.c
--- dietlibc-0.30/libm/k_sin.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/k_sin.c	2006-06-25 11:20:25.000000000 +0000
@@ -0,0 +1,79 @@
+/* @(#)k_sin.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: k_sin.c,v 1.8 1995/05/10 20:46:31 jtc Exp $";
+#endif
+
+/* __kernel_sin( x, y, iy)
+ * kernel sin function on [-pi/4, pi/4], pi/4 ~ 0.7854
+ * Input x is assumed to be bounded by ~pi/4 in magnitude.
+ * Input y is the tail of x.
+ * Input iy indicates whether y is 0. (if iy=0, y assume to be 0).
+ *
+ * Algorithm
+ *	1. Since sin(-x) = -sin(x), we need only to consider positive x.
+ *	2. if x < 2^-27 (hx<0x3e400000 0), return x with inexact if x!=0.
+ *	3. sin(x) is approximated by a polynomial of degree 13 on
+ *	   [0,pi/4]
+ *		  	         3            13
+ *	   	sin(x) ~ x + S1*x + ... + S6*x
+ *	   where
+ *
+ * 	|sin(x)         2     4     6     8     10     12  |     -58
+ * 	|----- - (1+S1*x +S2*x +S3*x +S4*x +S5*x  +S6*x   )| <= 2
+ * 	|  x 					           |
+ *
+ *	4. sin(x+y) = sin(x) + sin'(x')*y
+ *		    ~ sin(x) + (1-x*x/2)*y
+ *	   For better accuracy, let
+ *		     3      2      2      2      2
+ *		r = x *(S2+x *(S3+x *(S4+x *(S5+x *S6))))
+ *	   then                   3    2
+ *		sin(x) = x + (S1*x + (x *(r-y/2)+y))
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+half =  5.00000000000000000000e-01, /* 0x3FE00000, 0x00000000 */
+S1  = -1.66666666666666324348e-01, /* 0xBFC55555, 0x55555549 */
+S2  =  8.33333333332248946124e-03, /* 0x3F811111, 0x1110F8A6 */
+S3  = -1.98412698298579493134e-04, /* 0xBF2A01A0, 0x19C161D5 */
+S4  =  2.75573137070700676789e-06, /* 0x3EC71DE3, 0x57B1FE7D */
+S5  = -2.50507602534068634195e-08, /* 0xBE5AE5E6, 0x8A2B9CEB */
+S6  =  1.58969099521155010221e-10; /* 0x3DE5D93A, 0x5ACFD57C */
+
+#ifdef __STDC__
+	double __kernel_sin(double x, double y, int iy)
+#else
+	double __kernel_sin(x, y, iy)
+	double x,y; int iy;		/* iy=0 if y is zero */
+#endif
+{
+	double z,r,v;
+	int32_t ix;
+	GET_HIGH_WORD(ix,x);
+	ix &= 0x7fffffff;			/* high word of x */
+	if(ix<0x3e400000)			/* |x| < 2**-27 */
+	   {if((int)x==0) return x;}		/* generate inexact */
+	z	=  x*x;
+	v	=  z*x;
+	r	=  S2+z*(S3+z*(S4+z*(S5+z*S6)));
+	if(iy==0) return x+v*(S1+z*r);
+	else      return x-((z*(half*y-v*r)-y)-v*S1);
+}
diff -urN dietlibc-0.30/libm/k_standard.c dietlibc-0.30-libm/libm/k_standard.c
--- dietlibc-0.30/libm/k_standard.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/k_standard.c	2006-06-25 11:20:23.000000000 +0000
@@ -0,0 +1,782 @@
+/* @(#)k_standard.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: k_standard.c,v 1.6 1995/05/10 20:46:35 jtc Exp $";
+#endif
+
+#include "math.h"
+#include "math_private.h"
+#include <errno.h>
+
+#ifndef _USE_WRITE
+#include <stdio.h>			/* fputs(), stderr */
+#define	WRITE2(u,v)	fputs(u, stderr)
+#else	/* !defined(_USE_WRITE) */
+#include <unistd.h>			/* write */
+#define	WRITE2(u,v)	write(2, u, v)
+#undef fflush
+#endif	/* !defined(_USE_WRITE) */
+
+#ifdef __STDC__
+static const double zero = 0.0;	/* used as const */
+#else
+static double zero = 0.0;	/* used as const */
+#endif
+
+/*
+ * Standard conformance (non-IEEE) on exception cases.
+ * Mapping:
+ *	1 -- acos(|x|>1)
+ *	2 -- asin(|x|>1)
+ *	3 -- atan2(+-0,+-0)
+ *	4 -- hypot overflow
+ *	5 -- cosh overflow
+ *	6 -- exp overflow
+ *	7 -- exp underflow
+ *	8 -- y0(0)
+ *	9 -- y0(-ve)
+ *	10-- y1(0)
+ *	11-- y1(-ve)
+ *	12-- yn(0)
+ *	13-- yn(-ve)
+ *	14-- lgamma(finite) overflow
+ *	15-- lgamma(-integer)
+ *	16-- log(0)
+ *	17-- log(x<0)
+ *	18-- log10(0)
+ *	19-- log10(x<0)
+ *	20-- pow(0.0,0.0)
+ *	21-- pow(x,y) overflow
+ *	22-- pow(x,y) underflow
+ *	23-- pow(0,negative)
+ *	24-- pow(neg,non-integral)
+ *	25-- sinh(finite) overflow
+ *	26-- sqrt(negative)
+ *      27-- fmod(x,0)
+ *      28-- remainder(x,0)
+ *	29-- acosh(x<1)
+ *	30-- atanh(|x|>1)
+ *	31-- atanh(|x|=1)
+ *	32-- scalb overflow
+ *	33-- scalb underflow
+ *	34-- j0(|x|>X_TLOSS)
+ *	35-- y0(x>X_TLOSS)
+ *	36-- j1(|x|>X_TLOSS)
+ *	37-- y1(x>X_TLOSS)
+ *	38-- jn(|x|>X_TLOSS, n)
+ *	39-- yn(x>X_TLOSS, n)
+ *	40-- gamma(finite) overflow
+ *	41-- gamma(-integer)
+ *	42-- pow(NaN,0.0)
+ */
+
+
+#ifdef __STDC__
+	double __kernel_standard(double x, double y, int type)
+#else
+	double __kernel_standard(x,y,type)
+	double x,y; int type;
+#endif
+{
+	struct exception exc;
+#ifndef HUGE_VAL	/* this is the only routine that uses HUGE_VAL */
+#define HUGE_VAL inf
+	double inf = 0.0;
+
+	SET_HIGH_WORD(inf,0x7ff00000);	/* set inf to infinite */
+#endif
+
+#ifdef _USE_WRITE
+	(void) fflush(stdout);
+#endif
+	exc.arg1 = x;
+	exc.arg2 = y;
+	switch(type) {
+	    case 1:
+	    case 101:
+		/* acos(|x|>1) */
+		exc.type = DOMAIN;
+		exc.name = type < 100 ? "acos" : "acosf";
+		exc.retval = zero;
+		if (_LIB_VERSION == _POSIX_)
+		  errno = EDOM;
+		else if (!matherr(&exc)) {
+		  if(_LIB_VERSION == _SVID_) {
+		    (void) WRITE2("acos: DOMAIN error\n", 19);
+		  }
+		  errno = EDOM;
+		}
+		break;
+	    case 2:
+	    case 102:
+		/* asin(|x|>1) */
+		exc.type = DOMAIN;
+		exc.name = type < 100 ? "asin" : "asinf";
+		exc.retval = zero;
+		if(_LIB_VERSION == _POSIX_)
+		  errno = EDOM;
+		else if (!matherr(&exc)) {
+		  if(_LIB_VERSION == _SVID_) {
+		    	(void) WRITE2("asin: DOMAIN error\n", 19);
+		  }
+		  errno = EDOM;
+		}
+		break;
+	    case 3:
+	    case 103:
+		/* atan2(+-0,+-0) */
+		exc.arg1 = y;
+		exc.arg2 = x;
+		exc.type = DOMAIN;
+		exc.name = type < 100 ? "atan2" : "atan2f";
+		exc.retval = zero;
+		if(_LIB_VERSION == _POSIX_)
+		  errno = EDOM;
+		else if (!matherr(&exc)) {
+		  if(_LIB_VERSION == _SVID_) {
+			(void) WRITE2("atan2: DOMAIN error\n", 20);
+		      }
+		  errno = EDOM;
+		}
+		break;
+	    case 4:
+	    case 104:
+		/* hypot(finite,finite) overflow */
+		exc.type = OVERFLOW;
+		exc.name = type < 100 ? "hypot" : "hypotf";
+		if (_LIB_VERSION == _SVID_)
+		  exc.retval = HUGE;
+		else
+		  exc.retval = HUGE_VAL;
+		if (_LIB_VERSION == _POSIX_)
+		  errno = ERANGE;
+		else if (!matherr(&exc)) {
+			errno = ERANGE;
+		}
+		break;
+	    case 5:
+	    case 105:
+		/* cosh(finite) overflow */
+		exc.type = OVERFLOW;
+		exc.name = type < 100 ? "cosh" : "coshf";
+		if (_LIB_VERSION == _SVID_)
+		  exc.retval = HUGE;
+		else
+		  exc.retval = HUGE_VAL;
+		if (_LIB_VERSION == _POSIX_)
+		  errno = ERANGE;
+		else if (!matherr(&exc)) {
+			errno = ERANGE;
+		}
+		break;
+	    case 6:
+	    case 106:
+		/* exp(finite) overflow */
+		exc.type = OVERFLOW;
+		exc.name = type < 100 ? "exp" : "expf";
+		if (_LIB_VERSION == _SVID_)
+		  exc.retval = HUGE;
+		else
+		  exc.retval = HUGE_VAL;
+		if (_LIB_VERSION == _POSIX_)
+		  errno = ERANGE;
+		else if (!matherr(&exc)) {
+			errno = ERANGE;
+		}
+		break;
+	    case 7:
+	    case 107:
+		/* exp(finite) underflow */
+		exc.type = UNDERFLOW;
+		exc.name = type < 100 ? "exp" : "expf";
+		exc.retval = zero;
+		if (_LIB_VERSION == _POSIX_)
+		  errno = ERANGE;
+		else if (!matherr(&exc)) {
+			errno = ERANGE;
+		}
+		break;
+	    case 8:
+	    case 108:
+		/* y0(0) = -inf */
+		exc.type = DOMAIN;	/* should be SING for IEEE */
+		exc.name = type < 100 ? "y0" : "y0f";
+		if (_LIB_VERSION == _SVID_)
+		  exc.retval = -HUGE;
+		else
+		  exc.retval = -HUGE_VAL;
+		if (_LIB_VERSION == _POSIX_)
+		  errno = EDOM;
+		else if (!matherr(&exc)) {
+		  if (_LIB_VERSION == _SVID_) {
+			(void) WRITE2("y0: DOMAIN error\n", 17);
+		      }
+		  errno = EDOM;
+		}
+		break;
+	    case 9:
+	    case 109:
+		/* y0(x<0) = NaN */
+		exc.type = DOMAIN;
+		exc.name = type < 100 ? "y0" : "y0f";
+		if (_LIB_VERSION == _SVID_)
+		  exc.retval = -HUGE;
+		else
+		  exc.retval = -HUGE_VAL;
+		if (_LIB_VERSION == _POSIX_)
+		  errno = EDOM;
+		else if (!matherr(&exc)) {
+		  if (_LIB_VERSION == _SVID_) {
+			(void) WRITE2("y0: DOMAIN error\n", 17);
+		      }
+		  errno = EDOM;
+		}
+		break;
+	    case 10:
+	    case 110:
+		/* y1(0) = -inf */
+		exc.type = DOMAIN;	/* should be SING for IEEE */
+		exc.name = type < 100 ? "y1" : "y1f";
+		if (_LIB_VERSION == _SVID_)
+		  exc.retval = -HUGE;
+		else
+		  exc.retval = -HUGE_VAL;
+		if (_LIB_VERSION == _POSIX_)
+		  errno = EDOM;
+		else if (!matherr(&exc)) {
+		  if (_LIB_VERSION == _SVID_) {
+			(void) WRITE2("y1: DOMAIN error\n", 17);
+		      }
+		  errno = EDOM;
+		}
+		break;
+	    case 11:
+	    case 111:
+		/* y1(x<0) = NaN */
+		exc.type = DOMAIN;
+		exc.name = type < 100 ? "y1" : "y1f";
+		if (_LIB_VERSION == _SVID_)
+		  exc.retval = -HUGE;
+		else
+		  exc.retval = -HUGE_VAL;
+		if (_LIB_VERSION == _POSIX_)
+		  errno = EDOM;
+		else if (!matherr(&exc)) {
+		  if (_LIB_VERSION == _SVID_) {
+			(void) WRITE2("y1: DOMAIN error\n", 17);
+		      }
+		  errno = EDOM;
+		}
+		break;
+	    case 12:
+	    case 112:
+		/* yn(n,0) = -inf */
+		exc.type = DOMAIN;	/* should be SING for IEEE */
+		exc.name = type < 100 ? "yn" : "ynf";
+		if (_LIB_VERSION == _SVID_)
+		  exc.retval = -HUGE;
+		else
+		  exc.retval = -HUGE_VAL;
+		if (_LIB_VERSION == _POSIX_)
+		  errno = EDOM;
+		else if (!matherr(&exc)) {
+		  if (_LIB_VERSION == _SVID_) {
+			(void) WRITE2("yn: DOMAIN error\n", 17);
+		      }
+		  errno = EDOM;
+		}
+		break;
+	    case 13:
+	    case 113:
+		/* yn(x<0) = NaN */
+		exc.type = DOMAIN;
+		exc.name = type < 100 ? "yn" : "ynf";
+		if (_LIB_VERSION == _SVID_)
+		  exc.retval = -HUGE;
+		else
+		  exc.retval = -HUGE_VAL;
+		if (_LIB_VERSION == _POSIX_)
+		  errno = EDOM;
+		else if (!matherr(&exc)) {
+		  if (_LIB_VERSION == _SVID_) {
+			(void) WRITE2("yn: DOMAIN error\n", 17);
+		      }
+		  errno = EDOM;
+		}
+		break;
+	    case 14:
+	    case 114:
+		/* lgamma(finite) overflow */
+		exc.type = OVERFLOW;
+		exc.name = type < 100 ? "lgamma" : "lgammaf";
+                if (_LIB_VERSION == _SVID_)
+                  exc.retval = HUGE;
+                else
+                  exc.retval = HUGE_VAL;
+                if (_LIB_VERSION == _POSIX_)
+			errno = ERANGE;
+                else if (!matherr(&exc)) {
+                        errno = ERANGE;
+		}
+		break;
+	    case 15:
+	    case 115:
+		/* lgamma(-integer) or lgamma(0) */
+		exc.type = SING;
+		exc.name = type < 100 ? "lgamma" : "lgammaf";
+                if (_LIB_VERSION == _SVID_)
+                  exc.retval = HUGE;
+                else
+                  exc.retval = HUGE_VAL;
+		if (_LIB_VERSION == _POSIX_)
+		  errno = EDOM;
+		else if (!matherr(&exc)) {
+		  if (_LIB_VERSION == _SVID_) {
+			(void) WRITE2("lgamma: SING error\n", 19);
+		      }
+		  errno = EDOM;
+		}
+		break;
+	    case 16:
+	    case 116:
+		/* log(0) */
+		exc.type = SING;
+		exc.name = type < 100 ? "log" : "logf";
+		if (_LIB_VERSION == _SVID_)
+		  exc.retval = -HUGE;
+		else
+		  exc.retval = -HUGE_VAL;
+		if (_LIB_VERSION == _POSIX_)
+		  errno = ERANGE;
+		else if (!matherr(&exc)) {
+		  if (_LIB_VERSION == _SVID_) {
+			(void) WRITE2("log: SING error\n", 16);
+		      }
+		  errno = EDOM;
+		}
+		break;
+	    case 17:
+	    case 117:
+		/* log(x<0) */
+		exc.type = DOMAIN;
+		exc.name = type < 100 ? "log" : "logf";
+		if (_LIB_VERSION == _SVID_)
+		  exc.retval = -HUGE;
+		else
+		  exc.retval = -HUGE_VAL;
+		if (_LIB_VERSION == _POSIX_)
+		  errno = EDOM;
+		else if (!matherr(&exc)) {
+		  if (_LIB_VERSION == _SVID_) {
+			(void) WRITE2("log: DOMAIN error\n", 18);
+		      }
+		  errno = EDOM;
+		}
+		break;
+	    case 18:
+	    case 118:
+		/* log10(0) */
+		exc.type = SING;
+		exc.name = type < 100 ? "log10" : "log10f";
+		if (_LIB_VERSION == _SVID_)
+		  exc.retval = -HUGE;
+		else
+		  exc.retval = -HUGE_VAL;
+		if (_LIB_VERSION == _POSIX_)
+		  errno = ERANGE;
+		else if (!matherr(&exc)) {
+		  if (_LIB_VERSION == _SVID_) {
+			(void) WRITE2("log10: SING error\n", 18);
+		      }
+		  errno = EDOM;
+		}
+		break;
+	    case 19:
+	    case 119:
+		/* log10(x<0) */
+		exc.type = DOMAIN;
+		exc.name = type < 100 ? "log10" : "log10f";
+		if (_LIB_VERSION == _SVID_)
+		  exc.retval = -HUGE;
+		else
+		  exc.retval = -HUGE_VAL;
+		if (_LIB_VERSION == _POSIX_)
+		  errno = EDOM;
+		else if (!matherr(&exc)) {
+		  if (_LIB_VERSION == _SVID_) {
+			(void) WRITE2("log10: DOMAIN error\n", 20);
+		      }
+		  errno = EDOM;
+		}
+		break;
+	    case 20:
+	    case 120:
+		/* pow(0.0,0.0) */
+		/* error only if _LIB_VERSION == _SVID_ */
+		exc.type = DOMAIN;
+		exc.name = type < 100 ? "pow" : "powf";
+		exc.retval = zero;
+		if (_LIB_VERSION != _SVID_) exc.retval = 1.0;
+		else if (!matherr(&exc)) {
+			(void) WRITE2("pow(0,0): DOMAIN error\n", 23);
+			errno = EDOM;
+		}
+		break;
+	    case 21:
+	    case 121:
+		/* pow(x,y) overflow */
+		exc.type = OVERFLOW;
+		exc.name = type < 100 ? "pow" : "powf";
+		if (_LIB_VERSION == _SVID_) {
+		  exc.retval = HUGE;
+		  y *= 0.5;
+		  if(x<zero&&rint(y)!=y) exc.retval = -HUGE;
+		} else {
+		  exc.retval = HUGE_VAL;
+		  y *= 0.5;
+		  if(x<zero&&rint(y)!=y) exc.retval = -HUGE_VAL;
+		}
+		if (_LIB_VERSION == _POSIX_)
+		  errno = ERANGE;
+		else if (!matherr(&exc)) {
+			errno = ERANGE;
+		}
+		break;
+	    case 22:
+	    case 122:
+		/* pow(x,y) underflow */
+		exc.type = UNDERFLOW;
+		exc.name = type < 100 ? "pow" : "powf";
+		exc.retval =  zero;
+		if (_LIB_VERSION == _POSIX_)
+		  errno = ERANGE;
+		else if (!matherr(&exc)) {
+			errno = ERANGE;
+		}
+		break;
+	    case 23:
+	    case 123:
+		/* 0**neg */
+		exc.type = DOMAIN;
+		exc.name = type < 100 ? "pow" : "powf";
+		if (_LIB_VERSION == _SVID_)
+		  exc.retval = zero;
+		else
+		  exc.retval = -HUGE_VAL;
+		if (_LIB_VERSION == _POSIX_)
+		  errno = EDOM;
+		else if (!matherr(&exc)) {
+		  if (_LIB_VERSION == _SVID_) {
+			(void) WRITE2("pow(0,neg): DOMAIN error\n", 25);
+		      }
+		  errno = EDOM;
+		}
+		break;
+	    case 24:
+	    case 124:
+		/* neg**non-integral */
+		exc.type = DOMAIN;
+		exc.name = type < 100 ? "pow" : "powf";
+		if (_LIB_VERSION == _SVID_)
+		    exc.retval = zero;
+		else
+		    exc.retval = zero/zero;	/* X/Open allow NaN */
+		if (_LIB_VERSION == _POSIX_)
+		   errno = EDOM;
+		else if (!matherr(&exc)) {
+		  if (_LIB_VERSION == _SVID_) {
+			(void) WRITE2("neg**non-integral: DOMAIN error\n", 32);
+		      }
+		  errno = EDOM;
+		}
+		break;
+	    case 25:
+	    case 125:
+		/* sinh(finite) overflow */
+		exc.type = OVERFLOW;
+		exc.name = type < 100 ? "sinh" : "sinhf";
+		if (_LIB_VERSION == _SVID_)
+		  exc.retval = ( (x>zero) ? HUGE : -HUGE);
+		else
+		  exc.retval = ( (x>zero) ? HUGE_VAL : -HUGE_VAL);
+		if (_LIB_VERSION == _POSIX_)
+		  errno = ERANGE;
+		else if (!matherr(&exc)) {
+			errno = ERANGE;
+		}
+		break;
+	    case 26:
+	    case 126:
+		/* sqrt(x<0) */
+		exc.type = DOMAIN;
+		exc.name = type < 100 ? "sqrt" : "sqrtf";
+		if (_LIB_VERSION == _SVID_)
+		  exc.retval = zero;
+		else
+		  exc.retval = zero/zero;
+		if (_LIB_VERSION == _POSIX_)
+		  errno = EDOM;
+		else if (!matherr(&exc)) {
+		  if (_LIB_VERSION == _SVID_) {
+			(void) WRITE2("sqrt: DOMAIN error\n", 19);
+		      }
+		  errno = EDOM;
+		}
+		break;
+            case 27:
+	    case 127:
+                /* fmod(x,0) */
+                exc.type = DOMAIN;
+                exc.name = type < 100 ? "fmod" : "fmodf";
+                if (_LIB_VERSION == _SVID_)
+                    exc.retval = x;
+		else
+		    exc.retval = zero/zero;
+                if (_LIB_VERSION == _POSIX_)
+                  errno = EDOM;
+                else if (!matherr(&exc)) {
+                  if (_LIB_VERSION == _SVID_) {
+                    (void) WRITE2("fmod:  DOMAIN error\n", 20);
+                  }
+                  errno = EDOM;
+                }
+                break;
+            case 28:
+	    case 128:
+                /* remainder(x,0) */
+                exc.type = DOMAIN;
+                exc.name = type < 100 ? "remainder" : "remainderf";
+                exc.retval = zero/zero;
+                if (_LIB_VERSION == _POSIX_)
+                  errno = EDOM;
+                else if (!matherr(&exc)) {
+                  if (_LIB_VERSION == _SVID_) {
+                    (void) WRITE2("remainder: DOMAIN error\n", 24);
+                  }
+                  errno = EDOM;
+                }
+                break;
+            case 29:
+	    case 129:
+                /* acosh(x<1) */
+                exc.type = DOMAIN;
+                exc.name = type < 100 ? "acosh" : "acoshf";
+                exc.retval = zero/zero;
+                if (_LIB_VERSION == _POSIX_)
+                  errno = EDOM;
+                else if (!matherr(&exc)) {
+                  if (_LIB_VERSION == _SVID_) {
+                    (void) WRITE2("acosh: DOMAIN error\n", 20);
+                  }
+                  errno = EDOM;
+                }
+                break;
+            case 30:
+	    case 130:
+                /* atanh(|x|>1) */
+                exc.type = DOMAIN;
+                exc.name = type < 100 ? "atanh" : "atanhf";
+                exc.retval = zero/zero;
+                if (_LIB_VERSION == _POSIX_)
+                  errno = EDOM;
+                else if (!matherr(&exc)) {
+                  if (_LIB_VERSION == _SVID_) {
+                    (void) WRITE2("atanh: DOMAIN error\n", 20);
+                  }
+                  errno = EDOM;
+                }
+                break;
+            case 31:
+	    case 131:
+                /* atanh(|x|=1) */
+                exc.type = SING;
+                exc.name = type < 100 ? "atanh" : "atanhf";
+		exc.retval = x/zero;	/* sign(x)*inf */
+                if (_LIB_VERSION == _POSIX_)
+                  errno = EDOM;
+                else if (!matherr(&exc)) {
+                  if (_LIB_VERSION == _SVID_) {
+                    (void) WRITE2("atanh: SING error\n", 18);
+                  }
+                  errno = EDOM;
+                }
+                break;
+	    case 32:
+	    case 132:
+		/* scalb overflow; SVID also returns +-HUGE_VAL */
+		exc.type = OVERFLOW;
+		exc.name = type < 100 ? "scalb" : "scalbf";
+		exc.retval = x > zero ? HUGE_VAL : -HUGE_VAL;
+		if (_LIB_VERSION == _POSIX_)
+		  errno = ERANGE;
+		else if (!matherr(&exc)) {
+			errno = ERANGE;
+		}
+		break;
+	    case 33:
+	    case 133:
+		/* scalb underflow */
+		exc.type = UNDERFLOW;
+		exc.name = type < 100 ? "scalb" : "scalbf";
+		exc.retval = copysign(zero,x);
+		if (_LIB_VERSION == _POSIX_)
+		  errno = ERANGE;
+		else if (!matherr(&exc)) {
+			errno = ERANGE;
+		}
+		break;
+	    case 34:
+	    case 134:
+		/* j0(|x|>X_TLOSS) */
+                exc.type = TLOSS;
+                exc.name = type < 100 ? "j0" : "j0f";
+                exc.retval = zero;
+                if (_LIB_VERSION == _POSIX_)
+                        errno = ERANGE;
+                else if (!matherr(&exc)) {
+                        if (_LIB_VERSION == _SVID_) {
+                                (void) WRITE2(exc.name, 2);
+                                (void) WRITE2(": TLOSS error\n", 14);
+                        }
+                        errno = ERANGE;
+                }
+		break;
+	    case 35:
+	    case 135:
+		/* y0(x>X_TLOSS) */
+                exc.type = TLOSS;
+                exc.name = type < 100 ? "y0" : "y0f";
+                exc.retval = zero;
+                if (_LIB_VERSION == _POSIX_)
+                        errno = ERANGE;
+                else if (!matherr(&exc)) {
+                        if (_LIB_VERSION == _SVID_) {
+                                (void) WRITE2(exc.name, 2);
+                                (void) WRITE2(": TLOSS error\n", 14);
+                        }
+                        errno = ERANGE;
+                }
+		break;
+	    case 36:
+	    case 136:
+		/* j1(|x|>X_TLOSS) */
+                exc.type = TLOSS;
+                exc.name = type < 100 ? "j1" : "j1f";
+                exc.retval = zero;
+                if (_LIB_VERSION == _POSIX_)
+                        errno = ERANGE;
+                else if (!matherr(&exc)) {
+                        if (_LIB_VERSION == _SVID_) {
+                                (void) WRITE2(exc.name, 2);
+                                (void) WRITE2(": TLOSS error\n", 14);
+                        }
+                        errno = ERANGE;
+                }
+		break;
+	    case 37:
+	    case 137:
+		/* y1(x>X_TLOSS) */
+                exc.type = TLOSS;
+                exc.name = type < 100 ? "y1" : "y1f";
+                exc.retval = zero;
+                if (_LIB_VERSION == _POSIX_)
+                        errno = ERANGE;
+                else if (!matherr(&exc)) {
+                        if (_LIB_VERSION == _SVID_) {
+                                (void) WRITE2(exc.name, 2);
+                                (void) WRITE2(": TLOSS error\n", 14);
+                        }
+                        errno = ERANGE;
+                }
+		break;
+	    case 38:
+	    case 138:
+		/* jn(|x|>X_TLOSS) */
+                exc.type = TLOSS;
+                exc.name = type < 100 ? "jn" : "jnf";
+                exc.retval = zero;
+                if (_LIB_VERSION == _POSIX_)
+                        errno = ERANGE;
+                else if (!matherr(&exc)) {
+                        if (_LIB_VERSION == _SVID_) {
+                                (void) WRITE2(exc.name, 2);
+                                (void) WRITE2(": TLOSS error\n", 14);
+                        }
+                        errno = ERANGE;
+                }
+		break;
+	    case 39:
+	    case 139:
+		/* yn(x>X_TLOSS) */
+                exc.type = TLOSS;
+                exc.name = type < 100 ? "yn" : "ynf";
+                exc.retval = zero;
+                if (_LIB_VERSION == _POSIX_)
+                        errno = ERANGE;
+                else if (!matherr(&exc)) {
+                        if (_LIB_VERSION == _SVID_) {
+                                (void) WRITE2(exc.name, 2);
+                                (void) WRITE2(": TLOSS error\n", 14);
+                        }
+                        errno = ERANGE;
+                }
+		break;
+	    case 40:
+	    case 140:
+		/* gamma(finite) overflow */
+		exc.type = OVERFLOW;
+		exc.name = type < 100 ? "gamma" : "gammaf";
+                if (_LIB_VERSION == _SVID_)
+                  exc.retval = HUGE;
+                else
+                  exc.retval = HUGE_VAL;
+                if (_LIB_VERSION == _POSIX_)
+		  errno = ERANGE;
+                else if (!matherr(&exc)) {
+                  errno = ERANGE;
+                }
+		break;
+	    case 41:
+	    case 141:
+		/* gamma(-integer) or gamma(0) */
+		exc.type = SING;
+		exc.name = type < 100 ? "gamma" : "gammaf";
+                if (_LIB_VERSION == _SVID_)
+                  exc.retval = HUGE;
+                else
+                  exc.retval = HUGE_VAL;
+		if (_LIB_VERSION == _POSIX_)
+		  errno = EDOM;
+		else if (!matherr(&exc)) {
+		  if (_LIB_VERSION == _SVID_) {
+			(void) WRITE2("gamma: SING error\n", 18);
+		      }
+		  errno = EDOM;
+		}
+		break;
+	    case 42:
+	    case 142:
+		/* pow(NaN,0.0) */
+		/* error only if _LIB_VERSION == _SVID_ & _XOPEN_ */
+		exc.type = DOMAIN;
+		exc.name = type < 100 ? "pow" : "powf";
+		exc.retval = x;
+		if (_LIB_VERSION == _IEEE_ ||
+		    _LIB_VERSION == _POSIX_) exc.retval = 1.0;
+		else if (!matherr(&exc)) {
+			errno = EDOM;
+		}
+		break;
+	}
+	return exc.retval;
+}
diff -urN dietlibc-0.30/libm/k_tan.c dietlibc-0.30-libm/libm/k_tan.c
--- dietlibc-0.30/libm/k_tan.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/k_tan.c	2006-06-25 11:20:25.000000000 +0000
@@ -0,0 +1,131 @@
+/* @(#)k_tan.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: k_tan.c,v 1.8 1995/05/10 20:46:37 jtc Exp $";
+#endif
+
+/* __kernel_tan( x, y, k )
+ * kernel tan function on [-pi/4, pi/4], pi/4 ~ 0.7854
+ * Input x is assumed to be bounded by ~pi/4 in magnitude.
+ * Input y is the tail of x.
+ * Input k indicates whether tan (if k=1) or
+ * -1/tan (if k= -1) is returned.
+ *
+ * Algorithm
+ *	1. Since tan(-x) = -tan(x), we need only to consider positive x.
+ *	2. if x < 2^-28 (hx<0x3e300000 0), return x with inexact if x!=0.
+ *	3. tan(x) is approximated by a odd polynomial of degree 27 on
+ *	   [0,0.67434]
+ *		  	         3             27
+ *	   	tan(x) ~ x + T1*x + ... + T13*x
+ *	   where
+ *
+ * 	        |tan(x)         2     4            26   |     -59.2
+ * 	        |----- - (1+T1*x +T2*x +.... +T13*x    )| <= 2
+ * 	        |  x 					|
+ *
+ *	   Note: tan(x+y) = tan(x) + tan'(x)*y
+ *		          ~ tan(x) + (1+x*x)*y
+ *	   Therefore, for better accuracy in computing tan(x+y), let
+ *		     3      2      2       2       2
+ *		r = x *(T2+x *(T3+x *(...+x *(T12+x *T13))))
+ *	   then
+ *		 		    3    2
+ *		tan(x+y) = x + (T1*x + (x *(r+y)+y))
+ *
+ *      4. For x in [0.67434,pi/4],  let y = pi/4 - x, then
+ *		tan(x) = tan(pi/4-y) = (1-tan(y))/(1+tan(y))
+ *		       = 1 - 2*(tan(y) - (tan(y)^2)/(1+tan(y)))
+ */
+
+#include "math.h"
+#include "math_private.h"
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+one   =  1.00000000000000000000e+00, /* 0x3FF00000, 0x00000000 */
+pio4  =  7.85398163397448278999e-01, /* 0x3FE921FB, 0x54442D18 */
+pio4lo=  3.06161699786838301793e-17, /* 0x3C81A626, 0x33145C07 */
+T[] =  {
+  3.33333333333334091986e-01, /* 0x3FD55555, 0x55555563 */
+  1.33333333333201242699e-01, /* 0x3FC11111, 0x1110FE7A */
+  5.39682539762260521377e-02, /* 0x3FABA1BA, 0x1BB341FE */
+  2.18694882948595424599e-02, /* 0x3F9664F4, 0x8406D637 */
+  8.86323982359930005737e-03, /* 0x3F8226E3, 0xE96E8493 */
+  3.59207910759131235356e-03, /* 0x3F6D6D22, 0xC9560328 */
+  1.45620945432529025516e-03, /* 0x3F57DBC8, 0xFEE08315 */
+  5.88041240820264096874e-04, /* 0x3F4344D8, 0xF2F26501 */
+  2.46463134818469906812e-04, /* 0x3F3026F7, 0x1A8D1068 */
+  7.81794442939557092300e-05, /* 0x3F147E88, 0xA03792A6 */
+  7.14072491382608190305e-05, /* 0x3F12B80F, 0x32F0A7E9 */
+ -1.85586374855275456654e-05, /* 0xBEF375CB, 0xDB605373 */
+  2.59073051863633712884e-05, /* 0x3EFB2A70, 0x74BF7AD4 */
+};
+
+#ifdef __STDC__
+	double __kernel_tan(double x, double y, int iy)
+#else
+	double __kernel_tan(x, y, iy)
+	double x,y; int iy;
+#endif
+{
+	double z,r,v,w,s;
+	int32_t ix,hx;
+	GET_HIGH_WORD(hx,x);
+	ix = hx&0x7fffffff;	/* high word of |x| */
+	if(ix<0x3e300000)			/* x < 2**-28 */
+	    {if((int)x==0) {			/* generate inexact */
+	        u_int32_t low;
+		GET_LOW_WORD(low,x);
+		if(((ix|low)|(iy+1))==0) return one/fabs(x);
+		else return (iy==1)? x: -one/x;
+	    }
+	    }
+	if(ix>=0x3FE59428) { 			/* |x|>=0.6744 */
+	    if(hx<0) {x = -x; y = -y;}
+	    z = pio4-x;
+	    w = pio4lo-y;
+	    x = z+w; y = 0.0;
+	}
+	z	=  x*x;
+	w 	=  z*z;
+    /* Break x^5*(T[1]+x^2*T[2]+...) into
+     *	  x^5(T[1]+x^4*T[3]+...+x^20*T[11]) +
+     *	  x^5(x^2*(T[2]+x^4*T[4]+...+x^22*[T12]))
+     */
+	r = T[1]+w*(T[3]+w*(T[5]+w*(T[7]+w*(T[9]+w*T[11]))));
+	v = z*(T[2]+w*(T[4]+w*(T[6]+w*(T[8]+w*(T[10]+w*T[12])))));
+	s = z*x;
+	r = y + z*(s*(r+v)+y);
+	r += T[0]*s;
+	w = x+r;
+	if(ix>=0x3FE59428) {
+	    v = (double)iy;
+	    return (double)(1-((hx>>30)&2))*(v-2.0*(x-(w*w/(w+v)-r)));
+	}
+	if(iy==1) return w;
+	else {		/* if allow error up to 2 ulp,
+			   simply return -1.0/(x+r) here */
+     /*  compute -1.0/(x+r) accurately */
+	    double a,t;
+	    z  = w;
+	    SET_LOW_WORD(z,0);
+	    v  = r-(z - x); 	/* z+v = r+x */
+	    t = a  = -1.0/w;	/* a = -1.0/w */
+	    SET_LOW_WORD(t,0);
+	    s  = 1.0+t*z;
+	    return t+a*(s+t*v);
+	}
+}
diff -urN dietlibc-0.30/libm/math_private.h dietlibc-0.30-libm/libm/math_private.h
--- dietlibc-0.30/libm/math_private.h	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/math_private.h	2006-06-25 11:26:34.000000000 +0000
@@ -0,0 +1,236 @@
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+/*
+ * from: @(#)fdlibm.h 5.1 93/09/24
+ * $Id: math_private.h,v 1.3 2004/02/09 07:10:38 andersen Exp $
+ */
+
+#ifndef _MATH_PRIVATE_H_
+#define _MATH_PRIVATE_H_
+
+#  define weak_alias(name, aliasname) _weak_alias (name, aliasname)
+#  define _weak_alias(name, aliasname) \
+      extern __typeof (name) aliasname __attribute__ ((weak, alias (#name)));
+
+#include <endian.h>
+#include <sys/types.h>
+#define u_int32_t uint32_t
+
+/* The original fdlibm code used statements like:
+	n0 = ((*(int*)&one)>>29)^1;		* index of high word *
+	ix0 = *(n0+(int*)&x);			* high word of x *
+	ix1 = *((1-n0)+(int*)&x);		* low word of x *
+   to dig two 32 bit words out of the 64 bit IEEE floating point
+   value.  That is non-ANSI, and, moreover, the gcc instruction
+   scheduler gets it wrong.  We instead use the following macros.
+   Unlike the original code, we determine the endianness at compile
+   time, not at run time; I don't see much benefit to selecting
+   endianness at run time.  */
+
+/* A union which permits us to convert between a double and two 32 bit
+   ints.  */
+
+/*
+ * Math on arm is special:
+ * For FPA, float words are always big-endian.
+ * For VFP, floats words follow the memory system mode.
+ */
+
+#if (__BYTE_ORDER == __BIG_ENDIAN) || \
+    (!defined(__VFP_FP__) && (defined(__arm__) || defined(__thumb__)))
+
+typedef union
+{
+  double value;
+  struct
+  {
+    u_int32_t msw;
+    u_int32_t lsw;
+  } parts;
+} ieee_double_shape_type;
+
+#else
+
+typedef union
+{
+  double value;
+  struct
+  {
+    u_int32_t lsw;
+    u_int32_t msw;
+  } parts;
+} ieee_double_shape_type;
+
+#endif
+
+/* Get two 32 bit ints from a double.  */
+
+#define EXTRACT_WORDS(ix0,ix1,d)				\
+do {								\
+  ieee_double_shape_type ew_u;					\
+  ew_u.value = (d);						\
+  (ix0) = ew_u.parts.msw;					\
+  (ix1) = ew_u.parts.lsw;					\
+} while (0)
+
+/* Get the more significant 32 bit int from a double.  */
+
+#define GET_HIGH_WORD(i,d)					\
+do {								\
+  ieee_double_shape_type gh_u;					\
+  gh_u.value = (d);						\
+  (i) = gh_u.parts.msw;						\
+} while (0)
+
+/* Get the less significant 32 bit int from a double.  */
+
+#define GET_LOW_WORD(i,d)					\
+do {								\
+  ieee_double_shape_type gl_u;					\
+  gl_u.value = (d);						\
+  (i) = gl_u.parts.lsw;						\
+} while (0)
+
+/* Set a double from two 32 bit ints.  */
+
+#define INSERT_WORDS(d,ix0,ix1)					\
+do {								\
+  ieee_double_shape_type iw_u;					\
+  iw_u.parts.msw = (ix0);					\
+  iw_u.parts.lsw = (ix1);					\
+  (d) = iw_u.value;						\
+} while (0)
+
+/* Set the more significant 32 bits of a double from an int.  */
+
+#define SET_HIGH_WORD(d,v)					\
+do {								\
+  ieee_double_shape_type sh_u;					\
+  sh_u.value = (d);						\
+  sh_u.parts.msw = (v);						\
+  (d) = sh_u.value;						\
+} while (0)
+
+/* Set the less significant 32 bits of a double from an int.  */
+
+#define SET_LOW_WORD(d,v)					\
+do {								\
+  ieee_double_shape_type sl_u;					\
+  sl_u.value = (d);						\
+  sl_u.parts.lsw = (v);						\
+  (d) = sl_u.value;						\
+} while (0)
+
+/* A union which permits us to convert between a float and a 32 bit
+   int.  */
+
+typedef union
+{
+  float value;
+  u_int32_t word;
+} ieee_float_shape_type;
+
+/* Get a 32 bit int from a float.  */
+
+#define GET_FLOAT_WORD(i,d)					\
+do {								\
+  ieee_float_shape_type gf_u;					\
+  gf_u.value = (d);						\
+  (i) = gf_u.word;						\
+} while (0)
+
+/* Set a float from a 32 bit int.  */
+
+#define SET_FLOAT_WORD(d,i)					\
+do {								\
+  ieee_float_shape_type sf_u;					\
+  sf_u.word = (i);						\
+  (d) = sf_u.value;						\
+} while (0)
+
+/* ieee style elementary functions */
+extern double __ieee754_sqrt __P((double));
+extern double __ieee754_acos __P((double));
+extern double __ieee754_acosh __P((double));
+extern double __ieee754_log __P((double));
+extern double __ieee754_atanh __P((double));
+extern double __ieee754_asin __P((double));
+extern double __ieee754_atan2 __P((double,double));
+extern double __ieee754_exp __P((double));
+extern double __ieee754_cosh __P((double));
+extern double __ieee754_fmod __P((double,double));
+extern double __ieee754_pow __P((double,double));
+extern double __ieee754_lgamma_r __P((double,int *));
+extern double __ieee754_gamma_r __P((double,int *));
+extern double __ieee754_lgamma __P((double));
+extern double __ieee754_gamma __P((double));
+extern double __ieee754_log10 __P((double));
+extern double __ieee754_sinh __P((double));
+extern double __ieee754_hypot __P((double,double));
+extern double __ieee754_j0 __P((double));
+extern double __ieee754_j1 __P((double));
+extern double __ieee754_y0 __P((double));
+extern double __ieee754_y1 __P((double));
+extern double __ieee754_jn __P((int,double));
+extern double __ieee754_yn __P((int,double));
+extern double __ieee754_remainder __P((double,double));
+extern int    __ieee754_rem_pio2 __P((double,double*));
+#if defined(_SCALB_INT)
+extern double __ieee754_scalb __P((double,int));
+#else
+extern double __ieee754_scalb __P((double,double));
+#endif
+
+/* fdlibm kernel function */
+extern double __kernel_standard __P((double,double,int));
+extern double __kernel_sin __P((double,double,int));
+extern double __kernel_cos __P((double,double));
+extern double __kernel_tan __P((double,double,int));
+extern int    __kernel_rem_pio2 __P((double*,double*,int,int,int,const int*));
+
+
+/* ieee style elementary float functions */
+extern float __ieee754_sqrtf __P((float));
+extern float __ieee754_acosf __P((float));
+extern float __ieee754_acoshf __P((float));
+extern float __ieee754_logf __P((float));
+extern float __ieee754_atanhf __P((float));
+extern float __ieee754_asinf __P((float));
+extern float __ieee754_atan2f __P((float,float));
+extern float __ieee754_expf __P((float));
+extern float __ieee754_coshf __P((float));
+extern float __ieee754_fmodf __P((float,float));
+extern float __ieee754_powf __P((float,float));
+extern float __ieee754_lgammaf_r __P((float,int *));
+extern float __ieee754_gammaf_r __P((float,int *));
+extern float __ieee754_lgammaf __P((float));
+extern float __ieee754_gammaf __P((float));
+extern float __ieee754_log10f __P((float));
+extern float __ieee754_sinhf __P((float));
+extern float __ieee754_hypotf __P((float,float));
+extern float __ieee754_j0f __P((float));
+extern float __ieee754_j1f __P((float));
+extern float __ieee754_y0f __P((float));
+extern float __ieee754_y1f __P((float));
+extern float __ieee754_jnf __P((int,float));
+extern float __ieee754_ynf __P((int,float));
+extern float __ieee754_remainderf __P((float,float));
+extern int   __ieee754_rem_pio2f __P((float,float*));
+extern float __ieee754_scalbf __P((float,float));
+
+/* float versions of fdlibm kernel functions */
+extern float __kernel_sinf __P((float,float,int));
+extern float __kernel_cosf __P((float,float));
+extern float __kernel_tanf __P((float,float,int));
+extern int   __kernel_rem_pio2f __P((float*,float*,int,int,int,const int*));
+
+#endif /* _MATH_PRIVATE_H_ */
diff -urN dietlibc-0.30/libm/modf.c dietlibc-0.30-libm/libm/modf.c
--- dietlibc-0.30/libm/modf.c	2003-03-30 19:19:53.000000000 +0000
+++ dietlibc-0.30-libm/libm/modf.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,7 +0,0 @@
-#include <math.h>
-
-double modf(double x, double *iptr) {
-  double fmod_result = fmod(x,1.0);
-  *iptr = x - fmod_result;
-  return fmod_result;
-}
diff -urN dietlibc-0.30/libm/nan.c dietlibc-0.30-libm/libm/nan.c
--- dietlibc-0.30/libm/nan.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/nan.c	2006-06-25 11:20:03.000000000 +0000
@@ -0,0 +1,48 @@
+/***********************************************************************
+    nan, nanf, nanl - return quiet NaN
+
+	These functions shall return a quiet NaN, if available, with content
+	indicated through tagp.
+
+	If the implementation does not support quiet NaNs, these functions
+	shall return zero.
+
+   Calls:  strlen(), sprintf(), strtod()
+
+***********************************************************************/
+#include <math.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+double nan (const char *tagp)
+{
+    if (tagp[0] != '\0') {
+	char buf[6 + strlen (tagp)];
+	sprintf (buf, "NAN(%s)", tagp);
+	return strtod (buf, NULL);
+    }
+    return NAN;
+}
+
+float nanf (const char *tagp)
+{
+    if (tagp[0] != '\0') {
+	char buf[6 + strlen (tagp)];
+	sprintf (buf, "NAN(%s)", tagp);
+	return strtof (buf, NULL);
+    }
+    return NAN;
+}
+
+#if 0
+long double nanl (const char *tagp)
+{
+    if (tagp[0] != '\0') {
+	char buf[6 + strlen (tagp)];
+	sprintf (buf, "NAN(%s)", tagp);
+	return strtold (buf, NULL);
+    }
+    return NAN;
+}
+#endif
diff -urN dietlibc-0.30/libm/poly.c dietlibc-0.30-libm/libm/poly.c
--- dietlibc-0.30/libm/poly.c	2002-11-18 01:16:51.000000000 +0000
+++ dietlibc-0.30-libm/libm/poly.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,41 +0,0 @@
-/*--------------------------------------------------------------------------*
-
-Name		__poly - generates a polynomial from arguments
-
-Usage		double  __poly ( double x, int n, const double* c );
-
-Prototype in	math.h
-
-Description	__poly generates a polynomial in x, of degree n, with
-		coefficients c[0], c[1], ..., c[n]. For example, if n=4,
-		the generated polynomial is
-
-			c[4]*x^4 + c[3]*x^3 + c[2]*x^2 + c[1]*x + c[0]
-
-		The polynomial is calculated using Horner's method:
-
-			polynom = (..((x*c[n] + c[n-1])*x + c[n-2])..)*x + c[0]
-
-Return value	__poly returns the value of the polynomial as evaluated for
-		the given x.
-		A range error occurs if the result exceeds double range.
-
-*---------------------------------------------------------------------------*/
-
-#include <stdio.h>
-#include "dietlibm.h"
-
-double  __poly ( double x, size_t n, const double* c) 
-{
-    long double ret;
-    size_t      i;
-    
-    i   = n;
-    c  += n;
-    ret = 0;
-    do
-        ret = ret * x + *c--;
-    while ( i-- );
-    
-    return ret;
-}
diff -urN dietlibc-0.30/libm/pow.c dietlibc-0.30-libm/libm/pow.c
--- dietlibc-0.30/libm/pow.c	2003-10-10 13:37:34.000000000 +0000
+++ dietlibc-0.30-libm/libm/pow.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,42 +0,0 @@
-
-#include <math.h>
-#include "dietlibm.h"
-
-double  pow ( double mant, double expo )
-{
-    unsigned int  e;
-    long double   ret;
-
-    /* special cases 0^x */
-    if ( mant == 0. ) {
-        if ( expo > 0. )
-            return 0.;
-        else if ( expo == 0. )
-            return 1.;
-        else
-            return 1./mant;
-    }
-    
-    /* special cases x^n with n is integer */
-    if ( expo == (int) (e = (int) expo) ) {
-           
-        if ( (int)e < 0 ) {
-            e    = -e;
-            mant = 1./mant;
-        }
-   
-        ret = 1.;
-        
-        while (1) {
-            if ( e & 1 )
-                ret *= mant;
-            if ( (e >>= 1) == 0 )
-                break;
-            mant *= mant;
-         }
-        return ret;
-    }
-    
-    /* normal case */
-    return exp ( log (mant) * expo );
-}
diff -urN dietlibc-0.30/libm/rint.c dietlibc-0.30-libm/libm/rint.c
--- dietlibc-0.30/libm/rint.c	2001-07-30 13:45:43.000000000 +0000
+++ dietlibc-0.30-libm/libm/rint.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,5 +0,0 @@
-#include <math.h>
-
-double rint(double x) {
-  return floor(x+0.5);
-}
diff -urN dietlibc-0.30/libm/s_asinh.c dietlibc-0.30-libm/libm/s_asinh.c
--- dietlibc-0.30/libm/s_asinh.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_asinh.c	2006-06-25 11:19:59.000000000 +0000
@@ -0,0 +1,65 @@
+/* @(#)s_asinh.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_asinh.c,v 1.9 1995/05/12 04:57:37 jtc Exp $";
+#endif
+
+/* asinh(x)
+ * Method :
+ *	Based on
+ *		asinh(x) = sign(x) * log [ |x| + sqrt(x*x+1) ]
+ *	we have
+ *	asinh(x) := x  if  1+x*x=1,
+ *		 := sign(x)*(log(x)+ln2)) for large |x|, else
+ *		 := sign(x)*log(2|x|+1/(|x|+sqrt(x*x+1))) if|x|>2, else
+ *		 := sign(x)*log1p(|x| + x^2/(1 + sqrt(1+x^2)))
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+one =  1.00000000000000000000e+00, /* 0x3FF00000, 0x00000000 */
+ln2 =  6.93147180559945286227e-01, /* 0x3FE62E42, 0xFEFA39EF */
+huge=  1.00000000000000000000e+300;
+
+#ifdef __STDC__
+	double asinh(double x)
+#else
+	double asinh(x)
+	double x;
+#endif
+{
+	double t,w;
+	int32_t hx,ix;
+	GET_HIGH_WORD(hx,x);
+	ix = hx&0x7fffffff;
+	if(ix>=0x7ff00000) return x+x;	/* x is inf or NaN */
+	if(ix< 0x3e300000) {	/* |x|<2**-28 */
+	    if(huge+x>one) return x;	/* return x inexact except 0 */
+	}
+	if(ix>0x41b00000) {	/* |x| > 2**28 */
+	    w = __ieee754_log(fabs(x))+ln2;
+	} else if (ix>0x40000000) {	/* 2**28 > |x| > 2.0 */
+	    t = fabs(x);
+	    w = __ieee754_log(2.0*t+one/(__ieee754_sqrt(x*x+one)+t));
+	} else {		/* 2.0 > |x| > 2**-28 */
+	    t = x*x;
+	    w =log1p(fabs(x)+t/(one+__ieee754_sqrt(one+t)));
+	}
+	if(hx>0) return w; else return -w;
+}
diff -urN dietlibc-0.30/libm/s_atan.c dietlibc-0.30-libm/libm/s_atan.c
--- dietlibc-0.30/libm/s_atan.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_atan.c	2006-06-25 11:20:16.000000000 +0000
@@ -0,0 +1,139 @@
+/* @(#)s_atan.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_atan.c,v 1.8 1995/05/10 20:46:45 jtc Exp $";
+#endif
+
+/* atan(x)
+ * Method
+ *   1. Reduce x to positive by atan(x) = -atan(-x).
+ *   2. According to the integer k=4t+0.25 chopped, t=x, the argument
+ *      is further reduced to one of the following intervals and the
+ *      arctangent of t is evaluated by the corresponding formula:
+ *
+ *      [0,7/16]      atan(x) = t-t^3*(a1+t^2*(a2+...(a10+t^2*a11)...)
+ *      [7/16,11/16]  atan(x) = atan(1/2) + atan( (t-0.5)/(1+t/2) )
+ *      [11/16.19/16] atan(x) = atan( 1 ) + atan( (t-1)/(1+t) )
+ *      [19/16,39/16] atan(x) = atan(3/2) + atan( (t-1.5)/(1+1.5t) )
+ *      [39/16,INF]   atan(x) = atan(INF) + atan( -1/t )
+ *
+ * Constants:
+ * The hexadecimal values are the intended ones for the following
+ * constants. The decimal values may be used, provided that the
+ * compiler will convert from decimal to binary accurately enough
+ * to produce the hexadecimal values shown.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double atanhi[] = {
+#else
+static double atanhi[] = {
+#endif
+  4.63647609000806093515e-01, /* atan(0.5)hi 0x3FDDAC67, 0x0561BB4F */
+  7.85398163397448278999e-01, /* atan(1.0)hi 0x3FE921FB, 0x54442D18 */
+  9.82793723247329054082e-01, /* atan(1.5)hi 0x3FEF730B, 0xD281F69B */
+  1.57079632679489655800e+00, /* atan(inf)hi 0x3FF921FB, 0x54442D18 */
+};
+
+#ifdef __STDC__
+static const double atanlo[] = {
+#else
+static double atanlo[] = {
+#endif
+  2.26987774529616870924e-17, /* atan(0.5)lo 0x3C7A2B7F, 0x222F65E2 */
+  3.06161699786838301793e-17, /* atan(1.0)lo 0x3C81A626, 0x33145C07 */
+  1.39033110312309984516e-17, /* atan(1.5)lo 0x3C700788, 0x7AF0CBBD */
+  6.12323399573676603587e-17, /* atan(inf)lo 0x3C91A626, 0x33145C07 */
+};
+
+#ifdef __STDC__
+static const double aT[] = {
+#else
+static double aT[] = {
+#endif
+  3.33333333333329318027e-01, /* 0x3FD55555, 0x5555550D */
+ -1.99999999998764832476e-01, /* 0xBFC99999, 0x9998EBC4 */
+  1.42857142725034663711e-01, /* 0x3FC24924, 0x920083FF */
+ -1.11111104054623557880e-01, /* 0xBFBC71C6, 0xFE231671 */
+  9.09088713343650656196e-02, /* 0x3FB745CD, 0xC54C206E */
+ -7.69187620504482999495e-02, /* 0xBFB3B0F2, 0xAF749A6D */
+  6.66107313738753120669e-02, /* 0x3FB10D66, 0xA0D03D51 */
+ -5.83357013379057348645e-02, /* 0xBFADDE2D, 0x52DEFD9A */
+  4.97687799461593236017e-02, /* 0x3FA97B4B, 0x24760DEB */
+ -3.65315727442169155270e-02, /* 0xBFA2B444, 0x2C6A6C2F */
+  1.62858201153657823623e-02, /* 0x3F90AD3A, 0xE322DA11 */
+};
+
+#ifdef __STDC__
+	static const double
+#else
+	static double
+#endif
+one   = 1.0,
+huge   = 1.0e300;
+
+#ifdef __STDC__
+	double atan(double x)
+#else
+	double atan(x)
+	double x;
+#endif
+{
+	double w,s1,s2,z;
+	int32_t ix,hx,id;
+
+	GET_HIGH_WORD(hx,x);
+	ix = hx&0x7fffffff;
+	if(ix>=0x44100000) {	/* if |x| >= 2^66 */
+	    u_int32_t low;
+	    GET_LOW_WORD(low,x);
+	    if(ix>0x7ff00000||
+		(ix==0x7ff00000&&(low!=0)))
+		return x+x;		/* NaN */
+	    if(hx>0) return  atanhi[3]+atanlo[3];
+	    else     return -atanhi[3]-atanlo[3];
+	} if (ix < 0x3fdc0000) {	/* |x| < 0.4375 */
+	    if (ix < 0x3e200000) {	/* |x| < 2^-29 */
+		if(huge+x>one) return x;	/* raise inexact */
+	    }
+	    id = -1;
+	} else {
+	x = fabs(x);
+	if (ix < 0x3ff30000) {		/* |x| < 1.1875 */
+	    if (ix < 0x3fe60000) {	/* 7/16 <=|x|<11/16 */
+		id = 0; x = (2.0*x-one)/(2.0+x);
+	    } else {			/* 11/16<=|x|< 19/16 */
+		id = 1; x  = (x-one)/(x+one);
+	    }
+	} else {
+	    if (ix < 0x40038000) {	/* |x| < 2.4375 */
+		id = 2; x  = (x-1.5)/(one+1.5*x);
+	    } else {			/* 2.4375 <= |x| < 2^66 */
+		id = 3; x  = -1.0/x;
+	    }
+	}}
+    /* end of argument reduction */
+	z = x*x;
+	w = z*z;
+    /* break sum from i=0 to 10 aT[i]z**(i+1) into odd and even poly */
+	s1 = z*(aT[0]+w*(aT[2]+w*(aT[4]+w*(aT[6]+w*(aT[8]+w*aT[10])))));
+	s2 = w*(aT[1]+w*(aT[3]+w*(aT[5]+w*(aT[7]+w*aT[9]))));
+	if (id<0) return x - x*(s1+s2);
+	else {
+	    z = atanhi[id] - ((x*(s1+s2) - atanlo[id]) - x);
+	    return (hx<0)? -z:z;
+	}
+}
diff -urN dietlibc-0.30/libm/s_cbrt.c dietlibc-0.30-libm/libm/s_cbrt.c
--- dietlibc-0.30/libm/s_cbrt.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_cbrt.c	2006-06-25 11:20:16.000000000 +0000
@@ -0,0 +1,93 @@
+/* @(#)s_cbrt.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_cbrt.c,v 1.8 1995/05/10 20:46:49 jtc Exp $";
+#endif
+
+#include "math.h"
+#include "math_private.h"
+
+/* cbrt(x)
+ * Return cube root of x
+ */
+#ifdef __STDC__
+static const u_int32_t
+#else
+static u_int32_t
+#endif
+	B1 = 715094163, /* B1 = (682-0.03306235651)*2**20 */
+	B2 = 696219795; /* B2 = (664-0.03306235651)*2**20 */
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+C =  5.42857142857142815906e-01, /* 19/35     = 0x3FE15F15, 0xF15F15F1 */
+D = -7.05306122448979611050e-01, /* -864/1225 = 0xBFE691DE, 0x2532C834 */
+E =  1.41428571428571436819e+00, /* 99/70     = 0x3FF6A0EA, 0x0EA0EA0F */
+F =  1.60714285714285720630e+00, /* 45/28     = 0x3FF9B6DB, 0x6DB6DB6E */
+G =  3.57142857142857150787e-01; /* 5/14      = 0x3FD6DB6D, 0xB6DB6DB7 */
+
+#ifdef __STDC__
+	double cbrt(double x)
+#else
+	double cbrt(x)
+	double x;
+#endif
+{
+	int32_t	hx;
+	double r,s,t=0.0,w;
+	u_int32_t sign;
+	u_int32_t high,low;
+
+	GET_HIGH_WORD(hx,x);
+	sign=hx&0x80000000; 		/* sign= sign(x) */
+	hx  ^=sign;
+	if(hx>=0x7ff00000) return(x+x); /* cbrt(NaN,INF) is itself */
+	GET_LOW_WORD(low,x);
+	if((hx|low)==0)
+	    return(x);		/* cbrt(0) is itself */
+
+	SET_HIGH_WORD(x,hx);	/* x <- |x| */
+    /* rough cbrt to 5 bits */
+	if(hx<0x00100000) 		/* subnormal number */
+	  {SET_HIGH_WORD(t,0x43500000);	/* set t= 2**54 */
+	   t*=x; GET_HIGH_WORD(high,t); SET_HIGH_WORD(t,high/3+B2);
+	  }
+	else
+	  SET_HIGH_WORD(t,hx/3+B1);
+
+
+    /* new cbrt to 23 bits, may be implemented in single precision */
+	r=t*t/x;
+	s=C+r*t;
+	t*=G+F/(s+E+D/s);
+
+    /* chopped to 20 bits and make it larger than cbrt(x) */
+	GET_HIGH_WORD(high,t);
+	INSERT_WORDS(t,high+0x00000001,0);
+
+
+    /* one step newton iteration to 53 bits with error less than 0.667 ulps */
+	s=t*t;		/* t*t is exact */
+	r=x/s;
+	w=t+t;
+	r=(r-t)/(w+r);	/* r-s is exact */
+	t=t+t*r;
+
+    /* retore the sign bit */
+	GET_HIGH_WORD(high,t);
+	SET_HIGH_WORD(t,high|sign);
+	return(t);
+}
diff -urN dietlibc-0.30/libm/s_ceil.c dietlibc-0.30-libm/libm/s_ceil.c
--- dietlibc-0.30/libm/s_ceil.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_ceil.c	2006-06-25 11:29:20.000000000 +0000
@@ -0,0 +1,81 @@
+/* @(#)s_ceil.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_ceil.c,v 1.8 1995/05/10 20:46:53 jtc Exp $";
+#endif
+
+/*
+ * ceil(x)
+ * Return x rounded toward -inf to integral value
+ * Method:
+ *	Bit twiddling.
+ * Exception:
+ *	Inexact flag raised if x not equal to ceil(x).
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double huge = 1.0e300;
+#else
+static double huge = 1.0e300;
+#endif
+
+#ifdef __STDC__
+	double __ceil(double x)
+#else
+	double __ceil(x)
+	double x;
+#endif
+{
+	int32_t i0,i1,j0;
+	u_int32_t i,j;
+	EXTRACT_WORDS(i0,i1,x);
+	j0 = ((i0>>20)&0x7ff)-0x3ff;
+	if(j0<20) {
+	    if(j0<0) { 	/* raise inexact if x != 0 */
+		if(huge+x>0.0) {/* return 0*sign(x) if |x|<1 */
+		    if(i0<0) {i0=0x80000000;i1=0;}
+		    else if((i0|i1)!=0) { i0=0x3ff00000;i1=0;}
+		}
+	    } else {
+		i = (0x000fffff)>>j0;
+		if(((i0&i)|i1)==0) return x; /* x is integral */
+		if(huge+x>0.0) {	/* raise inexact flag */
+		    if(i0>0) i0 += (0x00100000)>>j0;
+		    i0 &= (~i); i1=0;
+		}
+	    }
+	} else if (j0>51) {
+	    if(j0==0x400) return x+x;	/* inf or NaN */
+	    else return x;		/* x is integral */
+	} else {
+	    i = ((u_int32_t)(0xffffffff))>>(j0-20);
+	    if((i1&i)==0) return x;	/* x is integral */
+	    if(huge+x>0.0) { 		/* raise inexact flag */
+		if(i0>0) {
+		    if(j0==20) i0+=1;
+		    else {
+			j = i1 + (1<<(52-j0));
+			if(j<i1) i0+=1;	/* got a carry */
+			i1 = j;
+		    }
+		}
+		i1 &= (~i);
+	    }
+	}
+	INSERT_WORDS(x,i0,i1);
+	return x;
+}
+weak_alias (__ceil, ceil)
diff -urN dietlibc-0.30/libm/s_ceilf.c dietlibc-0.30-libm/libm/s_ceilf.c
--- dietlibc-0.30/libm/s_ceilf.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_ceilf.c	2006-06-25 11:20:03.000000000 +0000
@@ -0,0 +1,62 @@
+/* s_ceilf.c -- float version of s_ceil.c.
+ * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
+ */
+
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_ceilf.c,v 1.4 1995/05/10 20:46:55 jtc Exp $";
+#endif
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const float huge = 1.0e30;
+#else
+static float huge = 1.0e30;
+#endif
+
+#ifdef __STDC__
+	float __ceilf(float x)
+#else
+	float __ceilf(x)
+	float x;
+#endif
+{
+	int32_t i0,j0;
+	u_int32_t i;
+
+	GET_FLOAT_WORD(i0,x);
+	j0 = ((i0>>23)&0xff)-0x7f;
+	if(j0<23) {
+	    if(j0<0) { 	/* raise inexact if x != 0 */
+		if(huge+x>(float)0.0) {/* return 0*sign(x) if |x|<1 */
+		    if(i0<0) {i0=0x80000000;}
+		    else if(i0!=0) { i0=0x3f800000;}
+		}
+	    } else {
+		i = (0x007fffff)>>j0;
+		if((i0&i)==0) return x; /* x is integral */
+		if(huge+x>(float)0.0) {	/* raise inexact flag */
+		    if(i0>0) i0 += (0x00800000)>>j0;
+		    i0 &= (~i);
+		}
+	    }
+	} else {
+	    if(j0==0x80) return x+x;	/* inf or NaN */
+	    else return x;		/* x is integral */
+	}
+	SET_FLOAT_WORD(x,i0);
+	return x;
+}
+weak_alias (__ceilf, ceilf)
diff -urN dietlibc-0.30/libm/s_copysign.c dietlibc-0.30-libm/libm/s_copysign.c
--- dietlibc-0.30/libm/s_copysign.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_copysign.c	2006-06-25 11:20:05.000000000 +0000
@@ -0,0 +1,39 @@
+/* @(#)s_copysign.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_copysign.c,v 1.8 1995/05/10 20:46:57 jtc Exp $";
+#endif
+
+/*
+ * copysign(double x, double y)
+ * copysign(x,y) returns a value with the magnitude of x and
+ * with the sign bit of y.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+	double copysign(double x, double y)
+#else
+	double copysign(x,y)
+	double x,y;
+#endif
+{
+	u_int32_t hx,hy;
+	GET_HIGH_WORD(hx,x);
+	GET_HIGH_WORD(hy,y);
+	SET_HIGH_WORD(x,(hx&0x7fffffff)|(hy&0x80000000));
+        return x;
+}
+
diff -urN dietlibc-0.30/libm/s_cos.c dietlibc-0.30-libm/libm/s_cos.c
--- dietlibc-0.30/libm/s_cos.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_cos.c	2006-06-25 11:20:04.000000000 +0000
@@ -0,0 +1,82 @@
+/* @(#)s_cos.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_cos.c,v 1.7 1995/05/10 20:47:02 jtc Exp $";
+#endif
+
+/* cos(x)
+ * Return cosine function of x.
+ *
+ * kernel function:
+ *	__kernel_sin		... sine function on [-pi/4,pi/4]
+ *	__kernel_cos		... cosine function on [-pi/4,pi/4]
+ *	__ieee754_rem_pio2	... argument reduction routine
+ *
+ * Method.
+ *      Let S,C and T denote the sin, cos and tan respectively on
+ *	[-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2
+ *	in [-pi/4 , +pi/4], and let n = k mod 4.
+ *	We have
+ *
+ *          n        sin(x)      cos(x)        tan(x)
+ *     ----------------------------------------------------------
+ *	    0	       S	   C		 T
+ *	    1	       C	  -S		-1/T
+ *	    2	      -S	  -C		 T
+ *	    3	      -C	   S		-1/T
+ *     ----------------------------------------------------------
+ *
+ * Special cases:
+ *      Let trig be any of sin, cos, or tan.
+ *      trig(+-INF)  is NaN, with signals;
+ *      trig(NaN)    is that NaN;
+ *
+ * Accuracy:
+ *	TRIG(x) returns trig(x) nearly rounded
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+	double cos(double x)
+#else
+	double cos(x)
+	double x;
+#endif
+{
+	double y[2],z=0.0;
+	int32_t n, ix;
+
+    /* High word of x. */
+	GET_HIGH_WORD(ix,x);
+
+    /* |x| ~< pi/4 */
+	ix &= 0x7fffffff;
+	if(ix <= 0x3fe921fb) return __kernel_cos(x,z);
+
+    /* cos(Inf or NaN) is NaN */
+	else if (ix>=0x7ff00000) return x-x;
+
+    /* argument reduction needed */
+	else {
+	    n = __ieee754_rem_pio2(x,y);
+	    switch(n&3) {
+		case 0: return  __kernel_cos(y[0],y[1]);
+		case 1: return -__kernel_sin(y[0],y[1],1);
+		case 2: return -__kernel_cos(y[0],y[1]);
+		default:
+		        return  __kernel_sin(y[0],y[1],1);
+	    }
+	}
+}
diff -urN dietlibc-0.30/libm/s_erf.c dietlibc-0.30-libm/libm/s_erf.c
--- dietlibc-0.30/libm/s_erf.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_erf.c	2006-06-25 11:20:05.000000000 +0000
@@ -0,0 +1,314 @@
+/* @(#)s_erf.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_erf.c,v 1.8 1995/05/10 20:47:05 jtc Exp $";
+#endif
+
+/* double erf(double x)
+ * double erfc(double x)
+ *			     x
+ *		      2      |\
+ *     erf(x)  =  ---------  | exp(-t*t)dt
+ *	 	   sqrt(pi) \|
+ *			     0
+ *
+ *     erfc(x) =  1-erf(x)
+ *  Note that
+ *		erf(-x) = -erf(x)
+ *		erfc(-x) = 2 - erfc(x)
+ *
+ * Method:
+ *	1. For |x| in [0, 0.84375]
+ *	    erf(x)  = x + x*R(x^2)
+ *          erfc(x) = 1 - erf(x)           if x in [-.84375,0.25]
+ *                  = 0.5 + ((0.5-x)-x*R)  if x in [0.25,0.84375]
+ *	   where R = P/Q where P is an odd poly of degree 8 and
+ *	   Q is an odd poly of degree 10.
+ *						 -57.90
+ *			| R - (erf(x)-x)/x | <= 2
+ *
+ *
+ *	   Remark. The formula is derived by noting
+ *          erf(x) = (2/sqrt(pi))*(x - x^3/3 + x^5/10 - x^7/42 + ....)
+ *	   and that
+ *          2/sqrt(pi) = 1.128379167095512573896158903121545171688
+ *	   is close to one. The interval is chosen because the fix
+ *	   point of erf(x) is near 0.6174 (i.e., erf(x)=x when x is
+ *	   near 0.6174), and by some experiment, 0.84375 is chosen to
+ * 	   guarantee the error is less than one ulp for erf.
+ *
+ *      2. For |x| in [0.84375,1.25], let s = |x| - 1, and
+ *         c = 0.84506291151 rounded to single (24 bits)
+ *         	erf(x)  = sign(x) * (c  + P1(s)/Q1(s))
+ *         	erfc(x) = (1-c)  - P1(s)/Q1(s) if x > 0
+ *			  1+(c+P1(s)/Q1(s))    if x < 0
+ *         	|P1/Q1 - (erf(|x|)-c)| <= 2**-59.06
+ *	   Remark: here we use the taylor series expansion at x=1.
+ *		erf(1+s) = erf(1) + s*Poly(s)
+ *			 = 0.845.. + P1(s)/Q1(s)
+ *	   That is, we use rational approximation to approximate
+ *			erf(1+s) - (c = (single)0.84506291151)
+ *	   Note that |P1/Q1|< 0.078 for x in [0.84375,1.25]
+ *	   where
+ *		P1(s) = degree 6 poly in s
+ *		Q1(s) = degree 6 poly in s
+ *
+ *      3. For x in [1.25,1/0.35(~2.857143)],
+ *         	erfc(x) = (1/x)*exp(-x*x-0.5625+R1/S1)
+ *         	erf(x)  = 1 - erfc(x)
+ *	   where
+ *		R1(z) = degree 7 poly in z, (z=1/x^2)
+ *		S1(z) = degree 8 poly in z
+ *
+ *      4. For x in [1/0.35,28]
+ *         	erfc(x) = (1/x)*exp(-x*x-0.5625+R2/S2) if x > 0
+ *			= 2.0 - (1/x)*exp(-x*x-0.5625+R2/S2) if -6<x<0
+ *			= 2.0 - tiny		(if x <= -6)
+ *         	erf(x)  = sign(x)*(1.0 - erfc(x)) if x < 6, else
+ *         	erf(x)  = sign(x)*(1.0 - tiny)
+ *	   where
+ *		R2(z) = degree 6 poly in z, (z=1/x^2)
+ *		S2(z) = degree 7 poly in z
+ *
+ *      Note1:
+ *	   To compute exp(-x*x-0.5625+R/S), let s be a single
+ *	   precision number and s := x; then
+ *		-x*x = -s*s + (s-x)*(s+x)
+ *	        exp(-x*x-0.5626+R/S) =
+ *			exp(-s*s-0.5625)*exp((s-x)*(s+x)+R/S);
+ *      Note2:
+ *	   Here 4 and 5 make use of the asymptotic series
+ *			  exp(-x*x)
+ *		erfc(x) ~ ---------- * ( 1 + Poly(1/x^2) )
+ *			  x*sqrt(pi)
+ *	   We use rational approximation to approximate
+ *      	g(s)=f(1/x^2) = log(erfc(x)*x) - x*x + 0.5625
+ *	   Here is the error bound for R1/S1 and R2/S2
+ *      	|R1/S1 - f(x)|  < 2**(-62.57)
+ *      	|R2/S2 - f(x)|  < 2**(-61.52)
+ *
+ *      5. For inf > x >= 28
+ *         	erf(x)  = sign(x) *(1 - tiny)  (raise inexact)
+ *         	erfc(x) = tiny*tiny (raise underflow) if x > 0
+ *			= 2 - tiny if x<0
+ *
+ *      7. Special case:
+ *         	erf(0)  = 0, erf(inf)  = 1, erf(-inf) = -1,
+ *         	erfc(0) = 1, erfc(inf) = 0, erfc(-inf) = 2,
+ *	   	erfc/erf(NaN) is NaN
+ */
+
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+tiny	    = 1e-300,
+half=  5.00000000000000000000e-01, /* 0x3FE00000, 0x00000000 */
+one =  1.00000000000000000000e+00, /* 0x3FF00000, 0x00000000 */
+two =  2.00000000000000000000e+00, /* 0x40000000, 0x00000000 */
+	/* c = (float)0.84506291151 */
+erx =  8.45062911510467529297e-01, /* 0x3FEB0AC1, 0x60000000 */
+/*
+ * Coefficients for approximation to  erf on [0,0.84375]
+ */
+efx =  1.28379167095512586316e-01, /* 0x3FC06EBA, 0x8214DB69 */
+efx8=  1.02703333676410069053e+00, /* 0x3FF06EBA, 0x8214DB69 */
+pp0  =  1.28379167095512558561e-01, /* 0x3FC06EBA, 0x8214DB68 */
+pp1  = -3.25042107247001499370e-01, /* 0xBFD4CD7D, 0x691CB913 */
+pp2  = -2.84817495755985104766e-02, /* 0xBF9D2A51, 0xDBD7194F */
+pp3  = -5.77027029648944159157e-03, /* 0xBF77A291, 0x236668E4 */
+pp4  = -2.37630166566501626084e-05, /* 0xBEF8EAD6, 0x120016AC */
+qq1  =  3.97917223959155352819e-01, /* 0x3FD97779, 0xCDDADC09 */
+qq2  =  6.50222499887672944485e-02, /* 0x3FB0A54C, 0x5536CEBA */
+qq3  =  5.08130628187576562776e-03, /* 0x3F74D022, 0xC4D36B0F */
+qq4  =  1.32494738004321644526e-04, /* 0x3F215DC9, 0x221C1A10 */
+qq5  = -3.96022827877536812320e-06, /* 0xBED09C43, 0x42A26120 */
+/*
+ * Coefficients for approximation to  erf  in [0.84375,1.25]
+ */
+pa0  = -2.36211856075265944077e-03, /* 0xBF6359B8, 0xBEF77538 */
+pa1  =  4.14856118683748331666e-01, /* 0x3FDA8D00, 0xAD92B34D */
+pa2  = -3.72207876035701323847e-01, /* 0xBFD7D240, 0xFBB8C3F1 */
+pa3  =  3.18346619901161753674e-01, /* 0x3FD45FCA, 0x805120E4 */
+pa4  = -1.10894694282396677476e-01, /* 0xBFBC6398, 0x3D3E28EC */
+pa5  =  3.54783043256182359371e-02, /* 0x3FA22A36, 0x599795EB */
+pa6  = -2.16637559486879084300e-03, /* 0xBF61BF38, 0x0A96073F */
+qa1  =  1.06420880400844228286e-01, /* 0x3FBB3E66, 0x18EEE323 */
+qa2  =  5.40397917702171048937e-01, /* 0x3FE14AF0, 0x92EB6F33 */
+qa3  =  7.18286544141962662868e-02, /* 0x3FB2635C, 0xD99FE9A7 */
+qa4  =  1.26171219808761642112e-01, /* 0x3FC02660, 0xE763351F */
+qa5  =  1.36370839120290507362e-02, /* 0x3F8BEDC2, 0x6B51DD1C */
+qa6  =  1.19844998467991074170e-02, /* 0x3F888B54, 0x5735151D */
+/*
+ * Coefficients for approximation to  erfc in [1.25,1/0.35]
+ */
+ra0  = -9.86494403484714822705e-03, /* 0xBF843412, 0x600D6435 */
+ra1  = -6.93858572707181764372e-01, /* 0xBFE63416, 0xE4BA7360 */
+ra2  = -1.05586262253232909814e+01, /* 0xC0251E04, 0x41B0E726 */
+ra3  = -6.23753324503260060396e+01, /* 0xC04F300A, 0xE4CBA38D */
+ra4  = -1.62396669462573470355e+02, /* 0xC0644CB1, 0x84282266 */
+ra5  = -1.84605092906711035994e+02, /* 0xC067135C, 0xEBCCABB2 */
+ra6  = -8.12874355063065934246e+01, /* 0xC0545265, 0x57E4D2F2 */
+ra7  = -9.81432934416914548592e+00, /* 0xC023A0EF, 0xC69AC25C */
+sa1  =  1.96512716674392571292e+01, /* 0x4033A6B9, 0xBD707687 */
+sa2  =  1.37657754143519042600e+02, /* 0x4061350C, 0x526AE721 */
+sa3  =  4.34565877475229228821e+02, /* 0x407B290D, 0xD58A1A71 */
+sa4  =  6.45387271733267880336e+02, /* 0x40842B19, 0x21EC2868 */
+sa5  =  4.29008140027567833386e+02, /* 0x407AD021, 0x57700314 */
+sa6  =  1.08635005541779435134e+02, /* 0x405B28A3, 0xEE48AE2C */
+sa7  =  6.57024977031928170135e+00, /* 0x401A47EF, 0x8E484A93 */
+sa8  = -6.04244152148580987438e-02, /* 0xBFAEEFF2, 0xEE749A62 */
+/*
+ * Coefficients for approximation to  erfc in [1/.35,28]
+ */
+rb0  = -9.86494292470009928597e-03, /* 0xBF843412, 0x39E86F4A */
+rb1  = -7.99283237680523006574e-01, /* 0xBFE993BA, 0x70C285DE */
+rb2  = -1.77579549177547519889e+01, /* 0xC031C209, 0x555F995A */
+rb3  = -1.60636384855821916062e+02, /* 0xC064145D, 0x43C5ED98 */
+rb4  = -6.37566443368389627722e+02, /* 0xC083EC88, 0x1375F228 */
+rb5  = -1.02509513161107724954e+03, /* 0xC0900461, 0x6A2E5992 */
+rb6  = -4.83519191608651397019e+02, /* 0xC07E384E, 0x9BDC383F */
+sb1  =  3.03380607434824582924e+01, /* 0x403E568B, 0x261D5190 */
+sb2  =  3.25792512996573918826e+02, /* 0x40745CAE, 0x221B9F0A */
+sb3  =  1.53672958608443695994e+03, /* 0x409802EB, 0x189D5118 */
+sb4  =  3.19985821950859553908e+03, /* 0x40A8FFB7, 0x688C246A */
+sb5  =  2.55305040643316442583e+03, /* 0x40A3F219, 0xCEDF3BE6 */
+sb6  =  4.74528541206955367215e+02, /* 0x407DA874, 0xE79FE763 */
+sb7  = -2.24409524465858183362e+01; /* 0xC03670E2, 0x42712D62 */
+
+#ifdef __STDC__
+	double erf(double x)
+#else
+	double erf(x)
+	double x;
+#endif
+{
+	int32_t hx,ix,i;
+	double R,S,P,Q,s,y,z,r;
+	GET_HIGH_WORD(hx,x);
+	ix = hx&0x7fffffff;
+	if(ix>=0x7ff00000) {		/* erf(nan)=nan */
+	    i = ((u_int32_t)hx>>31)<<1;
+	    return (double)(1-i)+one/x;	/* erf(+-inf)=+-1 */
+	}
+
+	if(ix < 0x3feb0000) {		/* |x|<0.84375 */
+	    if(ix < 0x3e300000) { 	/* |x|<2**-28 */
+	        if (ix < 0x00800000)
+		    return 0.125*(8.0*x+efx8*x);  /*avoid underflow */
+		return x + efx*x;
+	    }
+	    z = x*x;
+	    r = pp0+z*(pp1+z*(pp2+z*(pp3+z*pp4)));
+	    s = one+z*(qq1+z*(qq2+z*(qq3+z*(qq4+z*qq5))));
+	    y = r/s;
+	    return x + x*y;
+	}
+	if(ix < 0x3ff40000) {		/* 0.84375 <= |x| < 1.25 */
+	    s = fabs(x)-one;
+	    P = pa0+s*(pa1+s*(pa2+s*(pa3+s*(pa4+s*(pa5+s*pa6)))));
+	    Q = one+s*(qa1+s*(qa2+s*(qa3+s*(qa4+s*(qa5+s*qa6)))));
+	    if(hx>=0) return erx + P/Q; else return -erx - P/Q;
+	}
+	if (ix >= 0x40180000) {		/* inf>|x|>=6 */
+	    if(hx>=0) return one-tiny; else return tiny-one;
+	}
+	x = fabs(x);
+ 	s = one/(x*x);
+	if(ix< 0x4006DB6E) {	/* |x| < 1/0.35 */
+	    R=ra0+s*(ra1+s*(ra2+s*(ra3+s*(ra4+s*(
+				ra5+s*(ra6+s*ra7))))));
+	    S=one+s*(sa1+s*(sa2+s*(sa3+s*(sa4+s*(
+				sa5+s*(sa6+s*(sa7+s*sa8)))))));
+	} else {	/* |x| >= 1/0.35 */
+	    R=rb0+s*(rb1+s*(rb2+s*(rb3+s*(rb4+s*(
+				rb5+s*rb6)))));
+	    S=one+s*(sb1+s*(sb2+s*(sb3+s*(sb4+s*(
+				sb5+s*(sb6+s*sb7))))));
+	}
+	z  = x;
+	SET_LOW_WORD(z,0);
+	r  =  __ieee754_exp(-z*z-0.5625)*__ieee754_exp((z-x)*(z+x)+R/S);
+	if(hx>=0) return one-r/x; else return  r/x-one;
+}
+
+#ifdef __STDC__
+	double erfc(double x)
+#else
+	double erfc(x)
+	double x;
+#endif
+{
+	int32_t hx,ix;
+	double R,S,P,Q,s,y,z,r;
+	GET_HIGH_WORD(hx,x);
+	ix = hx&0x7fffffff;
+	if(ix>=0x7ff00000) {			/* erfc(nan)=nan */
+						/* erfc(+-inf)=0,2 */
+	    return (double)(((u_int32_t)hx>>31)<<1)+one/x;
+	}
+
+	if(ix < 0x3feb0000) {		/* |x|<0.84375 */
+	    if(ix < 0x3c700000)  	/* |x|<2**-56 */
+		return one-x;
+	    z = x*x;
+	    r = pp0+z*(pp1+z*(pp2+z*(pp3+z*pp4)));
+	    s = one+z*(qq1+z*(qq2+z*(qq3+z*(qq4+z*qq5))));
+	    y = r/s;
+	    if(hx < 0x3fd00000) {  	/* x<1/4 */
+		return one-(x+x*y);
+	    } else {
+		r = x*y;
+		r += (x-half);
+	        return half - r ;
+	    }
+	}
+	if(ix < 0x3ff40000) {		/* 0.84375 <= |x| < 1.25 */
+	    s = fabs(x)-one;
+	    P = pa0+s*(pa1+s*(pa2+s*(pa3+s*(pa4+s*(pa5+s*pa6)))));
+	    Q = one+s*(qa1+s*(qa2+s*(qa3+s*(qa4+s*(qa5+s*qa6)))));
+	    if(hx>=0) {
+	        z  = one-erx; return z - P/Q;
+	    } else {
+		z = erx+P/Q; return one+z;
+	    }
+	}
+	if (ix < 0x403c0000) {		/* |x|<28 */
+	    x = fabs(x);
+ 	    s = one/(x*x);
+	    if(ix< 0x4006DB6D) {	/* |x| < 1/.35 ~ 2.857143*/
+	        R=ra0+s*(ra1+s*(ra2+s*(ra3+s*(ra4+s*(
+				ra5+s*(ra6+s*ra7))))));
+	        S=one+s*(sa1+s*(sa2+s*(sa3+s*(sa4+s*(
+				sa5+s*(sa6+s*(sa7+s*sa8)))))));
+	    } else {			/* |x| >= 1/.35 ~ 2.857143 */
+		if(hx<0&&ix>=0x40180000) return two-tiny;/* x < -6 */
+	        R=rb0+s*(rb1+s*(rb2+s*(rb3+s*(rb4+s*(
+				rb5+s*rb6)))));
+	        S=one+s*(sb1+s*(sb2+s*(sb3+s*(sb4+s*(
+				sb5+s*(sb6+s*sb7))))));
+	    }
+	    z  = x;
+	    SET_LOW_WORD(z,0);
+	    r  =  __ieee754_exp(-z*z-0.5625)*
+			__ieee754_exp((z-x)*(z+x)+R/S);
+	    if(hx>0) return r/x; else return two-r/x;
+	} else {
+	    if(hx>0) return tiny*tiny; else return two-tiny;
+	}
+}
diff -urN dietlibc-0.30/libm/s_expm1.c dietlibc-0.30-libm/libm/s_expm1.c
--- dietlibc-0.30/libm/s_expm1.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_expm1.c	2006-06-25 11:20:18.000000000 +0000
@@ -0,0 +1,229 @@
+/* @(#)s_expm1.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_expm1.c,v 1.8 1995/05/10 20:47:09 jtc Exp $";
+#endif
+
+/* expm1(x)
+ * Returns exp(x)-1, the exponential of x minus 1.
+ *
+ * Method
+ *   1. Argument reduction:
+ *	Given x, find r and integer k such that
+ *
+ *               x = k*ln2 + r,  |r| <= 0.5*ln2 ~ 0.34658
+ *
+ *      Here a correction term c will be computed to compensate
+ *	the error in r when rounded to a floating-point number.
+ *
+ *   2. Approximating expm1(r) by a special rational function on
+ *	the interval [0,0.34658]:
+ *	Since
+ *	    r*(exp(r)+1)/(exp(r)-1) = 2+ r^2/6 - r^4/360 + ...
+ *	we define R1(r*r) by
+ *	    r*(exp(r)+1)/(exp(r)-1) = 2+ r^2/6 * R1(r*r)
+ *	That is,
+ *	    R1(r**2) = 6/r *((exp(r)+1)/(exp(r)-1) - 2/r)
+ *		     = 6/r * ( 1 + 2.0*(1/(exp(r)-1) - 1/r))
+ *		     = 1 - r^2/60 + r^4/2520 - r^6/100800 + ...
+ *      We use a special Reme algorithm on [0,0.347] to generate
+ * 	a polynomial of degree 5 in r*r to approximate R1. The
+ *	maximum error of this polynomial approximation is bounded
+ *	by 2**-61. In other words,
+ *	    R1(z) ~ 1.0 + Q1*z + Q2*z**2 + Q3*z**3 + Q4*z**4 + Q5*z**5
+ *	where 	Q1  =  -1.6666666666666567384E-2,
+ * 		Q2  =   3.9682539681370365873E-4,
+ * 		Q3  =  -9.9206344733435987357E-6,
+ * 		Q4  =   2.5051361420808517002E-7,
+ * 		Q5  =  -6.2843505682382617102E-9;
+ *  	(where z=r*r, and the values of Q1 to Q5 are listed below)
+ *	with error bounded by
+ *	    |                  5           |     -61
+ *	    | 1.0+Q1*z+...+Q5*z   -  R1(z) | <= 2
+ *	    |                              |
+ *
+ *	expm1(r) = exp(r)-1 is then computed by the following
+ * 	specific way which minimize the accumulation rounding error:
+ *			       2     3
+ *			      r     r    [ 3 - (R1 + R1*r/2)  ]
+ *	      expm1(r) = r + --- + --- * [--------------------]
+ *		              2     2    [ 6 - r*(3 - R1*r/2) ]
+ *
+ *	To compensate the error in the argument reduction, we use
+ *		expm1(r+c) = expm1(r) + c + expm1(r)*c
+ *			   ~ expm1(r) + c + r*c
+ *	Thus c+r*c will be added in as the correction terms for
+ *	expm1(r+c). Now rearrange the term to avoid optimization
+ * 	screw up:
+ *		        (      2                                    2 )
+ *		        ({  ( r    [ R1 -  (3 - R1*r/2) ]  )  }    r  )
+ *	 expm1(r+c)~r - ({r*(--- * [--------------------]-c)-c} - --- )
+ *	                ({  ( 2    [ 6 - r*(3 - R1*r/2) ]  )  }    2  )
+ *                      (                                             )
+ *
+ *		   = r - E
+ *   3. Scale back to obtain expm1(x):
+ *	From step 1, we have
+ *	   expm1(x) = either 2^k*[expm1(r)+1] - 1
+ *		    = or     2^k*[expm1(r) + (1-2^-k)]
+ *   4. Implementation notes:
+ *	(A). To save one multiplication, we scale the coefficient Qi
+ *	     to Qi*2^i, and replace z by (x^2)/2.
+ *	(B). To achieve maximum accuracy, we compute expm1(x) by
+ *	  (i)   if x < -56*ln2, return -1.0, (raise inexact if x!=inf)
+ *	  (ii)  if k=0, return r-E
+ *	  (iii) if k=-1, return 0.5*(r-E)-0.5
+ *        (iv)	if k=1 if r < -0.25, return 2*((r+0.5)- E)
+ *	       	       else	     return  1.0+2.0*(r-E);
+ *	  (v)   if (k<-2||k>56) return 2^k(1-(E-r)) - 1 (or exp(x)-1)
+ *	  (vi)  if k <= 20, return 2^k((1-2^-k)-(E-r)), else
+ *	  (vii) return 2^k(1-((E+2^-k)-r))
+ *
+ * Special cases:
+ *	expm1(INF) is INF, expm1(NaN) is NaN;
+ *	expm1(-INF) is -1, and
+ *	for finite argument, only expm1(0)=0 is exact.
+ *
+ * Accuracy:
+ *	according to an error analysis, the error is always less than
+ *	1 ulp (unit in the last place).
+ *
+ * Misc. info.
+ *	For IEEE double
+ *	    if x >  7.09782712893383973096e+02 then expm1(x) overflow
+ *
+ * Constants:
+ * The hexadecimal values are the intended ones for the following
+ * constants. The decimal values may be used, provided that the
+ * compiler will convert from decimal to binary accurately enough
+ * to produce the hexadecimal values shown.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+one		= 1.0,
+huge		= 1.0e+300,
+tiny		= 1.0e-300,
+o_threshold	= 7.09782712893383973096e+02,/* 0x40862E42, 0xFEFA39EF */
+ln2_hi		= 6.93147180369123816490e-01,/* 0x3fe62e42, 0xfee00000 */
+ln2_lo		= 1.90821492927058770002e-10,/* 0x3dea39ef, 0x35793c76 */
+invln2		= 1.44269504088896338700e+00,/* 0x3ff71547, 0x652b82fe */
+	/* scaled coefficients related to expm1 */
+Q1  =  -3.33333333333331316428e-02, /* BFA11111 111110F4 */
+Q2  =   1.58730158725481460165e-03, /* 3F5A01A0 19FE5585 */
+Q3  =  -7.93650757867487942473e-05, /* BF14CE19 9EAADBB7 */
+Q4  =   4.00821782732936239552e-06, /* 3ED0CFCA 86E65239 */
+Q5  =  -2.01099218183624371326e-07; /* BE8AFDB7 6E09C32D */
+
+#ifdef __STDC__
+	double expm1(double x)
+#else
+	double expm1(x)
+	double x;
+#endif
+{
+	double y,hi,lo,c=0.0,t,e,hxs,hfx,r1;
+	int32_t k,xsb;
+	u_int32_t hx;
+
+	GET_HIGH_WORD(hx,x);
+	xsb = hx&0x80000000;		/* sign bit of x */
+	if(xsb==0) y=x; else y= -x;	/* y = |x| */
+	hx &= 0x7fffffff;		/* high word of |x| */
+
+    /* filter out huge and non-finite argument */
+	if(hx >= 0x4043687A) {			/* if |x|>=56*ln2 */
+	    if(hx >= 0x40862E42) {		/* if |x|>=709.78... */
+                if(hx>=0x7ff00000) {
+		    u_int32_t low;
+		    GET_LOW_WORD(low,x);
+		    if(((hx&0xfffff)|low)!=0)
+		         return x+x; 	 /* NaN */
+		    else return (xsb==0)? x:-1.0;/* exp(+-inf)={inf,-1} */
+	        }
+	        if(x > o_threshold) return huge*huge; /* overflow */
+	    }
+	    if(xsb!=0) { /* x < -56*ln2, return -1.0 with inexact */
+		if(x+tiny<0.0)		/* raise inexact */
+		return tiny-one;	/* return -1 */
+	    }
+	}
+
+    /* argument reduction */
+	if(hx > 0x3fd62e42) {		/* if  |x| > 0.5 ln2 */
+	    if(hx < 0x3FF0A2B2) {	/* and |x| < 1.5 ln2 */
+		if(xsb==0)
+		    {hi = x - ln2_hi; lo =  ln2_lo;  k =  1;}
+		else
+		    {hi = x + ln2_hi; lo = -ln2_lo;  k = -1;}
+	    } else {
+		k  = invln2*x+((xsb==0)?0.5:-0.5);
+		t  = k;
+		hi = x - t*ln2_hi;	/* t*ln2_hi is exact here */
+		lo = t*ln2_lo;
+	    }
+	    x  = hi - lo;
+	    c  = (hi-x)-lo;
+	}
+	else if(hx < 0x3c900000) {  	/* when |x|<2**-54, return x */
+	    t = huge+x;	/* return x with inexact flags when x!=0 */
+	    return x - (t-(huge+x));
+	}
+	else k = 0;
+
+    /* x is now in primary range */
+	hfx = 0.5*x;
+	hxs = x*hfx;
+	r1 = one+hxs*(Q1+hxs*(Q2+hxs*(Q3+hxs*(Q4+hxs*Q5))));
+	t  = 3.0-r1*hfx;
+	e  = hxs*((r1-t)/(6.0 - x*t));
+	if(k==0) return x - (x*e-hxs);		/* c is 0 */
+	else {
+	    e  = (x*(e-c)-c);
+	    e -= hxs;
+	    if(k== -1) return 0.5*(x-e)-0.5;
+	    if(k==1) {
+	       	if(x < -0.25) return -2.0*(e-(x+0.5));
+	       	else 	      return  one+2.0*(x-e);
+	    }
+	    if (k <= -2 || k>56) {   /* suffice to return exp(x)-1 */
+	        u_int32_t high;
+	        y = one-(e-x);
+		GET_HIGH_WORD(high,y);
+		SET_HIGH_WORD(y,high+(k<<20));	/* add k to y's exponent */
+	        return y-one;
+	    }
+	    t = one;
+	    if(k<20) {
+	        u_int32_t high;
+	        SET_HIGH_WORD(t,0x3ff00000 - (0x200000>>k));  /* t=1-2^-k */
+	       	y = t-(e-x);
+		GET_HIGH_WORD(high,y);
+		SET_HIGH_WORD(y,high+(k<<20));	/* add k to y's exponent */
+	   } else {
+	        u_int32_t high;
+		SET_HIGH_WORD(t,((0x3ff-k)<<20));	/* 2^-k */
+	       	y = x-(e+t);
+	       	y += one;
+		GET_HIGH_WORD(high,y);
+		SET_HIGH_WORD(y,high+(k<<20));	/* add k to y's exponent */
+	    }
+	}
+	return y;
+}
diff -urN dietlibc-0.30/libm/s_fabs.c dietlibc-0.30-libm/libm/s_fabs.c
--- dietlibc-0.30/libm/s_fabs.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_fabs.c	2006-06-25 11:20:17.000000000 +0000
@@ -0,0 +1,35 @@
+/* @(#)s_fabs.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_fabs.c,v 1.7 1995/05/10 20:47:13 jtc Exp $";
+#endif
+
+/*
+ * fabs(x) returns the absolute value of x.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+	double fabs(double x)
+#else
+	double fabs(x)
+	double x;
+#endif
+{
+	u_int32_t high;
+	GET_HIGH_WORD(high,x);
+	SET_HIGH_WORD(x,high&0x7fffffff);
+        return x;
+}
diff -urN dietlibc-0.30/libm/s_finite.c dietlibc-0.30-libm/libm/s_finite.c
--- dietlibc-0.30/libm/s_finite.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_finite.c	2006-06-25 11:19:58.000000000 +0000
@@ -0,0 +1,35 @@
+/* @(#)s_finite.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_finite.c,v 1.8 1995/05/10 20:47:17 jtc Exp $";
+#endif
+
+/*
+ * finite(x) returns 1 is x is finite, else 0;
+ * no branching!
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+	int finite(double x)
+#else
+	int finite(x)
+	double x;
+#endif
+{
+	int32_t hx;
+	GET_HIGH_WORD(hx,x);
+	return (int)((u_int32_t)((hx&0x7fffffff)-0x7ff00000)>>31);
+}
diff -urN dietlibc-0.30/libm/s_floor.c dietlibc-0.30-libm/libm/s_floor.c
--- dietlibc-0.30/libm/s_floor.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_floor.c	2006-06-25 11:20:17.000000000 +0000
@@ -0,0 +1,81 @@
+/* @(#)s_floor.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_floor.c,v 1.8 1995/05/10 20:47:20 jtc Exp $";
+#endif
+
+/*
+ * floor(x)
+ * Return x rounded toward -inf to integral value
+ * Method:
+ *	Bit twiddling.
+ * Exception:
+ *	Inexact flag raised if x not equal to floor(x).
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double huge = 1.0e300;
+#else
+static double huge = 1.0e300;
+#endif
+
+#ifdef __STDC__
+	double floor(double x)
+#else
+	double floor(x)
+	double x;
+#endif
+{
+	int32_t i0,i1,j0;
+	u_int32_t i,j;
+	EXTRACT_WORDS(i0,i1,x);
+	j0 = ((i0>>20)&0x7ff)-0x3ff;
+	if(j0<20) {
+	    if(j0<0) { 	/* raise inexact if x != 0 */
+		if(huge+x>0.0) {/* return 0*sign(x) if |x|<1 */
+		    if(i0>=0) {i0=i1=0;}
+		    else if(((i0&0x7fffffff)|i1)!=0)
+			{ i0=0xbff00000;i1=0;}
+		}
+	    } else {
+		i = (0x000fffff)>>j0;
+		if(((i0&i)|i1)==0) return x; /* x is integral */
+		if(huge+x>0.0) {	/* raise inexact flag */
+		    if(i0<0) i0 += (0x00100000)>>j0;
+		    i0 &= (~i); i1=0;
+		}
+	    }
+	} else if (j0>51) {
+	    if(j0==0x400) return x+x;	/* inf or NaN */
+	    else return x;		/* x is integral */
+	} else {
+	    i = ((u_int32_t)(0xffffffff))>>(j0-20);
+	    if((i1&i)==0) return x;	/* x is integral */
+	    if(huge+x>0.0) { 		/* raise inexact flag */
+		if(i0<0) {
+		    if(j0==20) i0+=1;
+		    else {
+			j = i1+(1<<(52-j0));
+			if(j<i1) i0 +=1 ; 	/* got a carry */
+			i1=j;
+		    }
+		}
+		i1 &= (~i);
+	    }
+	}
+	INSERT_WORDS(x,i0,i1);
+	return x;
+}
diff -urN dietlibc-0.30/libm/s_floorf.c dietlibc-0.30-libm/libm/s_floorf.c
--- dietlibc-0.30/libm/s_floorf.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_floorf.c	2006-06-25 11:20:14.000000000 +0000
@@ -0,0 +1,71 @@
+/* s_floorf.c -- float version of s_floor.c.
+ * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
+ */
+
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_floorf.c,v 1.4 1995/05/10 20:47:22 jtc Exp $";
+#endif
+
+/*
+ * floorf(x)
+ * Return x rounded toward -inf to integral value
+ * Method:
+ *	Bit twiddling.
+ * Exception:
+ *	Inexact flag raised if x not equal to floorf(x).
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const float huge = 1.0e30;
+#else
+static float huge = 1.0e30;
+#endif
+
+#ifdef __STDC__
+	float __floorf(float x)
+#else
+	float __floorf(x)
+	float x;
+#endif
+{
+	int32_t i0,j0;
+	u_int32_t i;
+	GET_FLOAT_WORD(i0,x);
+	j0 = ((i0>>23)&0xff)-0x7f;
+	if(j0<23) {
+	    if(j0<0) { 	/* raise inexact if x != 0 */
+		if(huge+x>(float)0.0) {/* return 0*sign(x) if |x|<1 */
+		    if(i0>=0) {i0=0;}
+		    else if((i0&0x7fffffff)!=0)
+			{ i0=0xbf800000;}
+		}
+	    } else {
+		i = (0x007fffff)>>j0;
+		if((i0&i)==0) return x; /* x is integral */
+		if(huge+x>(float)0.0) {	/* raise inexact flag */
+		    if(i0<0) i0 += (0x00800000)>>j0;
+		    i0 &= (~i);
+		}
+	    }
+	} else {
+	    if(j0==0x80) return x+x;	/* inf or NaN */
+	    else return x;		/* x is integral */
+	}
+	SET_FLOAT_WORD(x,i0);
+	return x;
+}
+weak_alias (__floorf, floorf)
diff -urN dietlibc-0.30/libm/s_frexp.c dietlibc-0.30-libm/libm/s_frexp.c
--- dietlibc-0.30/libm/s_frexp.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_frexp.c	2006-06-25 11:20:20.000000000 +0000
@@ -0,0 +1,60 @@
+/* @(#)s_frexp.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_frexp.c,v 1.9 1995/05/10 20:47:24 jtc Exp $";
+#endif
+
+/*
+ * for non-zero x
+ *	x = frexp(arg,&exp);
+ * return a double fp quantity x such that 0.5 <= |x| <1.0
+ * and the corresponding binary exponent "exp". That is
+ *	arg = x*2^exp.
+ * If arg is inf, 0.0, or NaN, then frexp(arg,&exp) returns arg
+ * with *exp=0.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+two54 =  1.80143985094819840000e+16; /* 0x43500000, 0x00000000 */
+
+#ifdef __STDC__
+	double __frexp(double x, int *eptr)
+#else
+	double __frexp(x, eptr)
+	double x; int *eptr;
+#endif
+{
+	int32_t hx, ix, lx;
+	EXTRACT_WORDS(hx,lx,x);
+	ix = 0x7fffffff&hx;
+	*eptr = 0;
+	if(ix>=0x7ff00000||((ix|lx)==0)) return x;	/* 0,inf,nan */
+	if (ix<0x00100000) {		/* subnormal */
+	    x *= two54;
+	    GET_HIGH_WORD(hx,x);
+	    ix = hx&0x7fffffff;
+	    *eptr = -54;
+	}
+	*eptr += (ix>>20)-1022;
+	hx = (hx&0x800fffff)|0x3fe00000;
+	SET_HIGH_WORD(x,hx);
+	return x;
+}
+weak_alias (__frexp, frexp)
diff -urN dietlibc-0.30/libm/s_ilogb.c dietlibc-0.30-libm/libm/s_ilogb.c
--- dietlibc-0.30/libm/s_ilogb.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_ilogb.c	2006-06-25 11:20:02.000000000 +0000
@@ -0,0 +1,51 @@
+/* @(#)s_ilogb.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_ilogb.c,v 1.9 1995/05/10 20:47:28 jtc Exp $";
+#endif
+
+/* ilogb(double x)
+ * return the binary exponent of non-zero x
+ * ilogb(0) = 0x80000001
+ * ilogb(inf/NaN) = 0x7fffffff (no signal is raised)
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+	int ilogb(double x)
+#else
+	int ilogb(x)
+	double x;
+#endif
+{
+	int32_t hx,lx,ix;
+
+	GET_HIGH_WORD(hx,x);
+	hx &= 0x7fffffff;
+	if(hx<0x00100000) {
+	    GET_LOW_WORD(lx,x);
+	    if((hx|lx)==0)
+		return 0x80000001;	/* ilogb(0) = 0x80000001 */
+	    else			/* subnormal x */
+		if(hx==0) {
+		    for (ix = -1043; lx>0; lx<<=1) ix -=1;
+		} else {
+		    for (ix = -1022,hx<<=11; hx>0; hx<<=1) ix -=1;
+		}
+	    return ix;
+	}
+	else if (hx<0x7ff00000) return (hx>>20)-1023;
+	else return 0x7fffffff;
+}
diff -urN dietlibc-0.30/libm/s_ldexp.c dietlibc-0.30-libm/libm/s_ldexp.c
--- dietlibc-0.30/libm/s_ldexp.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_ldexp.c	2006-06-25 11:20:12.000000000 +0000
@@ -0,0 +1,32 @@
+/* @(#)s_ldexp.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_ldexp.c,v 1.6 1995/05/10 20:47:40 jtc Exp $";
+#endif
+
+#include "math.h"
+#include "math_private.h"
+#include <errno.h>
+
+#ifdef __STDC__
+	double ldexp(double value, int exp)
+#else
+	double ldexp(value, exp)
+	double value; int exp;
+#endif
+{
+	if(!finite(value)||value==0.0) return value;
+	value = scalbn(value,exp);
+	if(!finite(value)||value==0.0) errno = ERANGE;
+	return value;
+}
diff -urN dietlibc-0.30/libm/s_lib_version.c dietlibc-0.30-libm/libm/s_lib_version.c
--- dietlibc-0.30/libm/s_lib_version.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_lib_version.c	2006-06-25 11:20:09.000000000 +0000
@@ -0,0 +1,40 @@
+/* @(#)s_lib_ver.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_lib_version.c,v 1.6 1995/05/10 20:47:44 jtc Exp $";
+#endif
+
+/*
+ * MACRO for standards
+ */
+
+#include "math.h"
+#include "math_private.h"
+#if 0
+/*
+ * define and initialize _LIB_VERSION
+ */
+#ifdef _POSIX_MODE
+_LIB_VERSION_TYPE _LIB_VERSION = _POSIX_;
+#else
+#ifdef _XOPEN_MODE
+_LIB_VERSION_TYPE _LIB_VERSION = _XOPEN_;
+#else
+#ifdef _SVID3_MODE
+_LIB_VERSION_TYPE _LIB_VERSION = _SVID_;
+#else					/* default _IEEE_MODE */
+_LIB_VERSION_TYPE _LIB_VERSION = _IEEE_;
+#endif
+#endif
+#endif
+#endif
diff -urN dietlibc-0.30/libm/s_log1p.c dietlibc-0.30-libm/libm/s_log1p.c
--- dietlibc-0.30/libm/s_log1p.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_log1p.c	2006-06-25 11:20:15.000000000 +0000
@@ -0,0 +1,174 @@
+/* @(#)s_log1p.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_log1p.c,v 1.8 1995/05/10 20:47:46 jtc Exp $";
+#endif
+
+/* double log1p(double x)
+ *
+ * Method :
+ *   1. Argument Reduction: find k and f such that
+ *			1+x = 2^k * (1+f),
+ *	   where  sqrt(2)/2 < 1+f < sqrt(2) .
+ *
+ *      Note. If k=0, then f=x is exact. However, if k!=0, then f
+ *	may not be representable exactly. In that case, a correction
+ *	term is need. Let u=1+x rounded. Let c = (1+x)-u, then
+ *	log(1+x) - log(u) ~ c/u. Thus, we proceed to compute log(u),
+ *	and add back the correction term c/u.
+ *	(Note: when x > 2**53, one can simply return log(x))
+ *
+ *   2. Approximation of log1p(f).
+ *	Let s = f/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)
+ *		 = 2s + 2/3 s**3 + 2/5 s**5 + .....,
+ *	     	 = 2s + s*R
+ *      We use a special Reme algorithm on [0,0.1716] to generate
+ * 	a polynomial of degree 14 to approximate R The maximum error
+ *	of this polynomial approximation is bounded by 2**-58.45. In
+ *	other words,
+ *		        2      4      6      8      10      12      14
+ *	    R(z) ~ Lp1*s +Lp2*s +Lp3*s +Lp4*s +Lp5*s  +Lp6*s  +Lp7*s
+ *  	(the values of Lp1 to Lp7 are listed in the program)
+ *	and
+ *	    |      2          14          |     -58.45
+ *	    | Lp1*s +...+Lp7*s    -  R(z) | <= 2
+ *	    |                             |
+ *	Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f/2.
+ *	In order to guarantee error in log below 1ulp, we compute log
+ *	by
+ *		log1p(f) = f - (hfsq - s*(hfsq+R)).
+ *
+ *	3. Finally, log1p(x) = k*ln2 + log1p(f).
+ *		 	     = k*ln2_hi+(f-(hfsq-(s*(hfsq+R)+k*ln2_lo)))
+ *	   Here ln2 is split into two floating point number:
+ *			ln2_hi + ln2_lo,
+ *	   where n*ln2_hi is always exact for |n| < 2000.
+ *
+ * Special cases:
+ *	log1p(x) is NaN with signal if x < -1 (including -INF) ;
+ *	log1p(+INF) is +INF; log1p(-1) is -INF with signal;
+ *	log1p(NaN) is that NaN with no signal.
+ *
+ * Accuracy:
+ *	according to an error analysis, the error is always less than
+ *	1 ulp (unit in the last place).
+ *
+ * Constants:
+ * The hexadecimal values are the intended ones for the following
+ * constants. The decimal values may be used, provided that the
+ * compiler will convert from decimal to binary accurately enough
+ * to produce the hexadecimal values shown.
+ *
+ * Note: Assuming log() return accurate answer, the following
+ * 	 algorithm can be used to compute log1p(x) to within a few ULP:
+ *
+ *		u = 1+x;
+ *		if(u==1.0) return x ; else
+ *			   return log(u)*(x/(u-1.0));
+ *
+ *	 See HP-15C Advanced Functions Handbook, p.193.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+ln2_hi  =  6.93147180369123816490e-01,	/* 3fe62e42 fee00000 */
+ln2_lo  =  1.90821492927058770002e-10,	/* 3dea39ef 35793c76 */
+two54   =  1.80143985094819840000e+16,  /* 43500000 00000000 */
+Lp1 = 6.666666666666735130e-01,  /* 3FE55555 55555593 */
+Lp2 = 3.999999999940941908e-01,  /* 3FD99999 9997FA04 */
+Lp3 = 2.857142874366239149e-01,  /* 3FD24924 94229359 */
+Lp4 = 2.222219843214978396e-01,  /* 3FCC71C5 1D8E78AF */
+Lp5 = 1.818357216161805012e-01,  /* 3FC74664 96CB03DE */
+Lp6 = 1.531383769920937332e-01,  /* 3FC39A09 D078C69F */
+Lp7 = 1.479819860511658591e-01;  /* 3FC2F112 DF3E5244 */
+
+#ifdef __STDC__
+static const double zero = 0.0;
+#else
+static double zero = 0.0;
+#endif
+
+#ifdef __STDC__
+	double log1p(double x)
+#else
+	double log1p(x)
+	double x;
+#endif
+{
+	double hfsq,f=0,c=0,s,z,R,u;
+	int32_t k,hx,hu=0,ax;
+
+	GET_HIGH_WORD(hx,x);
+	ax = hx&0x7fffffff;
+
+	k = 1;
+	if (hx < 0x3FDA827A) {			/* x < 0.41422  */
+	    if(ax>=0x3ff00000) {		/* x <= -1.0 */
+		if(x==-1.0) return -two54/zero; /* log1p(-1)=+inf */
+		else return (x-x)/(x-x);	/* log1p(x<-1)=NaN */
+	    }
+	    if(ax<0x3e200000) {			/* |x| < 2**-29 */
+		if(two54+x>zero			/* raise inexact */
+	            &&ax<0x3c900000) 		/* |x| < 2**-54 */
+		    return x;
+		else
+		    return x - x*x*0.5;
+	    }
+	    if(hx>0||hx<=((int32_t)0xbfd2bec3)) {
+		k=0;f=x;hu=1;}	/* -0.2929<x<0.41422 */
+	}
+	if (hx >= 0x7ff00000) return x+x;
+	if(k!=0) {
+	    if(hx<0x43400000) {
+		u  = 1.0+x;
+		GET_HIGH_WORD(hu,u);
+	        k  = (hu>>20)-1023;
+	        c  = (k>0)? 1.0-(u-x):x-(u-1.0);/* correction term */
+		c /= u;
+	    } else {
+		u  = x;
+		GET_HIGH_WORD(hu,u);
+	        k  = (hu>>20)-1023;
+		c  = 0;
+	    }
+	    hu &= 0x000fffff;
+	    if(hu<0x6a09e) {
+	        SET_HIGH_WORD(u,hu|0x3ff00000);	/* normalize u */
+	    } else {
+	        k += 1;
+		SET_HIGH_WORD(u,hu|0x3fe00000);	/* normalize u/2 */
+	        hu = (0x00100000-hu)>>2;
+	    }
+	    f = u-1.0;
+	}
+	hfsq=0.5*f*f;
+	if(hu==0) {	/* |f| < 2**-20 */
+	    if(f==zero) {if(k==0) return zero;
+			else {c += k*ln2_lo; return k*ln2_hi+c;}
+	    }
+	    R = hfsq*(1.0-0.66666666666666666*f);
+	    if(k==0) return f-R; else
+	    	     return k*ln2_hi-((R-(k*ln2_lo+c))-f);
+	}
+ 	s = f/(2.0+f);
+	z = s*s;
+	R = z*(Lp1+z*(Lp2+z*(Lp3+z*(Lp4+z*(Lp5+z*(Lp6+z*Lp7))))));
+	if(k==0) return f-(hfsq-s*(hfsq+R)); else
+		 return k*ln2_hi-((hfsq-(s*(hfsq+R)+(k*ln2_lo+c)))-f);
+}
diff -urN dietlibc-0.30/libm/s_logb.c dietlibc-0.30-libm/libm/s_logb.c
--- dietlibc-0.30/libm/s_logb.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_logb.c	2006-06-25 11:20:20.000000000 +0000
@@ -0,0 +1,42 @@
+/* @(#)s_logb.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_logb.c,v 1.8 1995/05/10 20:47:50 jtc Exp $";
+#endif
+
+/*
+ * double logb(x)
+ * IEEE 754 logb. Included to pass IEEE test suite. Not recommend.
+ * Use ilogb instead.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+	double logb(double x)
+#else
+	double logb(x)
+	double x;
+#endif
+{
+	int32_t lx,ix;
+	EXTRACT_WORDS(ix,lx,x);
+	ix &= 0x7fffffff;			/* high |x| */
+	if((ix|lx)==0) return -1.0/fabs(x);
+	if(ix>=0x7ff00000) return x*x;
+	if((ix>>=20)==0) 			/* IEEE 754 logb */
+		return -1022.0;
+	else
+		return (double) (ix-1023);
+}
diff -urN dietlibc-0.30/libm/s_matherr.c dietlibc-0.30-libm/libm/s_matherr.c
--- dietlibc-0.30/libm/s_matherr.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_matherr.c	2006-06-25 11:20:08.000000000 +0000
@@ -0,0 +1,30 @@
+/* @(#)s_matherr.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_matherr.c,v 1.6 1995/05/10 20:47:53 jtc Exp $";
+#endif
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+	int matherr(struct exception *x)
+#else
+	int matherr(x)
+	struct exception *x;
+#endif
+{
+	int n=0;
+	if(x->arg1!=x->arg1) return 0;
+	return n;
+}
diff -urN dietlibc-0.30/libm/s_modf.c dietlibc-0.30-libm/libm/s_modf.c
--- dietlibc-0.30/libm/s_modf.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_modf.c	2006-06-25 11:20:21.000000000 +0000
@@ -0,0 +1,83 @@
+/* @(#)s_modf.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_modf.c,v 1.8 1995/05/10 20:47:55 jtc Exp $";
+#endif
+
+/*
+ * modf(double x, double *iptr)
+ * return fraction part of x, and return x's integral part in *iptr.
+ * Method:
+ *	Bit twiddling.
+ *
+ * Exception:
+ *	No exception.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double one = 1.0;
+#else
+static double one = 1.0;
+#endif
+
+#ifdef __STDC__
+	double modf(double x, double *iptr)
+#else
+	double modf(x, iptr)
+	double x,*iptr;
+#endif
+{
+	int32_t i0,i1,j0;
+	u_int32_t i;
+	EXTRACT_WORDS(i0,i1,x);
+	j0 = ((i0>>20)&0x7ff)-0x3ff;	/* exponent of x */
+	if(j0<20) {			/* integer part in high x */
+	    if(j0<0) {			/* |x|<1 */
+	        INSERT_WORDS(*iptr,i0&0x80000000,0);	/* *iptr = +-0 */
+		return x;
+	    } else {
+		i = (0x000fffff)>>j0;
+		if(((i0&i)|i1)==0) {		/* x is integral */
+		    u_int32_t high;
+		    *iptr = x;
+		    GET_HIGH_WORD(high,x);
+		    INSERT_WORDS(x,high&0x80000000,0);	/* return +-0 */
+		    return x;
+		} else {
+		    INSERT_WORDS(*iptr,i0&(~i),0);
+		    return x - *iptr;
+		}
+	    }
+	} else if (j0>51) {		/* no fraction part */
+	    u_int32_t high;
+	    *iptr = x*one;
+	    GET_HIGH_WORD(high,x);
+	    INSERT_WORDS(x,high&0x80000000,0);	/* return +-0 */
+	    return x;
+	} else {			/* fraction part in low x */
+	    i = ((u_int32_t)(0xffffffff))>>(j0-20);
+	    if((i1&i)==0) { 		/* x is integral */
+	        u_int32_t high;
+		*iptr = x;
+		GET_HIGH_WORD(high,x);
+		INSERT_WORDS(x,high&0x80000000,0);	/* return +-0 */
+		return x;
+	    } else {
+	        INSERT_WORDS(*iptr,i0,i1&(~i));
+		return x - *iptr;
+	    }
+	}
+}
diff -urN dietlibc-0.30/libm/s_nextafter.c dietlibc-0.30-libm/libm/s_nextafter.c
--- dietlibc-0.30/libm/s_nextafter.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_nextafter.c	2006-06-25 11:20:08.000000000 +0000
@@ -0,0 +1,79 @@
+/* @(#)s_nextafter.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_nextafter.c,v 1.8 1995/05/10 20:47:58 jtc Exp $";
+#endif
+
+/* IEEE functions
+ *	nextafter(x,y)
+ *	return the next machine floating-point number of x in the
+ *	direction toward y.
+ *   Special cases:
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+	double nextafter(double x, double y)
+#else
+	double nextafter(x,y)
+	double x,y;
+#endif
+{
+	int32_t hx,hy,ix,iy;
+	u_int32_t lx,ly;
+
+	EXTRACT_WORDS(hx,lx,x);
+	EXTRACT_WORDS(hy,ly,y);
+	ix = hx&0x7fffffff;		/* |x| */
+	iy = hy&0x7fffffff;		/* |y| */
+
+	if(((ix>=0x7ff00000)&&((ix-0x7ff00000)|lx)!=0) ||   /* x is nan */
+	   ((iy>=0x7ff00000)&&((iy-0x7ff00000)|ly)!=0))     /* y is nan */
+	   return x+y;
+	if(x==y) return x;		/* x=y, return x */
+	if((ix|lx)==0) {			/* x == 0 */
+	    INSERT_WORDS(x,hy&0x80000000,1);	/* return +-minsubnormal */
+	    y = x*x;
+	    if(y==x) return y; else return x;	/* raise underflow flag */
+	}
+	if(hx>=0) {				/* x > 0 */
+	    if(hx>hy||((hx==hy)&&(lx>ly))) {	/* x > y, x -= ulp */
+		if(lx==0) hx -= 1;
+		lx -= 1;
+	    } else {				/* x < y, x += ulp */
+		lx += 1;
+		if(lx==0) hx += 1;
+	    }
+	} else {				/* x < 0 */
+	    if(hy>=0||hx>hy||((hx==hy)&&(lx>ly))){/* x < y, x -= ulp */
+		if(lx==0) hx -= 1;
+		lx -= 1;
+	    } else {				/* x > y, x += ulp */
+		lx += 1;
+		if(lx==0) hx += 1;
+	    }
+	}
+	hy = hx&0x7ff00000;
+	if(hy>=0x7ff00000) return x+x;	/* overflow  */
+	if(hy<0x00100000) {		/* underflow */
+	    y = x*x;
+	    if(y!=x) {		/* raise underflow flag */
+	        INSERT_WORDS(y,hx,lx);
+		return y;
+	    }
+	}
+	INSERT_WORDS(x,hx,lx);
+	return x;
+}
diff -urN dietlibc-0.30/libm/s_rint.c dietlibc-0.30-libm/libm/s_rint.c
--- dietlibc-0.30/libm/s_rint.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_rint.c	2006-06-25 11:20:22.000000000 +0000
@@ -0,0 +1,86 @@
+/* @(#)s_rint.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_rint.c,v 1.8 1995/05/10 20:48:04 jtc Exp $";
+#endif
+
+/*
+ * rint(x)
+ * Return x rounded to integral value according to the prevailing
+ * rounding mode.
+ * Method:
+ *	Using floating addition.
+ * Exception:
+ *	Inexact flag raised if x not equal to rint(x).
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+TWO52[2]={
+  4.50359962737049600000e+15, /* 0x43300000, 0x00000000 */
+ -4.50359962737049600000e+15, /* 0xC3300000, 0x00000000 */
+};
+
+#ifdef __STDC__
+	double rint(double x)
+#else
+	double rint(x)
+	double x;
+#endif
+{
+	int32_t i0,j0,sx;
+	u_int32_t i,i1;
+	double w,t;
+	EXTRACT_WORDS(i0,i1,x);
+	sx = (i0>>31)&1;
+	j0 = ((i0>>20)&0x7ff)-0x3ff;
+	if(j0<20) {
+	    if(j0<0) {
+		if(((i0&0x7fffffff)|i1)==0) return x;
+		i1 |= (i0&0x0fffff);
+		i0 &= 0xfffe0000;
+		i0 |= ((i1|-i1)>>12)&0x80000;
+		SET_HIGH_WORD(x,i0);
+	        w = TWO52[sx]+x;
+	        t =  w-TWO52[sx];
+		GET_HIGH_WORD(i0,t);
+		SET_HIGH_WORD(t,(i0&0x7fffffff)|(sx<<31));
+	        return t;
+	    } else {
+		i = (0x000fffff)>>j0;
+		if(((i0&i)|i1)==0) return x; /* x is integral */
+		i>>=1;
+		if(((i0&i)|i1)!=0) {
+		    if(j0==19) i1 = 0x40000000; else
+		    i0 = (i0&(~i))|((0x20000)>>j0);
+		}
+	    }
+	} else if (j0>51) {
+	    if(j0==0x400) return x+x;	/* inf or NaN */
+	    else return x;		/* x is integral */
+	} else {
+	    i = ((u_int32_t)(0xffffffff))>>(j0-20);
+	    if((i1&i)==0) return x;	/* x is integral */
+	    i>>=1;
+	    if((i1&i)!=0) i1 = (i1&(~i))|((0x40000000)>>(j0-20));
+	}
+	INSERT_WORDS(x,i0,i1);
+	w = TWO52[sx]+x;
+	return w-TWO52[sx];
+}
diff -urN dietlibc-0.30/libm/s_scalbn.c dietlibc-0.30-libm/libm/s_scalbn.c
--- dietlibc-0.30/libm/s_scalbn.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_scalbn.c	2006-06-25 11:20:21.000000000 +0000
@@ -0,0 +1,67 @@
+/* @(#)s_scalbn.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_scalbn.c,v 1.8 1995/05/10 20:48:08 jtc Exp $";
+#endif
+
+/*
+ * scalbn (double x, int n)
+ * scalbn(x,n) returns x* 2**n  computed by  exponent
+ * manipulation rather than by actually performing an
+ * exponentiation or a multiplication.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+two54   =  1.80143985094819840000e+16, /* 0x43500000, 0x00000000 */
+twom54  =  5.55111512312578270212e-17, /* 0x3C900000, 0x00000000 */
+huge   = 1.0e+300,
+tiny   = 1.0e-300;
+
+#ifdef __STDC__
+	double scalbn (double x, int n)
+#else
+	double scalbn (x,n)
+	double x; int n;
+#endif
+{
+	int32_t k,hx,lx;
+	EXTRACT_WORDS(hx,lx,x);
+        k = (hx&0x7ff00000)>>20;		/* extract exponent */
+        if (k==0) {				/* 0 or subnormal x */
+            if ((lx|(hx&0x7fffffff))==0) return x; /* +-0 */
+	    x *= two54;
+	    GET_HIGH_WORD(hx,x);
+	    k = ((hx&0x7ff00000)>>20) - 54;
+            if (n< -50000) return tiny*x; 	/*underflow*/
+	    }
+        if (k==0x7ff) return x+x;		/* NaN or Inf */
+        k = k+n;
+        if (k >  0x7fe) return huge*copysign(huge,x); /* overflow  */
+        if (k > 0) 				/* normal result */
+	    {SET_HIGH_WORD(x,(hx&0x800fffff)|(k<<20)); return x;}
+        if (k <= -54) {
+            if (n > 50000) 	/* in case integer overflow in n+k */
+		return huge*copysign(huge,x);	/*overflow*/
+	    else return tiny*copysign(tiny,x); 	/*underflow*/
+	}
+        k += 54;				/* subnormal result */
+	SET_HIGH_WORD(x,(hx&0x800fffff)|(k<<20));
+        return x*twom54;
+}
diff -urN dietlibc-0.30/libm/s_signgam.c dietlibc-0.30-libm/libm/s_signgam.c
--- dietlibc-0.30/libm/s_signgam.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_signgam.c	2006-06-25 11:20:20.000000000 +0000
@@ -0,0 +1,3 @@
+#include "math.h"
+#include "math_private.h"
+int signgam = 0;
diff -urN dietlibc-0.30/libm/s_significand.c dietlibc-0.30-libm/libm/s_significand.c
--- dietlibc-0.30/libm/s_significand.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_significand.c	2006-06-25 11:19:59.000000000 +0000
@@ -0,0 +1,34 @@
+/* @(#)s_signif.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_significand.c,v 1.6 1995/05/10 20:48:11 jtc Exp $";
+#endif
+
+/*
+ * significand(x) computes just
+ * 	scalb(x, (double) -ilogb(x)),
+ * for exercising the fraction-part(F) IEEE 754-1985 test vector.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+	double significand(double x)
+#else
+	double significand(x)
+	double x;
+#endif
+{
+	return __ieee754_scalb(x,(double) -ilogb(x));
+}
diff -urN dietlibc-0.30/libm/s_sin.c dietlibc-0.30-libm/libm/s_sin.c
--- dietlibc-0.30/libm/s_sin.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_sin.c	2006-06-25 11:20:05.000000000 +0000
@@ -0,0 +1,82 @@
+/* @(#)s_sin.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_sin.c,v 1.7 1995/05/10 20:48:15 jtc Exp $";
+#endif
+
+/* sin(x)
+ * Return sine function of x.
+ *
+ * kernel function:
+ *	__kernel_sin		... sine function on [-pi/4,pi/4]
+ *	__kernel_cos		... cose function on [-pi/4,pi/4]
+ *	__ieee754_rem_pio2	... argument reduction routine
+ *
+ * Method.
+ *      Let S,C and T denote the sin, cos and tan respectively on
+ *	[-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2
+ *	in [-pi/4 , +pi/4], and let n = k mod 4.
+ *	We have
+ *
+ *          n        sin(x)      cos(x)        tan(x)
+ *     ----------------------------------------------------------
+ *	    0	       S	   C		 T
+ *	    1	       C	  -S		-1/T
+ *	    2	      -S	  -C		 T
+ *	    3	      -C	   S		-1/T
+ *     ----------------------------------------------------------
+ *
+ * Special cases:
+ *      Let trig be any of sin, cos, or tan.
+ *      trig(+-INF)  is NaN, with signals;
+ *      trig(NaN)    is that NaN;
+ *
+ * Accuracy:
+ *	TRIG(x) returns trig(x) nearly rounded
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+	double sin(double x)
+#else
+	double sin(x)
+	double x;
+#endif
+{
+	double y[2],z=0.0;
+	int32_t n, ix;
+
+    /* High word of x. */
+	GET_HIGH_WORD(ix,x);
+
+    /* |x| ~< pi/4 */
+	ix &= 0x7fffffff;
+	if(ix <= 0x3fe921fb) return __kernel_sin(x,z,0);
+
+    /* sin(Inf or NaN) is NaN */
+	else if (ix>=0x7ff00000) return x-x;
+
+    /* argument reduction needed */
+	else {
+	    n = __ieee754_rem_pio2(x,y);
+	    switch(n&3) {
+		case 0: return  __kernel_sin(y[0],y[1],1);
+		case 1: return  __kernel_cos(y[0],y[1]);
+		case 2: return -__kernel_sin(y[0],y[1],1);
+		default:
+			return -__kernel_cos(y[0],y[1]);
+	    }
+	}
+}
diff -urN dietlibc-0.30/libm/s_tan.c dietlibc-0.30-libm/libm/s_tan.c
--- dietlibc-0.30/libm/s_tan.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_tan.c	2006-06-25 11:20:06.000000000 +0000
@@ -0,0 +1,76 @@
+/* @(#)s_tan.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_tan.c,v 1.7 1995/05/10 20:48:18 jtc Exp $";
+#endif
+
+/* tan(x)
+ * Return tangent function of x.
+ *
+ * kernel function:
+ *	__kernel_tan		... tangent function on [-pi/4,pi/4]
+ *	__ieee754_rem_pio2	... argument reduction routine
+ *
+ * Method.
+ *      Let S,C and T denote the sin, cos and tan respectively on
+ *	[-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2
+ *	in [-pi/4 , +pi/4], and let n = k mod 4.
+ *	We have
+ *
+ *          n        sin(x)      cos(x)        tan(x)
+ *     ----------------------------------------------------------
+ *	    0	       S	   C		 T
+ *	    1	       C	  -S		-1/T
+ *	    2	      -S	  -C		 T
+ *	    3	      -C	   S		-1/T
+ *     ----------------------------------------------------------
+ *
+ * Special cases:
+ *      Let trig be any of sin, cos, or tan.
+ *      trig(+-INF)  is NaN, with signals;
+ *      trig(NaN)    is that NaN;
+ *
+ * Accuracy:
+ *	TRIG(x) returns trig(x) nearly rounded
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+	double tan(double x)
+#else
+	double tan(x)
+	double x;
+#endif
+{
+	double y[2],z=0.0;
+	int32_t n, ix;
+
+    /* High word of x. */
+	GET_HIGH_WORD(ix,x);
+
+    /* |x| ~< pi/4 */
+	ix &= 0x7fffffff;
+	if(ix <= 0x3fe921fb) return __kernel_tan(x,z,1);
+
+    /* tan(Inf or NaN) is NaN */
+	else if (ix>=0x7ff00000) return x-x;		/* NaN */
+
+    /* argument reduction needed */
+	else {
+	    n = __ieee754_rem_pio2(x,y);
+	    return __kernel_tan(y[0],y[1],1-((n&1)<<1)); /*   1 -- n even
+							-1 -- n odd */
+	}
+}
diff -urN dietlibc-0.30/libm/s_tanh.c dietlibc-0.30-libm/libm/s_tanh.c
--- dietlibc-0.30/libm/s_tanh.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/s_tanh.c	2006-06-25 11:20:22.000000000 +0000
@@ -0,0 +1,86 @@
+/* @(#)s_tanh.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: s_tanh.c,v 1.7 1995/05/10 20:48:22 jtc Exp $";
+#endif
+
+/* Tanh(x)
+ * Return the Hyperbolic Tangent of x
+ *
+ * Method :
+ *				       x    -x
+ *				      e  - e
+ *	0. tanh(x) is defined to be -----------
+ *				       x    -x
+ *				      e  + e
+ *	1. reduce x to non-negative by tanh(-x) = -tanh(x).
+ *	2.  0      <= x <= 2**-55 : tanh(x) := x*(one+x)
+ *					        -t
+ *	    2**-55 <  x <=  1     : tanh(x) := -----; t = expm1(-2x)
+ *					       t + 2
+ *						     2
+ *	    1      <= x <=  22.0  : tanh(x) := 1-  ----- ; t=expm1(2x)
+ *						   t + 2
+ *	    22.0   <  x <= INF    : tanh(x) := 1.
+ *
+ * Special cases:
+ *	tanh(NaN) is NaN;
+ *	only tanh(0)=0 is exact for finite argument.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double one=1.0, two=2.0, tiny = 1.0e-300;
+#else
+static double one=1.0, two=2.0, tiny = 1.0e-300;
+#endif
+
+#ifdef __STDC__
+	double tanh(double x)
+#else
+	double tanh(x)
+	double x;
+#endif
+{
+	double t,z;
+	int32_t jx,ix;
+
+    /* High word of |x|. */
+	GET_HIGH_WORD(jx,x);
+	ix = jx&0x7fffffff;
+
+    /* x is INF or NaN */
+	if(ix>=0x7ff00000) {
+	    if (jx>=0) return one/x+one;    /* tanh(+-inf)=+-1 */
+	    else       return one/x-one;    /* tanh(NaN) = NaN */
+	}
+
+    /* |x| < 22 */
+	if (ix < 0x40360000) {		/* |x|<22 */
+	    if (ix<0x3c800000) 		/* |x|<2**-55 */
+		return x*(one+x);    	/* tanh(small) = small */
+	    if (ix>=0x3ff00000) {	/* |x|>=1  */
+		t = expm1(two*fabs(x));
+		z = one - two/(t+two);
+	    } else {
+	        t = expm1(-two*fabs(x));
+	        z= -t/(t+two);
+	    }
+    /* |x| > 22, return +-1 */
+	} else {
+	    z = one - tiny;		/* raised inexact flag */
+	}
+	return (jx>=0)? z: -z;
+}
diff -urN dietlibc-0.30/libm/sinh.c dietlibc-0.30-libm/libm/sinh.c
--- dietlibc-0.30/libm/sinh.c	2001-07-27 20:30:34.000000000 +0000
+++ dietlibc-0.30-libm/libm/sinh.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,9 +0,0 @@
-#include <math.h>
-
-extern const float  __half;
-
-double  sinh ( double x )
-{
-    long double  y = exp (x);
-    return (y - 1./y) * __half;
-}
diff -urN dietlibc-0.30/libm/tanh.c dietlibc-0.30-libm/libm/tanh.c
--- dietlibc-0.30/libm/tanh.c	2001-07-27 20:30:34.000000000 +0000
+++ dietlibc-0.30-libm/libm/tanh.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,7 +0,0 @@
-#include <math.h>
-
-double  tanh ( double x )
-{
-    long double  y = exp (x + x);
-    return (y - 1.) / (y + 1.);
-}
diff -urN dietlibc-0.30/libm/w_acos.c dietlibc-0.30-libm/libm/w_acos.c
--- dietlibc-0.30/libm/w_acos.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_acos.c	2006-06-25 11:19:58.000000000 +0000
@@ -0,0 +1,43 @@
+/* @(#)w_acos.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: w_acos.c,v 1.6 1995/05/10 20:48:26 jtc Exp $";
+#endif
+
+/*
+ * wrap_acos(x)
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+
+#ifdef __STDC__
+	double acos(double x)		/* wrapper acos */
+#else
+	double acos(x)			/* wrapper acos */
+	double x;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_acos(x);
+#else
+	double z;
+	z = __ieee754_acos(x);
+	if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;
+	if(fabs(x)>1.0) {
+	        return __kernel_standard(x,x,1); /* acos(|x|>1) */
+	} else
+	    return z;
+#endif
+}
diff -urN dietlibc-0.30/libm/w_acosh.c dietlibc-0.30-libm/libm/w_acosh.c
--- dietlibc-0.30/libm/w_acosh.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_acosh.c	2006-06-25 11:20:01.000000000 +0000
@@ -0,0 +1,42 @@
+/* @(#)w_acosh.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: w_acosh.c,v 1.6 1995/05/10 20:48:31 jtc Exp $";
+#endif
+
+/*
+ * wrapper acosh(x)
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+	double acosh(double x)		/* wrapper acosh */
+#else
+	double acosh(x)			/* wrapper acosh */
+	double x;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_acosh(x);
+#else
+	double z;
+	z = __ieee754_acosh(x);
+	if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;
+	if(x<1.0) {
+	        return __kernel_standard(x,x,29); /* acosh(x<1) */
+	} else
+	    return z;
+#endif
+}
diff -urN dietlibc-0.30/libm/w_asin.c dietlibc-0.30-libm/libm/w_asin.c
--- dietlibc-0.30/libm/w_asin.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_asin.c	2006-06-25 11:19:58.000000000 +0000
@@ -0,0 +1,44 @@
+/* @(#)w_asin.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: w_asin.c,v 1.6 1995/05/10 20:48:35 jtc Exp $";
+#endif
+
+/*
+ * wrapper asin(x)
+ */
+
+
+#include "math.h"
+#include "math_private.h"
+
+
+#ifdef __STDC__
+	double asin(double x)		/* wrapper asin */
+#else
+	double asin(x)			/* wrapper asin */
+	double x;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_asin(x);
+#else
+	double z;
+	z = __ieee754_asin(x);
+	if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;
+	if(fabs(x)>1.0) {
+	        return __kernel_standard(x,x,2); /* asin(|x|>1) */
+	} else
+	    return z;
+#endif
+}
diff -urN dietlibc-0.30/libm/w_atan2.c dietlibc-0.30-libm/libm/w_atan2.c
--- dietlibc-0.30/libm/w_atan2.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_atan2.c	2006-06-25 11:20:08.000000000 +0000
@@ -0,0 +1,42 @@
+/* @(#)w_atan2.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: w_atan2.c,v 1.6 1995/05/10 20:48:39 jtc Exp $";
+#endif
+
+/*
+ * wrapper atan2(y,x)
+ */
+#include "math.h"
+#include "math_private.h"
+
+
+#ifdef __STDC__
+	double atan2(double y, double x)	/* wrapper atan2 */
+#else
+	double atan2(y,x)			/* wrapper atan2 */
+	double y,x;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_atan2(y,x);
+#else
+	double z;
+	z = __ieee754_atan2(y,x);
+	if(_LIB_VERSION == _IEEE_||isnan(x)||isnan(y)) return z;
+	if(x==0.0&&y==0.0) {
+	        return __kernel_standard(y,x,3); /* atan2(+-0,+-0) */
+	} else
+	    return z;
+#endif
+}
diff -urN dietlibc-0.30/libm/w_atanh.c dietlibc-0.30-libm/libm/w_atanh.c
--- dietlibc-0.30/libm/w_atanh.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_atanh.c	2006-06-25 11:20:09.000000000 +0000
@@ -0,0 +1,47 @@
+/* @(#)w_atanh.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: w_atanh.c,v 1.6 1995/05/10 20:48:43 jtc Exp $";
+#endif
+
+/*
+ * wrapper atanh(x)
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+
+#ifdef __STDC__
+	double atanh(double x)		/* wrapper atanh */
+#else
+	double atanh(x)			/* wrapper atanh */
+	double x;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_atanh(x);
+#else
+	double z,y;
+	z = __ieee754_atanh(x);
+	if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;
+	y = fabs(x);
+	if(y>=1.0) {
+	    if(y>1.0)
+	        return __kernel_standard(x,x,30); /* atanh(|x|>1) */
+	    else
+	        return __kernel_standard(x,x,31); /* atanh(|x|==1) */
+	} else
+	    return z;
+#endif
+}
diff -urN dietlibc-0.30/libm/w_cabs.c dietlibc-0.30-libm/libm/w_cabs.c
--- dietlibc-0.30/libm/w_cabs.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_cabs.c	2006-06-25 11:19:59.000000000 +0000
@@ -0,0 +1,18 @@
+/*
+ * cabs() wrapper for hypot().
+ *
+ * Written by J.T. Conklin, <jtc@wimsey.com>
+ * Placed into the Public Domain, 1994.
+ */
+
+#include <math.h>
+
+struct complex {
+	double x;
+	double y;
+};
+
+double cabs(struct complex z)
+{
+	return hypot(z.x, z.y);
+}
diff -urN dietlibc-0.30/libm/w_cosh.c dietlibc-0.30-libm/libm/w_cosh.c
--- dietlibc-0.30/libm/w_cosh.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_cosh.c	2006-06-25 11:19:59.000000000 +0000
@@ -0,0 +1,42 @@
+/* @(#)w_cosh.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: w_cosh.c,v 1.6 1995/05/10 20:48:47 jtc Exp $";
+#endif
+
+/*
+ * wrapper cosh(x)
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+	double cosh(double x)		/* wrapper cosh */
+#else
+	double cosh(x)			/* wrapper cosh */
+	double x;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_cosh(x);
+#else
+	double z;
+	z = __ieee754_cosh(x);
+	if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;
+	if(fabs(x)>7.10475860073943863426e+02) {
+	        return __kernel_standard(x,x,5); /* cosh overflow */
+	} else
+	    return z;
+#endif
+}
diff -urN dietlibc-0.30/libm/w_drem.c dietlibc-0.30-libm/libm/w_drem.c
--- dietlibc-0.30/libm/w_drem.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_drem.c	2006-06-25 11:20:00.000000000 +0000
@@ -0,0 +1,15 @@
+/*
+ * drem() wrapper for remainder().
+ *
+ * Written by J.T. Conklin, <jtc@wimsey.com>
+ * Placed into the Public Domain, 1994.
+ */
+
+#include <math.h>
+
+double
+drem(x, y)
+	double x, y;
+{
+	return remainder(x, y);
+}
diff -urN dietlibc-0.30/libm/w_exp.c dietlibc-0.30-libm/libm/w_exp.c
--- dietlibc-0.30/libm/w_exp.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_exp.c	2006-06-25 11:20:19.000000000 +0000
@@ -0,0 +1,54 @@
+/* @(#)w_exp.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: w_exp.c,v 1.6 1995/05/10 20:48:51 jtc Exp $";
+#endif
+
+/*
+ * wrapper exp(x)
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+static const double
+#else
+static double
+#endif
+o_threshold=  7.09782712893383973096e+02,  /* 0x40862E42, 0xFEFA39EF */
+u_threshold= -7.45133219101941108420e+02;  /* 0xc0874910, 0xD52D3051 */
+
+#ifdef __STDC__
+	double __exp(double x)		/* wrapper exp */
+#else
+	double __exp(x)			/* wrapper exp */
+	double x;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_exp(x);
+#else
+	double z;
+	z = __ieee754_exp(x);
+	if(_LIB_VERSION == _IEEE_) return z;
+	if(finite(x)) {
+	    if(x>o_threshold)
+	        return __kernel_standard(x,x,6); /* exp overflow */
+	    else if(x<u_threshold)
+	        return __kernel_standard(x,x,7); /* exp underflow */
+	}
+	return z;
+#endif
+}
+weak_alias (__exp, exp)
diff -urN dietlibc-0.30/libm/w_fmod.c dietlibc-0.30-libm/libm/w_fmod.c
--- dietlibc-0.30/libm/w_fmod.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_fmod.c	2006-06-25 11:20:00.000000000 +0000
@@ -0,0 +1,43 @@
+/* @(#)w_fmod.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: w_fmod.c,v 1.6 1995/05/10 20:48:55 jtc Exp $";
+#endif
+
+/*
+ * wrapper fmod(x,y)
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+
+#ifdef __STDC__
+	double fmod(double x, double y)	/* wrapper fmod */
+#else
+	double fmod(x,y)		/* wrapper fmod */
+	double x,y;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_fmod(x,y);
+#else
+	double z;
+	z = __ieee754_fmod(x,y);
+	if(_LIB_VERSION == _IEEE_ ||isnan(y)||isnan(x)) return z;
+	if(y==0.0) {
+	        return __kernel_standard(x,y,27); /* fmod(x,0) */
+	} else
+	    return z;
+#endif
+}
diff -urN dietlibc-0.30/libm/w_gamma.c dietlibc-0.30-libm/libm/w_gamma.c
--- dietlibc-0.30/libm/w_gamma.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_gamma.c	2006-06-25 11:20:23.000000000 +0000
@@ -0,0 +1,49 @@
+/* @(#)w_gamma.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: w_gamma.c,v 1.7 1995/11/20 22:06:43 jtc Exp $";
+#endif
+
+/* double gamma(double x)
+ * Return the logarithm of the Gamma function of x.
+ *
+ * Method: call gamma_r
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+extern int signgam;
+
+#ifdef __STDC__
+	double gamma(double x)
+#else
+	double gamma(x)
+	double x;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_lgamma_r(x,&signgam);
+#else
+        double y;
+        y = __ieee754_lgamma_r(x,&signgam);
+        if(_LIB_VERSION == _IEEE_) return y;
+        if(!finite(y)&&finite(x)) {
+            if(floor(x)==x&&x<=0.0)
+                return __kernel_standard(x,x,41); /* gamma pole */
+            else
+                return __kernel_standard(x,x,40); /* gamma overflow */
+        } else
+            return y;
+#endif
+}
diff -urN dietlibc-0.30/libm/w_gamma_r.c dietlibc-0.30-libm/libm/w_gamma_r.c
--- dietlibc-0.30/libm/w_gamma_r.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_gamma_r.c	2006-06-25 11:20:22.000000000 +0000
@@ -0,0 +1,46 @@
+/* @(#)wr_gamma.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: w_gamma_r.c,v 1.7 1995/11/20 22:06:45 jtc Exp $";
+#endif
+
+/*
+ * wrapper double gamma_r(double x, int *signgamp)
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+
+#ifdef __STDC__
+	double gamma_r(double x, int *signgamp) /* wrapper lgamma_r */
+#else
+	double gamma_r(x,signgamp)              /* wrapper lgamma_r */
+        double x; int *signgamp;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_lgamma_r(x,signgamp);
+#else
+        double y;
+        y = __ieee754_lgamma_r(x,signgamp);
+        if(_LIB_VERSION == _IEEE_) return y;
+        if(!finite(y)&&finite(x)) {
+            if(floor(x)==x&&x<=0.0)
+                return __kernel_standard(x,x,41); /* gamma pole */
+            else
+                return __kernel_standard(x,x,40); /* gamma overflow */
+        } else
+            return y;
+#endif
+}
diff -urN dietlibc-0.30/libm/w_hypot.c dietlibc-0.30-libm/libm/w_hypot.c
--- dietlibc-0.30/libm/w_hypot.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_hypot.c	2006-06-25 11:20:11.000000000 +0000
@@ -0,0 +1,43 @@
+/* @(#)w_hypot.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: w_hypot.c,v 1.6 1995/05/10 20:49:07 jtc Exp $";
+#endif
+
+/*
+ * wrapper hypot(x,y)
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+
+#ifdef __STDC__
+	double hypot(double x, double y)/* wrapper hypot */
+#else
+	double hypot(x,y)		/* wrapper hypot */
+	double x,y;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_hypot(x,y);
+#else
+	double z;
+	z = __ieee754_hypot(x,y);
+	if(_LIB_VERSION == _IEEE_) return z;
+	if((!finite(z))&&finite(x)&&finite(y))
+	    return __kernel_standard(x,y,4); /* hypot overflow */
+	else
+	    return z;
+#endif
+}
diff -urN dietlibc-0.30/libm/w_j0.c dietlibc-0.30-libm/libm/w_j0.c
--- dietlibc-0.30/libm/w_j0.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_j0.c	2006-06-25 11:20:18.000000000 +0000
@@ -0,0 +1,69 @@
+/* @(#)w_j0.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: w_j0.c,v 1.6 1995/05/10 20:49:11 jtc Exp $";
+#endif
+
+/*
+ * wrapper j0(double x), y0(double x)
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+	double j0(double x)		/* wrapper j0 */
+#else
+	double j0(x)			/* wrapper j0 */
+	double x;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_j0(x);
+#else
+	double z = __ieee754_j0(x);
+	if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;
+	if(fabs(x)>X_TLOSS) {
+	        return __kernel_standard(x,x,34); /* j0(|x|>X_TLOSS) */
+	} else
+	    return z;
+#endif
+}
+
+#ifdef __STDC__
+	double y0(double x)		/* wrapper y0 */
+#else
+	double y0(x)			/* wrapper y0 */
+	double x;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_y0(x);
+#else
+	double z;
+	z = __ieee754_y0(x);
+	if(_LIB_VERSION == _IEEE_ || isnan(x) ) return z;
+        if(x <= 0.0){
+                if(x==0.0)
+                    /* d= -one/(x-x); */
+                    return __kernel_standard(x,x,8);
+                else
+                    /* d = zero/(x-x); */
+                    return __kernel_standard(x,x,9);
+        }
+	if(x>X_TLOSS) {
+	        return __kernel_standard(x,x,35); /* y0(x>X_TLOSS) */
+	} else
+	    return z;
+#endif
+}
diff -urN dietlibc-0.30/libm/w_j1.c dietlibc-0.30-libm/libm/w_j1.c
--- dietlibc-0.30/libm/w_j1.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_j1.c	2006-06-25 11:20:18.000000000 +0000
@@ -0,0 +1,70 @@
+/* @(#)w_j1.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: w_j1.c,v 1.6 1995/05/10 20:49:15 jtc Exp $";
+#endif
+
+/*
+ * wrapper of j1,y1
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+	double j1(double x)		/* wrapper j1 */
+#else
+	double j1(x)			/* wrapper j1 */
+	double x;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_j1(x);
+#else
+	double z;
+	z = __ieee754_j1(x);
+	if(_LIB_VERSION == _IEEE_ || isnan(x) ) return z;
+	if(fabs(x)>X_TLOSS) {
+	        return __kernel_standard(x,x,36); /* j1(|x|>X_TLOSS) */
+	} else
+	    return z;
+#endif
+}
+
+#ifdef __STDC__
+	double y1(double x)		/* wrapper y1 */
+#else
+	double y1(x)			/* wrapper y1 */
+	double x;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_y1(x);
+#else
+	double z;
+	z = __ieee754_y1(x);
+	if(_LIB_VERSION == _IEEE_ || isnan(x) ) return z;
+        if(x <= 0.0){
+                if(x==0.0)
+                    /* d= -one/(x-x); */
+                    return __kernel_standard(x,x,10);
+                else
+                    /* d = zero/(x-x); */
+                    return __kernel_standard(x,x,11);
+        }
+	if(x>X_TLOSS) {
+	        return __kernel_standard(x,x,37); /* y1(x>X_TLOSS) */
+	} else
+	    return z;
+#endif
+}
diff -urN dietlibc-0.30/libm/w_jn.c dietlibc-0.30-libm/libm/w_jn.c
--- dietlibc-0.30/libm/w_jn.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_jn.c	2006-06-25 11:20:18.000000000 +0000
@@ -0,0 +1,92 @@
+/* @(#)w_jn.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: w_jn.c,v 1.6 1995/05/10 20:49:19 jtc Exp $";
+#endif
+
+/*
+ * wrapper jn(int n, double x), yn(int n, double x)
+ * floating point Bessel's function of the 1st and 2nd kind
+ * of order n
+ *
+ * Special cases:
+ *	y0(0)=y1(0)=yn(n,0) = -inf with division by zero signal;
+ *	y0(-ve)=y1(-ve)=yn(n,-ve) are NaN with invalid signal.
+ * Note 2. About jn(n,x), yn(n,x)
+ *	For n=0, j0(x) is called,
+ *	for n=1, j1(x) is called,
+ *	for n<x, forward recursion us used starting
+ *	from values of j0(x) and j1(x).
+ *	for n>x, a continued fraction approximation to
+ *	j(n,x)/j(n-1,x) is evaluated and then backward
+ *	recursion is used starting from a supposed value
+ *	for j(n,x). The resulting value of j(0,x) is
+ *	compared with the actual value to correct the
+ *	supposed value of j(n,x).
+ *
+ *	yn(n,x) is similar in all respects, except
+ *	that forward recursion is used for all
+ *	values of n>1.
+ *
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+	double jn(int n, double x)	/* wrapper jn */
+#else
+	double jn(n,x)			/* wrapper jn */
+	double x; int n;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_jn(n,x);
+#else
+	double z;
+	z = __ieee754_jn(n,x);
+	if(_LIB_VERSION == _IEEE_ || isnan(x) ) return z;
+	if(fabs(x)>X_TLOSS) {
+	    return __kernel_standard((double)n,x,38); /* jn(|x|>X_TLOSS,n) */
+	} else
+	    return z;
+#endif
+}
+
+#ifdef __STDC__
+	double yn(int n, double x)	/* wrapper yn */
+#else
+	double yn(n,x)			/* wrapper yn */
+	double x; int n;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_yn(n,x);
+#else
+	double z;
+	z = __ieee754_yn(n,x);
+	if(_LIB_VERSION == _IEEE_ || isnan(x) ) return z;
+        if(x <= 0.0){
+                if(x==0.0)
+                    /* d= -one/(x-x); */
+                    return __kernel_standard((double)n,x,12);
+                else
+                    /* d = zero/(x-x); */
+                    return __kernel_standard((double)n,x,13);
+        }
+	if(x>X_TLOSS) {
+	    return __kernel_standard((double)n,x,39); /* yn(x>X_TLOSS,n) */
+	} else
+	    return z;
+#endif
+}
diff -urN dietlibc-0.30/libm/w_lgamma.c dietlibc-0.30-libm/libm/w_lgamma.c
--- dietlibc-0.30/libm/w_lgamma.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_lgamma.c	2006-06-25 11:20:03.000000000 +0000
@@ -0,0 +1,49 @@
+/* @(#)w_lgamma.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: w_lgamma.c,v 1.6 1995/05/10 20:49:24 jtc Exp $";
+#endif
+
+/* double lgamma(double x)
+ * Return the logarithm of the Gamma function of x.
+ *
+ * Method: call __ieee754_lgamma_r
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+extern int signgam;
+
+#ifdef __STDC__
+	double lgamma(double x)
+#else
+	double lgamma(x)
+	double x;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_lgamma_r(x,&signgam);
+#else
+        double y;
+        y = __ieee754_lgamma_r(x,&signgam);
+        if(_LIB_VERSION == _IEEE_) return y;
+        if(!finite(y)&&finite(x)) {
+            if(floor(x)==x&&x<=0.0)
+                return __kernel_standard(x,x,15); /* lgamma pole */
+            else
+                return __kernel_standard(x,x,14); /* lgamma overflow */
+        } else
+            return y;
+#endif
+}
diff -urN dietlibc-0.30/libm/w_lgamma_r.c dietlibc-0.30-libm/libm/w_lgamma_r.c
--- dietlibc-0.30/libm/w_lgamma_r.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_lgamma_r.c	2006-06-25 11:20:11.000000000 +0000
@@ -0,0 +1,46 @@
+/* @(#)wr_lgamma.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: w_lgamma_r.c,v 1.6 1995/05/10 20:49:27 jtc Exp $";
+#endif
+
+/*
+ * wrapper double lgamma_r(double x, int *signgamp)
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+
+#ifdef __STDC__
+	double lgamma_r(double x, int *signgamp) /* wrapper lgamma_r */
+#else
+	double lgamma_r(x,signgamp)              /* wrapper lgamma_r */
+        double x; int *signgamp;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_lgamma_r(x,signgamp);
+#else
+        double y;
+        y = __ieee754_lgamma_r(x,signgamp);
+        if(_LIB_VERSION == _IEEE_) return y;
+        if(!finite(y)&&finite(x)) {
+            if(floor(x)==x&&x<=0.0)
+                return __kernel_standard(x,x,15); /* lgamma pole */
+            else
+                return __kernel_standard(x,x,14); /* lgamma overflow */
+        } else
+            return y;
+#endif
+}
diff -urN dietlibc-0.30/libm/w_log.c dietlibc-0.30-libm/libm/w_log.c
--- dietlibc-0.30/libm/w_log.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_log.c	2006-06-25 11:20:19.000000000 +0000
@@ -0,0 +1,43 @@
+/* @(#)w_log.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: w_log.c,v 1.6 1995/05/10 20:49:33 jtc Exp $";
+#endif
+
+/*
+ * wrapper log(x)
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+
+#ifdef __STDC__
+	double log(double x)		/* wrapper log */
+#else
+	double log(x)			/* wrapper log */
+	double x;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_log(x);
+#else
+	double z;
+	z = __ieee754_log(x);
+	if(_LIB_VERSION == _IEEE_ || isnan(x) || x > 0.0) return z;
+	if(x==0.0)
+	    return __kernel_standard(x,x,16); /* log(0) */
+	else
+	    return __kernel_standard(x,x,17); /* log(x<0) */
+#endif
+}
diff -urN dietlibc-0.30/libm/w_log10.c dietlibc-0.30-libm/libm/w_log10.c
--- dietlibc-0.30/libm/w_log10.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_log10.c	2006-06-25 11:20:21.000000000 +0000
@@ -0,0 +1,46 @@
+/* @(#)w_log10.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: w_log10.c,v 1.6 1995/05/10 20:49:35 jtc Exp $";
+#endif
+
+/*
+ * wrapper log10(X)
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+
+#ifdef __STDC__
+	double log10(double x)		/* wrapper log10 */
+#else
+	double log10(x)			/* wrapper log10 */
+	double x;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_log10(x);
+#else
+	double z;
+	z = __ieee754_log10(x);
+	if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;
+	if(x<=0.0) {
+	    if(x==0.0)
+	        return __kernel_standard(x,x,18); /* log10(0) */
+	    else
+	        return __kernel_standard(x,x,19); /* log10(x<0) */
+	} else
+	    return z;
+#endif
+}
diff -urN dietlibc-0.30/libm/w_pow.c dietlibc-0.30-libm/libm/w_pow.c
--- dietlibc-0.30/libm/w_pow.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_pow.c	2006-06-25 11:20:19.000000000 +0000
@@ -0,0 +1,61 @@
+
+
+/* @(#)w_pow.c 5.2 93/10/01 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+/*
+ * wrapper pow(x,y) return x**y
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+
+#ifdef __STDC__
+	double pow(double x, double y)	/* wrapper pow */
+#else
+	double pow(x,y)			/* wrapper pow */
+	double x,y;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return  __ieee754_pow(x,y);
+#else
+	double z;
+	z=__ieee754_pow(x,y);
+	if(_LIB_VERSION == _IEEE_|| isnan(y)) return z;
+	if(isnan(x)) {
+	    if(y==0.0)
+	        return __kernel_standard(x,y,42); /* pow(NaN,0.0) */
+	    else
+		return z;
+	}
+	if(x==0.0){
+	    if(y==0.0)
+	        return __kernel_standard(x,y,20); /* pow(0.0,0.0) */
+	    if(finite(y)&&y<0.0)
+	        return __kernel_standard(x,y,23); /* pow(0.0,negative) */
+	    return z;
+	}
+	if(!finite(z)) {
+	    if(finite(x)&&finite(y)) {
+	        if(isnan(z))
+	            return __kernel_standard(x,y,24); /* pow neg**non-int */
+	        else
+	            return __kernel_standard(x,y,21); /* pow overflow */
+	    }
+	}
+	if(z==0.0&&finite(x)&&finite(y))
+	    return __kernel_standard(x,y,22); /* pow underflow */
+	return z;
+#endif
+}
diff -urN dietlibc-0.30/libm/w_remainder.c dietlibc-0.30-libm/libm/w_remainder.c
--- dietlibc-0.30/libm/w_remainder.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_remainder.c	2006-06-25 11:20:14.000000000 +0000
@@ -0,0 +1,42 @@
+/* @(#)w_remainder.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: w_remainder.c,v 1.6 1995/05/10 20:49:44 jtc Exp $";
+#endif
+
+/*
+ * wrapper remainder(x,p)
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+	double remainder(double x, double y)	/* wrapper remainder */
+#else
+	double remainder(x,y)			/* wrapper remainder */
+	double x,y;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_remainder(x,y);
+#else
+	double z;
+	z = __ieee754_remainder(x,y);
+	if(_LIB_VERSION == _IEEE_ || isnan(y)) return z;
+	if(y==0.0)
+	    return __kernel_standard(x,y,28); /* remainder(x,0) */
+	else
+	    return z;
+#endif
+}
diff -urN dietlibc-0.30/libm/w_scalb.c dietlibc-0.30-libm/libm/w_scalb.c
--- dietlibc-0.30/libm/w_scalb.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_scalb.c	2006-06-25 11:20:19.000000000 +0000
@@ -0,0 +1,60 @@
+/* @(#)w_scalb.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: w_scalb.c,v 1.6 1995/05/10 20:49:48 jtc Exp $";
+#endif
+
+/*
+ * wrapper scalb(double x, double fn) is provide for
+ * passing various standard test suite. One
+ * should use scalbn() instead.
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#include <errno.h>
+
+#ifdef __STDC__
+#ifdef _SCALB_INT
+	double scalb(double x, int fn)		/* wrapper scalb */
+#else
+	double scalb(double x, double fn)	/* wrapper scalb */
+#endif
+#else
+	double scalb(x,fn)			/* wrapper scalb */
+#ifdef _SCALB_INT
+	double x; int fn;
+#else
+	double x,fn;
+#endif
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_scalb(x,fn);
+#else
+	double z;
+	z = __ieee754_scalb(x,fn);
+	if(_LIB_VERSION == _IEEE_) return z;
+	if(!(finite(z)||isnan(z))&&finite(x)) {
+	    return __kernel_standard(x,(double)fn,32); /* scalb overflow */
+	}
+	if(z==0.0&&z!=x) {
+	    return __kernel_standard(x,(double)fn,33); /* scalb underflow */
+	}
+#ifndef _SCALB_INT
+	if(!finite(fn)) errno = ERANGE;
+#endif
+	return z;
+#endif
+}
diff -urN dietlibc-0.30/libm/w_sinh.c dietlibc-0.30-libm/libm/w_sinh.c
--- dietlibc-0.30/libm/w_sinh.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_sinh.c	2006-06-25 11:20:07.000000000 +0000
@@ -0,0 +1,42 @@
+/* @(#)w_sinh.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: w_sinh.c,v 1.6 1995/05/10 20:49:51 jtc Exp $";
+#endif
+
+/*
+ * wrapper sinh(x)
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+	double sinh(double x)		/* wrapper sinh */
+#else
+	double sinh(x)			/* wrapper sinh */
+	double x;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_sinh(x);
+#else
+	double z;
+	z = __ieee754_sinh(x);
+	if(_LIB_VERSION == _IEEE_) return z;
+	if(!finite(z)&&finite(x)) {
+	    return __kernel_standard(x,x,25); /* sinh overflow */
+	} else
+	    return z;
+#endif
+}
diff -urN dietlibc-0.30/libm/w_sqrt.c dietlibc-0.30-libm/libm/w_sqrt.c
--- dietlibc-0.30/libm/w_sqrt.c	1970-01-01 00:00:00.000000000 +0000
+++ dietlibc-0.30-libm/libm/w_sqrt.c	2006-06-25 11:20:08.000000000 +0000
@@ -0,0 +1,42 @@
+/* @(#)w_sqrt.c 5.1 93/09/24 */
+/*
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+#if defined(LIBM_SCCS) && !defined(lint)
+static char rcsid[] = "$NetBSD: w_sqrt.c,v 1.6 1995/05/10 20:49:55 jtc Exp $";
+#endif
+
+/*
+ * wrapper sqrt(x)
+ */
+
+#include "math.h"
+#include "math_private.h"
+
+#ifdef __STDC__
+	double sqrt(double x)		/* wrapper sqrt */
+#else
+	double sqrt(x)			/* wrapper sqrt */
+	double x;
+#endif
+{
+#ifdef _IEEE_LIBM
+	return __ieee754_sqrt(x);
+#else
+	double z;
+	z = __ieee754_sqrt(x);
+	if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;
+	if(x<0.0) {
+	    return __kernel_standard(x,x,26); /* sqrt(negative) */
+	} else
+	    return z;
+#endif
+}
