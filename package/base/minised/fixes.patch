# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../minised/fixes.patch
# Copyright (C) 2004 - 2005 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

AFAICS all commands are executed - a /d deletes all and a /p prints all.
I fixed this to only execute when the address matched. I wonder how it could
be released this way.

There is more stuff to fix / implement ...

  - Rene Rebe <rene@exactcode.de>

diff -u sed-1.4-orig/sedexec.c sed-1.4/sedexec.c
--- ./sedexec.c	2003-12-29 22:36:33.000000000 +0100
+++ ./sedexec.c	2005-06-26 08:59:43.000000000 +0200
@@ -102,8 +102,10 @@
 		{
 			/* all no-address commands are selected */
 			if (ipc->addr1)
-				if (selected(ipc) == TRUE)
+				if (selected(ipc) == FALSE) {
+					ipc++;	/* not selected, next cmd */
 					continue;
+				}
 	doit:
 			command(ipc);	/* execute the command pointed at */
 

Fixed last line matching ...

  - Rene Rebe <rene@exactcode.de>

--- ./sedexec.c	2003-12-29 22:36:33.000000000 +0100
+++ ./sedexec.c	2005-06-26 23:00:22.000000000 +0200
@@ -729,15 +730,22 @@
 {
 	if (gets(buf) != NULL)
 	{
+		int c;
 		lnum++;			/* note that we got another line */
 		while (*buf++)		/* find the end of the input */
 		    continue;
+
+		if ((c = fgetc(stdin)) != EOF)
+			ungetc (c, stdin);
+		else {
+		  if (eargc == 0)		/* if no more args */
+			lastline = TRUE;	/*    set a flag */
+		}
+
 		return(--buf);		/* return ptr to terminating null */ 
 	}
 	else
 	{
-		if (eargc == 0)			/* if no more args */
-			lastline = TRUE;	/*    set a flag */
 		return(BAD);
 	}
 }
Index: sedexec.c
===================================================================
--- ./sedexec.c	(revision 7)
+++ ./sedexec.c	(revision 8)
@@ -149,6 +149,8 @@
 	register char	*p2 = ipc->addr2;	/*   and p2 at second */
 	char		c;
 
+	int selected = TRUE;
+
 	if (ipc->flags.inrange)
 	{
 		if (*p2 == CEND)
@@ -159,12 +161,9 @@
 			if (lnum > linenum[c])
 			{
 				ipc->flags.inrange = FALSE;
-				if (ipc->flags.allbut)
-					return(TRUE);
-				ipc++;
-				return(FALSE);
+				selected = 0;
 			}
-			if (lnum == linenum[c])
+			else if (lnum == linenum[c])
 				ipc->flags.inrange = FALSE;
 		}
 		else if (match(p2, 0))
@@ -174,10 +173,7 @@
 	{
 		if (!lastline)
 		{
-			if (ipc->flags.allbut)
-				return(TRUE);
-			ipc++;
-			return(FALSE);
+			selected = FALSE;
 		}
 	}
 	else if (*p1 == CLNUM)
@@ -185,10 +181,7 @@
 		c = p1[1];
 		if (lnum != linenum[c])
 		{
-			if (ipc->flags.allbut)
-				return(TRUE);
-			ipc++;
-			return(FALSE);
+			selected = FALSE;
 		}
 		if (p2)
 			ipc->flags.inrange = TRUE;
@@ -200,11 +193,9 @@
 	}
 	else
 	{
-		if (ipc->flags.allbut)
-			return(TRUE);
-		ipc++;
-		return(FALSE);
+		selected = FALSE;
 	}
+	return ipc->flags.allbut ? !selected : selected;
 }
 
 static int match(char *expbuf, int gf)	/* uses genbuf */
Index: sedexec.c
===================================================================
--- ./sedexec.c	(revision 8)
+++ ./sedexec.c	(revision 9)
@@ -100,12 +100,14 @@
 		/* loop through compiled commands, executing them */
 		for(ipc = cmds; ipc->command; )
 		{
-			/* all no-address commands are selected */
-			if (ipc->addr1)
-				if (selected(ipc) == FALSE) {
+			/* address command to select? - If not address
+			   but allbut then invert, that is skip, the commmand */
+			if (ipc->addr1 || ipc->flags.allbut) {
+				if (!ipc->addr1 || !selected(ipc)) {
 					ipc++;	/* not selected, next cmd */
 					continue;
 				}
+			}
 	doit:
 			command(ipc);	/* execute the command pointed at */
 
@@ -149,52 +151,42 @@
 	register char	*p2 = ipc->addr2;	/*   and p2 at second */
 	char		c;
 
-	int selected = TRUE;
+	int selected = FALSE;
 
 	if (ipc->flags.inrange)
 	{
+		selected = TRUE;
 		if (*p2 == CEND)
-			p1 = NULL;
+			;
 		else if (*p2 == CLNUM)
 		{
 			c = p2[1];
-			if (lnum > linenum[c])
-			{
+			if (lnum >= linenum[c])
 				ipc->flags.inrange = FALSE;
-				selected = 0;
-			}
-			else if (lnum == linenum[c])
-				ipc->flags.inrange = FALSE;
 		}
 		else if (match(p2, 0))
 			ipc->flags.inrange = FALSE;
 	}
 	else if (*p1 == CEND)
 	{
-		if (!lastline)
-		{
-			selected = FALSE;
-		}
+		if (lastline)
+			selected = TRUE;
 	}
 	else if (*p1 == CLNUM)
 	{
 		c = p1[1];
-		if (lnum != linenum[c])
-		{
-			selected = FALSE;
+		if (lnum == linenum[c]) {
+			selected = TRUE;
+			if (p2)
+				ipc->flags.inrange = TRUE;
 		}
-		if (p2)
-			ipc->flags.inrange = TRUE;
 	}
 	else if (match(p1, 0))
 	{
+		selected = TRUE;
 		if (p2)
 			ipc->flags.inrange = TRUE;
 	}
-	else
-	{
-		selected = FALSE;
-	}
 	return ipc->flags.allbut ? !selected : selected;
 }
 
Index: sedcomp.c
===================================================================
--- ./sedcomp.c	(revision 31)
+++ ./sedcomp.c	(revision 32)
@@ -195,17 +195,15 @@
 
 	for(;;)					/* main compilation loop */
 	{
-		if (*cp != ';')			/* get a new command line */
+		if (*cp == ';')			/* ; separates cmds */
+			cp++;
+		else				/* get a new command line */
 			if (cmdline(cp = linebuf) < 0)
 				break;
 		SKIPWS(cp);
+
 		if (*cp=='\0' || *cp=='#')	/* a comment */
 			continue;
-		if (*cp == ';')			/* ; separates cmds */
-		{
-			cp++;
-			continue;
-		}
 
 		/* compile first address */
 		if (fp > poolend)
@@ -262,9 +260,9 @@
 
 		SKIPWS(cp);			/* look for trailing stuff */
 		if (*cp != '\0')
-			if (*++cp == ';')
+			if (*cp == ';')
 				continue;
-			else if (cp[-1] != '#')
+			else if (*cp != '#')
 				ABORT(TRAIL);
 	}
 }
