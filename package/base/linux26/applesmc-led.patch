# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../linux26/applesmc-led.patch
# Copyright (C) 2008 - 2009 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

LED actiivity indicator for Apple Intel hardware thru applesmc
and generic SCSI/SATA LED trigger.

The SMC key used might not be perfect, it should rise the off
level, however the other ones sounding more appropriate did
not work.

  Signed-off-by: Ren√© Rebe <rene@exactcode.de>

--- ./drivers/hwmon/applesmc.c.orig	2008-04-17 04:49:44.000000000 +0200
+++ ./drivers/hwmon/applesmc.c	2008-04-18 16:06:42.000000000 +0200
@@ -63,6 +63,8 @@
 
 #define CLAMSHELL_KEY		"MSLD" /* r-o ui8 (unused) */
 
+#define LED_KEY			"LSLF" /* r-w ui16 */
+
 #define MOTION_SENSOR_X_KEY	"MO_X" /* r-o sp78 (2 bytes) */
 #define MOTION_SENSOR_Y_KEY	"MO_Y" /* r-o sp78 (2 bytes) */
 #define MOTION_SENSOR_Z_KEY	"MO_Z" /* r-o sp78 (2 bytes) */
@@ -154,7 +156,7 @@
  */
 static unsigned int key_at_index;
 
-static struct workqueue_struct *applesmc_led_wq;
+static struct workqueue_struct *applesmc_led_wq, *applesmc_backlight_wq;
 
 /*
  * __wait_status - Wait up to 2ms for the status port to get a certain value
@@ -745,13 +747,40 @@
 }
 static DECLARE_WORK(backlight_work, &applesmc_backlight_set);
 
-static void applesmc_brightness_set(struct led_classdev *led_cdev,
-						enum led_brightness value)
+static void applesmc_backlight_brightness_set(struct led_classdev *led_cdev,
+					      enum led_brightness value)
 {
 	int ret;
 
 	backlight_value = value;
-	ret = queue_work(applesmc_led_wq, &backlight_work);
+	ret = queue_work(applesmc_backlight_wq, &backlight_work);
+
+	if (debug && (!ret))
+		printk(KERN_DEBUG "applesmc: work was already on the queue.\n");
+}
+
+/* Store the next LED value to be written by the work */
+static unsigned int led_value;
+
+static void applesmc_led_set(struct work_struct *work)
+{
+	u8 buffer[2];
+
+	mutex_lock(&applesmc_lock);
+	buffer[0] = led_value;
+	buffer[1] = 0x00;
+	applesmc_write_key(LED_KEY, buffer, 2);
+	mutex_unlock(&applesmc_lock);
+}
+static DECLARE_WORK(led_work, &applesmc_led_set);
+
+static void applesmc_led_brightness_set(struct led_classdev *led_cdev,
+					 enum led_brightness value)
+{
+	int ret;
+
+	led_value = value;
+	ret = queue_work(applesmc_led_wq, &led_work);
 
 	if (debug && (!ret))
 		printk(KERN_DEBUG "applesmc: work was already on the queue.\n");
@@ -907,12 +936,18 @@
 	return count;
 }
 
+static struct led_classdev applesmc_led = {
+	.name			= "smc:case-led",
+	.default_trigger	= "ide-disk",
+	.brightness_set		= applesmc_led_brightness_set,
+};
+
 static struct led_classdev applesmc_backlight = {
-	.name			= "smc::kbd_backlight",
+	.name			= "smc:kbd_backlight",
 	.default_trigger	= "nand-disk",
-	.brightness_set		= applesmc_brightness_set,
+	.brightness_set		= applesmc_backlight_brightness_set,
 };
-
+  
 static DEVICE_ATTR(name, 0444, applesmc_name_show, NULL);
 
 static DEVICE_ATTR(position, 0444, applesmc_position_show, NULL);
@@ -1349,15 +1384,28 @@
 			goto out_temperature;
 	}
 
+        /* Create the workqueue */
+        applesmc_led_wq = create_singlethread_workqueue("applesmc-led");
+        if (!applesmc_led_wq) {
+                ret = -ENOMEM;
+                goto out_accelerometer;
+        }
+
+        /* register as a led device */
+        ret = led_classdev_register(&pdev->dev, &applesmc_led);
+        if (ret < 0)
+                goto out_led_wq;
+
+
 	if (applesmc_light) {
 		/* Add light sensor file */
 		ret = sysfs_create_file(&pdev->dev.kobj, &dev_attr_light.attr);
 		if (ret)
-			goto out_accelerometer;
+			goto out_led_ledclass;
 
 		/* Create the workqueue */
-		applesmc_led_wq = create_singlethread_workqueue("applesmc-led");
-		if (!applesmc_led_wq) {
+		applesmc_backlight_wq = create_singlethread_workqueue("applesmc-backlight");
+		if (!applesmc_backlight_wq) {
 			ret = -ENOMEM;
 			goto out_light_sysfs;
 		}
@@ -1383,10 +1431,14 @@
 		led_classdev_unregister(&applesmc_backlight);
 out_light_wq:
 	if (applesmc_light)
-		destroy_workqueue(applesmc_led_wq);
+		destroy_workqueue(applesmc_backlight_wq);
 out_light_sysfs:
 	if (applesmc_light)
 		sysfs_remove_file(&pdev->dev.kobj, &dev_attr_light.attr);
+out_led_ledclass:
+        led_classdev_unregister(&applesmc_led);
+out_led_wq:
+        destroy_workqueue(applesmc_led_wq);
 out_accelerometer:
 	if (applesmc_accelerometer)
 		applesmc_release_accelerometer();
--- linux-2.6.29/drivers/scsi/sd.c.vanilla	2009-03-26 16:17:02.000000000 +0100
+++ linux-2.6.29/drivers/scsi/sd.c	2009-03-26 16:17:08.000000000 +0100
@@ -48,6 +48,7 @@
 #include <linux/delay.h>
 #include <linux/mutex.h>
 #include <linux/string_helpers.h>
+#include <linux/leds.h>
 #include <linux/async.h>
 #include <asm/uaccess.h>

@@ -1021,6 +1022,8 @@
 	int sense_valid = 0;
 	int sense_deferred = 0;
 
+	ledtrig_ide_activity();
+
 	if (result) {
 		sense_valid = scsi_command_normalize_sense(SCpnt, &sshdr);
 		if (sense_valid)
