# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../linux26/mactel.patch
# Copyright (C) 2007 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

Apple IR patch.

From: James McKenzie <macmini@madingley.org>


---

 drivers/input/misc/Kconfig   |    5 +
 drivers/input/misc/Makefile  |    1 
 drivers/input/misc/appleir.c |  379 ++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 385 insertions(+), 0 deletions(-)

diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index 88e2907..d2d629a 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -113,6 +113,10 @@ config INPUT_ATI_REMOTE2
 	  To compile this driver as a module, choose M here: the module will be
 	  called ati_remote2.
 
+config USB_APPLEIR
+	tristate "Apple Mac Mini USB IR receiver (built in)"
+	depends on USB && INPUT
+
 config INPUT_KEYSPAN_REMOTE
 	tristate "Keyspan DMR USB remote control (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
@@ -179,3 +183,4 @@ config HP_SDC_RTC
 	  of the HP SDC controller.
 
 endif
+ 	
diff --git a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
index 3585b50..f73f139 100644
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -13,6 +13,7 @@ obj-$(CONFIG_INPUT_WISTRON_BTNS)	+= wistron_btns.o
 obj-$(CONFIG_INPUT_ATLAS_BTNS)		+= atlas_btns.o
 obj-$(CONFIG_INPUT_ATI_REMOTE)		+= ati_remote.o
 obj-$(CONFIG_INPUT_ATI_REMOTE2)		+= ati_remote2.o
+obj-$(CONFIG_USB_APPLEIR)		+= appleir.o
 obj-$(CONFIG_INPUT_KEYSPAN_REMOTE)	+= keyspan_remote.o
 obj-$(CONFIG_INPUT_POWERMATE)		+= powermate.o
 obj-$(CONFIG_INPUT_YEALINK)		+= yealink.o
diff --git a/drivers/input/misc/appleir.c b/drivers/input/misc/appleir.c
new file mode 100644
index 0000000..3ff46fc
--- /dev/null
+++ b/drivers/input/misc/appleir.c
@@ -0,0 +1,379 @@
+/*
+ * drivers/usb/input/appleir.c - driver for Apple Intel-based Macs IR Receiver
+ *
+ * Copyright (C) 2006 James McKenzie <macmini@madingley.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License v2 as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/usb.h>
+#include <linux/usb/input.h>
+#include <linux/mutex.h>
+#include <asm/unaligned.h>
+#include <asm/byteorder.h>
+
+#define DRIVER_VERSION "v1.2"
+#define DRIVER_AUTHOR "James McKenzie"
+#define DRIVER_DESC "USB Apple MacIntel IR Receiver driver"
+#define DRIVER_LICENSE "GPL"
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE(DRIVER_LICENSE);
+
+#define USB_VENDOR_ID_APPLE	0x05ac
+#define USB_DEVICE_ID_APPLE_IR  0x8240
+
+#define URB_SIZE 32
+
+#define MAX_KEYS 8
+#define MAX_KEYS_MASK (MAX_KEYS - 1)
+
+static int debug = 1;
+
+struct appleir {
+	struct input_dev *dev;
+	uint8_t *data;
+	dma_addr_t dma_buf;
+	struct usb_device *usbdev;
+	struct urb *urb;
+	struct timer_list key_up_timer;
+	int current_key;
+	char phys[32];
+};
+
+
+static struct usb_device_id appleir_ids[] = {
+	{
+		USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IR),
+		.driver_info = 0
+	},
+	{}
+};
+
+MODULE_DEVICE_TABLE(usb, appleir_ids);
+
+/*
+ * Devices report the following, where XX depends on the remote and/or the
+ * receiver (at least 2a, 83, ca, ee have been reported as possible values, it
+ * looks like it is remote control dependent).
+ * The fifth byte's LSB also depends on the hardware.
+ * 25 87 ee XX 0a/0b  	+
+ * 25 87 ee XX 0c/0d  	-
+ * 25 87 ee XX 09/08	<<
+ * 25 87 ee XX 06/07	>>
+ * 25 87 ee XX 05/04	>"
+ * 25 87 ee 83 03/02	menu
+ * 26 00 00 00 00	for key repeat
+ *
+ * Thomas Glanzmann also observes the following event sometimes sent after a key
+ * is released, which I interpret as a flat battery message:
+ * 25 87 e0 ca 06	flat battery
+ */
+
+static int keymap[MAX_KEYS] = {
+	KEY_RESERVED, KEY_MENU,
+	KEY_PLAYPAUSE, KEY_NEXTSONG,
+	KEY_PREVIOUSSONG, KEY_VOLUMEUP,
+	KEY_VOLUMEDOWN, KEY_RESERVED
+};
+
+static void dump_packet(struct appleir *appleir, char *msg,
+							uint8_t *data, int len)
+{
+	int i;
+
+	printk(KERN_ERR "appleir: %s (%d bytes)", msg, len);
+
+	for (i = 0; i < len; ++i) {
+		printk(" %02x", data[i]);
+	}
+
+	printk("\n");
+}
+
+
+static void key_up(struct appleir *appleir, int key)
+{
+	if (debug)
+		printk (KERN_DEBUG "key %d up\n", key);
+
+	input_report_key(appleir->dev, key, 0);
+	input_sync(appleir->dev);
+}
+
+static void key_down(struct appleir *appleir, int key)
+{
+	if (debug)
+		printk (KERN_DEBUG "key %d down\n", key);
+
+	input_report_key(appleir->dev, key, 1);
+	input_sync(appleir->dev);
+}
+
+static void battery_flat(struct appleir *appleir)
+{
+	printk(KERN_WARNING "appleir: possible flat battery?\n");
+}
+
+static void key_up_tick(unsigned long data)
+{
+	struct appleir *apple_ir = (struct appleir *)data;
+
+	if (apple_ir->current_key) {
+		key_up(apple_ir, apple_ir->current_key);
+		apple_ir->current_key = 0;
+	}
+}
+
+static void parse_data(struct appleir *apple_ir, uint8_t *data, int len)
+{
+	static const uint8_t keydown[] = { 0x25, 0x87, 0xee };
+	static const uint8_t keyrepeat[] = { 0x26, 0x00, 0x00, 0x00, 0x00 };
+	static const uint8_t flatbattery[] = { 0x25, 0x87, 0xe0 };
+
+	if (debug)
+		dump_packet(apple_ir, "received", data, len);
+
+	if (len != 5)
+		return;
+
+	if (!memcmp(data, keydown, sizeof(keydown))) {
+		/*
+		 * If we already have a key down, take it up before marking
+		 * this one down.
+		 */
+		if (apple_ir->current_key)
+			key_up(apple_ir, apple_ir->current_key);
+		apple_ir->current_key = keymap[(data[4] >> 1) & MAX_KEYS_MASK];
+
+		key_down(apple_ir, apple_ir->current_key);
+
+		/*
+		 * Remote doesn't do key up, either pull them up, in the test
+		 * above, or here set a timer which pulls them up after 1/8 s
+		 */
+		mod_timer(&apple_ir->key_up_timer, jiffies + HZ / 8);
+
+		return;
+	}
+
+	if (!memcmp(data, keyrepeat, sizeof(keyrepeat))) {
+		key_down(apple_ir, apple_ir->current_key);
+
+		/*
+		 * Remote doesn't do key up, either pull them up, in the test
+		 * above, or here set a timer which pulls them up after 1/8 s
+		 */
+		mod_timer(&apple_ir->key_up_timer, jiffies + HZ / 8);
+		return;
+	}
+
+	if (!memcmp(data, flatbattery, sizeof(flatbattery))) {
+		battery_flat(apple_ir);
+		/* Fall through */
+	}
+
+	dump_packet(apple_ir, "unknown packet", data, len);
+}
+
+static void appleir_urb(struct urb *urb)
+{
+	struct appleir *appleir = urb->context;
+	int retval;
+
+	switch (urb->status) {
+	case 0:
+		parse_data(appleir, urb->transfer_buffer, urb->actual_length);
+		break;
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+		/* this urb is terminated, clean up */
+		dbg("%s - urb shutting down with status: %d",
+						__FUNCTION__, urb->status);
+		return;
+	default:
+		dbg("%s - nonzero urb status received: %d",
+						__FUNCTION__, urb->status);
+	}
+
+	retval = usb_submit_urb(urb, GFP_ATOMIC);
+	if (retval)
+		err("%s - usb_submit_urb failed with result %d",
+						__FUNCTION__, retval);
+}
+
+
+static int appleir_open(struct input_dev *dev)
+{
+	struct appleir *appleir = dev->private;
+
+	if (usb_submit_urb(appleir->urb, GFP_KERNEL))
+		return -EIO;
+
+	return 0;
+}
+
+static void appleir_close(struct input_dev *dev)
+{
+	struct appleir *appleir = dev->private;
+	usb_kill_urb(appleir->urb);
+	del_timer_sync(&appleir->key_up_timer);
+}
+
+static int appleir_probe(struct usb_interface *intf,
+						const struct usb_device_id *id)
+{
+	struct usb_device *dev = interface_to_usbdev(intf);
+	struct usb_endpoint_descriptor *endpoint;
+	struct appleir *appleir = NULL;
+	struct input_dev *input_dev;
+	int i;
+	int ret = -ENOMEM;
+
+	appleir = kzalloc(sizeof(struct appleir), GFP_KERNEL);
+	if (!appleir)
+		goto fail;
+
+	memset(appleir, 0, sizeof(struct appleir));
+
+	appleir->data =
+	    usb_buffer_alloc(dev, URB_SIZE, GFP_KERNEL, &appleir->dma_buf);
+	if (!appleir->data)
+		goto fail_appleir;
+
+	appleir->urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!appleir->urb)
+		goto fail_buffer;
+
+	appleir->usbdev = dev;
+
+	input_dev = input_allocate_device();
+	if (!input_dev)
+		goto fail_urb;
+
+	appleir->dev = input_dev;
+
+	if (usb_make_path(dev, appleir->phys, sizeof(appleir->phys)) < 0)
+		goto fail_input_device;
+
+	strlcpy(appleir->phys, "/input0", sizeof(appleir->phys));
+
+	input_dev->name = "Apple MacIntel infrared remote control driver";
+	input_dev->phys = appleir->phys;
+	usb_to_input_id(dev, &input_dev->id);
+	input_dev->cdev.dev = &intf->dev;
+	input_dev->private = appleir;
+
+	input_dev->evbit[0] = BIT(EV_KEY) | BIT(EV_REP);
+	input_dev->ledbit[0] = 0;
+
+	for (i = 0; i < MAX_KEYS; i++) {
+		set_bit(keymap[i], input_dev->keybit);
+	}
+
+	clear_bit(0, input_dev->keybit);
+
+	input_dev->open = appleir_open;
+	input_dev->close = appleir_close;
+
+	endpoint = &intf->cur_altsetting->endpoint[0].desc;
+
+	usb_fill_int_urb(appleir->urb, dev,
+				usb_rcvintpipe(dev, endpoint->bEndpointAddress),
+				appleir->data, 8,
+				appleir_urb, appleir, endpoint->bInterval);
+
+	appleir->urb->transfer_dma = appleir->dma_buf;
+	appleir->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+
+	usb_set_intfdata(intf, appleir);
+
+	init_timer(&appleir->key_up_timer);
+
+	appleir->key_up_timer.function = key_up_tick;
+	appleir->key_up_timer.data = (unsigned long) appleir;
+
+	ret = input_register_device(appleir->dev);
+	if (ret < 0)
+		goto fail_timer;
+
+	return 0;
+
+fail_timer:
+	del_timer_sync(&appleir->key_up_timer);
+
+fail_input_device:
+	input_free_device(appleir->dev);
+
+fail_urb:
+	usb_free_urb(appleir->urb);
+
+fail_buffer:
+	usb_buffer_free(dev, URB_SIZE, appleir->data, appleir->dma_buf);
+
+fail_appleir:
+	kfree(appleir);
+
+fail:
+	return ret;
+}
+
+static void appleir_disconnect(struct usb_interface *intf)
+{
+	struct appleir *appleir = usb_get_intfdata(intf);
+
+	usb_set_intfdata(intf, NULL);
+	if (appleir) {
+		input_unregister_device(appleir->dev);
+		del_timer_sync(&appleir->key_up_timer);
+		usb_kill_urb(appleir->urb);
+		usb_free_urb(appleir->urb);
+		usb_buffer_free(interface_to_usbdev(intf), URB_SIZE,
+					appleir->data, appleir->dma_buf);
+		kfree(appleir);
+	}
+}
+
+static struct usb_driver appleir_driver = {
+	.name = "appleir",
+	.probe = appleir_probe,
+	.disconnect = appleir_disconnect,
+	.id_table = appleir_ids,
+};
+
+static int __init appleir_init(void)
+{
+	int retval;
+	retval = usb_register(&appleir_driver);
+	if (retval)
+		goto out;
+	info(DRIVER_VERSION ":" DRIVER_DESC);
+out:
+	return retval;
+}
+
+static void __exit appleir_exit(void)
+{
+	usb_deregister(&appleir_driver);
+}
+
+module_init(appleir_init);
+module_exit(appleir_exit);
