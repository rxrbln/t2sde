# --- ROCK-COPYRIGHT-NOTE-BEGIN ---
# 
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# Please add additional copyright information _after_ the line containing
# the ROCK-COPYRIGHT-NOTE-END tag. Otherwise it might get removed by
# the ./scripts/Create-CopyPatch script. Do not edit this copyright text!
# 
# ROCK Linux: rock-src/package/base/bash/bash205b-004.patch
# ROCK Linux is Copyright (C) 1998 - 2003 Clifford Wolf
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version. A copy of the GNU General Public
# License can be found at Documentation/COPYING.
# 
# Many people helped and are helping developing ROCK Linux. Please
# have a look at http://www.rocklinux.org/ and the Documentation/TEAM
# file for details.
# 
# --- ROCK-COPYRIGHT-NOTE-END ---

Official patches from ftp://ftp.gnu.org/pub/gnu/bash/bash-2.05b-patches/.


			     BASH PATCH REPORT
			     =================

Bash-Release: 2.05b
Patch-ID: bash205b-001

Bug-Reported-by:    taviso@sdf.lonestar.org
Bug-Reference-ID:   <200208021107.g72B723d021352@darkstar.example.net>
Bug-Reference-URL:  http://mail.gnu.org/pipermail/bug-bash/2002-August/004980.html

Bug-Description:

Bash goes into an infinite loop and eventually crashes with a SIGSEGV
when some keys on the numeric keypad are pressed, possibly in combination
with the shift key.

Patch:

*** ./lib/readline/bind.c	Thu Jan 24 11:15:52 2002
--- ./lib/readline/bind.c	Wed Jul 31 09:11:18 2002
***************
*** 312,316 ****
  	     and the function bound  to `a' to be executed when the user
  	     types `abx', leaving `bx' in the input queue. */
! 	  if (k.function /* && k.type == ISFUNC */)
  	    {
  	      map[ANYOTHERKEY] = k;
--- 312,316 ----
  	     and the function bound  to `a' to be executed when the user
  	     types `abx', leaving `bx' in the input queue. */
! 	  if (k.function && ((k.type == ISFUNC && k.function != rl_do_lowercase_version) || k.type == ISMACR))
  	    {
  	      map[ANYOTHERKEY] = k;


			     BASH PATCH REPORT
			     =================

Bash-Release: 2.05b
Patch-ID: bash205b-002

Bug-Reported-by:  rwhron@earthlink.net
Bug-Reference-ID: <20020724000454.GA15210@rushmore> (bug-bash)
Bug-Reference-URL: http://mail.gnu.org/pipermail/bug-bash/2002-July/004856.html

Bug-Description:

Repeating an edit in vi-mode with `.' does not work.

Patch:

*** ./lib/readline/readline.c	Wed Mar 13 17:10:46 2002
--- ./lib/readline/readline.c	Tue Jul 30 17:46:44 2002
***************
*** 685,688 ****
--- 685,689 ----
  #if defined (VI_MODE)
    if (rl_editing_mode == vi_mode && _rl_keymap == vi_movement_keymap &&
+       key != ANYOTHERKEY &&
        _rl_vi_textmod_command (key))
      _rl_vi_set_last (key, rl_numeric_arg, rl_arg_sign);



			     BASH PATCH REPORT
			     =================

Bash-Release: 2.05b
Patch-ID: bash205b-003

Bug-Reported-by:   jan.q.bruun-andersen@posten.se
Bug-Reference-ID:  <BE156C6450189B4ABAF7381F0AD4724A0165674F@002exmbs002.ad.posten.se>
Bug-Reference-URL: http://mail.gnu.org/pipermail/bug-bash/2002-July/004789.html

Bug-Description:

In certain cases, Bash appends a space instead of a slash to a directory
name relative to the current directory when performing command name
completion.  This affects partial completion of intermediate directory
names.

Patch:

*** ./bashline.c	Tue May  7 15:52:42 2002
--- ./bashline.c	Sat Aug  3 11:40:16 2002
***************
*** 1045,1049 ****
--- 1045,1052 ----
        else
  	{
+ #define CMD_IS_DIR(x)	(absolute_pathname(x) == 0 && *(x) != '~' && test_for_directory (x))
+ 
  	  matches = rl_completion_matches (text, command_word_completion_function);
+ 
  	  /* If we are attempting command completion and nothing matches, we
  	     do not want readline to perform filename completion for us.  We
***************
*** 1053,1057 ****
  	  if (matches == (char **)NULL)
  	    rl_ignore_some_completions_function = bash_ignore_filenames;
! 	  else if (matches[1] == 0 && *matches[0] != '/')
  	    /* Turn off rl_filename_completion_desired so readline doesn't
  	       append a slash if there is a directory with the same name
--- 1056,1060 ----
  	  if (matches == (char **)NULL)
  	    rl_ignore_some_completions_function = bash_ignore_filenames;
! 	  else if (matches[1] == 0 && CMD_IS_DIR(matches[0]))
  	    /* Turn off rl_filename_completion_desired so readline doesn't
  	       append a slash if there is a directory with the same name
***************
*** 1062,1066 ****
  	       conflict. */
  	    rl_filename_completion_desired = 0;
! 	  else if (matches[0] && matches[1] && STREQ (matches[0], matches[1]) && *matches[0] != '/')
  	    /* There are multiple instances of the same match (duplicate
  	       completions haven't yet been removed).  In this case, all of
--- 1065,1069 ----
  	       conflict. */
  	    rl_filename_completion_desired = 0;
! 	  else if (matches[0] && matches[1] && STREQ (matches[0], matches[1]) && CMD_IS_DIR (matches[0]))
  	    /* There are multiple instances of the same match (duplicate
  	       completions haven't yet been removed).  In this case, all of


			     BASH PATCH REPORT
			     =================

Bash-Release: 2.05b
Patch-ID: bash205b-004

Bug-Reported-by:   c.f.a.johnson@rogers.com
Bug-Reference-ID:  <aji8sb$1aa9bi$2@ID-136730.news.dfncis.de>
Bug-Reference-URL: http://mail.gnu.org/pipermail/bug-bash/2002-August/005074.html

Bug-Description:

A bug in the bash variable expansion code causes leading blanks in a
variable's value to be ignored when computing its length.

Patch:

*** ./subst.c	Mon Jun 24 07:59:45 2002
--- ./subst.c	Sat Aug 17 17:28:46 2002
***************
*** 1639,1647 ****
  /* This performs word splitting and quoted null character removal on
     STRING. */
! #if 0
! #define issep(c)	((separators)[1] ? (member ((c), separators)) : (c) == (separators)[0])
! #else
! #define issep(c)	((separators)[1] ? isifs(c) : (c) == (separators)[0])
! #endif
  
  WORD_LIST *
--- 1639,1646 ----
  /* This performs word splitting and quoted null character removal on
     STRING. */
! #define issep(c) \
! 	(((separators)[0]) ? ((separators)[1] ? isifs(c) \
! 					      : (c) == (separators)[0]) \
! 			   : 0)
  
  WORD_LIST *


			     BASH PATCH REPORT
			     =================

Bash-Release: 2.05b
Patch-ID: bash205b-005

Bug-Reported-by:	Jim Meyering <jim@meyering.net>
Bug-Reference-ID:	<87bs6v8iib.fsf@pixie.eng.ascend.com>
Bug-Reference-URL:	http://mail.gnu.org/archive/html/bug-bash/2002-09/msg00047.html

Bug-Description:

When in a locale with multibyte characters, the readline display updater
will occasionally cause a segmentation fault when attempting to compute
the length of the first multibyte character on the line.

Patch:

*** ./lib/readline/mbutil.c	Tue Jun  4 11:54:29 2002
--- ./lib/readline/mbutil.c	Mon Aug  5 11:20:39 2002
***************
*** 206,210 ****
      {
        /* shorted to compose multibyte char */
!       memset (ps, 0, sizeof(mbstate_t));
        return -2;
      }
--- 206,211 ----
      {
        /* shorted to compose multibyte char */
!       if (ps)
! 	memset (ps, 0, sizeof(mbstate_t));
        return -2;
      }
***************
*** 213,217 ****
        /* invalid to compose multibyte char */
        /* initialize the conversion state */
!       memset (ps, 0, sizeof(mbstate_t));
        return -1;
      }
--- 214,219 ----
        /* invalid to compose multibyte char */
        /* initialize the conversion state */
!       if (ps)
! 	memset (ps, 0, sizeof(mbstate_t));
        return -1;
      }
***************
*** 226,232 ****
  int
  _rl_compare_chars (buf1, pos1, ps1, buf2, pos2, ps2)
!      char *buf1, *buf2;
!      mbstate_t *ps1, *ps2;
!      int pos1, pos2;
  {
    int i, w1, w2;
--- 228,237 ----
  int
  _rl_compare_chars (buf1, pos1, ps1, buf2, pos2, ps2)
!      char *buf1;
!      int pos1;
!      mbstate_t *ps1;
!      char *buf2;
!      int pos2;
!      mbstate_t *ps2;
  {
    int i, w1, w2;
***************
*** 277,282 ****
  	  /* clear the state of the byte sequence, because
  	     in this case effect of mbstate is undefined  */
! 	  memset (ps, 0, sizeof (mbstate_t));
  	}
        else
  	pos += tmp;
--- 282,290 ----
  	  /* clear the state of the byte sequence, because
  	     in this case effect of mbstate is undefined  */
! 	  if (ps)
! 	    memset (ps, 0, sizeof (mbstate_t));
  	}
+       else if (tmp == 0)
+ 	pos++;
        else
  	pos += tmp;
			     BASH PATCH REPORT
			     =================

Bash-Release: 2.05b
Patch-ID: bash205b-006

Bug-Reported-by:	clowenst@ucsd.edu
Bug-Reference-ID:	<156388ec.0212021151.51a48df1@posting.google.com>
Bug-Reference-URL:	

Bug-Description:

When running in a locale with multibyte characters, the readline display
updater will use carriage returns when drawing the line, overwriting any
partial output already on the screen and not terminated by a newline.

Patch:

*** ./lib/readline/display.c	Tue Jun  4 10:54:47 2002
--- ./lib/readline/display.c	Fri Sep 13 16:22:57 2002
***************
*** 71,75 ****
  
  #if defined (HANDLE_MULTIBYTE)
! static int _rl_col_width PARAMS((char *, int, int));
  static int *_rl_wrapped_line;
  #else
--- 71,75 ----
  
  #if defined (HANDLE_MULTIBYTE)
! static int _rl_col_width PARAMS((const char *, int, int));
  static int *_rl_wrapped_line;
  #else
***************
*** 1349,1355 ****
  	      _rl_output_some_chars (nfd + lendiff, temp - lendiff);
  #if 0
- 	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-lendiff) - col_lendiff;
- #else
  	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-col_lendiff);
  #endif
  	    }
--- 1349,1355 ----
  	      _rl_output_some_chars (nfd + lendiff, temp - lendiff);
  #if 0
  	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-col_lendiff);
+ #else
+ 	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-lendiff);
  #endif
  	    }
***************
*** 1511,1516 ****
    /* If we have multibyte characters, NEW is indexed by the buffer point in
       a multibyte string, but _rl_last_c_pos is the display position.  In
!      this case, NEW's display position is not obvious. */
!   if ((MB_CUR_MAX == 1 || rl_byte_oriented ) && _rl_last_c_pos == new) return;
  #else
    if (_rl_last_c_pos == new) return;
--- 1511,1523 ----
    /* If we have multibyte characters, NEW is indexed by the buffer point in
       a multibyte string, but _rl_last_c_pos is the display position.  In
!      this case, NEW's display position is not obvious and must be
!      calculated. */
!   if (MB_CUR_MAX == 1 || rl_byte_oriented)
!     {
!       if (_rl_last_c_pos == new)
! 	return;
!     }
!   else if (_rl_last_c_pos == _rl_col_width (data, 0, new))
!     return;
  #else
    if (_rl_last_c_pos == new) return;
***************
*** 1595,1603 ****
      {
        if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
! 	{
! 	  tputs (_rl_term_cr, 1, _rl_output_character_function);
! 	  for (i = 0; i < new; i++)
! 	    putc (data[i], rl_outstream);
! 	}
        else
  	_rl_backspace (_rl_last_c_pos - new);
--- 1602,1606 ----
      {
        if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
! 	_rl_backspace (_rl_last_c_pos - _rl_col_width (data, 0, new));
        else
  	_rl_backspace (_rl_last_c_pos - new);
***************
*** 2118,2122 ****
  static int
  _rl_col_width (str, start, end)
!      char *str;
       int start, end;
  {
--- 2121,2125 ----
  static int
  _rl_col_width (str, start, end)
!      const char *str;
       int start, end;
  {
***************
*** 2194,2196 ****
  }
  #endif /* HANDLE_MULTIBYTE */
- 	  
--- 2197,2198 ----
			     BASH PATCH REPORT
			     =================

Bash-Release: 2.05b
Patch-ID:  bash205b-007

Bug-Reported-by:	dman@dman.ddts.net
Bug-Reference-ID:	<15893.26358.129589.503364@gargle.gargle.HOWL>
Bug-Reference-URL:	http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=175127

Bug-Description:

Using the vi editing mode's case-changing commands in a locale with
multibyte characters will cause garbage characters to be inserted into
the editing buffer.

Patch:

*** ./lib/readline/vi_mode.c	Thu May 23 13:27:58 2002
--- ./lib/readline/vi_mode.c	Tue Feb  4 15:11:07 2003
***************
*** 681,685 ****
  {
    wchar_t wc;
!   char mb[MB_LEN_MAX];
    mbstate_t ps;
  
--- 681,686 ----
  {
    wchar_t wc;
!   char mb[MB_LEN_MAX+1];
!   int mblen;
    mbstate_t ps;
  
***************
*** 704,708 ****
        if (wc)
  	{
! 	  wctomb (mb, wc);
  	  rl_begin_undo_group ();
  	  rl_delete (1, 0);
--- 705,711 ----
        if (wc)
  	{
! 	  mblen = wctomb (mb, wc);
! 	  if (mblen >= 0)
! 	    mb[mblen] = '\0';
  	  rl_begin_undo_group ();
  	  rl_delete (1, 0);
