# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../uclibc/cxa_atexit.patch
# Copyright (C) 2004 - 2005 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

Author: Stephen Warren
http://www.uclibc.org/lists/uclibc/2005-August/012448.html

Index: libc/stdlib/atexit.c
===================================================================
--- ./libc/stdlib/atexit.c	(revision 11280)
+++ ./libc/stdlib/atexit.c	(working copy)
@@ -32,6 +32,9 @@
  * August 2002    Erik Andersen
  *   Added locking so atexit and friends can be thread safe
  *
+ * August 2005    Stephen Warren
+ *   Added __cxa_atexit and __cxa_finalize support
+ *
  */
 
 #define _GNU_SOURCE
@@ -39,8 +42,8 @@
 #include <unistd.h>
 #include <stdlib.h>
 #include <errno.h>
+#include <atomic.h>
 
-
 #ifdef __UCLIBC_HAS_THREADS__
 #include <pthread.h>
 extern pthread_mutex_t mylock;
@@ -54,9 +57,12 @@
 
 typedef void (*aefuncp) (void);         /* atexit function pointer */
 typedef void (*oefuncp) (int, void *);  /* on_exit function pointer */
+typedef void (*cxaefuncp) (void *);     /* __cxa_atexit function pointer */
 typedef enum {
-	ef_atexit,
-	ef_on_exit
+    ef_free,
+    ef_in_use,
+    ef_on_exit,
+    ef_cxa_atexit
 } ef_type; /* exit function types */
 
 /* this is in the L_exit object */
@@ -67,13 +73,21 @@
 extern int __exit_count;
 extern void __exit_handler(int);
 struct exit_function {
-	ef_type type;	/* ef_atexit or ef_on_exit */
+        /*
+         * 'type' should be of type of the 'enum ef_type' above but since we
+         * need this element in an atomic operation we have to use 'long int'.
+         */
+        long int type; /* enum ef_type */
 	union {
-		aefuncp atexit;
-		struct {
-			oefuncp func;
-			void *arg;
-		} on_exit;
+                struct {
+                        oefuncp func;
+                        void *arg;
+                } on_exit;
+                struct {
+                        cxaefuncp func;
+                        void *arg;
+                        void* dso_handle;
+                } cxa_atexit;
 	} funcs;
 };
 #ifdef __UCLIBC_DYNAMIC_ATEXIT__
@@ -81,46 +95,35 @@
 #else
 extern struct exit_function __exit_function_table[__UCLIBC_MAX_ATEXIT];
 #endif
+extern struct exit_function *__new_exitfn (void);
 
+/* this is in the L___cxa_atexit object */
+extern int __cxa_atexit (cxaefuncp, void *arg, void *dso_handle);
+
+
 #ifdef L_atexit
-	/*
+extern void *__dso_handle __attribute__ ((__weak__));
+
+/*
  * register a function to be called at normal program termination
  * (the registered function takes no arguments)
-	 */
+ */
 int atexit(aefuncp func)
 {
-    struct exit_function *efp;
+    /*
+     * glibc casts aefuncp to cxaefuncp.
+     * This seems dodgy, but I guess callling a function with more
+     * parameters than it needs will work everywhere?
+     */
+    return __cxa_atexit((cxaefuncp)func, NULL,
+                        &__dso_handle == NULL ? NULL : __dso_handle);
+}
 
-    LOCK;
-    if (func) {
-#ifdef __UCLIBC_DYNAMIC_ATEXIT__
-	/* If we are out of function table slots, make some more */
-	if (__exit_slots < __exit_count+1) {
-	    efp=realloc(__exit_function_table, 
-					(__exit_slots+20)*sizeof(struct exit_function));
-	    if (efp==NULL) {
-		UNLOCK;
-		__set_errno(ENOMEM);
-		return -1;
-	    }
-		__exit_function_table = efp;
-	    __exit_slots+=20;
-	}
-#else
-	if (__exit_count >= __UCLIBC_MAX_ATEXIT) {
-	    UNLOCK;
-	    __set_errno(ENOMEM);
-	    return -1;
-	}
+/* Hide the symbol so that no definition but the one locally in the
+   executable or DSO is used.  */
+#ifdef HAVE_DOT_HIDDEN
+asm (".hidden\tatexit");
 #endif
-	__exit_cleanup = __exit_handler; /* enable cleanup */
-	efp = &__exit_function_table[__exit_count++];
-	efp->type = ef_atexit;
-	efp->funcs.atexit = func;
-    }
-    UNLOCK;
-    return 0;
-}
 #endif
 
 #ifdef L_on_exit
@@ -133,41 +136,92 @@
 int on_exit(oefuncp func, void *arg)
 {
     struct exit_function *efp;
+    
+    if (func == NULL) {
+        return 0;
+    }
 
-    LOCK;
-    if (func) {
-#ifdef __UCLIBC_DYNAMIC_ATEXIT__
-	/* If we are out of function table slots, make some more */
-	if (__exit_slots < __exit_count+1) {
-	    efp=realloc(__exit_function_table, 
-					(__exit_slots+20)*sizeof(struct exit_function));
-	    if (efp==NULL) {
-		UNLOCK;
-		__set_errno(ENOMEM);
-		return -1;
-	    }
-		__exit_function_table=efp;
-	    __exit_slots+=20;
-	}
-#else
-	if (__exit_count >= __UCLIBC_MAX_ATEXIT) {
-	    UNLOCK;
-	    __set_errno(ENOMEM);
-	    return -1;
-	}
+    efp = __new_exitfn();
+    if (efp == NULL) {
+        return -1;
+    }
+
+    efp->funcs.on_exit.func = func;
+    efp->funcs.on_exit.arg = arg;
+    /* assign last for thread safety, since we're now unlocked */
+    efp->type = ef_on_exit;
+
+    return 0;
+}
 #endif
 
-	__exit_cleanup = __exit_handler; /* enable cleanup */
-	efp = &__exit_function_table[__exit_count++];
-	efp->type = ef_on_exit;
-	efp->funcs.on_exit.func = func;
-	efp->funcs.on_exit.arg = arg;
+#ifdef L___cxa_atexit
+extern int __cxa_atexit (cxaefuncp func, void *arg, void *dso_handle)
+{
+    struct exit_function *efp;
+    
+    if (func == NULL) {
+        return 0;
     }
-    UNLOCK;
+
+    efp = __new_exitfn();
+    if (efp == NULL) {
+        return -1;
+    }
+
+    efp->funcs.cxa_atexit.func = func;
+    efp->funcs.cxa_atexit.arg = arg;
+    efp->funcs.cxa_atexit.dso_handle = dso_handle;
+    /* assign last for thread safety, since we're now unlocked */
+    efp->type = ef_cxa_atexit;
+
     return 0;
 }
 #endif
 
+#ifdef L___cxa_finalize
+/*
+ * If D is non-NULL, call all functions registered with `__cxa_atexit'
+ *  with the same dso handle.  Otherwise, if D is NULL, call all of the
+ *  registered handlers.
+ */
+void __cxa_finalize (void *dso_handle)
+{
+    struct exit_function *efp;
+    int exit_count_snapshot = __exit_count;
+
+    /* In reverse order */
+    while (exit_count_snapshot) {
+        efp = &__exit_function_table[--exit_count_snapshot];
+
+        /*
+         * We check dso_handle match before we verify the type of the union entry.
+         * However, the atomic_exchange will validate that we were really "allowed"
+         * to read dso_handle...
+         */
+        if ((dso_handle == NULL || dso_handle == efp->funcs.cxa_atexit.dso_handle)
+            /* We don't want to run this cleanup more than once. */
+            && !atomic_compare_and_exchange_bool_acq(&efp->type, ef_free, ef_cxa_atexit)
+           ) {
+            /* glibc passes status (0) too, but that's not in the prototype */
+            (*efp->funcs.cxa_atexit.func)(efp->funcs.cxa_atexit.arg);
+        }
+    }
+
+#if 0 /* haven't looked into this yet... */
+    /*
+     * Remove the registered fork handlers. We do not have to
+     * unregister anything if the program is going to terminate anyway.
+     */
+#ifdef UNREGISTER_ATFORK
+    if (d != NULL) {
+        UNREGISTER_ATFORK (d);
+    }
+#endif
+#endif
+}
+#endif
+
 #ifdef L___exit_handler
 int __exit_count = 0; /* Number of registered exit functions */
 #ifdef __UCLIBC_DYNAMIC_ATEXIT__
@@ -177,7 +231,46 @@
 struct exit_function __exit_function_table[__UCLIBC_MAX_ATEXIT];
 #endif
 
+/*
+ * Find and return a new exit_function pointer, for atexit,
+ * onexit and __cxa_atexit to initialize
+ */
+struct exit_function *__new_exitfn(void)
+{
+    struct exit_function *efp;
 
+    LOCK;
+
+#ifdef __UCLIBC_DYNAMIC_ATEXIT__
+    /* If we are out of function table slots, make some more */
+    if (__exit_slots < __exit_count+1) {
+        efp=realloc(__exit_function_table, 
+                    (__exit_slots+20)*sizeof(struct exit_function));
+        if (efp == NULL) {
+            UNLOCK;
+            __set_errno(ENOMEM);
+            return 0;
+        }
+        __exit_function_table = efp;
+        __exit_slots += 20;
+    }
+#else
+    if (__exit_count >= __UCLIBC_MAX_ATEXIT) {
+        UNLOCK;
+        __set_errno(ENOMEM);
+        return 0;
+    }
+#endif
+
+    __exit_cleanup = __exit_handler; /* enable cleanup */
+    efp = &__exit_function_table[__exit_count++];
+    efp->type = ef_in_use;
+
+    UNLOCK;
+
+    return efp;
+}
+
 /*
  * Handle the work of executing the registered exit functions
  * This is called while we are locked, so no additional locking
@@ -196,11 +289,12 @@
 				(efp->funcs.on_exit.func) (status, efp->funcs.on_exit.arg);
 			}
 			break;
-		case ef_atexit:
-			if (efp->funcs.atexit) {
-				(efp->funcs.atexit) ();
-			}
-			break;
+                case ef_cxa_atexit:
+                        if (efp->funcs.cxa_atexit.func) {
+                                /* glibc passes status too, but that's not in the prototype */
+                                (efp->funcs.cxa_atexit.func) (efp->funcs.cxa_atexit.arg);
+                        }
+                        break;
 		}
 	}
 #ifdef __UCLIBC_DYNAMIC_ATEXIT__
Index: libc/stdlib/Makefile
===================================================================
--- ./libc/stdlib/Makefile	(revision 11280)
+++ ./libc/stdlib/Makefile	(working copy)
@@ -79,7 +79,7 @@
 # wcstod wcstof wcstold
 
 MSRC2 = atexit.c
-MOBJ2 = atexit.o on_exit.o __exit_handler.o exit.o
+MOBJ2 = atexit.o on_exit.o __cxa_atexit.o __cxa_finalize.o __exit_handler.o exit.o
 
 CSRC = \
 	abort.c getenv.c mkdtemp.c mktemp.c realpath.c mkstemp.c mkstemp64.c \
