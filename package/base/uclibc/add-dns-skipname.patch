--- uClibc-0.9.27/libc/inet/resolv.c.orig	2005-02-01 11:16:03.000000000 -0800
+++ uClibc-0.9.27/libc/inet/resolv.c	2005-02-01 11:27:30.000000000 -0800
@@ -2543,4 +2543,85 @@
 		len = srcp - src;
 	return (len);
 }
+
+#define NS_TYPE_ELT                     0x40 /* EDNS0 extended label type */
+#define DNS_LABELTYPE_BITSTRING         0x41
+
+int
+__labellen(const u_char *lp)
+{
+        int bitlen;
+        u_char l = *lp;
+
+        if ((l & NS_CMPRSFLGS) == NS_CMPRSFLGS) {
+                /* should be avoided by the caller */
+                return(-1);
+        }
+
+        if ((l & NS_CMPRSFLGS) == NS_TYPE_ELT) {
+                if (l == DNS_LABELTYPE_BITSTRING) {
+                        if ((bitlen = *(lp + 1)) == 0)
+                                bitlen = 256;
+                        return((bitlen + 7 ) / 8 + 1);
+                }
+                return(-1);     /* unknwon ELT */
+        }
+        return(l);
+}
+
+/*
+ * ns_name_skip(ptrptr, eom)
+ *      Advance *ptrptr to skip over the compressed name it points at.
+ * return:
+ *      0 on success, -1 (with errno set) on failure.
+ */
+int
+__ns_name_skip(const u_char **ptrptr, const u_char *eom)
+{
+        const u_char *cp;
+        u_int n;
+        int l;
+
+        cp = *ptrptr;
+        while (cp < eom && (n = *cp++) != 0) {
+                /* Check for indirection. */
+                switch (n & NS_CMPRSFLGS) {
+                case 0:                 /* normal case, n == len */
+                        cp += n;
+                        continue;
+                case NS_TYPE_ELT: /* EDNS0 extended label */
+                        if ((l = __labellen(cp - 1)) < 0) {
+                                __set_errno(EMSGSIZE);
+                                return(-1);
+                        }
+                        cp += l;
+                        continue;
+                case NS_CMPRSFLGS:      /* indirection */
+                        cp++;
+                        break;
+                default:                /* illegal type */
+                        __set_errno(EMSGSIZE);
+                        return (-1);
+                }
+                break;
+        }
+        if (cp > eom) {
+                __set_errno(EMSGSIZE);
+                return (-1);
+        }
+        *ptrptr = cp;
+        return (0);
+}
+
+/*
+ * Skip over a compressed domain name. Return the size or -1.
+ */
+int
+__dn_skipname(const u_char *ptr, const u_char *eom) {
+        const u_char *saveptr = ptr;
+
+        if (__ns_name_skip(&ptr, eom) == -1)
+                return (-1);
+        return (ptr - saveptr);
+}
 #endif /* L_ns_name */
