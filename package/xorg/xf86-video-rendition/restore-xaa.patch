# --- T2-COPYRIGHT-BEGIN ---
# t2/package/*/xf86-video-rendition/restore-xaa.patch
# Copyright (C) 2026 The T2 SDE Project
# SPDX-License-Identifier: GPL-2.0 or patched project license
# --- T2-COPYRIGHT-END ---

diff --git a/configure.ac b/configure.ac
index eeeb126..c0c32b1 100644
--- a/configure.ac
+++ b/configure.ac
@@ -24,14 +24,14 @@
 AC_PREREQ([2.60])
 AC_INIT([xf86-video-rendition],
         [4.2.7],
-        [https://bugs.freedesktop.org/enter_bug.cgi?product=xorg],
+        [https://gitlab.freedesktop.org/xorg/driver/xf86-video-rendition/issues],
         [xf86-video-rendition])
 AC_CONFIG_SRCDIR([Makefile.am])
 AC_CONFIG_HEADERS([config.h])
 AC_CONFIG_AUX_DIR(.)
 
 # Initialize Automake
-AM_INIT_AUTOMAKE([foreign dist-bzip2])
+AM_INIT_AUTOMAKE([foreign dist-xz])
 
 # Require X.Org macros 1.8 or later for MAN_SUBSTS set by XORG_MANPAGE_SECTIONS
 m4_ifndef([XORG_MACROS_VERSION],
@@ -40,8 +40,7 @@ XORG_MACROS_VERSION(1.8)
 XORG_DEFAULT_OPTIONS
 
 # Initialize libtool
-AC_DISABLE_STATIC
-AC_PROG_LIBTOOL
+LT_INIT([disable-static])
 
 AH_TOP([#include "xorg-server.h"])
 
@@ -58,7 +57,7 @@ XORG_DRIVER_CHECK_EXT(RENDER, renderproto)
 XORG_DRIVER_CHECK_EXT(DPMSExtension, xextproto)
 
 # Obtain compiler/linker options for the driver dependencies
-PKG_CHECK_MODULES(XORG, [xorg-server >= 1.0.99.901 xproto fontsproto $REQUIRED_MODULES])
+PKG_CHECK_MODULES(XORG, [xorg-server >= 1.18 xproto fontsproto $REQUIRED_MODULES])
 
 # Checks for libraries.
 SAVE_CPPFLAGS="$CPPFLAGS"
@@ -66,28 +65,8 @@ CPPFLAGS="$CPPFLAGS $XORG_CFLAGS"
 AC_CHECK_DECL(XSERVER_LIBPCIACCESS,
               [XSERVER_LIBPCIACCESS=yes],[XSERVER_LIBPCIACCESS=no],
               [#include "xorg-server.h"])
-AC_CHECK_HEADER(xf1bpp.h,[AC_DEFINE(HAVE_XF1BPP, 1, [Have 1bpp support])],[])
-AC_CHECK_HEADER(xf4bpp.h,[AC_DEFINE(HAVE_XF4BPP, 1, [Have 4bpp support])],[])
 CPPFLAGS="$SAVE_CPPFLAGS"
 
-AC_ARG_ENABLE(xaa,
-              AS_HELP_STRING([--enable-xaa],
-                             [Enable legacy X Acceleration Architecture (XAA) [default=auto]]),
-              [XAA="$enableval"],
-              [XAA=auto])
-if test "x$XAA" != xno; then
-        save_CFLAGS=$CFLAGS
-        save_CPPFLAGS=$CPPFLAGS
-        CFLAGS=$XORG_CFLAGS
-        CPPFLAGS="$XORG_CFLAGS"
-        AC_CHECK_HEADERS([xaa.h], XAA=yes, XAA=no)
-        CFLAGS=$save_CFLAGS
-        CPPFLAGS=$save_CPPFLAGS
-fi
-AC_MSG_CHECKING([whether to include XAA support])
-AM_CONDITIONAL(XAA, test "x$XAA" = xyes)
-AC_MSG_RESULT([$XAA])
-
 if test "x$XSERVER_LIBPCIACCESS" = xyes; then
     PKG_CHECK_MODULES([PCIACCESS], [pciaccess >= 0.8.0])
     XORG_CFLAGS="$XORG_CFLAGS $PCIACCESS_CFLAGS"
diff --git a/man/rendition.man b/man/rendition.man
index afeee91..68a9a8c 100644
--- a/man/rendition.man
+++ b/man/rendition.man
@@ -1,8 +1,8 @@
 .\" shorthand for double quote that works everywhere.
 .ds q \N'34'
-.TH RENDITION __drivermansuffix__ __vendorversion__
+.TH RENDITION __drivermansuffix__ 2009-01-09 __vendorversion__
 .SH NAME
-rendition \- Rendition video driver
+rendition \- Rendition video driver for Xorg
 .SH SYNOPSIS
 .nf
 .B "Section \*qDevice\*q"
@@ -12,28 +12,31 @@ rendition \- Rendition video driver
 .B EndSection
 .fi
 .SH DESCRIPTION
-.B rendition 
-is an __xservername__ driver for Rendition/Micron based video cards.  The driver
-supports following framebuffer depths: 8, 15 (Verite V1000 only), 16
-and 24. Acceleration and multi-head configurations are
-not supported yet, but are work in progress.
+.B rendition
+is an Xorg driver for Rendition/Micron based video cards.
+The driver supports following framebuffer depths:
+8, 15 (Verite V1000 only), 16, and 24.
+Acceleration and multi-head configurations are not supported.
 .SH SUPPORTED HARDWARE
 The
 .B rendition
-driver supports PCI and AGP video cards based on the following Rendition/Micron chips:
+driver supports PCI and AGP video cards based on
+the following Rendition/Micron chips:
 .TP 12
 .B V1000
 Verite V1000 based cards.
 .TP 12
 .B V2100
-Verite V2100 based cards. Diamond Stealth II S220 is the only known such card.
+Verite V2100 based cards.
+Diamond Stealth II S220 is the only known such card.
 .TP 12
 .B V2200
 Verite V2200 based cards.
 .SH CONFIGURATION DETAILS
-Please refer to __xconfigfile__(__filemansuffix__) for general configuration
-details.  This section only covers configuration details specific to this
-driver.
+Please refer to
+.BR xorg.conf (__filemansuffix__)
+for general configuration details.
+This section only covers configuration details specific to this driver.
 .PP
 The driver auto-detects the chipset type, but the following
 .B ChipSet
@@ -45,9 +48,9 @@ section, and will override the auto-detection:
 "v1000", "v2x00".
 .RE
 .PP
-The driver will auto-detect the amount of video memory present for all
-chips. If the amount of memory is detected incorrectly, the actual amount
-of video memory should be specified with a
+The driver will auto-detect the amount of video memory present for all chips.
+If the amount of memory is detected incorrectly,
+the actual amount of video memory should be specified with a
 .B VideoRam
 entry in the config file
 .B \*qDevice\*q
@@ -58,54 +61,61 @@ The following driver
 are supported:
 .TP
 .BI "Option \*qSWCursor\*q \*q" boolean \*q
-Disables use of the hardware cursor. Default: use HW-cursor.
+Disables use of the hardware cursor.
+Default: use HW-cursor.
 .TP
 .BI "Option \*qOverclockMem\*q \*q" boolean \*q
 Increases the Mem/Sys clock to 125MHz/60MHz from standard 110MHz/50MHz.
 Default: Not overclocked.
 .TP
 .BI "Option \*qDacSpeed\*q \*q" MHz \*q
-Run the memory at a higher clock. Useful on some cards with display glitches
-at higher resolutions. But adds the risk to damage the hardware. Use with 
-caution.
+Run the memory at a higher clock.
+Useful on some cards with display glitches at higher resolutions,
+but adds risk to damage the hardware.
+.B Use with caution.
 .TP
 .BI "Option \*qFramebufferWC\*q \*q" boolean \*q
 If writecombine is disabled in BIOS, and you add this option in configuration
-file, then the driver will try to request writecombined access to the 
-framebuffer. This can drastically increase the performance on unaccelerated
-server. Requires that "MTRR"-support is compiled into the OS-kernel.
+file, then the driver will try to request writecombined access to the
+framebuffer.
+This can drastically increase the performance on unaccelerated server.
+Requires that "MTRR"-support is compiled into the OS-kernel.
 Default: Disabled for V1000, enabled for V2100/V2200.
 .TP
 .BI "Option \*qNoDDC\*q \*q" boolean \*q
-Disable probing of DDC-information from your monitor. This information is not
-used yet and is only there for informational purposes. 
-Safe to disable if you experience problems
-during startup of X-server.
+Disable probing of DDC-information from your monitor.
+This information is not used yet and is only there for informational purposes.
+Safe to disable if you experience problems during startup of X-server.
 Default: Probe DDC.
 .TP
 .BI "Option \*qShadowFB\*q \*q" boolean \*q
 If this option is enabled, the driver will cause the CPU to do each drawing
 operation first into a shadow frame buffer in system virtual memory and then
-copy the result into video memory. If this option is not active, the CPU will
-draw directly into video memory.  Enabling this option is beneficial for those
+copy the result into video memory.
+If this option is not active, the CPU will draw directly into video memory.
+Enabling this option is beneficial for those
 systems where reading from video memory is, on average, slower than the
-corresponding read/modify/write operation in system virtual memory.  This is 
-normally the case for PCI or AGP adapters, and, so, this option is enabled by
-default unless acceleration is enabled.
+corresponding read/modify/write operation in system virtual memory.
+This is normally the case for PCI or AGP adapters,
+and, so, this option is enabled by default unless acceleration is enabled.
 Default: Enabled unless acceleration is used.
 .TP
-.BI "Option \*qRotate\*q \*qCW\*q"
-.TP
-.BI "Option \*qRotate\*q \*qCCW\*q"
-Rotate the display clockwise or counterclockwise.  This mode is unaccelerated.
+.B "Option \*qRotate\*q \*qCW\*q"
+.TQ
+.B "Option \*qRotate\*q \*qCCW\*q"
+Rotate the display clockwise or counterclockwise.
+This mode is unaccelerated.
 Default: no rotation.
-.TP
 .SH "Notes"
 For the moment the driver defaults to not request write-combine for any chipset
-as there has been indications of problems with it. Use
+as there has been indications of problems with it.
+Use
 .B "Option \*qMTRR\*q"
 to let the driver request write-combining of memory access on the video board.
 .SH "SEE ALSO"
-__xservername__(1), __xconfigfile__(__filemansuffix__), Xserver(1), X(__miscmansuffix__)
+.BR Xorg (1),
+.BR xorg.conf (__filemansuffix__),
+.BR Xserver (1),
+.BR X (__miscmansuffix__)
 .SH AUTHORS
 Authors include: Marc Langenbach, Dejan Ilic
diff --git a/src/Makefile.am b/src/Makefile.am
index 0666377..292f3ec 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -23,12 +23,14 @@
 # -avoid-version prevents gratuitous .0.0.0 version numbers on the end
 # _ladir passes a dummy rpath to libtool so the thing will actually link
 # TODO: -nostdlib/-Bstatic/-lgcc platform magic, not installing the .a, etc.
-AM_CFLAGS = @XORG_CFLAGS@ -DMODULEDIR=\"@moduledir@\"
+AM_CFLAGS = $(BASE_CFLAGS) $(XORG_CFLAGS) -DMODULEDIR=\"@moduledir@\"
 rendition_drv_la_LTLIBRARIES = rendition_drv.la
 rendition_drv_la_LDFLAGS = -module -avoid-version
 rendition_drv_ladir = @moduledir@/drivers
 
 rendition_drv_la_SOURCES = \
+         accel.h \
+         accelX.c \
          cmd2d.h \
          commonregs.h \
          compat-api.h \
@@ -63,8 +65,6 @@ dist_driver_DATA = \
 	v20002d.uc
 
 EXTRA_DIST = \
-        accel.h \
-        accelX.c \
 	README.uc \
 	vgafont-std.data \
 	vgafont-vrx.data \
diff --git a/src/accelX.c b/src/accelX.c
index bd237b3..7c85209 100644
--- a/src/accelX.c
+++ b/src/accelX.c
@@ -153,7 +153,7 @@ RENDITIONAccelXAAInit(ScreenPtr pScreen)
     }
 
     /* Here we fill in the XAA callback names */
-    /* Sync is the only compulsary function   */
+    /* Sync is the only compulsory function   */
     pXAAinfo->Sync = RENDITIONSyncV1000;
 
     /* Here are the other functions & flags */
diff --git a/src/compat-api.h b/src/compat-api.h
index e4f03d2..826b968 100644
--- a/src/compat-api.h
+++ b/src/compat-api.h
@@ -28,45 +28,6 @@
 #ifndef COMPAT_API_H
 #define COMPAT_API_H
 
-#ifndef GLYPH_HAS_GLYPH_PICTURE_ACCESSOR
-#define GetGlyphPicture(g, s) GlyphPicture((g))[(s)->myNum]
-#define SetGlyphPicture(g, s, p) GlyphPicture((g))[(s)->myNum] = p
-#endif
-
-#ifndef XF86_HAS_SCRN_CONV
-#define xf86ScreenToScrn(s) xf86Screens[(s)->myNum]
-#define xf86ScrnToScreen(s) screenInfo.screens[(s)->scrnIndex]
-#endif
-
-#ifndef XF86_SCRN_INTERFACE
-
-#define SCRN_ARG_TYPE int
-#define SCRN_INFO_PTR(arg1) ScrnInfoPtr pScreenInfo = xf86Screens[(arg1)]
-
-#define SCREEN_ARG_TYPE int
-#define SCREEN_PTR(arg1) ScreenPtr pScreen = screenInfo.screens[(arg1)]
-
-#define SCREEN_INIT_ARGS_DECL int i, ScreenPtr pScreen, int argc, char **argv
-
-#define BLOCKHANDLER_ARGS_DECL int arg, pointer blockData, pointer pTimeout, pointer pReadmask
-#define BLOCKHANDLER_ARGS arg, blockData, pTimeout, pReadmask
-
-#define CLOSE_SCREEN_ARGS_DECL int scrnIndex, ScreenPtr pScreen
-#define CLOSE_SCREEN_ARGS scrnIndex, pScreen
-
-#define ADJUST_FRAME_ARGS_DECL int arg, int x, int y, int flags
-#define ADJUST_FRAME_ARGS(arg, x, y) (arg)->scrnIndex, x, y, 0
-
-#define SWITCH_MODE_ARGS_DECL int arg, DisplayModePtr mode, int flags
-#define SWITCH_MODE_ARGS(arg, m) (arg)->scrnIndex, m, 0
-
-#define FREE_SCREEN_ARGS_DECL int arg, int flags
-
-#define VT_FUNC_ARGS_DECL int arg, int flags
-#define VT_FUNC_ARGS pScreenInfo->scrnIndex, 0
-
-#define XF86_SCRN_ARG(x) ((x)->scrnIndex)
-#else
 #define SCRN_ARG_TYPE ScrnInfoPtr
 #define SCRN_INFO_PTR(arg1) ScrnInfoPtr pScreenInfo = (arg1)
 
@@ -95,5 +56,3 @@
 #define XF86_SCRN_ARG(x) (x)
 
 #endif
-
-#endif
diff --git a/src/hwcursor.c b/src/hwcursor.c
index 609417a..f52be9c 100644
--- a/src/hwcursor.c
+++ b/src/hwcursor.c
@@ -35,7 +35,7 @@ static void RENDITIONLoadCursorImage(ScrnInfoPtr pScreenInfo, unsigned char* src
 
 
 /*
- * This is top-level initialization funtion
+ * This is top-level initialization function
  */
 void
 RenditionHWCursorPreInit (ScrnInfoPtr pScreenInfo)
diff --git a/src/rendition.c b/src/rendition.c
index 02adecc..3b64559 100644
--- a/src/rendition.c
+++ b/src/rendition.c
@@ -37,6 +37,14 @@
 #include "config.h"
 #endif
 
+/*
+ * Activate acceleration code or not.
+ *
+ *         WARNING BUGGY !!!
+ * Yes, you activate it on your own risk.
+ */
+#define USE_ACCEL 1
+
 /*
  * includes 
  */
@@ -50,6 +58,7 @@
 #include "vtypes.h"
 #include "vboard.h"
 #include "vmodes.h"
+#include "accel.h"
 #include "vramdac.h"
 #include "rendition_shadow.h"
 #include "vbe.h"
@@ -80,7 +89,7 @@
 /*
  * Constants for the (theoretical) maximum width and height that can
  * be used to display data on the CRT.  These were calculated from 
- * the HORZ and VERT macors, respectively, in vmodes.c.
+ * the HORZ and VERT macros, respectively, in vmodes.c.
  */
 static const int MAX_HDISPLAY = 2048;
 static const int MAX_VDISPLAY = 2048;
@@ -88,7 +97,7 @@ static const int MAX_VDISPLAY = 2048;
 /*
  * Constants for the (theoretical) maximum line length of a scan line
  * and scan lines per screen (including overdraw).  These were 
- * calculated from the HORZ and VERT macors, respectively, in vmodes.c.
+ * calculated from the HORZ and VERT macros, respectively, in vmodes.c.
  */
 static const int MAX_HTOTAL   = 2880;
 static const int MAX_VTOTAL   = 2184;
@@ -480,7 +489,7 @@ renditionPreInit(ScrnInfoPtr pScreenInfo, int flags)
     MessageType       From;
     int               videoRam, Rounding, nModes = 0;
     renditionPtr      pRendition;
-    char             *in_string;
+    const char       *in_string;
     vgaHWPtr          pvgaHW;
     
 #ifdef DEBUG
@@ -654,6 +663,7 @@ renditionPreInit(ScrnInfoPtr pScreenInfo, int flags)
     vgaHWSetStdFuncs(pvgaHW);
     vgaHWGetIOBase(pvgaHW);             /* Get VGA I/O base */
 
+    pRendition->board.accel=0;
 #if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 12
     pRendition->board.vgaio_base = pvgaHW->PIOOffset;
 #else
@@ -683,7 +693,7 @@ renditionPreInit(ScrnInfoPtr pScreenInfo, int flags)
             renditionChipsets[
         pRendition->board.chip==V1000_DEVICE ? 0:1].name);
 
-    /* I do not get the IO base addres <ml> */
+    /* I do not get the IO base address <ml> */
     /* XXX Is this still true?  If so, the wrong base is being checked */
     xf86DrvMsg(pScreenInfo->scrnIndex, X_PROBED,
 	       "Rendition %s @ %lx/%lx\n",
@@ -718,7 +728,7 @@ renditionPreInit(ScrnInfoPtr pScreenInfo, int flags)
 
     /* Load the needed symbols */
 
-    pRendition->board.shadowfb=TRUE;
+    pRendition->board.shadowfb=FALSE;
 
     if ((in_string = xf86GetOptValString(pRendition->Options, OPTION_ROTATE))){
 	if(!xf86NameCmp(in_string, "CW")) {
@@ -741,7 +751,7 @@ renditionPreInit(ScrnInfoPtr pScreenInfo, int flags)
 	}
     }
     
-    if (xf86ReturnOptValBool(pRendition->Options, OPTION_SHADOW_FB,1)||
+    if (xf86ReturnOptValBool(pRendition->Options, OPTION_SHADOW_FB,1)||
 	pRendition->board.rotate) {
 	if (!xf86LoadSubModule(pScreenInfo, "shadowfb")) {
 	    xf86DrvMsg(pScreenInfo->scrnIndex, X_WARNING,
@@ -857,6 +867,31 @@ renditionPreInit(ScrnInfoPtr pScreenInfo, int flags)
       xf86DrvMsg(pScreenInfo->scrnIndex, X_CONFIG,
 		 "Software cursor selected\n");
 
+    /* Unmapping delayed until after micrcode loading */
+      /****************************************/
+      /* Reserve memory and load the microcode */
+      /****************************************/
+#if USE_ACCEL
+    if (!xf86ReturnOptValBool(pRendition->Options, OPTION_NOACCEL,0) &&
+	!pRendition->board.shadowfb) {
+	/* Load XAA if needed */
+	if (xf86LoadSubModule(pScreenInfo, "xaa")) {
+	    renditionMapMem(pScreenInfo);
+  	    RENDITIONAccelPreInit (pScreenInfo);
+	    renditionUnmapMem(pScreenInfo);
+	    pRendition->board.accel = TRUE;
+	} else     xf86DrvMsg(pScreenInfo->scrnIndex, X_WARNING,
+			      ("XAA module not found: "
+			       "Skipping acceleration\n"));
+    }
+    else
+      xf86DrvMsg(pScreenInfo->scrnIndex, X_CONFIG,
+		 ("Skipping acceleration on users request\n"));
+#else
+    xf86DrvMsg(pScreenInfo->scrnIndex, X_WARNING,
+	       ("Skipping acceleration\n"));
+#endif
+
 #ifdef DEBUG
     ErrorF("PreInit OK...!!!!\n");
     sleep(2);
@@ -1034,6 +1069,9 @@ renditionCloseScreen(CLOSE_SCREEN_ARGS_DECL)
     if (prenditionPriv->board.hwcursor_used)
 	RenditionHWCursorRelease(pScreenInfo);
 
+    if (prenditionPriv->board.accel)
+	RENDITIONAccelNone(pScreenInfo);
+
     if (pScreenInfo->vtSema)
 	renditionLeaveGraphics(pScreenInfo);
 
@@ -1073,7 +1111,6 @@ renditionScreenInit(SCREEN_INIT_ARGS_DECL)
     VisualPtr visual;
     vgaHWPtr pvgaHW;
     int displayWidth,width,height;
-    int scrnIndex = pScreenInfo->scrnIndex;
 
 #ifdef DEBUG
     ErrorF("RENDITION: renditionScreenInit() called\n");
@@ -1176,6 +1213,10 @@ renditionScreenInit(SCREEN_INIT_ARGS_DECL)
     /* The actual setup of the driver-specific code          */
     /* has to be after fbScreenInit and before cursor init */
     /*********************************************************/
+#if USE_ACCEL
+    if (pRendition->board.accel) 
+	RENDITIONAccelXAAInit (pScreen);
+#endif
 
     /* Initialise cursor functions */
     xf86SetSilkenMouse(pScreen);
@@ -1186,7 +1227,7 @@ renditionScreenInit(SCREEN_INIT_ARGS_DECL)
 	/* Initialise HW cursor */
 	if(!RenditionHWCursorInit(pScreen)){
 	    xf86DrvMsg(pScreenInfo->scrnIndex, X_ERROR,
-		       "Hardware Cursor initalization failed!!\n");
+		       "Hardware Cursor initialization failed!!\n");
 	}
     }
 
diff --git a/src/rendition.h b/src/rendition.h
index 4ef03a7..227a756 100644
--- a/src/rendition.h
+++ b/src/rendition.h
@@ -28,14 +28,6 @@
 /* All drivers using the mi colormap manipulation need this */
 #include "micmap.h"
 
-#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 6
-/* Needed by Resources Access Control (RAC) */
-#include "xf86RAC.h"
-
-/* Several predefined resource lists */
-#include "xf86Resources.h"
-#endif
-
 /* Needed by the Shadow Framebuffer */
 #include "shadowfb.h"
 
@@ -47,10 +39,8 @@
 #include "fb.h"
 
 /* Drivers using the XAA interface ... */
-#ifdef HAVE_XAA_H
 #include "xaa.h"
 #include "xaalocal.h"
-#endif
 #include "xf86fbman.h"
 
 /* HW-cursor definitions */
diff --git a/src/v2kregs.h b/src/v2kregs.h
index 5f6942c..e1124c3 100644
--- a/src/v2kregs.h
+++ b/src/v2kregs.h
@@ -9,7 +9,7 @@
 #define SCRATCH         0x70 /* 16-bit BIOS scratch space */
 
 #define MEMDIAG         0xa4 /* Memory diagnostic register #1 */
-#define CURSORBASE      0xac /* cursor base address bits [23:10] aligne to 1024 byte boundary */
+#define CURSORBASE      0xac /* cursor base address bits [23:10] aligned to 1024 byte boundary */
 
 #define PCLKPLL         0xc0 /* external device 0 */
 #define VINEVENBASE     0xd0 /* video input even field base address */
diff --git a/src/vboard.c b/src/vboard.c
index 622715f..c43dd99 100644
--- a/src/vboard.c
+++ b/src/vboard.c
@@ -63,7 +63,7 @@ verite_initboard(ScrnInfoPtr pScreenInfo)
     verite_write_memory32(vmb, 0x7f8, 0);
     verite_write_memory32(vmb, 0x7fc, 0);
 
-    /* Run the code we just transfered to the boards memory */
+    /* Run the code we just transferred to the boards memory */
     /* ... and start accelerator */
     v1k_flushicache(pScreenInfo);
 
diff --git a/src/vloaduc.c b/src/vloaduc.c
index 5c6aab0..8ef44b1 100644
--- a/src/vloaduc.c
+++ b/src/vloaduc.c
@@ -31,8 +31,13 @@
 #ifdef X_LITTLE_ENDIAN
 
 /* maybe swap word */
-#define SW32(x) lswapl(x)
-#define SW16(x) lswaps(x)
+#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 24
+# define SW32(x) lswapl(x)
+# define SW16(x) lswaps(x)
+#else
+# define SW32(x) bswap_32(x)
+# define SW16(x) bswap_16(x)
+#endif
 #else /* BIG_ENDIAN */
 #define SW32(x) (x)
 #define SW16(x) (x)
diff --git a/src/vramdac.c b/src/vramdac.c
index 21c1df7..da86b29 100644
--- a/src/vramdac.c
+++ b/src/vramdac.c
@@ -18,7 +18,7 @@
 
 #undef DEBUG
 
-/* directly accessable RAMDAC registers */
+/* directly accessible RAMDAC registers */
 #define BT485_WRITE_ADDR        0x00
 #define BT485_RAMDAC_DATA       0x01    
 #define BT485_PIXEL_MASK        0x02
@@ -36,7 +36,7 @@
 #define BT485_CURS_Y_LOW        0x0e
 #define BT485_CURS_Y_HIGH       0x0f
 
-/* indirectly accessable ramdac registers */
+/* indirectly accessible ramdac registers */
 #define BT485_COMMAND_REG_3     0x01
 
 /* bits in command register 0 */
diff --git a/src/vtypes.h b/src/vtypes.h
index b221aa3..c06722a 100644
--- a/src/vtypes.h
+++ b/src/vtypes.h
@@ -131,6 +131,9 @@ struct verite_board_t {
     vu8 *vmem_base;
     Bool init;
 
+    /* */
+    Bool accel;
+
     /* */
     vu32 csucode_base;
     vu32 ucode_base;
@@ -152,8 +155,8 @@ struct verite_board_t {
 
     Bool hwcursor_used;     /* Is HW-cursor used? */
     vu16 hwcursor_vmemsize; /* How much videomem does it use */
-    vu32 hwcursor_membase;  /* videomem adress for V2K-cursor */
-                            /* Has to be on 1024-byte boundry */
+    vu32 hwcursor_membase;  /* videomem address for V2K-cursor */
+                            /* Has to be on 1024-byte boundary */
 
     vu32 fbOffset;          /* Currently busy fb-memory marker */
     Bool overclock_mem;     /* Memory overclock ? */
@@ -185,9 +188,7 @@ typedef struct _renditionRec
     EntityInfoPtr pEnt;                 /* entity information */
     CloseScreenProcPtr CloseScreen;     /* wrap CloseScreen */
     xf86CursorInfoPtr CursorInfoRec;    /* Cursor data */
-#ifdef HAVE_XAA_H
     XAAInfoRecPtr AccelInfoRec;         /* Needed for XAA */
-#endif
     OptionInfoPtr Options;
     RenditionRegRec saveRegs;
 } renditionRec, *renditionPtr;
