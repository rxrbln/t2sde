diff --git a/hw/xfree86/ramdac/BT.c b/hw/xfree86/ramdac/BT.c
new file mode 100644
index 000000000..533344513
--- /dev/null
+++ b/hw/xfree86/ramdac/BT.c
@@ -0,0 +1,167 @@
+/*
+ * Copyright 1998 by Alan Hourihane, Wigan, England.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Alan Hourihane not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Alan Hourihane makes no representations
+ * about the suitability of this software for any purpose.  It is provided
+ * "as is" without express or implied warranty.
+ *
+ * ALAN HOURIHANE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL ALAN HOURIHANE BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authors:  Alan Hourihane, <alanh@fairlite.demon.co.uk>
+ *
+ * BT RAMDAC routines.
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#define INIT_BT_RAMDAC_INFO
+#include "BTPriv.h"
+#include "xf86RamDacPriv.h"
+
+void
+BTramdacRestore(ScrnInfoPtr pScrn, RamDacRecPtr ramdacPtr,
+                RamDacRegRecPtr ramdacReg)
+{
+    int i;
+
+    /* Here we pass a short, so that we can evaluate a mask too */
+    /* So that the mask is the high byte and the data the low byte */
+    /* Just the command/status registers */
+    for (i = 0x06; i < 0x0A; i++)
+        (*ramdacPtr->WriteDAC)
+            (pScrn, i, (ramdacReg->DacRegs[i] & 0xFF00) >> 8,
+             ramdacReg->DacRegs[i]);
+}
+
+void
+BTramdacSave(ScrnInfoPtr pScrn, RamDacRecPtr ramdacPtr,
+             RamDacRegRecPtr ramdacReg)
+{
+    int i;
+
+    (*ramdacPtr->ReadAddress) (pScrn, 0);       /* Start at index 0 */
+    for (i = 0; i < 768; i++)
+        ramdacReg->DAC[i] = (*ramdacPtr->ReadData) (pScrn);
+
+    /* Just the command/status registers */
+    for (i = 0x06; i < 0x0A; i++)
+        ramdacReg->DacRegs[i] = (*ramdacPtr->ReadDAC) (pScrn, i);
+}
+
+RamDacHelperRecPtr
+BTramdacProbe(ScrnInfoPtr pScrn,
+              RamDacSupportedInfoRecPtr ramdacs /*, RamDacRecPtr ramdacPtr */ )
+{
+    RamDacRecPtr ramdacPtr = RAMDACSCRPTR(pScrn);
+    Bool RamDacIsSupported = FALSE;
+    RamDacHelperRecPtr ramdacHelperPtr = NULL;
+    int BTramdac_ID = -1;
+    int i, status, cmd0;
+
+    /* Save COMMAND Register 0 */
+    cmd0 = (*ramdacPtr->ReadDAC) (pScrn, BT_COMMAND_REG_0);
+    /* Ensure were going to access the STATUS Register on next read */
+    (*ramdacPtr->WriteDAC) (pScrn, BT_COMMAND_REG_0, 0x7F, 0x00);
+
+    status = (*ramdacPtr->ReadDAC) (pScrn, BT_STATUS_REG);
+    switch (status) {
+    case 0x40:
+        BTramdac_ID = ATT20C504_RAMDAC;
+        break;
+    case 0xD0:
+        BTramdac_ID = ATT20C505_RAMDAC;
+        break;
+    default:
+        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                   "Unknown BT RAMDAC type (0x%x), assuming BT485\n", status);
+    case 0x80:
+    case 0x90:
+    case 0xA0:
+    case 0xB0:
+    case 0x28:                 /* This is for the DEC TGA - Questionable ? */
+        BTramdac_ID = BT485_RAMDAC;
+        break;
+    }
+
+    /* Restore COMMAND Register 0 */
+    (*ramdacPtr->WriteDAC) (pScrn, BT_COMMAND_REG_0, 0x00, cmd0);
+
+    if (BTramdac_ID == -1) {
+        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                   "Cannot determine BT RAMDAC type, aborting\n");
+        return NULL;
+    }
+    else {
+        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                   "Attached RAMDAC is %s\n",
+                   BTramdacDeviceInfo[BTramdac_ID & 0xFFFF].DeviceName);
+    }
+
+    for (i = 0; ramdacs[i].token != -1; i++) {
+        if (ramdacs[i].token == BTramdac_ID)
+            RamDacIsSupported = TRUE;
+    }
+
+    if (!RamDacIsSupported) {
+        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                   "This BT RAMDAC is NOT supported by this driver, aborting\n");
+        return NULL;
+    }
+
+    ramdacHelperPtr = RamDacHelperCreateInfoRec();
+    switch (BTramdac_ID) {
+    case BT485_RAMDAC:
+        ramdacHelperPtr->SetBpp = BTramdacSetBpp;
+        break;
+    }
+    ramdacPtr->RamDacType = BTramdac_ID;
+    ramdacHelperPtr->RamDacType = BTramdac_ID;
+    ramdacHelperPtr->Save = BTramdacSave;
+    ramdacHelperPtr->Restore = BTramdacRestore;
+
+    return ramdacHelperPtr;
+}
+
+void
+BTramdacSetBpp(ScrnInfoPtr pScrn, RamDacRegRecPtr ramdacReg)
+{
+    /* We need to deal with Direct Colour visuals for 8bpp and other
+     * good stuff for colours */
+    switch (pScrn->bitsPerPixel) {
+    case 32:
+        ramdacReg->DacRegs[BT_COMMAND_REG_1] = 0x10;
+        break;
+    case 24:
+        ramdacReg->DacRegs[BT_COMMAND_REG_1] = 0x10;
+        break;
+    case 16:
+        ramdacReg->DacRegs[BT_COMMAND_REG_1] = 0x38;
+        break;
+    case 15:
+        ramdacReg->DacRegs[BT_COMMAND_REG_1] = 0x30;
+        break;
+    case 8:
+        ramdacReg->DacRegs[BT_COMMAND_REG_1] = 0x40;
+        break;
+    case 4:
+        ramdacReg->DacRegs[BT_COMMAND_REG_1] = 0x60;
+        break;
+    }
+}
diff --git a/hw/xfree86/ramdac/BT.h b/hw/xfree86/ramdac/BT.h
new file mode 100644
index 000000000..6eeaf5db7
--- /dev/null
+++ b/hw/xfree86/ramdac/BT.h
@@ -0,0 +1,37 @@
+
+#include "xf86RamDac.h"
+
+extern _X_EXPORT RamDacHelperRecPtr BTramdacProbe(ScrnInfoPtr pScrn,
+                                                  RamDacSupportedInfoRecPtr
+                                                  ramdacs);
+extern _X_EXPORT void BTramdacSave(ScrnInfoPtr pScrn, RamDacRecPtr RamDacRec,
+                                   RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void BTramdacRestore(ScrnInfoPtr pScrn, RamDacRecPtr RamDacRec,
+                                      RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void BTramdacSetBpp(ScrnInfoPtr pScrn,
+                                     RamDacRegRecPtr RamDacRegRec);
+
+#define ATT20C504_RAMDAC 	(VENDOR_BT << 16) | 0x00
+#define ATT20C505_RAMDAC 	(VENDOR_BT << 16) | 0x01
+#define BT485_RAMDAC		(VENDOR_BT << 16) | 0x02
+
+/*
+ * BT registers
+ */
+
+#define BT_WRITE_ADDR		0x00
+#define BT_RAMDAC_DATA		0x01
+#define BT_PIXEL_MASK		0x02
+#define BT_READ_ADDR		0x03
+#define BT_CURS_WR_ADDR		0x04
+#define BT_CURS_DATA		0x05
+#define BT_COMMAND_REG_0	0x06
+#define BT_CURS_RD_ADDR		0x07
+#define BT_COMMAND_REG_1	0x08
+#define BT_COMMAND_REG_2	0x09
+#define BT_STATUS_REG		0x0A
+#define BT_CURS_RAM_DATA	0x0B
+#define BT_CURS_X_LOW		0x0C
+#define BT_CURS_X_HIGH		0x0D
+#define BT_CURS_Y_LOW		0x0E
+#define BT_CURS_Y_HIGH		0x0F
diff --git a/hw/xfree86/ramdac/BTPriv.h b/hw/xfree86/ramdac/BTPriv.h
new file mode 100644
index 000000000..95f288009
--- /dev/null
+++ b/hw/xfree86/ramdac/BTPriv.h
@@ -0,0 +1,20 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "BT.h"
+
+typedef struct {
+    const char *DeviceName;
+} xf86BTramdacInfo;
+
+extern xf86BTramdacInfo BTramdacDeviceInfo[];
+
+#ifdef INIT_BT_RAMDAC_INFO
+xf86BTramdacInfo BTramdacDeviceInfo[] = {
+    {"AT&T 20C504"},
+    {"AT&T 20C505"},
+    {"BT485/484"}
+};
+#endif
diff --git a/hw/xfree86/ramdac/IBM.c b/hw/xfree86/ramdac/IBM.c
new file mode 100644
index 000000000..6822be5f1
--- /dev/null
+++ b/hw/xfree86/ramdac/IBM.c
@@ -0,0 +1,645 @@
+/*
+ * Copyright 1998 by Alan Hourihane, Wigan, England.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Alan Hourihane not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Alan Hourihane makes no representations
+ * about the suitability of this software for any purpose.  It is provided
+ * "as is" without express or implied warranty.
+ *
+ * ALAN HOURIHANE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL ALAN HOURIHANE BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authors:  Alan Hourihane, <alanh@fairlite.demon.co.uk>
+ *
+ * IBM RAMDAC routines.
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include "xf86Cursor.h"
+
+#define INIT_IBM_RAMDAC_INFO
+#include "IBMPriv.h"
+#include "xf86RamDacPriv.h"
+
+#define INITIALFREQERR 100000
+
+unsigned long
+IBMramdac640CalculateMNPCForClock(unsigned long RefClock,       /* In 100Hz units */
+                                  unsigned long ReqClock,       /* In 100Hz units */
+                                  char IsPixClock,      /* boolean, is this the pixel or the sys clock */
+                                  unsigned long MinClock,       /* Min VCO rating */
+                                  unsigned long MaxClock,       /* Max VCO rating */
+                                  unsigned long *rM,    /* M Out */
+                                  unsigned long *rN,    /* N Out */
+                                  unsigned long *rP,    /* Min P In, P Out */
+                                  unsigned long *rC     /* C Out */
+    )
+{
+    unsigned long M, N, P, iP = *rP;
+    unsigned long IntRef, VCO, Clock;
+    long freqErr, lowestFreqErr = INITIALFREQERR;
+    unsigned long ActualClock = 0;
+
+    for (N = 0; N <= 63; N++) {
+        IntRef = RefClock / (N + 1);
+        if (IntRef < 10000)
+            break;              /* IntRef needs to be >= 1MHz */
+        for (M = 2; M <= 127; M++) {
+            VCO = IntRef * (M + 1);
+            if ((VCO < MinClock) || (VCO > MaxClock))
+                continue;
+            for (P = iP; P <= 4; P++) {
+                if (P != 0)
+                    Clock = (RefClock * (M + 1)) / ((N + 1) * 2 * P);
+                else
+                    Clock = (RefClock * (M + 1)) / (N + 1);
+
+                freqErr = (Clock - ReqClock);
+
+                if (freqErr < 0) {
+                    /* PixelClock gets rounded up always so monitor reports
+                       correct frequency. */
+                    if (IsPixClock)
+                        continue;
+                    freqErr = -freqErr;
+                }
+
+                if (freqErr < lowestFreqErr) {
+                    *rM = M;
+                    *rN = N;
+                    *rP = P;
+                    *rC = (VCO <= 1280000 ? 1 : 2);
+                    ActualClock = Clock;
+
+                    lowestFreqErr = freqErr;
+                    /* Return if we found an exact match */
+                    if (freqErr == 0)
+                        return ActualClock;
+                }
+            }
+        }
+    }
+
+    return ActualClock;
+}
+
+unsigned long
+IBMramdac526CalculateMNPCForClock(unsigned long RefClock,       /* In 100Hz units */
+                                  unsigned long ReqClock,       /* In 100Hz units */
+                                  char IsPixClock,      /* boolean, is this the pixel or the sys clock */
+                                  unsigned long MinClock,       /* Min VCO rating */
+                                  unsigned long MaxClock,       /* Max VCO rating */
+                                  unsigned long *rM,    /* M Out */
+                                  unsigned long *rN,    /* N Out */
+                                  unsigned long *rP,    /* Min P In, P Out */
+                                  unsigned long *rC     /* C Out */
+    )
+{
+    unsigned long M, N, P, iP = *rP;
+    unsigned long IntRef, VCO, Clock;
+    long freqErr, lowestFreqErr = INITIALFREQERR;
+    unsigned long ActualClock = 0;
+
+    for (N = 0; N <= 63; N++) {
+        IntRef = RefClock / (N + 1);
+        if (IntRef < 10000)
+            break;              /* IntRef needs to be >= 1MHz */
+        for (M = 0; M <= 63; M++) {
+            VCO = IntRef * (M + 1);
+            if ((VCO < MinClock) || (VCO > MaxClock))
+                continue;
+            for (P = iP; P <= 4; P++) {
+                if (P)
+                    Clock = (RefClock * (M + 1)) / ((N + 1) * 2 * P);
+                else
+                    Clock = VCO;
+
+                freqErr = (Clock - ReqClock);
+
+                if (freqErr < 0) {
+                    /* PixelClock gets rounded up always so monitor reports
+                       correct frequency. */
+                    if (IsPixClock)
+                        continue;
+                    freqErr = -freqErr;
+                }
+
+                if (freqErr < lowestFreqErr) {
+                    *rM = M;
+                    *rN = N;
+                    *rP = P;
+                    *rC = (VCO <= 1280000 ? 1 : 2);
+                    ActualClock = Clock;
+
+                    lowestFreqErr = freqErr;
+                    /* Return if we found an exact match */
+                    if (freqErr == 0)
+                        return ActualClock;
+                }
+            }
+        }
+    }
+
+    return ActualClock;
+}
+
+void
+IBMramdacRestore(ScrnInfoPtr pScrn, RamDacRecPtr ramdacPtr,
+                 RamDacRegRecPtr ramdacReg)
+{
+    int i, maxreg, dacreg;
+
+    switch (ramdacPtr->RamDacType) {
+    case IBM640_RAMDAC:
+        maxreg = 0x300;
+        dacreg = 1024;
+        break;
+    default:
+        maxreg = 0x100;
+        dacreg = 768;
+        break;
+    }
+
+    /* Here we pass a short, so that we can evaluate a mask too */
+    /* So that the mask is the high byte and the data the low byte */
+    for (i = 0; i < maxreg; i++)
+        (*ramdacPtr->WriteDAC)
+            (pScrn, i, (ramdacReg->DacRegs[i] & 0xFF00) >> 8,
+             ramdacReg->DacRegs[i]);
+
+    (*ramdacPtr->WriteAddress) (pScrn, 0);
+    for (i = 0; i < dacreg; i++)
+        (*ramdacPtr->WriteData) (pScrn, ramdacReg->DAC[i]);
+}
+
+void
+IBMramdacSave(ScrnInfoPtr pScrn, RamDacRecPtr ramdacPtr,
+              RamDacRegRecPtr ramdacReg)
+{
+    int i, maxreg, dacreg;
+
+    switch (ramdacPtr->RamDacType) {
+    case IBM640_RAMDAC:
+        maxreg = 0x300;
+        dacreg = 1024;
+        break;
+    default:
+        maxreg = 0x100;
+        dacreg = 768;
+        break;
+    }
+
+    (*ramdacPtr->ReadAddress) (pScrn, 0);
+    for (i = 0; i < dacreg; i++)
+        ramdacReg->DAC[i] = (*ramdacPtr->ReadData) (pScrn);
+
+    for (i = 0; i < maxreg; i++)
+        ramdacReg->DacRegs[i] = (*ramdacPtr->ReadDAC) (pScrn, i);
+}
+
+RamDacHelperRecPtr
+IBMramdacProbe(ScrnInfoPtr pScrn,
+               RamDacSupportedInfoRecPtr ramdacs /* , RamDacRecPtr ramdacPtr */
+               )
+{
+    RamDacRecPtr ramdacPtr = RAMDACSCRPTR(pScrn);
+    RamDacHelperRecPtr ramdacHelperPtr = NULL;
+    Bool RamDacIsSupported = FALSE;
+    int IBMramdac_ID = -1;
+    int i;
+    unsigned char id, rev, id2, rev2;
+
+    /* read ID and revision */
+    rev = (*ramdacPtr->ReadDAC) (pScrn, IBMRGB_rev);
+    id = (*ramdacPtr->ReadDAC) (pScrn, IBMRGB_id);
+
+    /* check if ID and revision are read only */
+    (*ramdacPtr->WriteDAC) (pScrn, ~rev, 0, IBMRGB_rev);
+    (*ramdacPtr->WriteDAC) (pScrn, ~id, 0, IBMRGB_id);
+    rev2 = (*ramdacPtr->ReadDAC) (pScrn, IBMRGB_rev);
+    id2 = (*ramdacPtr->ReadDAC) (pScrn, IBMRGB_id);
+
+    switch (id) {
+    case 0x30:
+        if (rev == 0xc0)
+            IBMramdac_ID = IBM624_RAMDAC;
+        if (rev == 0x80)
+            IBMramdac_ID = IBM624DB_RAMDAC;
+        break;
+    case 0x12:
+        if (rev == 0x1c)
+            IBMramdac_ID = IBM640_RAMDAC;
+        break;
+    case 0x01:
+        IBMramdac_ID = IBM525_RAMDAC;
+        break;
+    case 0x02:
+        if (rev == 0xf0)
+            IBMramdac_ID = IBM524_RAMDAC;
+        if (rev == 0xe0)
+            IBMramdac_ID = IBM524A_RAMDAC;
+        if (rev == 0xc0)
+            IBMramdac_ID = IBM526_RAMDAC;
+        if (rev == 0x80)
+            IBMramdac_ID = IBM526DB_RAMDAC;
+        break;
+    }
+
+    if (id == 1 || id == 2) {
+        if (id == id2 && rev == rev2) { /* IBM RGB52x found */
+            /* check for 128bit VRAM -> RGB528 */
+            if (((*ramdacPtr->ReadDAC) (pScrn, IBMRGB_misc1) & 0x03) == 0x03) {
+                IBMramdac_ID = IBM528_RAMDAC;   /* 128bit DAC found */
+                if (rev == 0xe0)
+                    IBMramdac_ID = IBM528A_RAMDAC;
+            }
+        }
+    }
+
+    (*ramdacPtr->WriteDAC) (pScrn, rev, 0, IBMRGB_rev);
+    (*ramdacPtr->WriteDAC) (pScrn, id, 0, IBMRGB_id);
+
+    if (IBMramdac_ID == -1) {
+        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                   "Cannot determine IBM RAMDAC type, aborting\n");
+        return NULL;
+    }
+    else {
+        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                   "Attached RAMDAC is %s\n",
+                   IBMramdacDeviceInfo[IBMramdac_ID & 0xFFFF].DeviceName);
+    }
+
+    for (i = 0; ramdacs[i].token != -1; i++) {
+        if (ramdacs[i].token == IBMramdac_ID)
+            RamDacIsSupported = TRUE;
+    }
+
+    if (!RamDacIsSupported) {
+        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                   "This IBM RAMDAC is NOT supported by this driver, aborting\n");
+        return NULL;
+    }
+
+    ramdacHelperPtr = RamDacHelperCreateInfoRec();
+    switch (IBMramdac_ID) {
+    case IBM526_RAMDAC:
+    case IBM526DB_RAMDAC:
+        ramdacHelperPtr->SetBpp = IBMramdac526SetBpp;
+        ramdacHelperPtr->HWCursorInit = IBMramdac526HWCursorInit;
+        break;
+    case IBM640_RAMDAC:
+        ramdacHelperPtr->SetBpp = IBMramdac640SetBpp;
+        ramdacHelperPtr->HWCursorInit = IBMramdac640HWCursorInit;
+        break;
+    }
+    ramdacPtr->RamDacType = IBMramdac_ID;
+    ramdacHelperPtr->RamDacType = IBMramdac_ID;
+    ramdacHelperPtr->Save = IBMramdacSave;
+    ramdacHelperPtr->Restore = IBMramdacRestore;
+
+    return ramdacHelperPtr;
+}
+
+void
+IBMramdac526SetBpp(ScrnInfoPtr pScrn, RamDacRegRecPtr ramdacReg)
+{
+    ramdacReg->DacRegs[IBMRGB_key_control] = 0x00;      /* Disable Chroma Key */
+
+    switch (pScrn->bitsPerPixel) {
+    case 32:
+        ramdacReg->DacRegs[IBMRGB_pix_fmt] = PIXEL_FORMAT_32BPP;
+        ramdacReg->DacRegs[IBMRGB_32bpp] = B32_DCOL_DIRECT;
+        ramdacReg->DacRegs[IBMRGB_24bpp] = 0;
+        ramdacReg->DacRegs[IBMRGB_16bpp] = 0;
+        ramdacReg->DacRegs[IBMRGB_8bpp] = 0;
+        if (pScrn->overlayFlags & OVERLAY_8_32_PLANAR) {
+            ramdacReg->DacRegs[IBMRGB_key_control] = 0x01;      /* Enable Key */
+            ramdacReg->DacRegs[IBMRGB_key] = 0xFF;
+            ramdacReg->DacRegs[IBMRGB_key_mask] = 0xFF;
+        }
+        break;
+    case 24:
+        ramdacReg->DacRegs[IBMRGB_pix_fmt] = PIXEL_FORMAT_24BPP;
+        ramdacReg->DacRegs[IBMRGB_32bpp] = 0;
+        ramdacReg->DacRegs[IBMRGB_24bpp] = B24_DCOL_DIRECT;
+        ramdacReg->DacRegs[IBMRGB_16bpp] = 0;
+        ramdacReg->DacRegs[IBMRGB_8bpp] = 0;
+        break;
+    case 16:
+        if (pScrn->depth == 16) {
+            ramdacReg->DacRegs[IBMRGB_pix_fmt] = PIXEL_FORMAT_16BPP;
+            ramdacReg->DacRegs[IBMRGB_32bpp] = 0;
+            ramdacReg->DacRegs[IBMRGB_24bpp] = 0;
+            ramdacReg->DacRegs[IBMRGB_16bpp] = B16_DCOL_DIRECT | B16_LINEAR |
+                B16_CONTIGUOUS | B16_565;
+            ramdacReg->DacRegs[IBMRGB_8bpp] = 0;
+        }
+        else {
+            ramdacReg->DacRegs[IBMRGB_pix_fmt] = PIXEL_FORMAT_16BPP;
+            ramdacReg->DacRegs[IBMRGB_32bpp] = 0;
+            ramdacReg->DacRegs[IBMRGB_24bpp] = 0;
+            ramdacReg->DacRegs[IBMRGB_16bpp] = B16_DCOL_DIRECT | B16_LINEAR |
+                B16_CONTIGUOUS | B16_555;
+            ramdacReg->DacRegs[IBMRGB_8bpp] = 0;
+        }
+        break;
+    case 8:
+        ramdacReg->DacRegs[IBMRGB_pix_fmt] = PIXEL_FORMAT_8BPP;
+        ramdacReg->DacRegs[IBMRGB_32bpp] = 0;
+        ramdacReg->DacRegs[IBMRGB_24bpp] = 0;
+        ramdacReg->DacRegs[IBMRGB_16bpp] = 0;
+        ramdacReg->DacRegs[IBMRGB_8bpp] = B8_DCOL_INDIRECT;
+        break;
+    case 4:
+        ramdacReg->DacRegs[IBMRGB_pix_fmt] = PIXEL_FORMAT_4BPP;
+        ramdacReg->DacRegs[IBMRGB_32bpp] = 0;
+        ramdacReg->DacRegs[IBMRGB_24bpp] = 0;
+        ramdacReg->DacRegs[IBMRGB_16bpp] = 0;
+        ramdacReg->DacRegs[IBMRGB_8bpp] = 0;
+    }
+}
+
+IBMramdac526SetBppProc *
+IBMramdac526SetBppWeak(void)
+{
+    return IBMramdac526SetBpp;
+}
+
+void
+IBMramdac640SetBpp(ScrnInfoPtr pScrn, RamDacRegRecPtr ramdacReg)
+{
+    unsigned char bpp = 0x00;
+    unsigned char overlaybpp = 0x00;
+    unsigned char offset = 0x00;
+    unsigned char dispcont = 0x44;
+
+    ramdacReg->DacRegs[RGB640_SER_WID_03_00] = 0x00;
+    ramdacReg->DacRegs[RGB640_SER_WID_07_04] = 0x00;
+    ramdacReg->DacRegs[RGB640_DIAGS] = 0x07;
+
+    switch (pScrn->depth) {
+    case 8:
+        ramdacReg->DacRegs[RGB640_SER_07_00] = 0x00;
+        ramdacReg->DacRegs[RGB640_SER_15_08] = 0x00;
+        ramdacReg->DacRegs[RGB640_SER_23_16] = 0x00;
+        ramdacReg->DacRegs[RGB640_SER_31_24] = 0x00;
+        ramdacReg->DacRegs[RGB640_SER_MODE] = IBM640_SER_16_1;  /*16:1 Mux */
+        ramdacReg->DacRegs[RGB640_MISC_CONF] = IBM640_PCLK_8;   /* pll / 8 */
+        bpp = 0x03;
+        break;
+    case 15:
+        ramdacReg->DacRegs[RGB640_SER_07_00] = 0x10;
+        ramdacReg->DacRegs[RGB640_SER_15_08] = 0x11;
+        ramdacReg->DacRegs[RGB640_SER_23_16] = 0x00;
+        ramdacReg->DacRegs[RGB640_SER_31_24] = 0x00;
+        ramdacReg->DacRegs[RGB640_SER_MODE] = IBM640_SER_8_1;   /* 8:1 Mux */
+        ramdacReg->DacRegs[RGB640_MISC_CONF] = IBM640_PCLK_8;   /* pll / 8 */
+        bpp = 0x0E;
+        break;
+    case 16:
+        ramdacReg->DacRegs[RGB640_SER_07_00] = 0x10;
+        ramdacReg->DacRegs[RGB640_SER_15_08] = 0x11;
+        ramdacReg->DacRegs[RGB640_SER_23_16] = 0x00;
+        ramdacReg->DacRegs[RGB640_SER_31_24] = 0x00;
+        ramdacReg->DacRegs[RGB640_SER_MODE] = IBM640_SER_8_1;   /* 8:1 Mux */
+        ramdacReg->DacRegs[RGB640_MISC_CONF] = IBM640_PCLK_8;   /* pll / 8 */
+        bpp = 0x05;
+        break;
+    case 24:
+        ramdacReg->DacRegs[RGB640_SER_07_00] = 0x30;
+        ramdacReg->DacRegs[RGB640_SER_15_08] = 0x31;
+        ramdacReg->DacRegs[RGB640_SER_23_16] = 0x32;
+        ramdacReg->DacRegs[RGB640_SER_31_24] = 0x33;
+        ramdacReg->DacRegs[RGB640_SER_MODE] = IBM640_SER_4_1;   /* 4:1 Mux */
+        ramdacReg->DacRegs[RGB640_MISC_CONF] = IBM640_PCLK_8;   /* pll / 8 */
+        bpp = 0x09;
+        if (pScrn->overlayFlags & OVERLAY_8_32_PLANAR) {
+            ramdacReg->DacRegs[RGB640_SER_WID_07_04] = 0x04;
+            ramdacReg->DacRegs[RGB640_CHROMA_KEY0] = 0xFF;
+            ramdacReg->DacRegs[RGB640_CHROMA_MASK0] = 0xFF;
+            offset = 0x04;
+            overlaybpp = 0x04;
+            dispcont = 0x48;
+        }
+        break;
+    case 30:                   /* 10 bit dac */
+        ramdacReg->DacRegs[RGB640_SER_07_00] = 0x30;
+        ramdacReg->DacRegs[RGB640_SER_15_08] = 0x31;
+        ramdacReg->DacRegs[RGB640_SER_23_16] = 0x32;
+        ramdacReg->DacRegs[RGB640_SER_31_24] = 0x33;
+        ramdacReg->DacRegs[RGB640_SER_MODE] = IBM640_SER_4_1;   /* 4:1 Mux */
+        ramdacReg->DacRegs[RGB640_MISC_CONF] = IBM640_PSIZE10 | IBM640_PCLK_8;  /* pll / 8 */
+        bpp = 0x0D;
+        break;
+    }
+
+    {
+        int i;
+
+        for (i = 0x100; i < 0x140; i += 4) {
+            /* Initialize FrameBuffer Window Attribute Table */
+            ramdacReg->DacRegs[i + 0] = bpp;
+            ramdacReg->DacRegs[i + 1] = offset;
+            ramdacReg->DacRegs[i + 2] = 0x00;
+            ramdacReg->DacRegs[i + 3] = 0x00;
+            /* Initialize Overlay Window Attribute Table */
+            ramdacReg->DacRegs[i + 0x100] = overlaybpp;
+            ramdacReg->DacRegs[i + 0x101] = 0x00;
+            ramdacReg->DacRegs[i + 0x102] = 0x00;
+            ramdacReg->DacRegs[i + 0x103] = dispcont;
+        }
+    }
+}
+
+static void
+IBMramdac526ShowCursor(ScrnInfoPtr pScrn)
+{
+    RamDacRecPtr ramdacPtr = RAMDACSCRPTR(pScrn);
+
+    /* Enable cursor - X11 mode */
+    (*ramdacPtr->WriteDAC) (pScrn, IBMRGB_curs, 0x00, 0x07);
+}
+
+static void
+IBMramdac640ShowCursor(ScrnInfoPtr pScrn)
+{
+    RamDacRecPtr ramdacPtr = RAMDACSCRPTR(pScrn);
+
+    /* Enable cursor - mode2 (x11 mode) */
+    (*ramdacPtr->WriteDAC) (pScrn, RGB640_CURSOR_CONTROL, 0x00, 0x0B);
+    (*ramdacPtr->WriteDAC) (pScrn, RGB640_CROSSHAIR_CONTROL, 0x00, 0x00);
+}
+
+static void
+IBMramdac526HideCursor(ScrnInfoPtr pScrn)
+{
+    RamDacRecPtr ramdacPtr = RAMDACSCRPTR(pScrn);
+
+    /* Disable cursor - X11 mode */
+    (*ramdacPtr->WriteDAC) (pScrn, IBMRGB_curs, 0x00, 0x24);
+}
+
+static void
+IBMramdac640HideCursor(ScrnInfoPtr pScrn)
+{
+    RamDacRecPtr ramdacPtr = RAMDACSCRPTR(pScrn);
+
+    /* Disable cursor - mode2 (x11 mode) */
+    (*ramdacPtr->WriteDAC) (pScrn, RGB640_CURSOR_CONTROL, 0x00, 0x08);
+}
+
+static void
+IBMramdac526SetCursorPosition(ScrnInfoPtr pScrn, int x, int y)
+{
+    RamDacRecPtr ramdacPtr = RAMDACSCRPTR(pScrn);
+
+    x += 64;
+    y += 64;
+
+    (*ramdacPtr->WriteDAC) (pScrn, IBMRGB_curs_hot_x, 0x00, 0x3f);
+    (*ramdacPtr->WriteDAC) (pScrn, IBMRGB_curs_hot_y, 0x00, 0x3f);
+    (*ramdacPtr->WriteDAC) (pScrn, IBMRGB_curs_xl, 0x00, x & 0xff);
+    (*ramdacPtr->WriteDAC) (pScrn, IBMRGB_curs_xh, 0x00, (x >> 8) & 0xf);
+    (*ramdacPtr->WriteDAC) (pScrn, IBMRGB_curs_yl, 0x00, y & 0xff);
+    (*ramdacPtr->WriteDAC) (pScrn, IBMRGB_curs_yh, 0x00, (y >> 8) & 0xf);
+}
+
+static void
+IBMramdac640SetCursorPosition(ScrnInfoPtr pScrn, int x, int y)
+{
+    RamDacRecPtr ramdacPtr = RAMDACSCRPTR(pScrn);
+
+    x += 64;
+    y += 64;
+
+    (*ramdacPtr->WriteDAC) (pScrn, RGB640_CURS_OFFSETX, 0x00, 0x3f);
+    (*ramdacPtr->WriteDAC) (pScrn, RGB640_CURS_OFFSETY, 0x00, 0x3f);
+    (*ramdacPtr->WriteDAC) (pScrn, RGB640_CURS_X_LOW, 0x00, x & 0xff);
+    (*ramdacPtr->WriteDAC) (pScrn, RGB640_CURS_X_HIGH, 0x00, (x >> 8) & 0xf);
+    (*ramdacPtr->WriteDAC) (pScrn, RGB640_CURS_Y_LOW, 0x00, y & 0xff);
+    (*ramdacPtr->WriteDAC) (pScrn, RGB640_CURS_Y_HIGH, 0x00, (y >> 8) & 0xf);
+}
+
+static void
+IBMramdac526SetCursorColors(ScrnInfoPtr pScrn, int bg, int fg)
+{
+    RamDacRecPtr ramdacPtr = RAMDACSCRPTR(pScrn);
+
+    (*ramdacPtr->WriteDAC) (pScrn, IBMRGB_curs_col1_r, 0x00, bg >> 16);
+    (*ramdacPtr->WriteDAC) (pScrn, IBMRGB_curs_col1_g, 0x00, bg >> 8);
+    (*ramdacPtr->WriteDAC) (pScrn, IBMRGB_curs_col1_b, 0x00, bg);
+    (*ramdacPtr->WriteDAC) (pScrn, IBMRGB_curs_col2_r, 0x00, fg >> 16);
+    (*ramdacPtr->WriteDAC) (pScrn, IBMRGB_curs_col2_g, 0x00, fg >> 8);
+    (*ramdacPtr->WriteDAC) (pScrn, IBMRGB_curs_col2_b, 0x00, fg);
+}
+
+static void
+IBMramdac640SetCursorColors(ScrnInfoPtr pScrn, int bg, int fg)
+{
+    RamDacRecPtr ramdacPtr = RAMDACSCRPTR(pScrn);
+
+    (*ramdacPtr->WriteDAC) (pScrn, RGB640_CURS_COL0, 0x00, 0);
+    (*ramdacPtr->WriteData) (pScrn, fg >> 16);
+    (*ramdacPtr->WriteData) (pScrn, fg >> 8);
+    (*ramdacPtr->WriteData) (pScrn, fg);
+    (*ramdacPtr->WriteData) (pScrn, bg >> 16);
+    (*ramdacPtr->WriteData) (pScrn, bg >> 8);
+    (*ramdacPtr->WriteData) (pScrn, bg);
+    (*ramdacPtr->WriteData) (pScrn, fg >> 16);
+    (*ramdacPtr->WriteData) (pScrn, fg >> 8);
+    (*ramdacPtr->WriteData) (pScrn, fg);
+    (*ramdacPtr->WriteData) (pScrn, bg >> 16);
+    (*ramdacPtr->WriteData) (pScrn, bg >> 8);
+    (*ramdacPtr->WriteData) (pScrn, bg);
+}
+
+static Bool
+IBMramdac526LoadCursorImage(ScrnInfoPtr pScrn, unsigned char *src)
+{
+    RamDacRecPtr ramdacPtr = RAMDACSCRPTR(pScrn);
+    int i;
+
+    /*
+     * Output the cursor data.  The realize function has put the planes into
+     * their correct order, so we can just blast this out.
+     */
+    for (i = 0; i < 1024; i++)
+        (*ramdacPtr->WriteDAC) (pScrn, IBMRGB_curs_array + i, 0x00, (*src++));
+    return TRUE;
+}
+
+static Bool
+IBMramdac640LoadCursorImage(ScrnInfoPtr pScrn, unsigned char *src)
+{
+    RamDacRecPtr ramdacPtr = RAMDACSCRPTR(pScrn);
+    int i;
+
+    /*
+     * Output the cursor data.  The realize function has put the planes into
+     * their correct order, so we can just blast this out.
+     */
+    for (i = 0; i < 1024; i++)
+        (*ramdacPtr->WriteDAC) (pScrn, RGB640_CURS_WRITE + i, 0x00, (*src++));
+    return TRUE;
+}
+
+static Bool
+IBMramdac526UseHWCursor(ScreenPtr pScr, CursorPtr pCurs)
+{
+    return TRUE;
+}
+
+static Bool
+IBMramdac640UseHWCursor(ScreenPtr pScr, CursorPtr pCurs)
+{
+    return TRUE;
+}
+
+void
+IBMramdac526HWCursorInit(xf86CursorInfoPtr infoPtr)
+{
+    infoPtr->MaxWidth = 64;
+    infoPtr->MaxHeight = 64;
+    infoPtr->Flags = HARDWARE_CURSOR_TRUECOLOR_AT_8BPP |
+        HARDWARE_CURSOR_AND_SOURCE_WITH_MASK |
+        HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_1;
+    infoPtr->SetCursorColors = IBMramdac526SetCursorColors;
+    infoPtr->SetCursorPosition = IBMramdac526SetCursorPosition;
+    infoPtr->LoadCursorImageCheck = IBMramdac526LoadCursorImage;
+    infoPtr->HideCursor = IBMramdac526HideCursor;
+    infoPtr->ShowCursor = IBMramdac526ShowCursor;
+    infoPtr->UseHWCursor = IBMramdac526UseHWCursor;
+}
+
+void
+IBMramdac640HWCursorInit(xf86CursorInfoPtr infoPtr)
+{
+    infoPtr->MaxWidth = 64;
+    infoPtr->MaxHeight = 64;
+    infoPtr->Flags = HARDWARE_CURSOR_TRUECOLOR_AT_8BPP |
+        HARDWARE_CURSOR_AND_SOURCE_WITH_MASK |
+        HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_1;
+    infoPtr->SetCursorColors = IBMramdac640SetCursorColors;
+    infoPtr->SetCursorPosition = IBMramdac640SetCursorPosition;
+    infoPtr->LoadCursorImageCheck = IBMramdac640LoadCursorImage;
+    infoPtr->HideCursor = IBMramdac640HideCursor;
+    infoPtr->ShowCursor = IBMramdac640ShowCursor;
+    infoPtr->UseHWCursor = IBMramdac640UseHWCursor;
+}
diff --git a/hw/xfree86/ramdac/IBM.h b/hw/xfree86/ramdac/IBM.h
new file mode 100644
index 000000000..986be2f48
--- /dev/null
+++ b/hw/xfree86/ramdac/IBM.h
@@ -0,0 +1,418 @@
+
+#include <xf86RamDac.h>
+
+extern _X_EXPORT RamDacHelperRecPtr IBMramdacProbe(ScrnInfoPtr pScrn,
+                                                   RamDacSupportedInfoRecPtr
+                                                   ramdacs);
+extern _X_EXPORT void IBMramdacSave(ScrnInfoPtr pScrn, RamDacRecPtr RamDacRec,
+                                    RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void IBMramdacRestore(ScrnInfoPtr pScrn,
+                                       RamDacRecPtr RamDacRec,
+                                       RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void IBMramdac526SetBpp(ScrnInfoPtr pScrn,
+                                         RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void IBMramdac640SetBpp(ScrnInfoPtr pScrn,
+                                         RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT unsigned long IBMramdac526CalculateMNPCForClock(unsigned long
+                                                                 RefClock,
+                                                                 unsigned long
+                                                                 ReqClock,
+                                                                 char
+                                                                 IsPixClock,
+                                                                 unsigned long
+                                                                 MinClock,
+                                                                 unsigned long
+                                                                 MaxClock,
+                                                                 unsigned long
+                                                                 *rM,
+                                                                 unsigned long
+                                                                 *rN,
+                                                                 unsigned long
+                                                                 *rP,
+                                                                 unsigned long
+                                                                 *rC);
+extern _X_EXPORT unsigned long IBMramdac640CalculateMNPCForClock(unsigned long
+                                                                 RefClock,
+                                                                 unsigned long
+                                                                 ReqClock,
+                                                                 char
+                                                                 IsPixClock,
+                                                                 unsigned long
+                                                                 MinClock,
+                                                                 unsigned long
+                                                                 MaxClock,
+                                                                 unsigned long
+                                                                 *rM,
+                                                                 unsigned long
+                                                                 *rN,
+                                                                 unsigned long
+                                                                 *rP,
+                                                                 unsigned long
+                                                                 *rC);
+extern _X_EXPORT void IBMramdac526HWCursorInit(xf86CursorInfoPtr infoPtr);
+extern _X_EXPORT void IBMramdac640HWCursorInit(xf86CursorInfoPtr infoPtr);
+
+typedef void IBMramdac526SetBppProc(ScrnInfoPtr, RamDacRegRecPtr);
+extern _X_EXPORT IBMramdac526SetBppProc *IBMramdac526SetBppWeak(void);
+
+#define IBM524_RAMDAC		((VENDOR_IBM << 16) | 0x00)
+#define IBM524A_RAMDAC		((VENDOR_IBM << 16) | 0x01)
+#define IBM525_RAMDAC		((VENDOR_IBM << 16) | 0x02)
+#define IBM526_RAMDAC		((VENDOR_IBM << 16) | 0x03)
+#define IBM526DB_RAMDAC		((VENDOR_IBM << 16) | 0x04)
+#define IBM528_RAMDAC		((VENDOR_IBM << 16) | 0x05)
+#define IBM528A_RAMDAC		((VENDOR_IBM << 16) | 0x06)
+#define IBM624_RAMDAC		((VENDOR_IBM << 16) | 0x07)
+#define IBM624DB_RAMDAC		((VENDOR_IBM << 16) | 0x08)
+#define IBM640_RAMDAC		((VENDOR_IBM << 16) | 0x09)
+
+/*
+ * IBM Ramdac registers
+ */
+
+#define IBMRGB_REF_FREQ_1       14.31818
+#define IBMRGB_REF_FREQ_2       50.00000
+
+#define IBMRGB_rev		0x00
+#define IBMRGB_id		0x01
+#define IBMRGB_misc_clock	0x02
+#define IBMRGB_sync		0x03
+#define IBMRGB_hsync_pos	0x04
+#define IBMRGB_pwr_mgmt		0x05
+#define IBMRGB_dac_op		0x06
+#define IBMRGB_pal_ctrl		0x07
+#define IBMRGB_sysclk		0x08    /* not RGB525 */
+#define IBMRGB_pix_fmt		0x0a
+#define IBMRGB_8bpp		0x0b
+#define IBMRGB_16bpp		0x0c
+#define IBMRGB_24bpp		0x0d
+#define IBMRGB_32bpp		0x0e
+#define IBMRGB_pll_ctrl1	0x10
+#define IBMRGB_pll_ctrl2	0x11
+#define IBMRGB_pll_ref_div_fix	0x14
+#define IBMRGB_sysclk_ref_div	0x15    /* not RGB525 */
+#define IBMRGB_sysclk_vco_div	0x16    /* not RGB525 */
+/* #define IBMRGB_f0		0x20 */
+
+#define IBMRGB_sysclk_n		0x15
+#define IBMRGB_sysclk_m		0x16
+#define IBMRGB_sysclk_p		0x17
+#define IBMRGB_sysclk_c		0x18
+
+#define IBMRGB_m0		0x20
+#define IBMRGB_n0		0x21
+#define IBMRGB_p0		0x22
+#define IBMRGB_c0		0x23
+#define IBMRGB_m1		0x24
+#define IBMRGB_n1		0x25
+#define IBMRGB_p1		0x26
+#define IBMRGB_c1		0x27
+#define IBMRGB_m2		0x28
+#define IBMRGB_n2		0x29
+#define IBMRGB_p2		0x2a
+#define IBMRGB_c2		0x2b
+#define IBMRGB_m3		0x2c
+#define IBMRGB_n3		0x2d
+#define IBMRGB_p3		0x2e
+#define IBMRGB_c3		0x2f
+
+#define IBMRGB_curs		0x30
+#define IBMRGB_curs_xl		0x31
+#define IBMRGB_curs_xh		0x32
+#define IBMRGB_curs_yl		0x33
+#define IBMRGB_curs_yh		0x34
+#define IBMRGB_curs_hot_x	0x35
+#define IBMRGB_curs_hot_y	0x36
+#define IBMRGB_curs_col1_r	0x40
+#define IBMRGB_curs_col1_g	0x41
+#define IBMRGB_curs_col1_b	0x42
+#define IBMRGB_curs_col2_r	0x43
+#define IBMRGB_curs_col2_g	0x44
+#define IBMRGB_curs_col2_b	0x45
+#define IBMRGB_curs_col3_r	0x46
+#define IBMRGB_curs_col3_g	0x47
+#define IBMRGB_curs_col3_b	0x48
+#define IBMRGB_border_col_r	0x60
+#define IBMRGB_border_col_g	0x61
+#define IBMRGB_botder_col_b	0x62
+#define IBMRGB_key		0x68
+#define IBMRGB_key_mask		0x6C
+#define IBMRGB_misc1		0x70
+#define IBMRGB_misc2		0x71
+#define IBMRGB_misc3		0x72
+#define IBMRGB_misc4		0x73    /* not RGB525 */
+#define IBMRGB_key_control	0x78
+#define IBMRGB_dac_sense	0x82
+#define IBMRGB_misr_r		0x84
+#define IBMRGB_misr_g		0x86
+#define IBMRGB_misr_b		0x88
+#define IBMRGB_pll_vco_div_in	0x8e
+#define IBMRGB_pll_ref_div_in	0x8f
+#define IBMRGB_vram_mask_0	0x90
+#define IBMRGB_vram_mask_1	0x91
+#define IBMRGB_vram_mask_2	0x92
+#define IBMRGB_vram_mask_3	0x93
+#define IBMRGB_curs_array	0x100
+
+/* Constants rgb525.h */
+
+/* RGB525_REVISION_LEVEL */
+#define RGB525_PRODUCT_REV_LEVEL        0xf0
+
+/* RGB525_ID */
+#define RGB525_PRODUCT_ID               0x01
+
+/* RGB525_MISC_CTRL_1 */
+#define MISR_CNTL_ENABLE                0x80
+#define VMSK_CNTL_ENABLE                0x40
+#define PADR_RDMT_RDADDR                0x0
+#define PADR_RDMT_PAL_STATE             0x20
+#define SENS_DSAB_DISABLE               0x10
+#define SENS_SEL_BIT3                   0x0
+#define SENS_SEL_BIT7                   0x08
+#define VRAM_SIZE_32                    0x0
+#define VRAM_SIZE_64                    0x01
+
+/* RGB525_MISC_CTRL_2 */
+#define PCLK_SEL_LCLK                   0x0
+#define PCLK_SEL_PLL                    0x40
+#define PCLK_SEL_EXT                    0x80
+#define INTL_MODE_ENABLE                0x20
+#define BLANK_CNTL_ENABLE               0x10
+#define COL_RES_6BIT                    0x0
+#define COL_RES_8BIT                    0x04
+#define PORT_SEL_VGA                    0x0
+#define PORT_SEL_VRAM                   0x01
+
+/* RGB525_MISC_CTRL_3 */
+#define SWAP_RB                         0x80
+#define SWAP_WORD_LOHI                  0x0
+#define SWAP_WORD_HILO                  0x10
+#define SWAP_NIB_HILO                   0x0
+#define SWAP_NIB_LOHI                   0x02
+
+/* RGB525_MISC_CLK_CTRL */
+#define DDOT_CLK_ENABLE                 0x0
+#define DDOT_CLK_DISABLE                0x80
+#define SCLK_ENABLE                     0x0
+#define SCLK_DISABLE                    0x40
+#define B24P_DDOT_PLL                   0x0
+#define B24P_DDOT_SCLK                  0x20
+#define DDOT_DIV_PLL_1                  0x0
+#define DDOT_DIV_PLL_2                  0x02
+#define DDOT_DIV_PLL_4                  0x04
+#define DDOT_DIV_PLL_8                  0x06
+#define DDOT_DIV_PLL_16                 0x08
+#define PLL_DISABLE                     0x0
+#define PLL_ENABLE                      0x01
+
+/* RGB525_SYNC_CTRL */
+#define DLY_CNTL_ADD                    0x0
+#define DLY_SYNC_NOADD                  0x80
+#define CSYN_INVT_DISABLE               0x0
+#define CSYN_INVT_ENABLE                0x40
+#define VSYN_INVT_DISABLE               0x0
+#define VSYN_INVT_ENABLE                0x20
+#define HSYN_INVT_DISABLE               0x0
+#define HSYN_INVT_ENABLE                0x10
+#define VSYN_CNTL_NORMAL                0x0
+#define VSYN_CNTL_HIGH                  0x04
+#define VSYN_CNTL_LOW                   0x08
+#define VSYN_CNTL_DISABLE               0x0C
+#define HSYN_CNTL_NORMAL                0x0
+#define HSYN_CNTL_HIGH                  0x01
+#define HSYN_CNTL_LOW                   0x02
+#define HSYN_CNTL_DISABLE               0x03
+
+/* RGB525_HSYNC_CTRL */
+#define HSYN_POS(n)                     (n)
+
+/* RGB525_POWER_MANAGEMENT */
+#define SCLK_PWR_NORMAL                 0x0
+#define SCLK_PWR_DISABLE                0x10
+#define DDOT_PWR_NORMAL                 0x0
+#define DDOT_PWR_DISABLE                0x08
+#define SYNC_PWR_NORMAL                 0x0
+#define SYNC_PWR_DISABLE                0x04
+#define ICLK_PWR_NORMAL                 0x0
+#define ICLK_PWR_DISABLE                0x02
+#define DAC_PWR_NORMAL                  0x0
+#define DAC_PWR_DISABLE                 0x01
+
+/* RGB525_DAC_OPERATION */
+#define SOG_DISABLE                     0x0
+#define SOG_ENABLE                      0x08
+#define BRB_NORMAL                      0x0
+#define BRB_ALWAYS                      0x04
+#define DSR_DAC_SLOW                    0x02
+#define DSR_DAC_FAST                    0x0
+#define DPE_DISABLE                     0x0
+#define DPE_ENABLE                      0x01
+
+/* RGB525_PALETTE_CTRL */
+#define SIXBIT_LINEAR_ENABLE            0x0
+#define SIXBIT_LINEAR_DISABLE           0x80
+#define PALETTE_PARITION(n)             (n)
+
+/* RGB525_PIXEL_FORMAT */
+#define PIXEL_FORMAT_4BPP               0x02
+#define PIXEL_FORMAT_8BPP               0x03
+#define PIXEL_FORMAT_16BPP              0x04
+#define PIXEL_FORMAT_24BPP              0x05
+#define PIXEL_FORMAT_32BPP              0x06
+
+/* RGB525_8BPP_CTRL */
+#define B8_DCOL_INDIRECT                0x0
+#define B8_DCOL_DIRECT                  0x01
+
+/* RGB525_16BPP_CTRL */
+#define B16_DCOL_INDIRECT               0x0
+#define B16_DCOL_DYNAMIC                0x40
+#define B16_DCOL_DIRECT                 0xC0
+#define B16_POL_FORCE_BYPASS            0x0
+#define B16_POL_FORCE_LOOKUP            0x20
+#define B16_ZIB                         0x0
+#define B16_LINEAR                      0x04
+#define B16_555                         0x0
+#define B16_565                         0x02
+#define B16_SPARSE                      0x0
+#define B16_CONTIGUOUS                  0x01
+
+/* RGB525_24BPP_CTRL */
+#define B24_DCOL_INDIRECT               0x0
+#define B24_DCOL_DIRECT                 0x01
+
+/* RGB525_32BPP_CTRL */
+#define B32_POL_FORCE_BYPASS            0x0
+#define B32_POL_FORCE_LOOKUP            0x04
+#define B32_DCOL_INDIRECT               0x0
+#define B32_DCOL_DYNAMIC                0x01
+#define B32_DCOL_DIRECT                 0x03
+
+/* RGB525_PLL_CTRL_1 */
+#define REF_SRC_REFCLK                  0x0
+#define REF_SRC_EXTCLK                  0x10
+#define PLL_EXT_FS_3_0                  0x0
+#define PLL_EXT_FS_2_0                  0x01
+#define PLL_CNTL2_3_0                   0x02
+#define PLL_CNTL2_2_0                   0x03
+
+/* RGB525_PLL_CTRL_2 */
+#define PLL_INT_FS_3_0(n)               (n)
+#define PLL_INT_FS_2_0(n)               (n)
+
+/* RGB525_PLL_REF_DIV_COUNT */
+#define REF_DIV_COUNT(n)                (n)
+
+/* RGB525_F0 - RGB525_F15 */
+#define VCO_DIV_COUNT(n)                (n)
+
+/* RGB525_PLL_REFCLK values */
+#define RGB525_PLL_REFCLK_MHz(n)        ((n)/2)
+
+/* RGB525_CURSOR_CONTROL */
+#define SMLC_PART_0                     0x0
+#define SMLC_PART_1                     0x40
+#define SMLC_PART_2                     0x80
+#define SMLC_PART_3                     0xC0
+#define PIX_ORDER_RL                    0x0
+#define PIX_ORDER_LR                    0x20
+#define LOC_READ_LAST                   0x0
+#define LOC_READ_ACTUAL                 0x10
+#define UPDT_CNTL_DELAYED               0x0
+#define UPDT_CNTL_IMMEDIATE             0x08
+#define CURSOR_SIZE_32                  0x0
+#define CURSOR_SIZE_64                  0x40
+#define CURSOR_MODE_OFF                 0x0
+#define CURSOR_MODE_3_COLOR             0x01
+#define CURSOR_MODE_2_COLOR_HL          0x02
+#define CURSOR_MODE_2_COLOR             0x03
+
+/* RGB525_REVISION_LEVEL */
+#define REVISION_LEVEL                  0xF0    /* predefined */
+
+/* RGB525_ID */
+#define ID_CODE                         0x01    /* predefined */
+
+/* MISR status */
+#define RGB525_MISR_DONE                0x01
+
+/* the IBMRGB640 is rather different from the rest of the RAMDACs,
+   so we define a completely new set of register names for it */
+#define RGB640_SER_07_00		0x02
+#define RGB640_SER_15_08		0x03
+#define RGB640_SER_23_16		0x04
+#define RGB640_SER_31_24		0x05
+#define RGB640_SER_WID_03_00		0x06
+#define RGB640_SER_WID_07_04		0x07
+#define RGB640_SER_MODE			0x08
+#define		IBM640_SER_2_1	0x00
+#define		IBM640_SER_4_1	0x01
+#define		IBM640_SER_8_1	0x02
+#define		IBM640_SER_16_1	0x03
+#define		IBM640_SER_16_3	0x05
+#define		IBM640_SER_5_1	0x06
+#define RGB640_PIXEL_INTERLEAVE		0x09
+#define RGB640_MISC_CONF		0x0a
+#define		IBM640_PCLK		0x00
+#define		IBM640_PCLK_2		0x40
+#define		IBM640_PCLK_4		0x80
+#define		IBM640_PCLK_8		0xc0
+#define		IBM640_PSIZE10		0x10
+#define		IBM640_LCI		0x08
+#define		IBM640_WIDCTL_MASK	0x07
+#define RGB640_VGA_CONTROL		0x0b
+#define 	IBM640_RDBK	0x04
+#define 	IBM640_PSIZE8	0x02
+#define		IBM640_VRAM	0x01
+#define RGB640_DAC_CONTROL		0x0d
+#define		IBM640_MONO	0x08
+#define		IBM640_DACENBL	0x04
+#define		IBM640_SHUNT	0x02
+#define		IBM640_SLOWSLEW	0x01
+#define RGB640_OUTPUT_CONTROL		0x0e
+#define		IBM640_RDAI	0x04
+#define		IBM640_WDAI	0x02
+#define		IBM640_WATCTL	0x01
+#define RGB640_SYNC_CONTROL		0x0f
+#define		IBM640_PWR	0x20
+#define		IBM640_VSP	0x10
+#define		IBM640_HSP	0x08
+#define		IBM640_CSE	0x04
+#define		IBM640_CSG	0x02
+#define		IBM640_BPE	0x01
+#define RGB640_PLL_N			0x10
+#define RGB640_PLL_M			0x11
+#define RGB640_PLL_P			0x12
+#define RGB640_PLL_CTL			0x13
+#define 	IBM640_PLL_EN	0x04
+#define		IBM640_PLL_HIGH	0x10
+#define		IBM640_PLL_LOW	0x01
+#define RGB640_AUX_PLL_CTL		0x17
+#define		IBM640_AUXPLL	0x04
+#define		IBM640_AUX_HI	0x02
+#define		IBM640_AUX_LO	0x01
+#define RGB640_CHROMA_KEY0		0x20
+#define RGB640_CHROMA_MASK0		0x21
+#define RGB640_CURS_X_LOW		0x40
+#define RGB640_CURS_X_HIGH		0x41
+#define RGB640_CURS_Y_LOW		0x42
+#define RGB640_CURS_Y_HIGH		0x43
+#define RGB640_CURS_OFFSETX		0x44
+#define RGB640_CURS_OFFSETY		0x45
+#define RGB640_CURSOR_CONTROL		0x4B
+#define		IBM640_CURS_OFF		0x00
+#define		IBM640_CURS_MODE0	0x01
+#define		IBM640_CURS_MODE1	0x02
+#define		IBM640_CURS_MODE2	0x03
+#define		IBM640_CURS_ADV		0x04
+#define RGB640_CROSSHAIR_CONTROL	0x57
+#define RGB640_VRAM_MASK0		0xf0
+#define RGB640_VRAM_MASK1		0xf1
+#define RGB640_VRAM_MASK2		0xf2
+#define RGB640_DIAGS			0xfa
+#define RGB640_CURS_WRITE		0x1000
+#define RGB640_CURS_COL0		0x4800
+#define RGB640_CURS_COL1		0x4801
+#define RGB640_CURS_COL2		0x4802
+#define RGB640_CURS_COL3		0x4803
diff --git a/hw/xfree86/ramdac/IBMPriv.h b/hw/xfree86/ramdac/IBMPriv.h
new file mode 100644
index 000000000..48588c851
--- /dev/null
+++ b/hw/xfree86/ramdac/IBMPriv.h
@@ -0,0 +1,27 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "IBM.h"
+
+typedef struct {
+    const char *DeviceName;
+} xf86IBMramdacInfo;
+
+extern xf86IBMramdacInfo IBMramdacDeviceInfo[];
+
+#ifdef INIT_IBM_RAMDAC_INFO
+xf86IBMramdacInfo IBMramdacDeviceInfo[] = {
+    {"IBM 524"},
+    {"IBM 524A"},
+    {"IBM 525"},
+    {"IBM 526"},
+    {"IBM 526DB(DoubleBuffer)"},
+    {"IBM 528"},
+    {"IBM 528A"},
+    {"IBM 624"},
+    {"IBM 624DB(DoubleBuffer)"},
+    {"IBM 640"}
+};
+#endif
diff --git a/hw/xfree86/ramdac/Makefile.am b/hw/xfree86/ramdac/Makefile.am
index 8e14f2678..770c13cf2 100644
--- a/hw/xfree86/ramdac/Makefile.am
+++ b/hw/xfree86/ramdac/Makefile.am
@@ -1,10 +1,13 @@
 noinst_LTLIBRARIES = libramdac.la
 
-libramdac_la_SOURCES = xf86CursorRD.c xf86HWCurs.c xf86BitOrder.c
+libramdac_la_SOURCES = xf86RamDac.c xf86RamDacCmap.c \
+                       xf86CursorRD.c xf86HWCurs.c IBM.c BT.c TI.c \
+                       xf86BitOrder.c
 
-sdk_HEADERS = xf86Cursor.h
+sdk_HEADERS = BT.h IBM.h TI.h xf86Cursor.h xf86RamDac.h
 
-EXTRA_DIST = xf86CursorPriv.h CURSOR.NOTES
+EXTRA_DIST = BTPriv.h IBMPriv.h TIPriv.h xf86CursorPriv.h xf86RamDacPriv.h \
+	CURSOR.NOTES
 
 AM_CFLAGS = $(DIX_CFLAGS) $(XORG_CFLAGS)
 AM_CPPFLAGS = $(XORG_INCS)
diff --git a/hw/xfree86/ramdac/TI.c b/hw/xfree86/ramdac/TI.c
new file mode 100644
index 000000000..0ae1db57e
--- /dev/null
+++ b/hw/xfree86/ramdac/TI.c
@@ -0,0 +1,726 @@
+/*
+ * Copyright 1998 by Alan Hourihane, Wigan, England.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Alan Hourihane not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Alan Hourihane makes no representations
+ * about the suitability of this software for any purpose.  It is provided
+ * "as is" without express or implied warranty.
+ *
+ * ALAN HOURIHANE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL ALAN HOURIHANE BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authors:  Alan Hourihane, <alanh@fairlite.demon.co.uk>
+ *
+ * Modified from IBM.c to support TI RAMDAC routines
+ *   by Jens Owen, <jens@tungstengraphics.com>.
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include "xf86Cursor.h"
+
+#define INIT_TI_RAMDAC_INFO
+#include "TIPriv.h"
+#include "xf86RamDacPriv.h"
+
+/* The following values are in kHz */
+#define TI_MIN_VCO_FREQ  110000
+#define TI_MAX_VCO_FREQ  220000
+
+unsigned long
+TIramdacCalculateMNPForClock(unsigned long RefClock,    /* In 100Hz units */
+                             unsigned long ReqClock,    /* In 100Hz units */
+                             char IsPixClock,   /* boolean, is this the pixel or the sys clock */
+                             unsigned long MinClock,    /* Min VCO rating */
+                             unsigned long MaxClock,    /* Max VCO rating */
+                             unsigned long *rM, /* M Out */
+                             unsigned long *rN, /* N Out */
+                             unsigned long *rP  /* Min P In, P Out */
+    )
+{
+    unsigned long n, p;
+    unsigned long best_m = 0, best_n = 0;
+    double VCO, IntRef = (double) RefClock;
+    double m_err, inc_m, calc_m;
+    unsigned long ActualClock;
+
+    /* Make sure that MinClock <= ReqClock <= MaxClock */
+    if (ReqClock < MinClock)
+        ReqClock = MinClock;
+    if (ReqClock > MaxClock)
+        ReqClock = MaxClock;
+
+    /*
+     * ActualClock = VCO / 2 ^ p
+     * Choose p so that TI_MIN_VCO_FREQ <= VCO <= TI_MAX_VCO_FREQ
+     * Note that since TI_MAX_VCO_FREQ = 2 * TI_MIN_VCO_FREQ
+     * we don't have to bother checking for this maximum limit.
+     */
+    VCO = (double) ReqClock;
+    for (p = 0; p < 3 && VCO < TI_MIN_VCO_FREQ; (p)++)
+        VCO *= 2.0;
+
+    /*
+     * We avoid doing multiplications by ( 65 - n ),
+     * and add an increment instead - this keeps any error small.
+     */
+    inc_m = VCO / (IntRef * 8.0);
+
+    /* Initial value of calc_m for the loop */
+    calc_m = inc_m + inc_m + inc_m;
+
+    /* Initial amount of error for an integer - impossibly large */
+    m_err = 2.0;
+
+    /* Search for the closest INTEGER value of ( 65 - m ) */
+    for (n = 3; n <= 25; (n)++, calc_m += inc_m) {
+
+        /* Ignore values of ( 65 - m ) which we can't use */
+        if (calc_m < 3.0 || calc_m > 64.0)
+            continue;
+
+        /*
+         * Pick the closest INTEGER (has smallest fractional part).
+         * The optimizer should clean this up for us.
+         */
+        if ((calc_m - (int) calc_m) < m_err) {
+            m_err = calc_m - (int) calc_m;
+            best_m = (int) calc_m;
+            best_n = n;
+        }
+    }
+
+    /* 65 - ( 65 - x ) = x */
+    *rM = 65 - best_m;
+    *rN = 65 - best_n;
+    *rP = p;
+
+    /* Now all the calculations can be completed */
+    VCO = 8.0 * IntRef * best_m / best_n;
+    ActualClock = VCO / (1 << p);
+
+    DebugF("f_out=%ld f_vco=%.1f n=%lu m=%lu p=%lu\n",
+           ActualClock, VCO, *rN, *rM, *rP);
+
+    return ActualClock;
+}
+
+void
+TIramdacRestore(ScrnInfoPtr pScrn, RamDacRecPtr ramdacPtr,
+                RamDacRegRecPtr ramdacReg)
+{
+    int i;
+    unsigned long status;
+
+    /* Here we pass a short, so that we can evaluate a mask too
+     * So that the mask is the high byte and the data the low byte
+     * Order is important
+     */
+    TIRESTORE(TIDAC_latch_ctrl);
+    TIRESTORE(TIDAC_true_color_ctrl);
+    TIRESTORE(TIDAC_multiplex_ctrl);
+    TIRESTORE(TIDAC_clock_select);
+    TIRESTORE(TIDAC_palette_page);
+    TIRESTORE(TIDAC_general_ctrl);
+    TIRESTORE(TIDAC_misc_ctrl);
+    /* 0x2A & 0x2B are reserved */
+    TIRESTORE(TIDAC_key_over_low);
+    TIRESTORE(TIDAC_key_over_high);
+    TIRESTORE(TIDAC_key_red_low);
+    TIRESTORE(TIDAC_key_red_high);
+    TIRESTORE(TIDAC_key_green_low);
+    TIRESTORE(TIDAC_key_green_high);
+    TIRESTORE(TIDAC_key_blue_low);
+    TIRESTORE(TIDAC_key_blue_high);
+    TIRESTORE(TIDAC_key_ctrl);
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_clock_ctrl, 0, 0x30);
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_clock_ctrl, 0, 0x38);
+    TIRESTORE(TIDAC_clock_ctrl);
+    TIRESTORE(TIDAC_sense_test);
+    TIRESTORE(TIDAC_ind_curs_ctrl);
+
+    /* only restore clocks if they were valid to begin with */
+
+    if (ramdacReg->DacRegs[TIDAC_PIXEL_VALID]) {
+        /* Reset pixel clock */
+        (*ramdacPtr->WriteDAC) (pScrn, TIDAC_pll_addr, 0, 0x22);
+        (*ramdacPtr->WriteDAC) (pScrn, TIDAC_pll_pixel_data, 0, 0x3c);
+
+        /* Restore N, M & P values for pixel clocks */
+        (*ramdacPtr->WriteDAC) (pScrn, TIDAC_pll_addr, 0, 0);
+        (*ramdacPtr->WriteDAC) (pScrn, TIDAC_pll_pixel_data, 0,
+                                ramdacReg->DacRegs[TIDAC_PIXEL_N]);
+        (*ramdacPtr->WriteDAC) (pScrn, TIDAC_pll_pixel_data, 0,
+                                ramdacReg->DacRegs[TIDAC_PIXEL_M]);
+        (*ramdacPtr->WriteDAC) (pScrn, TIDAC_pll_pixel_data, 0,
+                                ramdacReg->DacRegs[TIDAC_PIXEL_P]);
+
+        /* wait for pixel clock to lock */
+        i = 1000000;
+        do {
+            status = (*ramdacPtr->ReadDAC) (pScrn, TIDAC_pll_pixel_data);
+        } while ((!(status & 0x40)) && (--i));
+        if (!(status & 0x40)) {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                       "Pixel clock setup timed out\n");
+            return;
+        }
+    }
+
+    if (ramdacReg->DacRegs[TIDAC_LOOP_VALID]) {
+        /* Reset loop clock */
+        (*ramdacPtr->WriteDAC) (pScrn, TIDAC_pll_addr, 0, 0x22);
+        (*ramdacPtr->WriteDAC) (pScrn, TIDAC_pll_loop_data, 0, 0x70);
+
+        /* Restore N, M & P values for pixel clocks */
+        (*ramdacPtr->WriteDAC) (pScrn, TIDAC_pll_addr, 0, 0);
+        (*ramdacPtr->WriteDAC) (pScrn, TIDAC_pll_loop_data, 0,
+                                ramdacReg->DacRegs[TIDAC_LOOP_N]);
+        (*ramdacPtr->WriteDAC) (pScrn, TIDAC_pll_loop_data, 0,
+                                ramdacReg->DacRegs[TIDAC_LOOP_M]);
+        (*ramdacPtr->WriteDAC) (pScrn, TIDAC_pll_loop_data, 0,
+                                ramdacReg->DacRegs[TIDAC_LOOP_P]);
+
+        /* wait for loop clock to lock */
+        i = 1000000;
+        do {
+            status = (*ramdacPtr->ReadDAC) (pScrn, TIDAC_pll_loop_data);
+        } while ((!(status & 0x40)) && (--i));
+        if (!(status & 0x40)) {
+            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                       "Loop clock setup timed out\n");
+            return;
+        }
+    }
+
+    /* restore palette */
+    (*ramdacPtr->WriteAddress) (pScrn, 0);
+#ifndef NOT_DONE
+    for (i = 0; i < 768; i++)
+        (*ramdacPtr->WriteData) (pScrn, ramdacReg->DAC[i]);
+#else
+    (*ramdacPtr->WriteData) (pScrn, 0);
+    (*ramdacPtr->WriteData) (pScrn, 0);
+    (*ramdacPtr->WriteData) (pScrn, 0);
+    for (i = 0; i < 765; i++)
+        (*ramdacPtr->WriteData) (pScrn, 0xff);
+#endif
+}
+
+void
+TIramdacSave(ScrnInfoPtr pScrn, RamDacRecPtr ramdacPtr,
+             RamDacRegRecPtr ramdacReg)
+{
+    int i;
+
+    (*ramdacPtr->ReadAddress) (pScrn, 0);
+    for (i = 0; i < 768; i++)
+        ramdacReg->DAC[i] = (*ramdacPtr->ReadData) (pScrn);
+
+    /* Read back N,M and P values for pixel clock */
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_pll_addr, 0, 0);
+    ramdacReg->DacRegs[TIDAC_PIXEL_N] =
+        (*ramdacPtr->ReadDAC) (pScrn, TIDAC_pll_pixel_data);
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_pll_addr, 0, 0x11);
+    ramdacReg->DacRegs[TIDAC_PIXEL_M] =
+        (*ramdacPtr->ReadDAC) (pScrn, TIDAC_pll_pixel_data);
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_pll_addr, 0, 0x22);
+    ramdacReg->DacRegs[TIDAC_PIXEL_P] =
+        (*ramdacPtr->ReadDAC) (pScrn, TIDAC_pll_pixel_data);
+
+    /* Read back N,M and P values for loop clock */
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_pll_addr, 0, 0);
+    ramdacReg->DacRegs[TIDAC_LOOP_N] =
+        (*ramdacPtr->ReadDAC) (pScrn, TIDAC_pll_loop_data);
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_pll_addr, 0, 0x11);
+    ramdacReg->DacRegs[TIDAC_LOOP_M] =
+        (*ramdacPtr->ReadDAC) (pScrn, TIDAC_pll_loop_data);
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_pll_addr, 0, 0x22);
+    ramdacReg->DacRegs[TIDAC_LOOP_P] =
+        (*ramdacPtr->ReadDAC) (pScrn, TIDAC_pll_loop_data);
+
+    /* Order is important */
+    TISAVE(TIDAC_latch_ctrl);
+    TISAVE(TIDAC_true_color_ctrl);
+    TISAVE(TIDAC_multiplex_ctrl);
+    TISAVE(TIDAC_clock_select);
+    TISAVE(TIDAC_palette_page);
+    TISAVE(TIDAC_general_ctrl);
+    TISAVE(TIDAC_misc_ctrl);
+    /* 0x2A & 0x2B are reserved */
+    TISAVE(TIDAC_key_over_low);
+    TISAVE(TIDAC_key_over_high);
+    TISAVE(TIDAC_key_red_low);
+    TISAVE(TIDAC_key_red_high);
+    TISAVE(TIDAC_key_green_low);
+    TISAVE(TIDAC_key_green_high);
+    TISAVE(TIDAC_key_blue_low);
+    TISAVE(TIDAC_key_blue_high);
+    TISAVE(TIDAC_key_ctrl);
+    TISAVE(TIDAC_clock_ctrl);
+    TISAVE(TIDAC_sense_test);
+    TISAVE(TIDAC_ind_curs_ctrl);
+}
+
+RamDacHelperRecPtr
+TIramdacProbe(ScrnInfoPtr pScrn, RamDacSupportedInfoRecPtr ramdacs)
+{
+    RamDacRecPtr ramdacPtr = RAMDACSCRPTR(pScrn);
+    RamDacHelperRecPtr ramdacHelperPtr = NULL;
+    Bool RamDacIsSupported = FALSE;
+    int TIramdac_ID = -1;
+    int i;
+    unsigned char id, rev, rev2, id2;
+
+    /* read ID and revision */
+    rev = (*ramdacPtr->ReadDAC) (pScrn, TIDAC_rev);
+    id = (*ramdacPtr->ReadDAC) (pScrn, TIDAC_id);
+
+    /* check if ID and revision are read only */
+    (*ramdacPtr->WriteDAC) (pScrn, ~rev, 0, TIDAC_rev);
+    (*ramdacPtr->WriteDAC) (pScrn, ~id, 0, TIDAC_id);
+    rev2 = (*ramdacPtr->ReadDAC) (pScrn, TIDAC_rev);
+    id2 = (*ramdacPtr->ReadDAC) (pScrn, TIDAC_id);
+
+    switch (id) {
+    case TIDAC_TVP_3030_ID:
+        if (id == id2 && rev == rev2)   /* check for READ ONLY */
+            TIramdac_ID = TI3030_RAMDAC;
+        break;
+    case TIDAC_TVP_3026_ID:
+        if (id == id2 && rev == rev2)   /* check for READ ONLY */
+            TIramdac_ID = TI3026_RAMDAC;
+        break;
+    }
+
+    (*ramdacPtr->WriteDAC) (pScrn, rev, 0, TIDAC_rev);
+    (*ramdacPtr->WriteDAC) (pScrn, id, 0, TIDAC_id);
+
+    if (TIramdac_ID == -1) {
+        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                   "Cannot determine TI RAMDAC type, aborting\n");
+        return NULL;
+    }
+    else {
+        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                   "Attached RAMDAC is %s\n",
+                   TIramdacDeviceInfo[TIramdac_ID & 0xFFFF].DeviceName);
+    }
+
+    for (i = 0; ramdacs[i].token != -1; i++) {
+        if (ramdacs[i].token == TIramdac_ID)
+            RamDacIsSupported = TRUE;
+    }
+
+    if (!RamDacIsSupported) {
+        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
+                   "This TI RAMDAC is NOT supported by this driver, aborting\n");
+        return NULL;
+    }
+
+    ramdacHelperPtr = RamDacHelperCreateInfoRec();
+    switch (TIramdac_ID) {
+    case TI3030_RAMDAC:
+        ramdacHelperPtr->SetBpp = TIramdac3030SetBpp;
+        ramdacHelperPtr->HWCursorInit = TIramdacHWCursorInit;
+        break;
+    case TI3026_RAMDAC:
+        ramdacHelperPtr->SetBpp = TIramdac3026SetBpp;
+        ramdacHelperPtr->HWCursorInit = TIramdacHWCursorInit;
+        break;
+    }
+    ramdacPtr->RamDacType = TIramdac_ID;
+    ramdacHelperPtr->RamDacType = TIramdac_ID;
+    ramdacHelperPtr->Save = TIramdacSave;
+    ramdacHelperPtr->Restore = TIramdacRestore;
+
+    return ramdacHelperPtr;
+}
+
+void
+TIramdac3026SetBpp(ScrnInfoPtr pScrn, RamDacRegRecPtr ramdacReg)
+{
+    switch (pScrn->bitsPerPixel) {
+    case 32:
+        /* order is important */
+        ramdacReg->DacRegs[TIDAC_latch_ctrl] = 0x06;
+        ramdacReg->DacRegs[TIDAC_true_color_ctrl] = 0x46;
+        ramdacReg->DacRegs[TIDAC_multiplex_ctrl] = 0x5c;
+        ramdacReg->DacRegs[TIDAC_clock_select] = 0x05;
+        ramdacReg->DacRegs[TIDAC_palette_page] = 0x00;
+        ramdacReg->DacRegs[TIDAC_general_ctrl] = 0x10;
+        ramdacReg->DacRegs[TIDAC_misc_ctrl] = 0x3C;
+        /* 0x2A & 0x2B are reserved */
+        ramdacReg->DacRegs[TIDAC_key_over_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_over_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_red_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_red_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_green_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_green_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_blue_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_blue_high] = 0x00;
+        ramdacReg->DacRegs[TIDAC_key_ctrl] = 0x10;
+        ramdacReg->DacRegs[TIDAC_sense_test] = 0x00;
+        if (pScrn->overlayFlags & OVERLAY_8_32_PLANAR) {
+            ramdacReg->DacRegs[TIDAC_true_color_ctrl] = 0x06;
+            ramdacReg->DacRegs[TIDAC_misc_ctrl] = 0x3C;
+            ramdacReg->DacRegs[TIDAC_key_ctrl] = 0x01;
+        }
+        ramdacReg->DacRegs[TIDAC_ind_curs_ctrl] = 0x00;
+        break;
+    case 24:
+        /* order is important */
+        ramdacReg->DacRegs[TIDAC_latch_ctrl] = 0x06;
+        ramdacReg->DacRegs[TIDAC_true_color_ctrl] = 0x56;
+        ramdacReg->DacRegs[TIDAC_multiplex_ctrl] = 0x58;
+        ramdacReg->DacRegs[TIDAC_clock_select] = 0x25;
+        ramdacReg->DacRegs[TIDAC_palette_page] = 0x00;
+        ramdacReg->DacRegs[TIDAC_general_ctrl] = 0x00;
+        ramdacReg->DacRegs[TIDAC_misc_ctrl] = 0x2C;
+        /* 0x2A & 0x2B are reserved */
+        ramdacReg->DacRegs[TIDAC_key_over_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_over_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_red_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_red_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_green_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_green_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_blue_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_blue_high] = 0x00;
+        ramdacReg->DacRegs[TIDAC_key_ctrl] = 0x10;
+        ramdacReg->DacRegs[TIDAC_sense_test] = 0x00;
+        ramdacReg->DacRegs[TIDAC_ind_curs_ctrl] = 0x00;
+        break;
+    case 16:
+        /* order is important */
+#if 0
+        /* Matrox driver uses this */
+        ramdacReg->DacRegs[TIDAC_latch_ctrl] = 0x07;
+#else
+        ramdacReg->DacRegs[TIDAC_latch_ctrl] = 0x06;
+#endif
+        if (pScrn->depth == 16) {
+            ramdacReg->DacRegs[TIDAC_true_color_ctrl] = 0x45;
+        }
+        else {
+            ramdacReg->DacRegs[TIDAC_true_color_ctrl] = 0x44;
+        }
+#if 0
+        /* Matrox driver uses this */
+        ramdacReg->DacRegs[TIDAC_multiplex_ctrl] = 0x50;
+        ramdacReg->DacRegs[TIDAC_clock_select] = 0x15;
+        ramdacReg->DacRegs[TIDAC_palette_page] = 0x00;
+        ramdacReg->DacRegs[TIDAC_general_ctrl] = 0x00;
+#else
+        ramdacReg->DacRegs[TIDAC_multiplex_ctrl] = 0x54;
+        ramdacReg->DacRegs[TIDAC_clock_select] = 0x05;
+        ramdacReg->DacRegs[TIDAC_palette_page] = 0x00;
+        ramdacReg->DacRegs[TIDAC_general_ctrl] = 0x10;
+#endif
+        ramdacReg->DacRegs[TIDAC_misc_ctrl] = 0x2C;
+        /* 0x2A & 0x2B are reserved */
+        ramdacReg->DacRegs[TIDAC_key_over_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_over_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_red_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_red_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_green_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_green_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_blue_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_blue_high] = 0x00;
+        ramdacReg->DacRegs[TIDAC_key_ctrl] = 0x10;
+        ramdacReg->DacRegs[TIDAC_sense_test] = 0x00;
+        ramdacReg->DacRegs[TIDAC_ind_curs_ctrl] = 0x00;
+        break;
+    case 8:
+        /* order is important */
+        ramdacReg->DacRegs[TIDAC_latch_ctrl] = 0x06;
+        ramdacReg->DacRegs[TIDAC_true_color_ctrl] = 0x80;
+        ramdacReg->DacRegs[TIDAC_multiplex_ctrl] = 0x4c;
+        ramdacReg->DacRegs[TIDAC_clock_select] = 0x05;
+        ramdacReg->DacRegs[TIDAC_palette_page] = 0x00;
+        ramdacReg->DacRegs[TIDAC_general_ctrl] = 0x10;
+        ramdacReg->DacRegs[TIDAC_misc_ctrl] = 0x1C;
+        /* 0x2A & 0x2B are reserved */
+        ramdacReg->DacRegs[TIDAC_key_over_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_over_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_red_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_red_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_green_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_green_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_blue_low] = 0x00;
+        ramdacReg->DacRegs[TIDAC_key_blue_high] = 0x00;
+        ramdacReg->DacRegs[TIDAC_key_ctrl] = 0x00;
+        ramdacReg->DacRegs[TIDAC_sense_test] = 0x00;
+        ramdacReg->DacRegs[TIDAC_ind_curs_ctrl] = 0x00;
+        break;
+    }
+}
+
+void
+TIramdac3030SetBpp(ScrnInfoPtr pScrn, RamDacRegRecPtr ramdacReg)
+{
+    switch (pScrn->bitsPerPixel) {
+    case 32:
+        /* order is important */
+        ramdacReg->DacRegs[TIDAC_latch_ctrl] = 0x06;
+        ramdacReg->DacRegs[TIDAC_true_color_ctrl] = 0x46;
+        ramdacReg->DacRegs[TIDAC_multiplex_ctrl] = 0x5D;
+        ramdacReg->DacRegs[TIDAC_clock_select] = 0x05;
+        ramdacReg->DacRegs[TIDAC_palette_page] = 0x00;
+        ramdacReg->DacRegs[TIDAC_general_ctrl] = 0x10;
+        ramdacReg->DacRegs[TIDAC_misc_ctrl] = 0x3C;
+        /* 0x2A & 0x2B are reserved */
+        ramdacReg->DacRegs[TIDAC_key_over_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_over_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_red_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_red_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_green_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_green_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_blue_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_blue_high] = 0x00;
+        ramdacReg->DacRegs[TIDAC_key_ctrl] = 0x10;
+        ramdacReg->DacRegs[TIDAC_sense_test] = 0x00;
+        if (pScrn->overlayFlags & OVERLAY_8_32_PLANAR) {
+            ramdacReg->DacRegs[TIDAC_true_color_ctrl] = 0x06;
+            ramdacReg->DacRegs[TIDAC_misc_ctrl] = 0x3C;
+            ramdacReg->DacRegs[TIDAC_key_ctrl] = 0x01;
+        }
+        ramdacReg->DacRegs[TIDAC_ind_curs_ctrl] = 0x00;
+        break;
+    case 24:
+        /* order is important */
+        ramdacReg->DacRegs[TIDAC_latch_ctrl] = 0x06;
+        ramdacReg->DacRegs[TIDAC_true_color_ctrl] = 0x56;
+        ramdacReg->DacRegs[TIDAC_multiplex_ctrl] = 0x58;
+        ramdacReg->DacRegs[TIDAC_clock_select] = 0x25;
+        ramdacReg->DacRegs[TIDAC_palette_page] = 0x00;
+        ramdacReg->DacRegs[TIDAC_general_ctrl] = 0x00;
+        ramdacReg->DacRegs[TIDAC_misc_ctrl] = 0x2C;
+        /* 0x2A & 0x2B are reserved */
+        ramdacReg->DacRegs[TIDAC_key_over_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_over_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_red_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_red_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_green_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_green_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_blue_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_blue_high] = 0x00;
+        ramdacReg->DacRegs[TIDAC_key_ctrl] = 0x10;
+        ramdacReg->DacRegs[TIDAC_sense_test] = 0x00;
+        ramdacReg->DacRegs[TIDAC_ind_curs_ctrl] = 0x00;
+        break;
+    case 16:
+        /* order is important */
+#if 0
+        /* Matrox driver uses this */
+        ramdacReg->DacRegs[TIDAC_latch_ctrl] = 0x07;
+#else
+        ramdacReg->DacRegs[TIDAC_latch_ctrl] = 0x06;
+#endif
+        if (pScrn->depth == 16) {
+            ramdacReg->DacRegs[TIDAC_true_color_ctrl] = 0x45;
+        }
+        else {
+            ramdacReg->DacRegs[TIDAC_true_color_ctrl] = 0x44;
+        }
+#if 0
+        /* Matrox driver uses this */
+        ramdacReg->DacRegs[TIDAC_multiplex_ctrl] = 0x50;
+        ramdacReg->DacRegs[TIDAC_clock_select] = 0x15;
+        ramdacReg->DacRegs[TIDAC_palette_page] = 0x00;
+        ramdacReg->DacRegs[TIDAC_general_ctrl] = 0x00;
+#else
+        ramdacReg->DacRegs[TIDAC_multiplex_ctrl] = 0x55;
+        ramdacReg->DacRegs[TIDAC_clock_select] = 0x85;
+        ramdacReg->DacRegs[TIDAC_palette_page] = 0x00;
+        ramdacReg->DacRegs[TIDAC_general_ctrl] = 0x10;
+#endif
+        ramdacReg->DacRegs[TIDAC_misc_ctrl] = 0x2C;
+        /* 0x2A & 0x2B are reserved */
+        ramdacReg->DacRegs[TIDAC_key_over_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_over_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_red_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_red_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_green_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_green_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_blue_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_blue_high] = 0x00;
+        ramdacReg->DacRegs[TIDAC_key_ctrl] = 0x10;
+        ramdacReg->DacRegs[TIDAC_sense_test] = 0x00;
+        ramdacReg->DacRegs[TIDAC_ind_curs_ctrl] = 0x00;
+        break;
+    case 8:
+        /* order is important */
+        ramdacReg->DacRegs[TIDAC_latch_ctrl] = 0x06;
+        ramdacReg->DacRegs[TIDAC_true_color_ctrl] = 0x80;
+        ramdacReg->DacRegs[TIDAC_multiplex_ctrl] = 0x4d;
+        ramdacReg->DacRegs[TIDAC_clock_select] = 0x05;
+        ramdacReg->DacRegs[TIDAC_palette_page] = 0x00;
+        ramdacReg->DacRegs[TIDAC_general_ctrl] = 0x10;
+        ramdacReg->DacRegs[TIDAC_misc_ctrl] = 0x1C;
+        /* 0x2A & 0x2B are reserved */
+        ramdacReg->DacRegs[TIDAC_key_over_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_over_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_red_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_red_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_green_low] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_green_high] = 0xFF;
+        ramdacReg->DacRegs[TIDAC_key_blue_low] = 0x00;
+        ramdacReg->DacRegs[TIDAC_key_blue_high] = 0x00;
+        ramdacReg->DacRegs[TIDAC_key_ctrl] = 0x00;
+        ramdacReg->DacRegs[TIDAC_sense_test] = 0x00;
+        ramdacReg->DacRegs[TIDAC_ind_curs_ctrl] = 0x00;
+        break;
+    }
+}
+
+static void
+TIramdacShowCursor(ScrnInfoPtr pScrn)
+{
+    RamDacRecPtr ramdacPtr = RAMDACSCRPTR(pScrn);
+
+    /* Enable cursor - X11 mode */
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_ind_curs_ctrl, 0, 0x03);
+}
+
+static void
+TIramdacHideCursor(ScrnInfoPtr pScrn)
+{
+    RamDacRecPtr ramdacPtr = RAMDACSCRPTR(pScrn);
+
+    /* Disable cursor - X11 mode */
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_ind_curs_ctrl, 0, 0x00);
+}
+
+static void
+TIramdacSetCursorPosition(ScrnInfoPtr pScrn, int x, int y)
+{
+    RamDacRecPtr ramdacPtr = RAMDACSCRPTR(pScrn);
+
+    x += 64;
+    y += 64;
+
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_CURS_XLOW, 0, x & 0xff);
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_CURS_XHIGH, 0, (x >> 8) & 0x0f);
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_CURS_YLOW, 0, y & 0xff);
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_CURS_YHIGH, 0, (y >> 8) & 0x0f);
+}
+
+static void
+TIramdacSetCursorColors(ScrnInfoPtr pScrn, int bg, int fg)
+{
+    RamDacRecPtr ramdacPtr = RAMDACSCRPTR(pScrn);
+
+    /* Background color */
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_CURS_WRITE_ADDR, 0, 1);
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_CURS_COLOR, 0,
+                            ((bg & 0x00ff0000) >> 16));
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_CURS_COLOR, 0,
+                            ((bg & 0x0000ff00) >> 8));
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_CURS_COLOR, 0, (bg & 0x000000ff));
+
+    /* Foreground color */
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_CURS_WRITE_ADDR, 0, 2);
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_CURS_COLOR, 0,
+                            ((fg & 0x00ff0000) >> 16));
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_CURS_COLOR, 0,
+                            ((fg & 0x0000ff00) >> 8));
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_CURS_COLOR, 0, (fg & 0x000000ff));
+}
+
+static Bool
+TIramdacLoadCursorImage(ScrnInfoPtr pScrn, unsigned char *src)
+{
+    RamDacRecPtr ramdacPtr = RAMDACSCRPTR(pScrn);
+    int i = 1024;
+
+    /* reset A9,A8 */
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_ind_curs_ctrl, 0, 0x00);
+    /* reset cursor RAM load address A7..A0 */
+    (*ramdacPtr->WriteDAC) (pScrn, TIDAC_INDEX, 0x00, 0x00);
+
+    while (i--) {
+        /* NOT_DONE: might need a delay here */
+        (*ramdacPtr->WriteDAC) (pScrn, TIDAC_CURS_RAM_DATA, 0, *(src++));
+    }
+    return TRUE;
+}
+
+static Bool
+TIramdacUseHWCursor(ScreenPtr pScr, CursorPtr pCurs)
+{
+    return TRUE;
+}
+
+void
+TIramdacHWCursorInit(xf86CursorInfoPtr infoPtr)
+{
+    infoPtr->MaxWidth = 64;
+    infoPtr->MaxHeight = 64;
+    infoPtr->Flags = HARDWARE_CURSOR_BIT_ORDER_MSBFIRST |
+        HARDWARE_CURSOR_TRUECOLOR_AT_8BPP |
+        HARDWARE_CURSOR_SOURCE_MASK_NOT_INTERLEAVED;
+    infoPtr->SetCursorColors = TIramdacSetCursorColors;
+    infoPtr->SetCursorPosition = TIramdacSetCursorPosition;
+    infoPtr->LoadCursorImageCheck = TIramdacLoadCursorImage;
+    infoPtr->HideCursor = TIramdacHideCursor;
+    infoPtr->ShowCursor = TIramdacShowCursor;
+    infoPtr->UseHWCursor = TIramdacUseHWCursor;
+}
+
+void
+TIramdacLoadPalette(ScrnInfoPtr pScrn,
+                    int numColors,
+                    int *indices, LOCO * colors, VisualPtr pVisual)
+{
+    RamDacRecPtr hwp = RAMDACSCRPTR(pScrn);
+    int i, index, shift;
+
+    if (pScrn->depth == 16) {
+        for (i = 0; i < numColors; i++) {
+            index = indices[i];
+            (*hwp->WriteAddress) (pScrn, index << 2);
+            (*hwp->WriteData) (pScrn, colors[index >> 1].red);
+            (*hwp->WriteData) (pScrn, colors[index].green);
+            (*hwp->WriteData) (pScrn, colors[index >> 1].blue);
+
+            if (index <= 31) {
+                (*hwp->WriteAddress) (pScrn, index << 3);
+                (*hwp->WriteData) (pScrn, colors[index].red);
+                (*hwp->WriteData) (pScrn, colors[(index << 1) + 1].green);
+                (*hwp->WriteData) (pScrn, colors[index].blue);
+            }
+        }
+    }
+    else {
+        shift = (pScrn->depth == 15) ? 3 : 0;
+
+        for (i = 0; i < numColors; i++) {
+            index = indices[i];
+            (*hwp->WriteAddress) (pScrn, index << shift);
+            (*hwp->WriteData) (pScrn, colors[index].red);
+            (*hwp->WriteData) (pScrn, colors[index].green);
+            (*hwp->WriteData) (pScrn, colors[index].blue);
+        }
+    }
+}
+
+TIramdacLoadPaletteProc *
+TIramdacLoadPaletteWeak(void)
+{
+    return TIramdacLoadPalette;
+}
diff --git a/hw/xfree86/ramdac/TI.h b/hw/xfree86/ramdac/TI.h
new file mode 100644
index 000000000..3969ee71d
--- /dev/null
+++ b/hw/xfree86/ramdac/TI.h
@@ -0,0 +1,106 @@
+
+#include <xf86RamDac.h>
+
+extern _X_EXPORT unsigned long TIramdacCalculateMNPForClock(unsigned long
+                                                            RefClock,
+                                                            unsigned long
+                                                            ReqClock,
+                                                            char IsPixClock,
+                                                            unsigned long
+                                                            MinClock,
+                                                            unsigned long
+                                                            MaxClock,
+                                                            unsigned long *rM,
+                                                            unsigned long *rN,
+                                                            unsigned long *rP);
+extern _X_EXPORT RamDacHelperRecPtr TIramdacProbe(ScrnInfoPtr pScrn,
+                                                  RamDacSupportedInfoRecPtr
+                                                  ramdacs);
+extern _X_EXPORT void TIramdacSave(ScrnInfoPtr pScrn, RamDacRecPtr RamDacRec,
+                                   RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void TIramdacRestore(ScrnInfoPtr pScrn, RamDacRecPtr RamDacRec,
+                                      RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void TIramdac3026SetBpp(ScrnInfoPtr pScrn,
+                                         RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void TIramdac3030SetBpp(ScrnInfoPtr pScrn,
+                                         RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void TIramdacHWCursorInit(xf86CursorInfoPtr infoPtr);
+extern _X_EXPORT void TIramdacLoadPalette(ScrnInfoPtr pScrn, int numColors,
+                                          int *indices, LOCO * colors,
+                                          VisualPtr pVisual);
+
+typedef void TIramdacLoadPaletteProc(ScrnInfoPtr, int, int *, LOCO *,
+                                     VisualPtr);
+extern _X_EXPORT TIramdacLoadPaletteProc *TIramdacLoadPaletteWeak(void);
+
+#define TI3030_RAMDAC		(VENDOR_TI << 16) | 0x00
+#define TI3026_RAMDAC		(VENDOR_TI << 16) | 0x01
+
+/*
+ * TI Ramdac registers
+ */
+
+#define TIDAC_rev		0x01
+#define TIDAC_ind_curs_ctrl	0x06
+#define TIDAC_byte_router_ctrl	0x07
+#define TIDAC_latch_ctrl	0x0f
+#define TIDAC_true_color_ctrl	0x18
+#define TIDAC_multiplex_ctrl	0x19
+#define TIDAC_clock_select	0x1a
+#define TIDAC_palette_page	0x1c
+#define TIDAC_general_ctrl	0x1d
+#define TIDAC_misc_ctrl		0x1e
+#define TIDAC_pll_addr		0x2c
+#define TIDAC_pll_pixel_data	0x2d
+#define TIDAC_pll_memory_data	0x2e
+#define TIDAC_pll_loop_data	0x2f
+#define TIDAC_key_over_low	0x30
+#define TIDAC_key_over_high	0x31
+#define TIDAC_key_red_low	0x32
+#define TIDAC_key_red_high	0x33
+#define TIDAC_key_green_low	0x34
+#define TIDAC_key_green_high	0x35
+#define TIDAC_key_blue_low	0x36
+#define TIDAC_key_blue_high	0x37
+#define TIDAC_key_ctrl		0x38
+#define TIDAC_clock_ctrl	0x39
+#define TIDAC_sense_test	0x3a
+#define TIDAC_test_mode_data	0x3b
+#define TIDAC_crc_remain_lsb	0x3c
+#define TIDAC_crc_remain_msb	0x3d
+#define TIDAC_crc_bit_select	0x3e
+#define TIDAC_id		0x3f
+
+/* These are pll values that are accessed via TIDAC_pll_pixel_data */
+#define TIDAC_PIXEL_N		0x80
+#define TIDAC_PIXEL_M		0x81
+#define TIDAC_PIXEL_P		0x82
+#define TIDAC_PIXEL_VALID	0x83
+
+/* These are pll values that are accessed via TIDAC_pll_loop_data */
+#define TIDAC_LOOP_N		0x90
+#define TIDAC_LOOP_M		0x91
+#define TIDAC_LOOP_P		0x92
+#define TIDAC_LOOP_VALID	0x93
+
+/* Direct mapping addresses */
+#define TIDAC_INDEX		0xa0
+#define TIDAC_PALETTE_DATA	0xa1
+#define TIDAC_READ_MASK		0xa2
+#define TIDAC_READ_ADDR		0xa3
+#define TIDAC_CURS_WRITE_ADDR	0xa4
+#define TIDAC_CURS_COLOR	0xa5
+#define TIDAC_CURS_READ_ADDR	0xa7
+#define TIDAC_CURS_CTL		0xa9
+#define TIDAC_INDEXED_DATA	0xaa
+#define TIDAC_CURS_RAM_DATA	0xab
+#define TIDAC_CURS_XLOW		0xac
+#define TIDAC_CURS_XHIGH	0xad
+#define TIDAC_CURS_YLOW		0xae
+#define TIDAC_CURS_YHIGH	0xaf
+
+#define TIDAC_sw_reset		0xff
+
+/* Constants */
+#define TIDAC_TVP_3026_ID       0x26
+#define TIDAC_TVP_3030_ID       0x30
diff --git a/hw/xfree86/ramdac/TIPriv.h b/hw/xfree86/ramdac/TIPriv.h
new file mode 100644
index 000000000..ece03483b
--- /dev/null
+++ b/hw/xfree86/ramdac/TIPriv.h
@@ -0,0 +1,29 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "TI.h"
+
+typedef struct {
+    const char *DeviceName;
+} xf86TIramdacInfo;
+
+extern xf86TIramdacInfo TIramdacDeviceInfo[];
+
+#ifdef INIT_TI_RAMDAC_INFO
+xf86TIramdacInfo TIramdacDeviceInfo[] = {
+    {"TI TVP3030"},
+    {"TI TVP3026"}
+};
+#endif
+
+#define TISAVE(_reg) do { 						\
+    ramdacReg->DacRegs[_reg] = (*ramdacPtr->ReadDAC)(pScrn, _reg);	\
+} while (0)
+
+#define TIRESTORE(_reg) do { 						\
+    (*ramdacPtr->WriteDAC)(pScrn, _reg, 				\
+	(ramdacReg->DacRegs[_reg] & 0xFF00) >> 8, 			\
+	ramdacReg->DacRegs[_reg]);					\
+} while (0)
diff --git a/hw/xfree86/ramdac/meson.build b/hw/xfree86/ramdac/meson.build
index 0a2bb4b79..babf2b821 100644
--- a/hw/xfree86/ramdac/meson.build
+++ b/hw/xfree86/ramdac/meson.build
@@ -1,6 +1,11 @@
 srcs_xorg_ramdac = [
+    'xf86RamDac.c',
+    'xf86RamDacCmap.c',
     'xf86CursorRD.c',
     'xf86HWCurs.c',
+    'IBM.c',
+    'BT.c',
+    'TI.c',
 ]
 
 xorg_ramdac = static_library('xorg_ramdac',
@@ -12,7 +17,11 @@ xorg_ramdac = static_library('xorg_ramdac',
 
 install_data(
     [
+        'BT.h',
+        'IBM.h',
+        'TI.h',
         'xf86Cursor.h',
+        'xf86RamDac.h',
     ],
     install_dir: xorgsdkdir,
 )
diff --git a/hw/xfree86/ramdac/xf86RamDac.c b/hw/xfree86/ramdac/xf86RamDac.c
new file mode 100644
index 000000000..a67164917
--- /dev/null
+++ b/hw/xfree86/ramdac/xf86RamDac.c
@@ -0,0 +1,152 @@
+/*
+ * Copyright 1998 by Alan Hourihane, Wigan, England.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Alan Hourihane not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Alan Hourihane makes no representations
+ * about the suitability of this software for any purpose.  It is provided
+ * "as is" without express or implied warranty.
+ *
+ * ALAN HOURIHANE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL ALAN HOURIHANE BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authors:  Alan Hourihane, <alanh@fairlite.demon.co.uk>
+ *
+ * Generic RAMDAC access routines.
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "xf86.h"
+#include "xf86_OSproc.h"
+
+#include "xf86RamDacPriv.h"
+
+int RamDacHWPrivateIndex = -1;
+int RamDacScreenPrivateIndex = -1;
+
+RamDacRecPtr
+RamDacCreateInfoRec(void)
+{
+    RamDacRecPtr infoRec;
+
+    infoRec = calloc(1, sizeof(RamDacRec));
+
+    return infoRec;
+}
+
+RamDacHelperRecPtr
+RamDacHelperCreateInfoRec(void)
+{
+    RamDacHelperRecPtr infoRec;
+
+    infoRec = calloc(1, sizeof(RamDacHelperRec));
+
+    return infoRec;
+}
+
+void
+RamDacDestroyInfoRec(RamDacRecPtr infoRec)
+{
+    free(infoRec);
+}
+
+void
+RamDacHelperDestroyInfoRec(RamDacHelperRecPtr infoRec)
+{
+    free(infoRec);
+}
+
+Bool
+RamDacInit(ScrnInfoPtr pScrn, RamDacRecPtr ramdacPriv)
+{
+    RamDacScreenRecPtr ramdacScrPtr;
+
+    /*
+     * make sure the RamDacRec is allocated
+     */
+    if (!RamDacGetRec(pScrn))
+        return FALSE;
+    ramdacScrPtr =
+        ((RamDacScreenRecPtr) (pScrn)->privates[RamDacGetScreenIndex()].ptr);
+    ramdacScrPtr->RamDacRec = ramdacPriv;
+
+    return TRUE;
+}
+
+void
+RamDacGetRecPrivate(void)
+{
+    if (RamDacHWPrivateIndex < 0)
+        RamDacHWPrivateIndex = xf86AllocateScrnInfoPrivateIndex();
+    if (RamDacScreenPrivateIndex < 0)
+        RamDacScreenPrivateIndex = xf86AllocateScrnInfoPrivateIndex();
+    return;
+}
+
+Bool
+RamDacGetRec(ScrnInfoPtr scrp)
+{
+    RamDacGetRecPrivate();
+    /*
+     * New privates are always set to NULL, so we can check if the allocation
+     * has already been done.
+     */
+    if (scrp->privates[RamDacHWPrivateIndex].ptr != NULL)
+        return TRUE;
+    if (scrp->privates[RamDacScreenPrivateIndex].ptr != NULL)
+        return TRUE;
+
+    scrp->privates[RamDacHWPrivateIndex].ptr =
+        xnfcalloc(sizeof(RamDacHWRec), 1);
+    scrp->privates[RamDacScreenPrivateIndex].ptr =
+        xnfcalloc(sizeof(RamDacScreenRec), 1);
+
+    return TRUE;
+}
+
+void
+RamDacFreeRec(ScrnInfoPtr pScrn)
+{
+    RamDacHWRecPtr ramdacHWPtr;
+    RamDacScreenRecPtr ramdacScrPtr;
+
+    if (RamDacHWPrivateIndex < 0)
+        return;
+
+    if (RamDacScreenPrivateIndex < 0)
+        return;
+
+    ramdacHWPtr = RAMDACHWPTR(pScrn);
+    ramdacScrPtr = ((RamDacScreenRecPtr)
+                    (pScrn)->privates[RamDacGetScreenIndex()].ptr);
+
+    free(ramdacHWPtr);
+    ramdacHWPtr = NULL;
+
+    free(ramdacScrPtr);
+    ramdacScrPtr = NULL;
+}
+
+int
+RamDacGetHWIndex(void)
+{
+    return RamDacHWPrivateIndex;
+}
+
+int
+RamDacGetScreenIndex(void)
+{
+    return RamDacScreenPrivateIndex;
+}
diff --git a/hw/xfree86/ramdac/xf86RamDac.h b/hw/xfree86/ramdac/xf86RamDac.h
new file mode 100644
index 000000000..af16b7faa
--- /dev/null
+++ b/hw/xfree86/ramdac/xf86RamDac.h
@@ -0,0 +1,88 @@
+
+#ifndef _XF86RAMDAC_H
+#define _XF86RAMDAC_H 1
+
+#include "colormapst.h"
+#include "xf86Cursor.h"
+
+/* Define unique vendor codes for RAMDAC's */
+#define VENDOR_IBM	0x0000
+#define VENDOR_BT	0x0001
+#define VENDOR_TI	0x0002
+
+typedef struct _RamDacRegRec {
+/* This is probably the nastiest assumption, we allocate 1024 slots for
+ * ramdac registers, should be enough. I've checked IBM and TVP series
+ * and they seem o.k
+ * Then we allocate 768 entries for the DAC too. IBM640 needs 1024 -FIXME
+ */
+    unsigned short DacRegs[0x400];      /* register set */
+    unsigned char DAC[0x300];   /* colour map */
+    Bool Overlay;
+} RamDacRegRec, *RamDacRegRecPtr;
+
+typedef struct _RamDacHWRegRec {
+    RamDacRegRec SavedReg;
+    RamDacRegRec ModeReg;
+} RamDacHWRec, *RamDacHWRecPtr;
+
+typedef struct _RamDacRec {
+    CARD32 RamDacType;
+
+    void (*LoadPalette) (ScrnInfoPtr pScrn,
+                         int numColors,
+                         int *indices, LOCO * colors, VisualPtr pVisual);
+
+    unsigned char (*ReadDAC) (ScrnInfoPtr pScrn, CARD32);
+
+    void (*WriteDAC) (ScrnInfoPtr pScrn, CARD32, unsigned char, unsigned char);
+
+    void (*WriteAddress) (ScrnInfoPtr pScrn, CARD32);
+
+    void (*WriteData) (ScrnInfoPtr pScrn, unsigned char);
+
+    void (*ReadAddress) (ScrnInfoPtr pScrn, CARD32);
+
+    unsigned char (*ReadData) (ScrnInfoPtr pScrn);
+} RamDacRec, *RamDacRecPtr;
+
+typedef struct _RamDacHelperRec {
+    CARD32 RamDacType;
+
+    void (*Restore) (ScrnInfoPtr pScrn,
+                     RamDacRecPtr ramdacPtr, RamDacRegRecPtr ramdacReg);
+
+    void (*Save) (ScrnInfoPtr pScrn,
+                  RamDacRecPtr ramdacPtr, RamDacRegRecPtr ramdacReg);
+
+    void (*SetBpp) (ScrnInfoPtr pScrn, RamDacRegRecPtr ramdacReg);
+
+    void (*HWCursorInit) (xf86CursorInfoPtr infoPtr);
+} RamDacHelperRec, *RamDacHelperRecPtr;
+
+#define RAMDACHWPTR(p) ((RamDacHWRecPtr)((p)->privates[RamDacGetHWIndex()].ptr))
+
+typedef struct _RamdacScreenRec {
+    RamDacRecPtr RamDacRec;
+} RamDacScreenRec, *RamDacScreenRecPtr;
+
+#define RAMDACSCRPTR(p) ((RamDacScreenRecPtr)((p)->privates[RamDacGetScreenIndex()].ptr))->RamDacRec
+
+extern _X_EXPORT int RamDacHWPrivateIndex;
+extern _X_EXPORT int RamDacScreenPrivateIndex;
+
+typedef struct {
+    int token;
+} RamDacSupportedInfoRec, *RamDacSupportedInfoRecPtr;
+
+extern _X_EXPORT RamDacRecPtr RamDacCreateInfoRec(void);
+extern _X_EXPORT RamDacHelperRecPtr RamDacHelperCreateInfoRec(void);
+extern _X_EXPORT void RamDacDestroyInfoRec(RamDacRecPtr RamDacRec);
+extern _X_EXPORT void RamDacHelperDestroyInfoRec(RamDacHelperRecPtr RamDacRec);
+extern _X_EXPORT Bool RamDacInit(ScrnInfoPtr pScrn, RamDacRecPtr RamDacRec);
+extern _X_EXPORT Bool RamDacHandleColormaps(ScreenPtr pScreen, int maxColors,
+                                            int sigRGBbits, unsigned int flags);
+extern _X_EXPORT void RamDacFreeRec(ScrnInfoPtr pScrn);
+extern _X_EXPORT int RamDacGetHWIndex(void);
+
+#endif                          /* _XF86RAMDAC_H */
diff --git a/hw/xfree86/ramdac/xf86RamDacCmap.c b/hw/xfree86/ramdac/xf86RamDacCmap.c
new file mode 100644
index 000000000..2a0f75569
--- /dev/null
+++ b/hw/xfree86/ramdac/xf86RamDacCmap.c
@@ -0,0 +1,70 @@
+/*
+ * Copyright 1998 by Alan Hourihane, Wigan, England.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Alan Hourihane not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Alan Hourihane makes no representations
+ * about the suitability of this software for any purpose.  It is provided
+ * "as is" without express or implied warranty.
+ *
+ * ALAN HOURIHANE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL ALAN HOURIHANE BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authors:  Alan Hourihane, <alanh@fairlite.demon.co.uk>
+ *
+ * Generic RAMDAC access to colormaps.
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <X11/X.h>
+#include <X11/Xproto.h>
+#include "windowstr.h"
+#include "mipointer.h"
+#include "micmap.h"
+
+#include "xf86.h"
+#include "colormapst.h"
+#include "xf86RamDacPriv.h"
+
+void
+RamDacLoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices, LOCO * colors,
+                  VisualPtr pVisual)
+{
+    RamDacRecPtr hwp = RAMDACSCRPTR(pScrn);
+    int i, index;
+
+    for (i = 0; i < numColors; i++) {
+        index = indices[i];
+        (*hwp->WriteAddress) (pScrn, index);
+        (*hwp->WriteData) (pScrn, colors[index].red);
+        (*hwp->WriteData) (pScrn, colors[index].green);
+        (*hwp->WriteData) (pScrn, colors[index].blue);
+    }
+}
+
+Bool
+RamDacHandleColormaps(ScreenPtr pScreen, int maxColors, int sigRGBbits,
+                      unsigned int flags)
+{
+    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
+    RamDacRecPtr hwp = RAMDACSCRPTR(pScrn);
+
+    if (hwp->LoadPalette == NULL)
+        return xf86HandleColormaps(pScreen, maxColors, sigRGBbits,
+                                   RamDacLoadPalette, NULL, flags);
+    else
+        return xf86HandleColormaps(pScreen, maxColors, sigRGBbits,
+                                   hwp->LoadPalette, NULL, flags);
+}
diff --git a/hw/xfree86/ramdac/xf86RamDacPriv.h b/hw/xfree86/ramdac/xf86RamDacPriv.h
new file mode 100644
index 000000000..ae1c665de
--- /dev/null
+++ b/hw/xfree86/ramdac/xf86RamDacPriv.h
@@ -0,0 +1,13 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "xf86RamDac.h"
+#include "xf86cmap.h"
+
+void RamDacGetRecPrivate(void);
+Bool RamDacGetRec(ScrnInfoPtr pScrn);
+int RamDacGetScreenIndex(void);
+void RamDacLoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices,
+                       LOCO * colors, VisualPtr pVisual);
diff --git a/hw/xfree86/sdksyms.sh b/hw/xfree86/sdksyms.sh
index 9d95c5052..6849bd451 100755
--- a/hw/xfree86/sdksyms.sh
+++ b/hw/xfree86/sdksyms.sh
@@ -148,7 +148,11 @@ cat > sdksyms.c << EOF
 
 
 /* hw/xfree86/ramdac/Makefile.am */
+#include "BT.h"
+#include "IBM.h"
+#include "TI.h"
 #include "xf86Cursor.h"
+#include "xf86RamDac.h"
 
 
 /* hw/xfree86/shadowfb/Makefile.am -- module */
