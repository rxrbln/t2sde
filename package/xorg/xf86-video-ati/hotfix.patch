# --- T2-COPYRIGHT-NOTE-BEGIN ---
# T2 SDE: package/*/xf86-video-ati/hotfix.patch
# Copyright (C) 2022 The T2 SDE Project
# 
# This Copyright note is generated by scripts/Create-CopyPatch,
# more information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License version 2 as used by the T2 SDE.
# --- T2-COPYRIGHT-NOTE-END ---

diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
new file mode 100644
index 00000000..52f9d491
--- /dev/null
+++ b/.gitlab-ci.yml
@@ -0,0 +1,134 @@
+# vim: set expandtab shiftwidth=2 tabstop=8 textwidth=0 filetype=yaml:
+
+# FDO_DISTRIBUTION_TAG is the tag of the docker image used for the build
+# jobs. If the image doesn't exist yet, the docker-image stage generates it
+# or copies it from upstream (this is all handled by the templates).
+#
+# In order to generate a new image, one should generally change the tag.
+# While removing the image from the registry would also work, that's not
+# recommended except for ephemeral images during development.
+#
+variables:
+  FDO_DISTRIBUTION_VERSION: buster-slim
+  FDO_DISTRIBUTION_EXEC: 'bash .gitlab-ci/debian-install.sh'
+  FDO_DISTRIBUTION_TAG: "2021-05-10"
+  FDO_UPSTREAM_REPO: xorg/driver/xf86-video-ati
+
+#
+# This CI uses the freedesktop.org ci-templates.
+# Please see the ci-templates documentation for details:
+# https://freedesktop.pages.freedesktop.org/ci-templates/
+
+.templates_sha: &template_sha 34f4ade99434043f88e164933f570301fd18b125 # see https://docs.gitlab.com/ee/ci/yaml/#includefile
+
+include:
+  - project: 'freedesktop/ci-templates'
+    ref: *template_sha
+    file: '/templates/debian.yml'
+  - project: 'freedesktop/ci-templates'
+    ref: *template_sha
+    file: '/templates/ci-fairy.yml'
+  - template: Security/SAST.gitlab-ci.yml
+
+
+stages:
+  - docker-image
+  - build
+  - test
+
+#
+# Verify that commit messages are as expected
+#
+check-commits:
+  extends:
+    - .fdo.ci-fairy
+  stage: test
+  script:
+    - ci-fairy check-commits --junit-xml=results.xml
+  except:
+    - master@$FDO_UPSTREAM_REPO
+  variables:
+    GIT_DEPTH: 100
+  artifacts:
+    reports:
+      junit: results.xml
+  allow_failure: true
+
+#
+# Verify that the merge request has the allow-collaboration checkbox ticked
+#
+check-merge-request:
+  extends:
+    - .fdo.ci-fairy
+  stage: test
+  script:
+    - ci-fairy check-merge-request --require-allow-collaboration --junit-xml=results.xml
+  artifacts:
+    when: on_failure
+    reports:
+      junit: results.xml
+  allow_failure: true
+
+
+#
+# Build a container with the given tag and the packages pre-installed.
+# This only happens if/when the tag changes, otherwise the existing image is
+# re-used.
+#
+container-build:
+  extends:
+    - .fdo.container-build@debian
+  stage: docker-image
+  variables:
+    GIT_STRATEGY: none
+
+
+# The default build instructions
+.default_build:
+  extends:
+    - .fdo.distribution-image@debian
+  stage: build
+  script:
+  - ./autogen.sh
+  - make -j${FDO_CI_CONCURRENT:-4} check V=1
+  variables:
+    CFLAGS: "-pipe -g -O2 -Werror"
+    ACLOCAL_PATH: /usr/local/xserver-$XSERVER_VERSION/share/aclocal
+    PKG_CONFIG_PATH: /usr/local/xserver-$XSERVER_VERSION/lib/pkgconfig
+
+build-distcheck:
+  extends:
+    - .default_build
+  script:
+  - ./autogen.sh
+  - make -j${FDO_CI_CONCURRENT:-4} check V=1
+  - make install V=1
+  - make -j${FDO_CI_CONCURRENT:-4} distcheck
+  variables:
+    XSERVER_VERSION: "1.20"
+
+build-gcc:
+  extends:
+    - .default_build
+  parallel:
+    matrix:
+      - XSERVER_VERSION: ["1.16", "1.17", "1.18", "1.19"]
+
+build-clang:
+  extends:
+    - .default_build
+  parallel:
+    matrix:
+      - XSERVER_VERSION: ["1.20", "1.18", "1.19"]
+  variables:
+    CC: clang
+
+build-noglamor:
+  extends:
+    - .default_build
+  script:
+  - ./autogen.sh --disable-glamor
+  - make -j${FDO_CI_CONCURRENT:-4} check V=1
+  parallel:
+    matrix:
+      - XSERVER_VERSION: ["1.13", "1.14", "1.15"]
diff --git a/.gitlab-ci/debian-install.sh b/.gitlab-ci/debian-install.sh
new file mode 100644
index 00000000..4e528588
--- /dev/null
+++ b/.gitlab-ci/debian-install.sh
@@ -0,0 +1,74 @@
+#!/bin/bash
+
+set -e
+set -o xtrace
+
+echo 'deb-src https://deb.debian.org/debian buster main' >/etc/apt/sources.list.d/deb-src.list
+apt-get update
+
+
+# Ephemeral packages (installed for this script and removed again at the end)
+EPHEMERAL="
+	ca-certificates
+	git
+	"
+
+# libXfont/xserver build dependencies
+apt-get install -y --no-remove \
+	autoconf \
+	automake \
+	build-essential \
+	libtool \
+	pkg-config \
+	$EPHEMERAL
+
+echo 'APT::Get::Build-Dep-Automatic "true";' >>/etc/apt/apt.conf
+apt-get build-dep -y xorg-server
+
+
+git clone https://gitlab.freedesktop.org/xorg/lib/libXfont.git
+cd libXfont
+git checkout libXfont-1.5-branch
+./autogen.sh
+make install-pkgconfigDATA
+cd ..
+rm -rf libXfont
+
+
+git clone https://gitlab.freedesktop.org/xorg/xserver.git
+cd xserver
+
+for VERSION in 1.13 1.14 1.15; do
+    git checkout server-${VERSION}-branch
+    ./autogen.sh --prefix=/usr/local/xserver-$VERSION --enable-dri2
+    make -C include install-nodist_sdkHEADERS
+    make install-headers install-aclocalDATA install-pkgconfigDATA clean
+done
+
+for VERSION in 1.16 1.17 1.18 1.19 1.20; do
+    git checkout server-${VERSION}-branch
+    ./autogen.sh --prefix=/usr/local/xserver-$VERSION --enable-dri2 --enable-dri3 --enable-glamor
+    make -C include install-nodist_sdkHEADERS
+    make install-headers install-aclocalDATA install-pkgconfigDATA clean
+done
+
+cd ..
+rm -rf xserver
+
+
+# xf86-video-ati build dependencies
+apt-get install -y --no-remove \
+	clang \
+	libdrm-dev \
+	libgbm-dev \
+	libgl1-mesa-dev \
+	libpciaccess-dev \
+	libpixman-1-dev \
+	libudev-dev \
+	xutils-dev \
+	x11proto-dev
+
+
+# Remove unneeded packages
+apt-get purge -y $EPHEMERAL
+apt-get autoremove -y --purge
diff --git a/README.md b/README.md
index 7c9925c7..98666d48 100644
--- a/README.md
+++ b/README.md
@@ -10,7 +10,7 @@ Please submit bug reports to the Xorg bugzilla:
 
   https://bugs.freedesktop.org/enter_bug.cgi?product=xorg&component=Driver/Radeon
 
-The master development code repository can be found at:
+The primary development code repository can be found at:
 
   https://gitlab.freedesktop.org/xorg/driver/xf86-video-ati
 
diff --git a/configure.ac b/configure.ac
index a504695b..8864a421 100644
--- a/configure.ac
+++ b/configure.ac
@@ -34,7 +34,7 @@ AC_CONFIG_MACRO_DIR([m4])
 AC_CONFIG_AUX_DIR(.)
 
 # Initialize Automake
-AM_INIT_AUTOMAKE([foreign dist-bzip2])
+AM_INIT_AUTOMAKE([foreign dist-xz])
 AC_SYS_LARGEFILE
 
 # Require X.Org macros 1.8 or later for MAN_SUBSTS set by XORG_MANPAGE_SECTIONS
diff --git a/man/radeon.man b/man/radeon.man
index dcebf537..247dcdb7 100644
--- a/man/radeon.man
+++ b/man/radeon.man
@@ -290,7 +290,7 @@ on. If this option is set, the default value of the property is 'on' or 'off'
 accordingly. If this option isn't set, the default value of the property is
 .B auto,
 which means that TearFree is on for rotated outputs, outputs with RandR
-transforms applied and for RandR 1.4 slave outputs, otherwise off.
+transforms applied and for RandR 1.4 secondary outputs, otherwise off.
 .TP
 .BI "Option \*qAccelMethod\*q \*q" "string" \*q
 Chooses between available acceleration architectures.  Valid values are
diff --git a/src/cayman_shader.h b/src/cayman_shader.h
index c4cdc688..9cc5ed8f 100644
--- a/src/cayman_shader.h
+++ b/src/cayman_shader.h
@@ -30,7 +30,7 @@
 
 #include "radeon.h"
 
-/* Oder of instructions: All CF, All ALU, All Tex/Vtx fetches */
+/* Order of instructions: All CF, All ALU, All Tex/Vtx fetches */
 
 
 // CF insts
diff --git a/src/compat-api.h b/src/compat-api.h
index f4e7524f..def6d3e4 100644
--- a/src/compat-api.h
+++ b/src/compat-api.h
@@ -34,4 +34,10 @@
 #define BLOCKHANDLER_ARGS pScreen, pTimeout, pReadmask
 #endif
 
+#if ABI_VIDEODRV_VERSION < SET_ABI_VERSION(25, 2)
+#define current_primary current_master
+#define primary_pixmap master_pixmap
+#define secondary_dst slave_dst
+#endif
+
 #endif
diff --git a/src/drmmode_display.c b/src/drmmode_display.c
index 0e9e2474..a58f24dd 100644
--- a/src/drmmode_display.c
+++ b/src/drmmode_display.c
@@ -45,7 +45,9 @@
 #include "radeon_glamor.h"
 #include "radeon_reg.h"
 
+#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(1,19,99,1,0)
 #include <dri.h>
+#endif
 
 #include "drmmode_display.h"
 
@@ -720,7 +722,7 @@ drmmode_crtc_prime_scanout_update(xf86CrtcPtr crtc, DisplayModePtr mode,
 		xorg_list_for_each_entry(dirty, &screen->pixmap_dirty_list,
 					 ent) {
 			if (radeon_dirty_src_equals(dirty, drmmode_crtc->prime_scanout_pixmap)) {
-				dirty->slave_dst =
+				dirty->secondary_dst =
 					drmmode_crtc->scanout[scanout_id].pixmap;
 				break;
 			}
@@ -1275,7 +1277,7 @@ drmmode_show_cursor (xf86CrtcPtr crtc)
 	    arg.hot_y = yhot;
 
 	    ret = drmIoctl(pRADEONEnt->fd, DRM_IOCTL_MODE_CURSOR2, &arg);
-	    if (ret == -EINVAL)
+	    if (ret == -1 && errno == EINVAL)
 		use_set_cursor2 = FALSE;
 	    else
 		return;
@@ -1356,7 +1358,7 @@ drmmode_set_scanout_pixmap(xf86CrtcPtr crtc, PixmapPtr ppix)
 
 	xorg_list_for_each_entry(dirty, &screen->pixmap_dirty_list, ent) {
 		if (radeon_dirty_src_equals(dirty, drmmode_crtc->prime_scanout_pixmap)) {
-			PixmapStopDirtyTracking(dirty->src, dirty->slave_dst);
+			PixmapStopDirtyTracking(dirty->src, dirty->secondary_dst);
 			break;
 		}
 	}
diff --git a/src/drmmode_display.h b/src/drmmode_display.h
index 96eaef0a..8cd8a0a6 100644
--- a/src/drmmode_display.h
+++ b/src/drmmode_display.h
@@ -262,7 +262,7 @@ Bool drmmode_wait_vblank(xf86CrtcPtr crtc, drmVBlankSeqType type,
 			 uint64_t *ust, uint32_t *result_seq);
 
 
-miPointerSpriteFuncRec drmmode_sprite_funcs;
+extern miPointerSpriteFuncRec drmmode_sprite_funcs;
 
 
 #endif
diff --git a/src/evergreen_shader.h b/src/evergreen_shader.h
index 8c7136b7..c82672b4 100644
--- a/src/evergreen_shader.h
+++ b/src/evergreen_shader.h
@@ -30,7 +30,7 @@
 
 #include "radeon.h"
 
-/* Oder of instructions: All CF, All ALU, All Tex/Vtx fetches */
+/* Order of instructions: All CF, All ALU, All Tex/Vtx fetches */
 
 
 // CF insts
diff --git a/src/evergreen_state.h b/src/evergreen_state.h
index 7e54e1c7..34ba87b6 100644
--- a/src/evergreen_state.h
+++ b/src/evergreen_state.h
@@ -350,7 +350,7 @@ extern void *RADEONEXACreatePixmap2(ScreenPtr pScreen, int width, int height,
 				    int *new_pitch);
 extern void RADEONEXADestroyPixmap(ScreenPtr pScreen, void *driverPriv);
 extern Bool RADEONEXAPixmapIsOffscreen(PixmapPtr pPix);
-extern Bool RADEONEXASharePixmapBacking(PixmapPtr ppix, ScreenPtr slave, void **handle_p);
+extern Bool RADEONEXASharePixmapBacking(PixmapPtr ppix, ScreenPtr secondary, void **handle_p);
 extern Bool RADEONEXASetSharedPixmapBacking(PixmapPtr ppix, void *handle);
 
 #endif
diff --git a/src/r600_shader.h b/src/r600_shader.h
index d79ed400..b34670ee 100644
--- a/src/r600_shader.h
+++ b/src/r600_shader.h
@@ -53,12 +53,12 @@
  * Special case: square() - i.e. same component in src0+src1 doesn't need read port -> ignores swizzle for src1.
  * No restrictions for constants or PV/PS.
  * t can load multiple components in a single cycle slot, but has to share cycles with xyzw.
- * t with single constant may not load GPRs or PV/PS in cycle 0 (carefull with ALU_TRANS_210).
+ * t with single constant may not load GPRs or PV/PS in cycle 0 (careful with ALU_TRANS_210).
  * t with two constants may only load GPRs or PV/PS in cycle 2.
  */
 
 
-/* Oder of instructions: All CF, All ALU, All Tex/Vtx fetches */
+/* Order of instructions: All CF, All ALU, All Tex/Vtx fetches */
 
 
 // CF insts
@@ -174,7 +174,7 @@
     cpu_to_le32((((array_base) << 0) | ((type) << 13) | ((rw_gpr) << 15) | ((rr) << 22) | ((index_gpr) << 23) | \
 		 ((es) << 30)))
 // R7xx apparently doesn't have the ELEM_LOOP entry any more
-// We still expose it, but ELEM_LOOP is explicitely R6xx now.
+// We still expose it, but ELEM_LOOP is explicitly R6xx now.
 // TODO: is this just forgotten in the docs, or really not available any more?
 #define CF_ALLOC_IMP_EXP_DWORD1_BUF(array_size, comp_mask, el, bc, eop, vpm, cf_inst, wqm, b) \
     cpu_to_le32((((array_size) << 0) | ((comp_mask) << 12) | ((el) << 16) | ((bc) << 17) | \
diff --git a/src/r600_state.h b/src/r600_state.h
index 34345996..567c3ca2 100644
--- a/src/r600_state.h
+++ b/src/r600_state.h
@@ -321,6 +321,6 @@ extern void *RADEONEXACreatePixmap2(ScreenPtr pScreen, int width, int height,
 				    int *new_pitch);
 extern void RADEONEXADestroyPixmap(ScreenPtr pScreen, void *driverPriv);
 extern Bool RADEONEXAPixmapIsOffscreen(PixmapPtr pPix);
-extern Bool RADEONEXASharePixmapBacking(PixmapPtr ppix, ScreenPtr slave, void **handle_p);
+extern Bool RADEONEXASharePixmapBacking(PixmapPtr ppix, ScreenPtr secondary, void **handle_p);
 extern Bool RADEONEXASetSharedPixmapBacking(PixmapPtr ppix, void *handle);
 #endif
diff --git a/src/radeon.h b/src/radeon.h
index 2c913466..68d7756a 100644
--- a/src/radeon.h
+++ b/src/radeon.h
@@ -182,18 +182,18 @@ typedef enum {
 
 
 static inline ScreenPtr
-radeon_master_screen(ScreenPtr screen)
+radeon_primary_screen(ScreenPtr screen)
 {
-    if (screen->current_master)
-	return screen->current_master;
+    if (screen->current_primary)
+	return screen->current_primary;
 
     return screen;
 }
 
 static inline ScreenPtr
-radeon_dirty_master(PixmapDirtyUpdatePtr dirty)
+radeon_dirty_primary(PixmapDirtyUpdatePtr dirty)
 {
-    return radeon_master_screen(dirty->slave_dst->drawable.pScreen);
+    return radeon_primary_screen(dirty->secondary_dst->drawable.pScreen);
 }
 
 static inline DrawablePtr
@@ -790,8 +790,8 @@ static inline Bool radeon_set_pixmap_bo(PixmapPtr pPix, struct radeon_buffer *bo
 
 static inline struct radeon_buffer *radeon_get_pixmap_bo(PixmapPtr pPix)
 {
-#ifdef USE_GLAMOR
     RADEONInfoPtr info = RADEONPTR(xf86ScreenToScrn(pPix->drawable.pScreen));
+#ifdef USE_GLAMOR
 
     if (info->use_glamor) {
 	struct radeon_pixmap *priv;
@@ -799,7 +799,7 @@ static inline struct radeon_buffer *radeon_get_pixmap_bo(PixmapPtr pPix)
 	return priv ? priv->bo : NULL;
     } else
 #endif
-    {
+    if (info->accelOn) {
 	struct radeon_exa_pixmap_priv *driver_priv;
 	driver_priv = exaGetPixmapDriverPrivate(pPix);
 	return driver_priv ? driver_priv->bo : NULL;
@@ -896,7 +896,7 @@ radeon_pixmap_get_fb(PixmapPtr pix)
 				   handle);
     }
 
-    return *fb_ptr;
+    return fb_ptr ? *fb_ptr : NULL;
 }
 
 
diff --git a/src/radeon_dri2.c b/src/radeon_dri2.c
index 66a223d8..17983779 100644
--- a/src/radeon_dri2.c
+++ b/src/radeon_dri2.c
@@ -728,8 +728,9 @@ radeon_dri2_exchange_buffers(DrawablePtr draw, DRI2BufferPtr front, DRI2BufferPt
 {
     struct dri2_buffer_priv *front_priv = front->driverPrivate;
     struct dri2_buffer_priv *back_priv = back->driverPrivate;
-    ScreenPtr screen = draw->pScreen;
-    RADEONInfoPtr info = RADEONPTR(xf86ScreenToScrn(screen));
+#ifdef USE_GLAMOR
+    RADEONInfoPtr info = RADEONPTR(xf86ScreenToScrn(draw->pScreen));
+#endif
     RegionRec region;
     int tmp;
 
diff --git a/src/radeon_exa.c b/src/radeon_exa.c
index 268155ed..320ff992 100644
--- a/src/radeon_exa.c
+++ b/src/radeon_exa.c
@@ -282,7 +282,7 @@ void RADEONEXADestroyPixmap(ScreenPtr pScreen, void *driverPriv)
     free(driverPriv);
 }
 
-Bool RADEONEXASharePixmapBacking(PixmapPtr ppix, ScreenPtr slave, void **fd_handle)
+Bool RADEONEXASharePixmapBacking(PixmapPtr ppix, ScreenPtr seconndary, void **fd_handle)
 {
     struct radeon_exa_pixmap_priv *driver_priv = exaGetPixmapDriverPrivate(ppix);
 
diff --git a/src/radeon_exa_render.c b/src/radeon_exa_render.c
index c61d83f4..a5f9612b 100644
--- a/src/radeon_exa_render.c
+++ b/src/radeon_exa_render.c
@@ -1511,7 +1511,7 @@ static Bool R300PrepareComposite(int op, PicturePtr pSrcPicture,
      * DST_VEC_LOC is the slot in the PVS input vector memory when PVS/TCL is
      * enabled.  This memory provides the imputs to the vertex shader program
      * and ordering is not important.  When PVS/TCL is disabled, this field maps
-     * directly to the GA input memory and the order is signifigant.  In
+     * directly to the GA input memory and the order is significant.  In
      * PVS_BYPASS mode the order is as follows:
      * Position
      * Point Size
diff --git a/src/radeon_glamor.c b/src/radeon_glamor.c
index f1098381..ccf99941 100644
--- a/src/radeon_glamor.c
+++ b/src/radeon_glamor.c
@@ -366,7 +366,7 @@ radeon_glamor_set_pixmap_bo(DrawablePtr drawable, PixmapPtr pixmap)
 
 
 static Bool
-radeon_glamor_share_pixmap_backing(PixmapPtr pixmap, ScreenPtr slave,
+radeon_glamor_share_pixmap_backing(PixmapPtr pixmap, ScreenPtr secondary,
 				   void **handle_p)
 {
 	ScreenPtr screen = pixmap->drawable.pScreen;
diff --git a/src/radeon_glamor_wrappers.c b/src/radeon_glamor_wrappers.c
index edffd9ad..bc47cc89 100644
--- a/src/radeon_glamor_wrappers.c
+++ b/src/radeon_glamor_wrappers.c
@@ -1,12 +1,12 @@
 /*
- * Copyright © 2001 Keith Packard
+ * Copyright Â© 2001 Keith Packard
  *             2010 Intel Corporation
  *             2012,2015 Advanced Micro Devices, Inc.
  *
- * Partly based on code Copyright © 2008 Red Hat, Inc.
- * Partly based on code Copyright © 2000 SuSE, Inc.
+ * Partly based on code Copyright Â© 2008 Red Hat, Inc.
+ * Partly based on code Copyright Â© 2000 SuSE, Inc.
  *
- * Partly based on code that is Copyright © The XFree86 Project Inc.
+ * Partly based on code that is Copyright Â© The XFree86 Project Inc.
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
diff --git a/src/radeon_kms.c b/src/radeon_kms.c
index b3db7c41..51b00dd9 100644
--- a/src/radeon_kms.c
+++ b/src/radeon_kms.c
@@ -559,8 +559,8 @@ dirty_region(PixmapDirtyUpdatePtr dirty)
 	if (dirty->rotation != RR_Rotate_0) {
 		dstregion = transform_region(damageregion,
 					     &dirty->f_inverse,
-					     dirty->slave_dst->drawable.width,
-					     dirty->slave_dst->drawable.height);
+					     dirty->secondary_dst->drawable.width,
+					     dirty->secondary_dst->drawable.height);
 	} else
 #endif
 	{
@@ -568,7 +568,7 @@ dirty_region(PixmapDirtyUpdatePtr dirty)
 
 	    dstregion = RegionDuplicate(damageregion);
 	    RegionTranslate(dstregion, -dirty->x, -dirty->y);
-	    PixmapRegionInit(&pixregion, dirty->slave_dst);
+	    PixmapRegionInit(&pixregion, dirty->secondary_dst);
 	    RegionIntersect(dstregion, dstregion, &pixregion);
 	    RegionUninit(&pixregion);
 	}
@@ -585,8 +585,8 @@ redisplay_dirty(PixmapDirtyUpdatePtr dirty, RegionPtr region)
 	if (RegionNil(region))
 		goto out;
 
-	if (dirty->slave_dst->master_pixmap)
-	    DamageRegionAppend(&dirty->slave_dst->drawable, region);
+	if (dirty->secondary_dst->primary_pixmap)
+	    DamageRegionAppend(&dirty->secondary_dst->drawable, region);
 
 #ifdef HAS_DIRTYTRACKING_ROTATION
 	PixmapSyncDirtyHelper(dirty);
@@ -595,8 +595,8 @@ redisplay_dirty(PixmapDirtyUpdatePtr dirty, RegionPtr region)
 #endif
 
 	radeon_cs_flush_indirect(src_scrn);
-	if (dirty->slave_dst->master_pixmap)
-	    DamageRegionProcessPending(&dirty->slave_dst->drawable);
+	if (dirty->secondary_dst->primary_pixmap)
+	    DamageRegionProcessPending(&dirty->secondary_dst->drawable);
 
 out:
 	DamageEmpty(dirty->damage);
@@ -613,12 +613,12 @@ radeon_prime_scanout_update_abort(xf86CrtcPtr crtc, void *event_data)
 void
 radeon_sync_shared_pixmap(PixmapDirtyUpdatePtr dirty)
 {
-    ScreenPtr master_screen = radeon_dirty_master(dirty);
+    ScreenPtr primary_screen = radeon_dirty_primary(dirty);
     PixmapDirtyUpdatePtr ent;
     RegionPtr region;
 
-    xorg_list_for_each_entry(ent, &master_screen->pixmap_dirty_list, ent) {
-	if (!radeon_dirty_src_equals(dirty, ent->slave_dst))
+    xorg_list_for_each_entry(ent, &primary_screen->pixmap_dirty_list, ent) {
+	if (!radeon_dirty_src_equals(dirty, ent->secondary_dst))
 	    continue;
 
 	region = dirty_region(ent);
@@ -631,45 +631,45 @@ radeon_sync_shared_pixmap(PixmapDirtyUpdatePtr dirty)
 #if HAS_SYNC_SHARED_PIXMAP
 
 static Bool
-master_has_sync_shared_pixmap(ScrnInfoPtr scrn, PixmapDirtyUpdatePtr dirty)
+primary_has_sync_shared_pixmap(ScrnInfoPtr scrn, PixmapDirtyUpdatePtr dirty)
 {
-    ScreenPtr master_screen = radeon_dirty_master(dirty);
+    ScreenPtr primary_screen = radeon_dirty_primary(dirty);
 
-    return !!master_screen->SyncSharedPixmap;
+    return !!primary_screen->SyncSharedPixmap;
 }
 
 static Bool
-slave_has_sync_shared_pixmap(ScrnInfoPtr scrn, PixmapDirtyUpdatePtr dirty)
+secondary_has_sync_shared_pixmap(ScrnInfoPtr scrn, PixmapDirtyUpdatePtr dirty)
 {
-    ScreenPtr slave_screen = dirty->slave_dst->drawable.pScreen;
+    ScreenPtr secondary_screen = dirty->secondary_dst->drawable.pScreen;
 
-    return !!slave_screen->SyncSharedPixmap;
+    return !!secondary_screen->SyncSharedPixmap;
 }
 
 static void
 call_sync_shared_pixmap(PixmapDirtyUpdatePtr dirty)
 {
-    ScreenPtr master_screen = radeon_dirty_master(dirty);
+    ScreenPtr primary_screen = radeon_dirty_primary(dirty);
 
-    master_screen->SyncSharedPixmap(dirty);
+    primary_screen->SyncSharedPixmap(dirty);
 }
 
 #else /* !HAS_SYNC_SHARED_PIXMAP */
 
 static Bool
-master_has_sync_shared_pixmap(ScrnInfoPtr scrn, PixmapDirtyUpdatePtr dirty)
+primary_has_sync_shared_pixmap(ScrnInfoPtr scrn, PixmapDirtyUpdatePtr dirty)
 {
-    ScrnInfoPtr master_scrn = xf86ScreenToScrn(radeon_dirty_master(dirty));
+    ScrnInfoPtr primary_scrn = xf86ScreenToScrn(radeon_dirty_primary(dirty));
 
-    return master_scrn->driverName == scrn->driverName;
+    return primary_scrn->driverName == scrn->driverName;
 }
 
 static Bool
-slave_has_sync_shared_pixmap(ScrnInfoPtr scrn, PixmapDirtyUpdatePtr dirty)
+secondary_has_sync_shared_pixmap(ScrnInfoPtr scrn, PixmapDirtyUpdatePtr dirty)
 {
-    ScrnInfoPtr slave_scrn = xf86ScreenToScrn(dirty->slave_dst->drawable.pScreen);
+    ScrnInfoPtr secondary_scrn = xf86ScreenToScrn(dirty->secondary_dst->drawable.pScreen);
 
-    return slave_scrn->driverName == scrn->driverName;
+    return secondary_scrn->driverName == scrn->driverName;
 }
 
 static void
@@ -684,12 +684,12 @@ call_sync_shared_pixmap(PixmapDirtyUpdatePtr dirty)
 static xf86CrtcPtr
 radeon_prime_dirty_to_crtc(PixmapDirtyUpdatePtr dirty)
 {
-    ScreenPtr screen = dirty->slave_dst->drawable.pScreen;
+    ScreenPtr screen = dirty->secondary_dst->drawable.pScreen;
     ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
     xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
     int c;
 
-    /* Find the CRTC which is scanning out from this slave pixmap */
+    /* Find the CRTC which is scanning out from this secondary pixmap */
     for (c = 0; c < xf86_config->num_crtc; c++) {
 	xf86CrtcPtr xf86_crtc = xf86_config->crtc[c];
 	drmmode_crtc_private_ptr drmmode_crtc = xf86_crtc->driver_private;
@@ -714,7 +714,7 @@ radeon_prime_scanout_do_update(xf86CrtcPtr crtc, unsigned scanout_id)
 	if (radeon_dirty_src_equals(dirty, drmmode_crtc->prime_scanout_pixmap)) {
 	    RegionPtr region;
 
-	    if (master_has_sync_shared_pixmap(scrn, dirty))
+	    if (primary_has_sync_shared_pixmap(scrn, dirty))
 		call_sync_shared_pixmap(dirty);
 
 	    region = dirty_region(dirty);
@@ -727,7 +727,7 @@ radeon_prime_scanout_do_update(xf86CrtcPtr crtc, unsigned scanout_id)
 		radeon_cs_flush_indirect(scrn);
 		RegionCopy(&drmmode_crtc->scanout_last_region, region);
 		RegionTranslate(region, -crtc->x, -crtc->y);
-		dirty->slave_dst = drmmode_crtc->scanout[scanout_id].pixmap;
+		dirty->secondary_dst = drmmode_crtc->scanout[scanout_id].pixmap;
 	    }
 
 	    redisplay_dirty(dirty, region);
@@ -754,7 +754,7 @@ radeon_prime_scanout_update_handler(xf86CrtcPtr crtc, uint32_t frame, uint64_t u
 static void
 radeon_prime_scanout_update(PixmapDirtyUpdatePtr dirty)
 {
-    ScreenPtr screen = dirty->slave_dst->drawable.pScreen;
+    ScreenPtr screen = dirty->secondary_dst->drawable.pScreen;
     ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
     RADEONEntPtr pRADEONEnt = RADEONEntPriv(scrn);
     xf86CrtcPtr xf86_crtc = radeon_prime_dirty_to_crtc(dirty);
@@ -818,7 +818,7 @@ radeon_prime_scanout_update(PixmapDirtyUpdatePtr dirty)
 static void
 radeon_prime_scanout_flip(PixmapDirtyUpdatePtr ent)
 {
-    ScreenPtr screen = ent->slave_dst->drawable.pScreen;
+    ScreenPtr screen = ent->secondary_dst->drawable.pScreen;
     ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
     RADEONEntPtr pRADEONEnt = RADEONEntPriv(scrn);
     xf86CrtcPtr crtc = radeon_prime_dirty_to_crtc(ent);
@@ -893,11 +893,11 @@ radeon_dirty_update(ScrnInfoPtr scrn)
 		if (screen->isGPU) {
 			PixmapDirtyUpdatePtr region_ent = ent;
 
-			if (master_has_sync_shared_pixmap(scrn, ent)) {
-				ScreenPtr master_screen = radeon_dirty_master(ent);
+			if (primary_has_sync_shared_pixmap(scrn, ent)) {
+				ScreenPtr primary_screen = radeon_dirty_primary(ent);
 
-				xorg_list_for_each_entry(region_ent, &master_screen->pixmap_dirty_list, ent) {
-					if (radeon_dirty_src_equals(ent, region_ent->slave_dst))
+				xorg_list_for_each_entry(region_ent, &primary_screen->pixmap_dirty_list, ent) {
+					if (radeon_dirty_src_equals(ent, region_ent->secondary_dst))
 						break;
 				}
 			}
@@ -921,7 +921,7 @@ radeon_dirty_update(ScrnInfoPtr scrn)
 
 			RegionDestroy(region);
 		} else {
-			if (slave_has_sync_shared_pixmap(scrn, ent))
+			if (secondary_has_sync_shared_pixmap(scrn, ent))
 				continue;
 
 			region = dirty_region(ent);
@@ -931,6 +931,13 @@ radeon_dirty_update(ScrnInfoPtr scrn)
 	}
 }
 
+static void
+radeonSourceValidate(DrawablePtr draw, int x, int y, int w, int h,
+		     unsigned int subWindowMode)
+{
+}
+
+
 
 Bool
 radeon_scanout_do_update(xf86CrtcPtr xf86_crtc, int scanout_id,
@@ -993,7 +1000,7 @@ radeon_scanout_do_update(xf86CrtcPtr xf86_crtc, int scanout_id,
 	    SetPicturePictFilter(src, xf86_crtc->filter, xf86_crtc->params,
 				 xf86_crtc->nparams);
 
-	pScreen->SourceValidate = NULL;
+	pScreen->SourceValidate = radeonSourceValidate;
 	CompositePicture(PictOpSrc,
 			 src, NULL, dst,
 			 extents.x1, extents.y1, 0, 0, extents.x1,
@@ -1216,7 +1223,7 @@ static void RADEONBlockHandler_KMS(BLOCKHANDLER_ARGS_DECL)
     (*pScreen->BlockHandler) (BLOCKHANDLER_ARGS);
     pScreen->BlockHandler = RADEONBlockHandler_KMS;
 
-    if (!xf86ScreenToScrn(radeon_master_screen(pScreen))->vtSema)
+    if (!xf86ScreenToScrn(radeon_primary_screen(pScreen))->vtSema)
 	return;
 
     if (!pScreen->isGPU)
@@ -2584,7 +2591,7 @@ CARD32 cleanup_black_fb(OsTimerPtr timer, CARD32 now, pointer data)
     xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
     int c;
 
-    if (xf86ScreenToScrn(radeon_master_screen(screen))->vtSema)
+    if (xf86ScreenToScrn(radeon_primary_screen(screen))->vtSema)
 	return 0;
 
     /* Unreference the all-black FB created by RADEONLeaveVT_KMS. After
diff --git a/src/radeon_present.c b/src/radeon_present.c
index 494655c9..d010aa19 100644
--- a/src/radeon_present.c
+++ b/src/radeon_present.c
@@ -254,7 +254,9 @@ radeon_present_check_flip(RRCrtcPtr crtc, WindowPtr window, PixmapPtr pixmap,
     xf86CrtcPtr xf86_crtc = crtc->devPrivate;
     ScreenPtr screen = window->drawable.pScreen;
     ScrnInfoPtr scrn = xf86_crtc->scrn;
+#ifdef USE_GLAMOR
     struct radeon_pixmap *priv = radeon_get_pixmap_private(pixmap);
+#endif
     xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(scrn);
     RADEONInfoPtr info = RADEONPTR(scrn);
     PixmapPtr screen_pixmap = screen->GetScreenPixmap(screen);
@@ -278,10 +280,13 @@ radeon_present_check_flip(RRCrtcPtr crtc, WindowPtr window, PixmapPtr pixmap,
 	return FALSE;
 #endif
 
+#ifdef USE_GLAMOR
     if (priv && priv->fb_failed)
 	return FALSE;
+#endif
 
     if (!radeon_pixmap_get_fb(pixmap)) {
+#ifdef USE_GLAMOR
 	if (!priv)
 	    priv = radeon_get_pixmap_private(pixmap);
 
@@ -291,6 +296,7 @@ radeon_present_check_flip(RRCrtcPtr crtc, WindowPtr window, PixmapPtr pixmap,
 		       "normal if using PRIME render offloading)\n");
 	    priv->fb_failed = TRUE;
 	}
+#endif
 
 	return FALSE;
     }
diff --git a/src/radeon_textured_videofuncs.c b/src/radeon_textured_videofuncs.c
index 0959b119..ba10c60d 100644
--- a/src/radeon_textured_videofuncs.c
+++ b/src/radeon_textured_videofuncs.c
@@ -1134,7 +1134,7 @@ R300PrepareTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
      * DST_VEC_LOC is the slot in the PVS input vector memory when PVS/TCL is
      * enabled.  This memory provides the imputs to the vertex shader program
      * and ordering is not important.  When PVS/TCL is disabled, this field maps
-     * directly to the GA input memory and the order is signifigant.  In
+     * directly to the GA input memory and the order is significant.  In
      * PVS_BYPASS mode the order is as follows:
      * Position
      * Point Size
@@ -2578,7 +2578,7 @@ R500PrepareTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
      * DST_VEC_LOC is the slot in the PVS input vector memory when PVS/TCL is
      * enabled.  This memory provides the imputs to the vertex shader program
      * and ordering is not important.  When PVS/TCL is disabled, this field maps
-     * directly to the GA input memory and the order is signifigant.  In
+     * directly to the GA input memory and the order is significant.  In
      * PVS_BYPASS mode the order is as follows:
      * Position
      * Point Size
diff --git a/src/simple_list.h b/src/simple_list.h
index ff7f8882..0be4ad1a 100644
--- a/src/simple_list.h
+++ b/src/simple_list.h
@@ -2,7 +2,7 @@
  * \file simple_list.h
  * Simple macros for type-safe, intrusive lists.
  *
- *  Intended to work with a list sentinal which is created as an empty
+ *  Intended to work with a list sentinel which is created as an empty
  *  list.  Insert & delete are O(1).
  *  
  * \author
@@ -108,12 +108,12 @@ do {						\
 /**
  * Make a empty list empty.
  *
- * \param sentinal list (sentinal element).
+ * \param sentinel list (sentinel element).
  */
-#define make_empty_list(sentinal)		\
+#define make_empty_list(sentinel)		\
 do {						\
-   (sentinal)->next = sentinal;			\
-   (sentinal)->prev = sentinal;			\
+   (sentinel)->next = sentinel;			\
+   (sentinel)->prev = sentinel;			\
 } while (0)
 
 /**
