# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../linux26mips/hotfix2.patch
# Copyright (C) 2011 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

include/asm/delay.h:74:3: error: impossible constraint in 'asm'

h constraint removed in gcc-4.4 and up

	- Rene Rebe <rene@exactcode.de>

--- linux-2.6.19/include/asm-mips/delay.h.vanilla	2011-02-06 11:50:19.530951434 +0000
+++ linux-2.6.19/include/asm-mips/delay.h	2011-02-06 11:57:05.982805922 +0000
@@ -48,35 +48,21 @@
  * a constant)
  */
 
-static inline void __udelay(unsigned long usecs, unsigned long lpj)
-{
-	unsigned long lo;
-
-	/*
-	 * The rates of 128 is rounded wrongly by the catchall case
-	 * for 64-bit.  Excessive precission?  Probably ...
-	 */
-#if defined(CONFIG_64BIT) && (HZ == 128)
-	usecs *= 0x0008637bd05af6c7UL;		/* 2**64 / (1000000 / HZ) */
-#elif defined(CONFIG_64BIT)
-	usecs *= (0x8000000000000000UL / (500000 / HZ));
-#else /* 32-bit junk follows here */
-	usecs *= (unsigned long) (((0x8000000000000000ULL / (500000 / HZ)) +
-	                           0x80000000ULL) >> 32);
-#endif
+#ifdef CONFIG_64BIT 
+	typedef unsigned int uintx_t __attribute__((mode(TI))); 
+#else 
+	typedef u64 uintx_t; 
+#endif 
 
-	if (sizeof(long) == 4)
-		__asm__("multu\t%2, %3"
-		: "=h" (usecs), "=l" (lo)
-		: "r" (usecs), "r" (lpj)
-		: GCC_REG_ACCUM);
-	else if (sizeof(long) == 8)
-		__asm__("dmultu\t%2, %3"
-		: "=h" (usecs), "=l" (lo)
-		: "r" (usecs), "r" (lpj)
-		: GCC_REG_ACCUM);
+static inline unsigned long __usecs_to_loops(unsigned long usecs, 
+	                unsigned long lpj) 
+{ 
+        return ((uintx_t)usecs * lpj) >> BITS_PER_LONG; 
+} 
 
-	__delay(usecs);
+static inline void __udelay(unsigned long usecs, unsigned long lpj)
+{
+	__delay(__usecs_to_loops(usecs, lpj));
 }
 
 #define __udelay_val cpu_data[smp_processor_id()].udelay_val
