# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../kvm/04-qemu-applesmc.patch
# Copyright (C) 2009 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

#qemu-only -> submit upstream qemu
--- kvm-85/qemu/Makefile.target.vanilla	2009-05-05 17:14:18.000000000 +0200
+++ kvm-85/qemu/Makefile.target	2009-05-05 17:14:22.000000000 +0200
@@ -645,7 +645,7 @@
 OBJS+= ide.o pckbd.o ps2.o vga.o $(SOUND_HW) dma.o
 OBJS+= fdc.o mc146818rtc.o serial.o i8259.o i8254.o pcspk.o pc.o
 OBJS+= cirrus_vga.o apic.o ioapic.o parallel.o acpi.o piix_pci.o
-OBJS+= usb-uhci.o vmmouse.o vmport.o vmware_vga.o hpet.o lpc.o
+OBJS+= usb-uhci.o vmmouse.o vmport.o vmware_vga.o hpet.o lpc.o applesmc.o
 OBJS += device-hotplug.o pci-hotplug.o
 OBJS+= extboot.o
 # virtio support
Index: kvm-83/qemu/hw/applesmc.c
===================================================================
--- /dev/null
+++ kvm-83/qemu/hw/applesmc.c
@@ -0,0 +1,171 @@
+/*
+ *  Apple SMC controller
+ *
+ *  Copyright (c) 2007 Alexander Graf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * *****************************************************************
+ *
+ * In all Intel-based Apple hardware there is an SMC chip to control the
+ * backlight, fans and several other generic device parameters. It also
+ * contains the magic keys used to dongle Mac OS X to the device.
+ *
+ * This driver was mostly created by looking at the Linux AppleSMC driver
+ * implementation and does not support IRQ.
+ *
+ */
+
+#include "hw.h"
+#include "pci.h"
+#include "console.h"
+#include "qemu-timer.h"
+
+/* data port used by Apple SMC */
+#define APPLESMC_DATA_PORT	0x300
+/* command/status port used by Apple SMC */
+#define APPLESMC_CMD_PORT	0x304
+#define APPLESMC_NR_PORTS	32 /* 0x300-0x31f */
+#define APPLESMC_MAX_DATA_LENGTH 32
+
+#define APPLESMC_READ_CMD	0x10
+#define APPLESMC_WRITE_CMD	0x11
+#define APPLESMC_GET_KEY_BY_INDEX_CMD	0x12
+#define APPLESMC_GET_KEY_TYPE_CMD	0x13
+
+static char osk[64] = "This is a dummy key. Enter the real key using the -osk parameter";
+
+struct AppleSMCData {
+    uint8_t len;
+    char *key;
+    char *data;
+};
+
+static struct AppleSMCData data[] = {
+    { .key = "REV ", .len=6, .data="\0x01\0x13\0x0f\0x00\0x00\0x03" },
+    { .key = "OSK0", .len=32, .data=osk },
+    { .key = "OSK1", .len=32, .data=osk+32 },
+    { .key = "NATJ", .len=1, .data="\0" },
+    { .key = "MSSP", .len=1, .data="\0" },
+    { .key = "MSSD", .len=1, .data="\0x3" },
+    { .len=0 }
+};
+
+struct AppleSMCStatus {
+    uint8_t cmd;
+    uint8_t status;
+    uint8_t key[4];
+    uint8_t read_pos;
+    uint8_t data_len;
+    uint8_t data_pos;
+    uint8_t data[255];
+    uint8_t charactic[4];
+};
+
+static void applesmc_io_cmd_writeb(void *opaque, uint32_t addr, uint32_t val)
+{
+    struct AppleSMCStatus *s = (struct AppleSMCStatus *)opaque;
+    printf("APPLESMC: CMD Write B: %#x = %#x\n", addr, val);
+    switch(val) {
+        case APPLESMC_READ_CMD:
+            s->status = 0x0c;
+            break;
+    }
+    s->cmd = val;
+    s->read_pos = 0;
+    s->data_pos = 0;
+}
+
+static void applesmc_fill_data(struct AppleSMCStatus *s)
+{
+    struct AppleSMCData *d;
+    for(d=data; d->len; d++) {
+        uint32_t key_data = *((uint32_t*)d->key);
+        uint32_t key_current = *((uint32_t*)s->key);
+        if(key_data == key_current) {
+            printf("APPLESMC: Key matched (%s Len=%d Data=%s)\n", d->key, d->len, d->data);
+            memcpy(s->data, d->data, d->len);
+            return;
+        }
+    }
+}
+
+static void applesmc_io_data_writeb(void *opaque, uint32_t addr, uint32_t val)
+{
+    struct AppleSMCStatus *s = (struct AppleSMCStatus *)opaque;
+    printf("APPLESMC: DATA Write B: %#x = %#x\n", addr, val);
+    switch(s->cmd) {
+        case APPLESMC_READ_CMD:
+            if(s->read_pos < 4) {
+                s->key[s->read_pos] = val;
+                s->status = 0x04;
+            } else if(s->read_pos == 4) {
+                s->data_len = val;
+                s->status = 0x05;
+                s->data_pos = 0;
+                printf("APPLESMC: Key = %c%c%c%c Len = %d\n", s->key[0], s->key[1], s->key[2], s->key[3], val);
+                applesmc_fill_data(s);
+            }
+            s->read_pos++;
+            break;
+    }
+}
+
+static uint32_t applesmc_io_data_readb(void *opaque, uint32_t addr1)
+{
+    struct AppleSMCStatus *s = (struct AppleSMCStatus *)opaque;
+    uint8_t retval = 0;
+    switch(s->cmd) {
+        case APPLESMC_READ_CMD:
+            if(s->data_pos < s->data_len) {
+                retval = s->data[s->data_pos];
+                printf("APPLESMC: READ_DATA[%d] = %#hhx\n", s->data_pos, retval);
+                s->data_pos++;
+                if(s->data_pos == s->data_len) {
+                    s->status = 0x00;
+                    printf("APPLESMC: EOF\n");
+                } else
+                    s->status = 0x05;
+            }
+    }
+    printf("APPLESMC: DATA Read b: %#x = %#x\n", addr1, retval);
+    return retval;
+}
+
+static uint32_t applesmc_io_cmd_readb(void *opaque, uint32_t addr1)
+{
+    printf("APPLESMC: CMD Read B: %#x\n", addr1);
+    return ((struct AppleSMCStatus*)opaque)->status;
+}
+
+void applesmc_setkey(char *key) {
+    if(strlen(key) == 64) {
+        memcpy(osk, key, 64);
+    }
+}
+
+void applesmc_init() {
+    struct ApleSMCStatus *s;
+    s = qemu_mallocz(sizeof(struct AppleSMCStatus));
+
+    if(osk[0] == 'T') {
+        printf("WARNING: Using AppleSMC with invalid key\n");
+    }
+    register_ioport_read(APPLESMC_DATA_PORT, 4, 1, applesmc_io_data_readb, s);
+    register_ioport_read(APPLESMC_CMD_PORT, 4, 1, applesmc_io_cmd_readb, s);
+    register_ioport_write(APPLESMC_DATA_PORT, 4, 1, applesmc_io_data_writeb, s);
+    register_ioport_write(APPLESMC_CMD_PORT, 4, 1, applesmc_io_cmd_writeb, s);
+}
+
Index: kvm-83/qemu/hw/pc.h
===================================================================
--- kvm-83.orig/qemu/hw/pc.h
+++ kvm-83/qemu/hw/pc.h
@@ -172,6 +172,10 @@ void pci_piix4_ide_init(PCIBus *bus, Blo
 
 void isa_ne2000_init(int base, qemu_irq irq, NICInfo *nd);
 
+/* applesmc.c */
+void applesmc_init(void);
+void applesmc_setkey(char *key);
+
 /* lpc.c */
 void lpc_init(PCIBus *bus, int devfn, qemu_irq *pic);
 
--- kvm-85/qemu/qemu-options.hx.vanilla	2009-05-05 17:17:37.000000000 +0200
+++ kvm-85/qemu/qemu-options.hx	2009-05-05 17:21:52.000000000 +0200
@@ -666,6 +666,16 @@
 ETEXI
 
 #ifdef TARGET_I386
+DEF("osk", HAS_ARG, QEMU_OPTION_osk,                                                                                 
+    "-osk           set AppleSMC key\n")
+#endif
+STEXI
+@item -osk
+Set AppleSMC key.
+ETEXI
+
+
+#ifdef TARGET_I386
 DEF("acpitable", HAS_ARG, QEMU_OPTION_acpitable,
     "-acpitable [sig=str][,rev=n][,oem_id=str][,oem_table_id=str][,oem_rev=n][,asl_compiler_id=str][,asl_compiler_rev=n][,data=file1[:file2]...]\n"
     "                ACPI table description\n")
--- kvm-85/qemu/vl.c.vanilla	2009-05-05 17:15:11.000000000 +0200
+++ kvm-85/qemu/vl.c	2009-05-05 17:25:45.000000000 +0200
@@ -5072,6 +5072,9 @@
             case QEMU_OPTION_no_hpet:
                 no_hpet = 1;
                 break;
+            case QEMU_OPTION_osk:
+                applesmc_setkey(optarg);
+                break;
 #endif
             case QEMU_OPTION_no_reboot:
                 no_reboot = 1;
