# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../kvm/03-qemu-lpc.patch
# Copyright (C) 2011 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

From: Alexander Graf <agraf@suse.de>
Date: Tue, 30 Nov 2010 14:24:04 +0000 (+0100)
Subject: Add LPC device emulation
X-Git-Url: http://repo.or.cz/w/qemu/agraf.git/commitdiff_plain/71f1f25277f2e2035eec1badf76b6035a0390efa

Add LPC device emulation

Signed-off-by: Alexander Graf <agraf@suse.de>
---

--- qemu-kvm-0.15.0/Makefile.objs.vanilla	2011-12-07 19:15:50.237204501 +0000
+++ qemu-kvm-0.15.0/Makefile.objs	2011-12-07 19:16:32.413199084 +0000
@@ -205,7 +205,7 @@
 hw-obj-$(CONFIG_APM) += pm_smbus.o apm.o
 hw-obj-$(CONFIG_DMA) += dma.o
 hw-obj-$(CONFIG_HPET) += hpet.o
-hw-obj-$(CONFIG_APPLESMC) += applesmc.o
+hw-obj-$(CONFIG_APPLESMC) += applesmc.o lpc.o
 hw-obj-$(CONFIG_SMARTCARD) += usb-ccid.o ccid-card-passthru.o
 hw-obj-$(CONFIG_SMARTCARD_NSS) += ccid-card-emulated.o
 hw-obj-$(CONFIG_USB_REDIR) += usb-redir.o
--- /dev/null
+++ b/hw/lpc.c
@@ -0,0 +1,200 @@
+/*
+ *  Low Pin Count emulation
+ *
+ *  Copyright (c) 2007 Alexander Graf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * *****************************************************************
+ *
+ * This driver emulates an ICH-7 LPC partially. The LPC is basically the
+ * same as the ISA-bridge in the existing PIIX implementation, but
+ * more recent and includes support for HPET and Power Management.
+ *
+ *
+ * 00:1f.0 0601: 8086:27b9 (rev 02)
+ *         Subsystem: 1025:0107
+ *         Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B-
+ *         Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=medium >TAbort- <TAbort- <MAbort- >SERR- <PERR-
+ *         Latency: 0
+ *         Capabilities: [e0] Vendor Specific Information
+ * 00: 86 80 b9 27 07 01 10 02 02 00 01 06 00 00 80 00
+ * 10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+ * 20: 00 00 00 00 00 00 00 00 00 00 00 00 25 10 07 01
+ * 30: 00 00 00 00 e0 00 00 00 00 00 00 00 00 00 00 00
+ * 40: 01 10 00 00 80 00 00 00 81 11 00 00 10 00 00 00
+ * 50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+ * 60: 80 80 80 80 90 00 00 00 80 80 80 80 00 00 00 00
+ * 70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+ * 80: 10 00 02 3f 00 00 00 00 01 12 04 00 00 00 00 00
+ * 90: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+ * a0: 24 06 00 00 01 00 00 00 13 1c 0a 00 00 03 00 00
+ * b0: 00 00 f0 00 00 00 00 00 00 80 09 00 00 00 00 00
+ * c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+ * d0: 33 22 11 00 67 45 00 00 cf ff 00 00 00 00 00 00
+ * e0: 09 00 0c 10 b4 02 24 17 00 00 00 00 00 00 00 00
+ * f0: 01 c0 d1 fe 00 00 00 00 86 0f 02 00 00 00 00 00
+ */
+#include "hw.h"
+#include "pci.h"
+#include "console.h"
+
+#define RCBA_BASE		0xFED1C000
+
+typedef struct LPCState {
+    PCIDevice card;
+} LPCState;
+
+static uint32_t rcba_ram_readl(void *opaque, target_phys_addr_t addr)
+{
+    printf("qemu: rcba_read l at %#lx\n", addr);
+    if(addr == RCBA_BASE + 0x3404) { /* This is the HPET config pointer */
+        printf("qemu: rcba_read HPET_CONFIG_POINTER\n");
+        return 0xf0; // enabled at 0xfed00000
+    } else if(addr == RCBA_BASE + 0x3410) { /* This is the HPET config pointer */
+        printf("qemu: rcba_read GCS\n");
+        return 0;
+    } else {
+        return 0x0;
+    }
+}
+
+static void rcba_ram_writel(void *opaque, target_phys_addr_t addr,
+                uint32_t value)
+{
+    printf("qemu: rcba_write l %#lx = %#x\n", addr, value);
+}
+
+static CPUReadMemoryFunc *rcba_ram_read[] = {
+    NULL,
+    NULL,
+    rcba_ram_readl,
+};
+
+static CPUWriteMemoryFunc *rcba_ram_write[] = {
+    NULL,
+    NULL,
+    rcba_ram_writel,
+};
+
+static int lpc_init(PCIDevice *dev)
+{
+    int iomemtype;
+    uint8_t *pci_conf;
+
+#if 0
+    /* register a function 1 of PIIX3 */
+    d = (PCIDevice *)pci_register_device(bus, "LPC",
+                                           sizeof(PCIDevice),
+                                           31 << 3,
+                                           NULL, NULL);
+#endif
+    pci_conf = dev->config;
+    pci_conf[0x00] = 0x86;
+    pci_conf[0x01] = 0x80;
+    pci_conf[0x02] = 0xb9;
+    pci_conf[0x03] = 0x27;
+    pci_conf[0x08] = 0x02; // Revision 2
+
+    pci_conf[0x0a] = 0x01; // PCI-to-ISA Bridge
+    pci_conf[0x0b] = 0x06; // Bridge
+
+    pci_conf[0x0e] = 0xf0;
+
+    // Subsystem
+    pci_conf[0x2c] = 0x86;
+    pci_conf[0x2d] = 0x80;
+    pci_conf[0x2e] = 0x70;
+    pci_conf[0x2f] = 0x72;
+
+    pci_conf[0x3d] = 0x03;
+
+    // PMBASE
+    pci_conf[0x40] = 0x01;
+    pci_conf[0x41] = 0x0b;
+
+    pci_set_long(pci_conf + 0xf0, RCBA_BASE | 1);
+
+    /* RCBA Area */
+
+    iomemtype = cpu_register_io_memory(rcba_ram_read, rcba_ram_write, dev, DEVICE_NATIVE_ENDIAN);
+
+    cpu_register_physical_memory(RCBA_BASE, 0x4000, iomemtype);
+#if 0
+    cpu_register_physical_memory(0x00CDA000, 0x4000, iomemtype);
+#endif
+
+    pci_conf[0x04] = 0x07; // master, memory and I/O
+    pci_conf[0x05] = 0x00;
+    pci_conf[0x06] = 0x00;
+    pci_conf[0x07] = 0x02; // PCI_status_devsel_medium
+    pci_conf[0x4c] = 0x4d;
+    pci_conf[0x4e] = 0x03;
+    pci_conf[0x4f] = 0x00;
+    pci_conf[0x60] = 0x0a; // PCI A -> IRQ 10
+    pci_conf[0x61] = 0x0a; // PCI B -> IRQ 10
+    pci_conf[0x62] = 0x0b; // PCI C -> IRQ 11
+    pci_conf[0x63] = 0x0b; // PCI D -> IRQ 11
+    pci_conf[0x69] = 0x02;
+    pci_conf[0x70] = 0x80;
+    pci_conf[0x76] = 0x0c;
+    pci_conf[0x77] = 0x0c;
+    pci_conf[0x78] = 0x02;
+    pci_conf[0x79] = 0x00;
+    pci_conf[0x80] = 0x00;
+    pci_conf[0x82] = 0x00;
+    pci_conf[0xa0] = 0x08;
+    pci_conf[0xa2] = 0x00;
+    pci_conf[0xa3] = 0x00;
+    pci_conf[0xa4] = 0x00;
+    pci_conf[0xa5] = 0x00;
+    pci_conf[0xa6] = 0x00;
+    pci_conf[0xa7] = 0x00;
+    pci_conf[0xa8] = 0x0f;
+    pci_conf[0xaa] = 0x00;
+    pci_conf[0xab] = 0x00;
+    pci_conf[0xac] = 0x00;
+    pci_conf[0xae] = 0x00;
+
+#if 0
+    register_ioport_read(0x1000, 128, 1, pmbase_readb, d);
+    register_ioport_write(0x1000, 128, 1, pmbase_writeb, d);
+    register_ioport_read(0x1000, 64, 2, pmbase_readw, d);
+    register_ioport_write(0x1000, 64, 2, pmbase_writew, d);
+    register_ioport_read(0x1000, 32, 4, pmbase_readl, d);
+    register_ioport_write(0x1000, 32, 5, pmbase_writel, d);
+#endif
+
+    return 0;
+}
+
+static int lpc_uninit(PCIDevice *dev)
+{
+    return 0;
+}
+
+static PCIDeviceInfo lpc_info = {
+    .qdev.name  = "lpc",
+    .qdev.size  = sizeof(LPCState),
+    .init       = lpc_init,
+    .exit       = lpc_uninit,
+};
+
+static void lpc_register_device(void)
+{
+    pci_qdev_register(&lpc_info);
+}
+
+device_init(lpc_register_device)
