# Quick patch until proper version is upstream, but is safe. 
# Signed-off-by: Alex Graf - agraf@suse 
Index: kvm-75/qemu/qemu-kvm-x86.c
===================================================================
--- kvm-75.orig/qemu/qemu-kvm-x86.c
+++ kvm-75/qemu/qemu-kvm-x86.c
@@ -465,10 +465,11 @@ static void host_cpuid(uint32_t function
 }
 
 
-static void do_cpuid_ent(struct kvm_cpuid_entry *e, uint32_t function,
+static void do_cpuid_ent(struct kvm_cpuid_entry *e, uint32_t function, uint32_t index,
 			 CPUState *env)
 {
     env->regs[R_EAX] = function;
+    env->regs[R_ECX] = index;
     qemu_kvm_cpuid_on_env(env);
     e->function = function;
     e->eax = env->regs[R_EAX];
@@ -554,7 +555,7 @@ int kvm_arch_qemu_init_env(CPUState *cen
 #endif
     int cpuid_nent = 0;
     CPUState copy;
-    uint32_t i, limit;
+    uint32_t i, j, limit;
 
     copy = *cenv;
 
@@ -579,15 +580,26 @@ int kvm_arch_qemu_init_env(CPUState *cen
     qemu_kvm_cpuid_on_env(&copy);
     limit = copy.regs[R_EAX];
 
-    for (i = 0; i <= limit; ++i)
-	do_cpuid_ent(&cpuid_ent[cpuid_nent++], i, &copy);
+    for (i = 0; i <= limit; ++i) {
+        switch(i) {
+            case 4:
+                for(j = 0; ; j++) {
+	            do_cpuid_ent(&cpuid_ent[cpuid_nent++], i, j, &copy);
+                    if(!copy.regs[R_EAX]) break;
+                }
+                break;
+            default:
+	        do_cpuid_ent(&cpuid_ent[cpuid_nent++], i, 0, &copy);
+                break;
+        }
+    }
 
     copy.regs[R_EAX] = 0x80000000;
     qemu_kvm_cpuid_on_env(&copy);
     limit = copy.regs[R_EAX];
 
     for (i = 0x80000000; i <= limit; ++i)
-	do_cpuid_ent(&cpuid_ent[cpuid_nent++], i, &copy);
+	do_cpuid_ent(&cpuid_ent[cpuid_nent++], i, 0, &copy);
 
     kvm_setup_cpuid(kvm_context, cenv->cpu_index, cpuid_nent, cpuid_ent);
     return 0;
