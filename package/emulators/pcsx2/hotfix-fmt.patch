# --- T2-COPYRIGHT-BEGIN ---
# t2/package/*/pcsx2/hotfix-fmt.patch
# Copyright (C) 2025 The T2 SDE Project
# SPDX-License-Identifier: GPL-2.0 or patched project license
# --- T2-COPYRIGHT-END ---

From de9d08075e845912f375ef9501969f430ea642f6 Mon Sep 17 00:00:00 2001
From: TheLastRar <TheLastRar@users.noreply.github.com>
Date: Wed, 15 Jan 2025 21:26:10 +0000
Subject: [PATCH] Misc: Don't use deprecated fmt/core.h header

---
 common/Assertions.cpp                              | 1 -
 common/Console.h                                   | 2 +-
 common/Error.h                                     | 2 +-
 common/Linux/LnxHostSys.cpp                        | 2 +-
 common/Linux/LnxMisc.cpp                           | 2 +-
 common/SmallString.h                               | 2 +-
 common/StringUtil.cpp                              | 2 +-
 common/Windows/WinHostSys.cpp                      | 1 -
 common/Windows/WinMisc.cpp                         | 2 --
 pcsx2-gsrunner/Main.cpp                            | 2 +-
 pcsx2-qt/Debugger/DebuggerSettingsManager.cpp      | 1 -
 pcsx2-qt/QtHost.cpp                                | 2 +-
 pcsx2/CDVD/CDVDcommon.cpp                          | 2 +-
 pcsx2/CDVD/IsoHasher.cpp                           | 2 +-
 pcsx2/CDVD/OutputIsoFile.cpp                       | 2 +-
 pcsx2/DEV9/Win32/tap-win32.cpp                     | 2 +-
 pcsx2/GS/Renderers/Common/GSRenderer.cpp           | 2 +-
 pcsx2/GSDumpReplayer.cpp                           | 2 +-
 pcsx2/GameDatabase.cpp                             | 2 +-
 pcsx2/Hw.cpp                                       | 2 +-
 pcsx2/ImGui/FullscreenUI.cpp                       | 2 +-
 pcsx2/ImGui/ImGuiFullscreen.cpp                    | 2 +-
 pcsx2/ImGui/ImGuiManager.cpp                       | 2 +-
 pcsx2/Input/InputManager.cpp                       | 2 +-
 pcsx2/Input/XInputSource.cpp                       | 2 ++
 pcsx2/PrecompiledHeader.h                          | 2 +-
 pcsx2/Recording/PadData.cpp                        | 2 +-
 pcsx2/Recording/Utilities/InputRecordingLogger.cpp | 2 +-
 pcsx2/SIO/Memcard/MemoryCardFile.cpp               | 2 +-
 pcsx2/SIO/Memcard/MemoryCardFolder.cpp             | 2 +-
 pcsx2/SIO/Memcard/MemoryCardFolder.h               | 2 --
 pcsx2/SaveState.cpp                                | 2 +-
 pcsx2/SourceLog.cpp                                | 2 +-
 pcsx2/VMManager.cpp                                | 2 +-
 pcsx2/Vif_HashBucket.h                             | 1 -
 pcsx2/ps2/Iop/IopHw_Internal.h                     | 2 +-
 pcsx2/ps2/Iop/PsxBios.cpp                          | 2 +-
 pcsx2/ps2/eeHwTraceLog.inl                         | 2 +-
 pcsx2/vtlb.cpp                                     | 2 +-
 pcsx2/x86/iR3000A.cpp                              | 2 --
 pcsx2/x86/microVU_Log.inl                          | 2 +-
 updater/UpdaterExtractor.h                         | 2 +-
 44 files changed, 36 insertions(+), 46 deletions(-)

diff --git a/common/Assertions.cpp b/common/Assertions.cpp
index 754d4810349b7..6cfe8508c2277 100644
--- a/common/Assertions.cpp
+++ b/common/Assertions.cpp
@@ -7,7 +7,6 @@
 #include "Threading.h"
 
 #include <mutex>
-#include "fmt/core.h"
 
 #ifdef _WIN32
 #include "RedtapeWindows.h"
diff --git a/common/Console.h b/common/Console.h
index 45d6dcc776f5c..f928a61d6d396 100644
--- a/common/Console.h
+++ b/common/Console.h
@@ -5,7 +5,7 @@
 
 #include "Pcsx2Defs.h"
 
-#include "fmt/core.h"
+#include "fmt/base.h"
 
 #include <cstdarg>
 #include <string>
diff --git a/common/Error.h b/common/Error.h
index c3c48c3c36141..94955948df596 100644
--- a/common/Error.h
+++ b/common/Error.h
@@ -5,7 +5,7 @@
 
 #include "Pcsx2Defs.h"
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 #include <string>
 
diff --git a/common/Linux/LnxHostSys.cpp b/common/Linux/LnxHostSys.cpp
index 54a8e2f24aae8..104ceeab35909 100644
--- a/common/Linux/LnxHostSys.cpp
+++ b/common/Linux/LnxHostSys.cpp
@@ -17,7 +17,7 @@
 #include <ucontext.h>
 #include <unistd.h>
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 #if defined(__FreeBSD__)
 #include "cpuinfo.h"
diff --git a/common/Linux/LnxMisc.cpp b/common/Linux/LnxMisc.cpp
index b564adaf4979d..2c36c9bab7084 100644
--- a/common/Linux/LnxMisc.cpp
+++ b/common/Linux/LnxMisc.cpp
@@ -11,7 +11,7 @@
 #include "common/Threading.h"
 #include "common/WindowInfo.h"
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 #include <ctype.h>
 #include <time.h>
diff --git a/common/SmallString.h b/common/SmallString.h
index 00bfa76b3c98c..ee0e777740268 100644
--- a/common/SmallString.h
+++ b/common/SmallString.h
@@ -5,7 +5,7 @@
 
 #include "Pcsx2Defs.h"
 
-#include "fmt/core.h"
+#include "fmt/base.h"
 
 #include <algorithm>
 #include <cstdarg>
diff --git a/common/StringUtil.cpp b/common/StringUtil.cpp
index f520d97ce8167..14cc9de6a2d98 100644
--- a/common/StringUtil.cpp
+++ b/common/StringUtil.cpp
@@ -10,7 +10,7 @@
 #include <sstream>
 #include <algorithm>
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 #ifdef _WIN32
 #include "RedtapeWindows.h"
diff --git a/common/Windows/WinHostSys.cpp b/common/Windows/WinHostSys.cpp
index 54e76fa6ccfb4..1e13bd7e9931a 100644
--- a/common/Windows/WinHostSys.cpp
+++ b/common/Windows/WinHostSys.cpp
@@ -10,7 +10,6 @@
 #include "common/RedtapeWindows.h"
 #include "common/StringUtil.h"
 
-#include "fmt/core.h"
 #include "fmt/format.h"
 
 #include <mutex>
diff --git a/common/Windows/WinMisc.cpp b/common/Windows/WinMisc.cpp
index cc9b2929d84b0..5de77b51f70dd 100644
--- a/common/Windows/WinMisc.cpp
+++ b/common/Windows/WinMisc.cpp
@@ -8,8 +8,6 @@
 #include "common/Threading.h"
 #include "common/WindowInfo.h"
 
-#include "fmt/core.h"
-
 #include <mmsystem.h>
 #include <timeapi.h>
 #include <VersionHelpers.h>
diff --git a/pcsx2-gsrunner/Main.cpp b/pcsx2-gsrunner/Main.cpp
index d3ad1e818251b..fe27b2922ff8e 100644
--- a/pcsx2-gsrunner/Main.cpp
+++ b/pcsx2-gsrunner/Main.cpp
@@ -13,7 +13,7 @@
 #include "common/RedtapeWindows.h"
 #endif
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 #include "common/Assertions.h"
 #include "common/Console.h"
diff --git a/pcsx2-qt/Debugger/DebuggerSettingsManager.cpp b/pcsx2-qt/Debugger/DebuggerSettingsManager.cpp
index aa5193c2accb2..4096acd19659f 100644
--- a/pcsx2-qt/Debugger/DebuggerSettingsManager.cpp
+++ b/pcsx2-qt/Debugger/DebuggerSettingsManager.cpp
@@ -9,7 +9,6 @@
 #include <QtCore/QFile>
 
 #include "common/Console.h"
-#include "fmt/core.h"
 #include "VMManager.h"
 #include "Models/BreakpointModel.h"
 
diff --git a/pcsx2-qt/QtHost.cpp b/pcsx2-qt/QtHost.cpp
index fcc976d44a8c8..186e2078a5b04 100644
--- a/pcsx2-qt/QtHost.cpp
+++ b/pcsx2-qt/QtHost.cpp
@@ -51,7 +51,7 @@
 #include <QtGui/QClipboard>
 #include <QtGui/QInputMethod>
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 #include <cmath>
 #include <csignal>
diff --git a/pcsx2/CDVD/CDVDcommon.cpp b/pcsx2/CDVD/CDVDcommon.cpp
index 5162b85440966..8218655566ebd 100644
--- a/pcsx2/CDVD/CDVDcommon.cpp
+++ b/pcsx2/CDVD/CDVDcommon.cpp
@@ -23,7 +23,7 @@
 #include <memory>
 #include <time.h>
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 // TODO: FIXME! Should be platform specific.
 #ifdef _WIN32
diff --git a/pcsx2/CDVD/IsoHasher.cpp b/pcsx2/CDVD/IsoHasher.cpp
index af05d0f6d6a8e..4efc1d5829790 100644
--- a/pcsx2/CDVD/IsoHasher.cpp
+++ b/pcsx2/CDVD/IsoHasher.cpp
@@ -9,7 +9,7 @@
 #include "common/MD5Digest.h"
 #include "common/StringUtil.h"
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 #include <algorithm>
 
diff --git a/pcsx2/CDVD/OutputIsoFile.cpp b/pcsx2/CDVD/OutputIsoFile.cpp
index 9e072e54feda9..f1f531a875193 100644
--- a/pcsx2/CDVD/OutputIsoFile.cpp
+++ b/pcsx2/CDVD/OutputIsoFile.cpp
@@ -8,7 +8,7 @@
 #include "common/FileSystem.h"
 #include "common/StringUtil.h"
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 #include <errno.h>
 
diff --git a/pcsx2/DEV9/Win32/tap-win32.cpp b/pcsx2/DEV9/Win32/tap-win32.cpp
index d52ba6a400ce2..6cf35f22896da 100644
--- a/pcsx2/DEV9/Win32/tap-win32.cpp
+++ b/pcsx2/DEV9/Win32/tap-win32.cpp
@@ -5,7 +5,7 @@
 #include "common/RedtapeWilCom.h"
 #include "common/StringUtil.h"
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 #include <stdio.h>
 #include <WinSock2.h>
diff --git a/pcsx2/GS/Renderers/Common/GSRenderer.cpp b/pcsx2/GS/Renderers/Common/GSRenderer.cpp
index e564e0e6d26ba..95fa243e7d00a 100644
--- a/pcsx2/GS/Renderers/Common/GSRenderer.cpp
+++ b/pcsx2/GS/Renderers/Common/GSRenderer.cpp
@@ -21,7 +21,7 @@
 #include "common/StringUtil.h"
 #include "common/Timer.h"
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 #include "IconsFontAwesome5.h"
 
 #include <algorithm>
diff --git a/pcsx2/GSDumpReplayer.cpp b/pcsx2/GSDumpReplayer.cpp
index 46e20cf7fbae1..6e8dbe5c02527 100644
--- a/pcsx2/GSDumpReplayer.cpp
+++ b/pcsx2/GSDumpReplayer.cpp
@@ -16,7 +16,7 @@
 
 #include "imgui.h"
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 #include "common/Error.h"
 #include "common/FileSystem.h"
diff --git a/pcsx2/GameDatabase.cpp b/pcsx2/GameDatabase.cpp
index 6d6a814d63067..165af8c840c55 100644
--- a/pcsx2/GameDatabase.cpp
+++ b/pcsx2/GameDatabase.cpp
@@ -18,7 +18,7 @@
 #include <sstream>
 #include "ryml_std.hpp"
 #include "ryml.hpp"
-#include "fmt/core.h"
+#include "fmt/format.h"
 #include "fmt/ranges.h"
 #include <fstream>
 #include <mutex>
diff --git a/pcsx2/Hw.cpp b/pcsx2/Hw.cpp
index 64f3d1df1be38..f2ccdb559be0a 100644
--- a/pcsx2/Hw.cpp
+++ b/pcsx2/Hw.cpp
@@ -9,7 +9,7 @@
 
 #include "common/WrappedMemCopy.h"
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 using namespace R5900;
 
diff --git a/pcsx2/ImGui/FullscreenUI.cpp b/pcsx2/ImGui/FullscreenUI.cpp
index 44afb555a5366..71eeff42ef643 100644
--- a/pcsx2/ImGui/FullscreenUI.cpp
+++ b/pcsx2/ImGui/FullscreenUI.cpp
@@ -47,7 +47,7 @@
 #include "imgui_internal.h"
 
 #include "fmt/chrono.h"
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 #include <array>
 #include <bitset>
diff --git a/pcsx2/ImGui/ImGuiFullscreen.cpp b/pcsx2/ImGui/ImGuiFullscreen.cpp
index 8d9a8a07e0e55..c7a9b999eba69 100644
--- a/pcsx2/ImGui/ImGuiFullscreen.cpp
+++ b/pcsx2/ImGui/ImGuiFullscreen.cpp
@@ -3,7 +3,7 @@
 
 #define IMGUI_DEFINE_MATH_OPERATORS
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 #include "Host.h"
 #include "GS/Renderers/Common/GSDevice.h"
 #include "GS/Renderers/Common/GSTexture.h"
diff --git a/pcsx2/ImGui/ImGuiManager.cpp b/pcsx2/ImGui/ImGuiManager.cpp
index 234565ce32b16..8dc4d9ca8a7bb 100644
--- a/pcsx2/ImGui/ImGuiManager.cpp
+++ b/pcsx2/ImGui/ImGuiManager.cpp
@@ -23,7 +23,7 @@
 #include "common/Path.h"
 #include "common/Timer.h"
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 #include "imgui.h"
 #include "imgui_internal.h"
 #include "common/Image.h"
diff --git a/pcsx2/Input/InputManager.cpp b/pcsx2/Input/InputManager.cpp
index 33dde367afc12..9b1e1c929c423 100644
--- a/pcsx2/Input/InputManager.cpp
+++ b/pcsx2/Input/InputManager.cpp
@@ -16,7 +16,7 @@
 
 #include "IconsPromptFont.h"
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 #include <array>
 #include <atomic>
diff --git a/pcsx2/Input/XInputSource.cpp b/pcsx2/Input/XInputSource.cpp
index 215f8e55d76d4..b60c0cf794df0 100644
--- a/pcsx2/Input/XInputSource.cpp
+++ b/pcsx2/Input/XInputSource.cpp
@@ -10,6 +10,8 @@
 
 #include "IconsPromptFont.h"
 
+#include "fmt/format.h"
+
 #include <cmath>
 
 static const char* s_axis_names[XInputSource::NUM_AXES] = {
diff --git a/pcsx2/PrecompiledHeader.h b/pcsx2/PrecompiledHeader.h
index c558b6c223475..8a8c28abc5588 100644
--- a/pcsx2/PrecompiledHeader.h
+++ b/pcsx2/PrecompiledHeader.h
@@ -43,5 +43,5 @@
 // We use fmt a fair bit now.
 // fmt pch breaks GCC in debug builds: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=114370
 #if !defined(__GNUC__) || defined(__clang__)
-#include "fmt/core.h"
+#include "fmt/format.h"
 #endif
diff --git a/pcsx2/Recording/PadData.cpp b/pcsx2/Recording/PadData.cpp
index c07233618ce3c..e384ff233856e 100644
--- a/pcsx2/Recording/PadData.cpp
+++ b/pcsx2/Recording/PadData.cpp
@@ -7,7 +7,7 @@
 #include "SIO/Pad/PadDualshock2.h"
 #include "SIO/Sio.h"
 
-#include <fmt/core.h>
+#include "fmt/format.h"
 
 PadData::PadData(const int port, const int slot)
 {
diff --git a/pcsx2/Recording/Utilities/InputRecordingLogger.cpp b/pcsx2/Recording/Utilities/InputRecordingLogger.cpp
index 434acf6a99023..5a7f32d42c272 100644
--- a/pcsx2/Recording/Utilities/InputRecordingLogger.cpp
+++ b/pcsx2/Recording/Utilities/InputRecordingLogger.cpp
@@ -10,7 +10,7 @@
 #include "GS.h"
 #include "Host.h"
 
-#include <fmt/core.h>
+#include "fmt/format.h"
 
 namespace InputRec
 {
diff --git a/pcsx2/SIO/Memcard/MemoryCardFile.cpp b/pcsx2/SIO/Memcard/MemoryCardFile.cpp
index 032cef212a44f..08afa1a26e91e 100644
--- a/pcsx2/SIO/Memcard/MemoryCardFile.cpp
+++ b/pcsx2/SIO/Memcard/MemoryCardFile.cpp
@@ -20,7 +20,7 @@
 #include "Host.h"
 #include "IconsPromptFont.h"
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 #include <map>
 
diff --git a/pcsx2/SIO/Memcard/MemoryCardFolder.cpp b/pcsx2/SIO/Memcard/MemoryCardFolder.cpp
index 2d857dae611d8..be6b889529b25 100644
--- a/pcsx2/SIO/Memcard/MemoryCardFolder.cpp
+++ b/pcsx2/SIO/Memcard/MemoryCardFolder.cpp
@@ -17,7 +17,7 @@
 #include "common/StringUtil.h"
 #include "common/Timer.h"
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 #include "ryml_std.hpp"
 #include "ryml.hpp"
 
diff --git a/pcsx2/SIO/Memcard/MemoryCardFolder.h b/pcsx2/SIO/Memcard/MemoryCardFolder.h
index 7f5dc6d42432c..1fce0d9aba3cd 100644
--- a/pcsx2/SIO/Memcard/MemoryCardFolder.h
+++ b/pcsx2/SIO/Memcard/MemoryCardFolder.h
@@ -10,8 +10,6 @@
 
 #include "Config.h"
 
-#include "fmt/core.h"
-
 //#define DEBUG_WRITE_FOLDER_CARD_IN_MEMORY_TO_FILE_ON_CHANGE
 
 // --------------------------------------------------------------------------------------
diff --git a/pcsx2/SaveState.cpp b/pcsx2/SaveState.cpp
index e7719814cf554..fbc990dd44b6d 100644
--- a/pcsx2/SaveState.cpp
+++ b/pcsx2/SaveState.cpp
@@ -37,7 +37,7 @@
 #include "common/StringUtil.h"
 #include "common/ZipHelpers.h"
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 #include <csetjmp>
 #include <png.h>
diff --git a/pcsx2/SourceLog.cpp b/pcsx2/SourceLog.cpp
index 582a70cd1445b..73448d5f5196f 100644
--- a/pcsx2/SourceLog.cpp
+++ b/pcsx2/SourceLog.cpp
@@ -13,7 +13,7 @@
 #include "R3000A.h"
 #include "R5900.h"
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 #include <cctype>
 #include <cstdarg>
diff --git a/pcsx2/VMManager.cpp b/pcsx2/VMManager.cpp
index ba11e44ed8b72..1b4ab39180cf8 100644
--- a/pcsx2/VMManager.cpp
+++ b/pcsx2/VMManager.cpp
@@ -57,7 +57,7 @@
 #include "IconsPromptFont.h"
 #include "cpuinfo.h"
 #include "discord_rpc.h"
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 #include <atomic>
 #include <mutex>
diff --git a/pcsx2/Vif_HashBucket.h b/pcsx2/Vif_HashBucket.h
index 6e650d0458c38..ad04cf62643b0 100644
--- a/pcsx2/Vif_HashBucket.h
+++ b/pcsx2/Vif_HashBucket.h
@@ -4,7 +4,6 @@
 #pragma once
 
 #include <array>
-#include "fmt/core.h"
 #include "common/AlignedMalloc.h"
 
 // nVifBlock - Ordered for Hashing; the 'num' and 'upkType' fields are
diff --git a/pcsx2/ps2/Iop/IopHw_Internal.h b/pcsx2/ps2/Iop/IopHw_Internal.h
index 66baa54191d90..eb3dfb551e3d8 100644
--- a/pcsx2/ps2/Iop/IopHw_Internal.h
+++ b/pcsx2/ps2/Iop/IopHw_Internal.h
@@ -6,7 +6,7 @@
 #include "Common.h"
 #include "IopHw.h"
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 namespace IopMemory {
 namespace Internal {
diff --git a/pcsx2/ps2/Iop/PsxBios.cpp b/pcsx2/ps2/Iop/PsxBios.cpp
index 3810bf462eebe..acf6e54adf22d 100644
--- a/pcsx2/ps2/Iop/PsxBios.cpp
+++ b/pcsx2/ps2/Iop/PsxBios.cpp
@@ -5,7 +5,7 @@
 #include "R3000A.h"
 #include "IopMem.h"
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 static std::string psxout_buf;
 
diff --git a/pcsx2/ps2/eeHwTraceLog.inl b/pcsx2/ps2/eeHwTraceLog.inl
index ebd3fd94c3e45..f44345dda9625 100644
--- a/pcsx2/ps2/eeHwTraceLog.inl
+++ b/pcsx2/ps2/eeHwTraceLog.inl
@@ -3,7 +3,7 @@
 
 #pragma once
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 #define eeAddrInRange(name, addr) \
 	(addr >= EEMemoryMap::name##_Start && addr < EEMemoryMap::name##_End)
diff --git a/pcsx2/vtlb.cpp b/pcsx2/vtlb.cpp
index c0d5919f3937f..d1026a3e8b6a0 100644
--- a/pcsx2/vtlb.cpp
+++ b/pcsx2/vtlb.cpp
@@ -27,7 +27,7 @@
 #include "common/BitUtils.h"
 #include "common/Error.h"
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 #include <bit>
 #ifdef _M_X86
diff --git a/pcsx2/x86/iR3000A.cpp b/pcsx2/x86/iR3000A.cpp
index 4a6bfc777f53a..36807b78ed8ba 100644
--- a/pcsx2/x86/iR3000A.cpp
+++ b/pcsx2/x86/iR3000A.cpp
@@ -26,8 +26,6 @@
 #include "common/Perf.h"
 #include "DebugTools/Breakpoints.h"
 
-#include "fmt/core.h"
-
 // #define DUMP_BLOCKS 1
 // #define TRACE_BLOCKS 1
 
diff --git a/pcsx2/x86/microVU_Log.inl b/pcsx2/x86/microVU_Log.inl
index 31d146e13368c..1b77f300c5b48 100644
--- a/pcsx2/x86/microVU_Log.inl
+++ b/pcsx2/x86/microVU_Log.inl
@@ -8,7 +8,7 @@
 #include "common/FileSystem.h"
 #include "common/Path.h"
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 // writes text directly to mVU.logFile, no newlines appended.
 _mVUt void __mVULog(const char* fmt, ...)
diff --git a/updater/UpdaterExtractor.h b/updater/UpdaterExtractor.h
index 7069c3f251104..dfcdcaad02d24 100644
--- a/updater/UpdaterExtractor.h
+++ b/updater/UpdaterExtractor.h
@@ -7,7 +7,7 @@
 #include "common/ScopedGuard.h"
 #include "common/StringUtil.h"
 
-#include "fmt/core.h"
+#include "fmt/format.h"
 
 #if defined(_WIN32)
 #include "7z.h"
From c58f6f2f70d5a323c47663362d8d42ac79e30f4c Mon Sep 17 00:00:00 2001
From: TheLastRar <TheLastRar@users.noreply.github.com>
Date: Wed, 15 Jan 2025 21:26:10 +0000
Subject: [PATCH] 3rdparty: Update fmt to v11.1.2

---
 3rdparty/fmt/CMakeLists.txt           |  228 +-
 3rdparty/fmt/ChangeLog.md             | 8022 +++++++++----------------
 3rdparty/fmt/README.md                |   81 +-
 3rdparty/fmt/include/fmt/args.h       |  163 +-
 3rdparty/fmt/include/fmt/base.h       | 2958 +++++++++
 3rdparty/fmt/include/fmt/chrono.h     | 1230 ++--
 3rdparty/fmt/include/fmt/color.h      |  221 +-
 3rdparty/fmt/include/fmt/compile.h    |  164 +-
 3rdparty/fmt/include/fmt/core.h       | 2972 +--------
 3rdparty/fmt/include/fmt/format-inl.h |  393 +-
 3rdparty/fmt/include/fmt/format.h     | 3035 +++++-----
 3rdparty/fmt/include/fmt/os.h         |  272 +-
 3rdparty/fmt/include/fmt/ostream.h    |  205 +-
 3rdparty/fmt/include/fmt/printf.h     |  412 +-
 3rdparty/fmt/include/fmt/ranges.h     |  594 +-
 3rdparty/fmt/include/fmt/std.h        |  471 +-
 3rdparty/fmt/include/fmt/xchar.h      |  270 +-
 3rdparty/fmt/src/fmt.cc               |  107 +-
 3rdparty/fmt/src/format.cc            |    5 +-
 3rdparty/fmt/src/os.cc                |  150 +-
 cmake/SearchForStuff.cmake            |    2 +-
 21 files changed, 9870 insertions(+), 12085 deletions(-)
 create mode 100644 3rdparty/fmt/include/fmt/base.h

diff --git a/3rdparty/fmt/CMakeLists.txt b/3rdparty/fmt/CMakeLists.txt
index 6f49af1d94958..059b150238450 100644
--- a/3rdparty/fmt/CMakeLists.txt
+++ b/3rdparty/fmt/CMakeLists.txt
@@ -1,4 +1,4 @@
-cmake_minimum_required(VERSION 3.8...3.26)
+cmake_minimum_required(VERSION 3.8...3.28)
 
 # Fallback for using newer policies on CMake <3.12.
 if (${CMAKE_VERSION} VERSION_LESS 3.12)
@@ -36,6 +36,12 @@ function(enable_module target)
   endif ()
 endfunction()
 
+set(FMT_USE_CMAKE_MODULES FALSE)
+if (CMAKE_VERSION VERSION_GREATER_EQUAL 3.28 AND
+    CMAKE_GENERATOR STREQUAL "Ninja")
+  set(FMT_USE_CMAKE_MODULES TRUE)
+endif ()
+
 # Adds a library compiled with C++20 module support.
 # `enabled` is a CMake variables that specifies if modules are enabled.
 # If modules are disabled `add_module_library` falls back to creating a
@@ -53,6 +59,7 @@ function(add_module_library name)
   if (NOT ${${AML_IF}})
     # Create a non-modular library.
     target_sources(${name} PRIVATE ${AML_FALLBACK})
+    set_target_properties(${name} PROPERTIES CXX_SCAN_FOR_MODULES OFF)
     return()
   endif ()
 
@@ -62,48 +69,55 @@ function(add_module_library name)
     target_compile_options(${name} PUBLIC -fmodules-ts)
   endif ()
 
-  # `std` is affected by CMake options and may be higher than C++20.
-  get_target_property(std ${name} CXX_STANDARD)
-
-  if (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
-    set(pcms)
-    foreach (src ${sources})
-      get_filename_component(pcm ${src} NAME_WE)
-      set(pcm ${pcm}.pcm)
-
-      # Propagate -fmodule-file=*.pcm to targets that link with this library.
-      target_compile_options(
-        ${name} PUBLIC -fmodule-file=${CMAKE_CURRENT_BINARY_DIR}/${pcm})
-
-      # Use an absolute path to prevent target_link_libraries prepending -l
-      # to it.
-      set(pcms ${pcms} ${CMAKE_CURRENT_BINARY_DIR}/${pcm})
-      add_custom_command(
-        OUTPUT ${pcm}
-        COMMAND ${CMAKE_CXX_COMPILER}
-                -std=c++${std} -x c++-module --precompile -c
-                -o ${pcm} ${CMAKE_CURRENT_SOURCE_DIR}/${src}
-                "-I$<JOIN:$<TARGET_PROPERTY:${name},INCLUDE_DIRECTORIES>,;-I>"
-        # Required by the -I generator expression above.
-        COMMAND_EXPAND_LISTS
-        DEPENDS ${src})
-    endforeach ()
-
-    # Add .pcm files as sources to make sure they are built before the library.
-    set(sources)
-    foreach (pcm ${pcms})
-      get_filename_component(pcm_we ${pcm} NAME_WE)
-      set(obj ${pcm_we}.o)
-      # Use an absolute path to prevent target_link_libraries prepending -l.
-      set(sources ${sources} ${pcm} ${CMAKE_CURRENT_BINARY_DIR}/${obj})
-      add_custom_command(
-        OUTPUT ${obj}
-        COMMAND ${CMAKE_CXX_COMPILER} $<TARGET_PROPERTY:${name},COMPILE_OPTIONS>
-                -c -o ${obj} ${pcm}
-        DEPENDS ${pcm})
-    endforeach ()
-  endif ()
-  target_sources(${name} PRIVATE ${sources})
+  target_compile_definitions(${name} PRIVATE FMT_MODULE)
+
+  if (FMT_USE_CMAKE_MODULES)
+    target_sources(${name} PUBLIC FILE_SET fmt TYPE CXX_MODULES
+                   FILES ${sources})
+  else()
+    # `std` is affected by CMake options and may be higher than C++20.
+    get_target_property(std ${name} CXX_STANDARD)
+
+    if (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
+      set(pcms)
+      foreach (src ${sources})
+        get_filename_component(pcm ${src} NAME_WE)
+        set(pcm ${pcm}.pcm)
+
+        # Propagate -fmodule-file=*.pcm to targets that link with this library.
+        target_compile_options(
+          ${name} PUBLIC -fmodule-file=${CMAKE_CURRENT_BINARY_DIR}/${pcm})
+
+        # Use an absolute path to prevent target_link_libraries prepending -l
+        # to it.
+        set(pcms ${pcms} ${CMAKE_CURRENT_BINARY_DIR}/${pcm})
+        add_custom_command(
+          OUTPUT ${pcm}
+          COMMAND ${CMAKE_CXX_COMPILER}
+                  -std=c++${std} -x c++-module --precompile -c
+                  -o ${pcm} ${CMAKE_CURRENT_SOURCE_DIR}/${src}
+                  "-I$<JOIN:$<TARGET_PROPERTY:${name},INCLUDE_DIRECTORIES>,;-I>"
+          # Required by the -I generator expression above.
+          COMMAND_EXPAND_LISTS
+          DEPENDS ${src})
+      endforeach ()
+
+      # Add .pcm files as sources to make sure they are built before the library.
+      set(sources)
+      foreach (pcm ${pcms})
+        get_filename_component(pcm_we ${pcm} NAME_WE)
+        set(obj ${pcm_we}.o)
+        # Use an absolute path to prevent target_link_libraries prepending -l.
+        set(sources ${sources} ${pcm} ${CMAKE_CURRENT_BINARY_DIR}/${obj})
+        add_custom_command(
+          OUTPUT ${obj}
+          COMMAND ${CMAKE_CXX_COMPILER} $<TARGET_PROPERTY:${name},COMPILE_OPTIONS>
+                  -c -o ${obj} ${pcm}
+          DEPENDS ${pcm})
+      endforeach ()
+    endif ()
+    target_sources(${name} PRIVATE ${sources})
+  endif()
 endfunction()
 
 include(CMakeParseArguments)
@@ -145,21 +159,33 @@ option(FMT_WERROR "Halt the compilation with an error on compiler warnings."
        OFF)
 
 # Options that control generation of various targets.
+option(FMT_DOC "Generate the doc target." ${FMT_MASTER_PROJECT})
 option(FMT_INSTALL "Generate the install target." ON)
+option(FMT_TEST "Generate the test target." ${FMT_MASTER_PROJECT})
 option(FMT_FUZZ "Generate the fuzz target." OFF)
-option(FMT_OS "Include core requiring OS (Windows/Posix) " ON)
+option(FMT_CUDA_TEST "Generate the cuda-test target." OFF)
+option(FMT_OS "Include OS-specific APIs." ON)
 option(FMT_MODULE "Build a module instead of a traditional library." OFF)
 option(FMT_SYSTEM_HEADERS "Expose headers with marking them as system." OFF)
+option(FMT_UNICODE "Enable Unicode support." ON)
 
+if (FMT_TEST AND FMT_MODULE)
+  # The tests require {fmt} to be compiled as traditional library
+  message(STATUS "Testing is incompatible with build mode 'module'.")
+endif ()
 set(FMT_SYSTEM_HEADERS_ATTRIBUTE "")
 if (FMT_SYSTEM_HEADERS)
   set(FMT_SYSTEM_HEADERS_ATTRIBUTE SYSTEM)
 endif ()
+if (CMAKE_SYSTEM_NAME STREQUAL "MSDOS")
+  set(FMT_TEST OFF)
+  message(STATUS "MSDOS is incompatible with gtest")
+endif ()
 
-# Get version from core.h
-file(READ include/fmt/core.h core_h)
-if (NOT core_h MATCHES "FMT_VERSION ([0-9]+)([0-9][0-9])([0-9][0-9])")
-  message(FATAL_ERROR "Cannot get FMT_VERSION from core.h.")
+# Get version from base.h
+file(READ include/fmt/base.h base_h)
+if (NOT base_h MATCHES "FMT_VERSION ([0-9]+)([0-9][0-9])([0-9][0-9])")
+  message(FATAL_ERROR "Cannot get FMT_VERSION from base.h.")
 endif ()
 # Use math to skip leading zeros if any.
 math(EXPR CPACK_PACKAGE_VERSION_MAJOR ${CMAKE_MATCH_1})
@@ -167,7 +193,7 @@ math(EXPR CPACK_PACKAGE_VERSION_MINOR ${CMAKE_MATCH_2})
 math(EXPR CPACK_PACKAGE_VERSION_PATCH ${CMAKE_MATCH_3})
 join(FMT_VERSION ${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.
                  ${CPACK_PACKAGE_VERSION_PATCH})
-message(STATUS "Version: ${FMT_VERSION}")
+message(STATUS "{fmt} version: ${FMT_VERSION}")
 
 message(STATUS "Build type: ${CMAKE_BUILD_TYPE}")
 
@@ -214,7 +240,13 @@ if (CMAKE_CXX_COMPILER_ID MATCHES "GNU")
   endif ()
   if (NOT CMAKE_CXX_COMPILER_VERSION VERSION_LESS 6.0)
       set(PEDANTIC_COMPILE_FLAGS ${PEDANTIC_COMPILE_FLAGS} -Wshift-overflow=2
-          -Wnull-dereference -Wduplicated-cond)
+          -Wduplicated-cond)
+      # Workaround for GCC regression
+      # [12/13/14/15 regression] New (since gcc 12) false positive null-dereference in vector.resize
+      # https://gcc.gnu.org/bugzilla/show_bug.cgi?id=108860
+      if (CMAKE_CXX_COMPILER_VERSION VERSION_LESS 12.0)
+        set(PEDANTIC_COMPILE_FLAGS ${PEDANTIC_COMPILE_FLAGS} -Wnull-dereference)
+      endif ()
   endif ()
   set(WERROR_FLAG -Werror)
 endif ()
@@ -263,13 +295,10 @@ function(add_headers VAR)
 endfunction()
 
 # Define the fmt library, its includes and the needed defines.
-add_headers(FMT_HEADERS args.h chrono.h color.h compile.h core.h format.h
+add_headers(FMT_HEADERS args.h base.h chrono.h color.h compile.h core.h format.h
                         format-inl.h os.h ostream.h printf.h ranges.h std.h
                         xchar.h)
 set(FMT_SOURCES src/format.cc)
-if (FMT_OS)
-  set(FMT_SOURCES ${FMT_SOURCES} src/os.cc)
-endif ()
 
 add_module_library(fmt src/fmt.cc FALLBACK
                    ${FMT_SOURCES} ${FMT_HEADERS} README.md ChangeLog.md
@@ -277,6 +306,10 @@ add_module_library(fmt src/fmt.cc FALLBACK
 add_library(fmt::fmt ALIAS fmt)
 if (FMT_MODULE)
   enable_module(fmt)
+elseif (FMT_OS)
+  target_sources(fmt PRIVATE src/os.cc)
+else()
+  target_compile_definitions(fmt PRIVATE FMT_OS=0)
 endif ()
 
 if (FMT_WERROR)
@@ -292,7 +325,7 @@ else ()
   message(WARNING "Feature cxx_std_11 is unknown for the CXX compiler")
 endif ()
 
-target_include_directories(fmt ${FMT_SYSTEM_HEADERS_ATTRIBUTE} PUBLIC
+target_include_directories(fmt ${FMT_SYSTEM_HEADERS_ATTRIBUTE} BEFORE PUBLIC
   $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>
   $<INSTALL_INTERFACE:${FMT_INC_DIR}>)
 
@@ -328,11 +361,21 @@ endif ()
 add_library(fmt-header-only INTERFACE)
 add_library(fmt::fmt-header-only ALIAS fmt-header-only)
 
+if (NOT MSVC)
+  # Unicode is always supported on compilers other than MSVC.
+elseif (FMT_UNICODE)
+  # Unicode support requires compiling with /utf-8.
+  target_compile_options(fmt PUBLIC $<$<AND:$<COMPILE_LANGUAGE:CXX>,$<CXX_COMPILER_ID:MSVC>>:/utf-8>)
+  target_compile_options(fmt-header-only INTERFACE $<$<AND:$<COMPILE_LANGUAGE:CXX>,$<CXX_COMPILER_ID:MSVC>>:/utf-8>)
+else ()
+  target_compile_definitions(fmt PUBLIC FMT_UNICODE=0)
+endif ()
+
 target_compile_definitions(fmt-header-only INTERFACE FMT_HEADER_ONLY=1)
 target_compile_features(fmt-header-only INTERFACE cxx_std_11)
 
 target_include_directories(fmt-header-only
-  ${FMT_SYSTEM_HEADERS_ATTRIBUTE} INTERFACE
+  ${FMT_SYSTEM_HEADERS_ATTRIBUTE} BEFORE INTERFACE
   $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>
   $<INSTALL_INTERFACE:${FMT_INC_DIR}>)
 
@@ -377,12 +420,20 @@ if (FMT_INSTALL)
 
   set(INSTALL_TARGETS fmt fmt-header-only)
 
+  set(INSTALL_FILE_SET)
+  if (FMT_USE_CMAKE_MODULES)
+    set(INSTALL_FILE_SET FILE_SET fmt DESTINATION "${FMT_INC_DIR}/fmt")
+  endif()
+
   # Install the library and headers.
-  install(TARGETS ${INSTALL_TARGETS} EXPORT ${targets_export_name}
+  install(TARGETS ${INSTALL_TARGETS}
+          COMPONENT fmt-core
+          EXPORT ${targets_export_name}
           LIBRARY DESTINATION ${FMT_LIB_DIR}
           ARCHIVE DESTINATION ${FMT_LIB_DIR}
           PUBLIC_HEADER DESTINATION "${FMT_INC_DIR}/fmt"
-          RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
+          RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
+          ${INSTALL_FILE_SET})
 
   # Use a namespace because CMake provides better diagnostics for namespaced
   # imported targets.
@@ -390,13 +441,61 @@ if (FMT_INSTALL)
          FILE ${PROJECT_BINARY_DIR}/${targets_export_name}.cmake)
 
   # Install version, config and target files.
-  install(
-    FILES ${project_config} ${version_config}
-    DESTINATION ${FMT_CMAKE_DIR})
+  install(FILES ${project_config} ${version_config}
+          DESTINATION ${FMT_CMAKE_DIR}
+          COMPONENT fmt-core)
   install(EXPORT ${targets_export_name} DESTINATION ${FMT_CMAKE_DIR}
-          NAMESPACE fmt::)
+          NAMESPACE fmt::
+          COMPONENT fmt-core)
+
+  install(FILES "${pkgconfig}" DESTINATION "${FMT_PKGCONFIG_DIR}"
+          COMPONENT fmt-core)
+endif ()
+
+function(add_doc_target)
+  find_program(DOXYGEN doxygen
+    PATHS "$ENV{ProgramFiles}/doxygen/bin"
+          "$ENV{ProgramFiles\(x86\)}/doxygen/bin")
+  if (NOT DOXYGEN)
+    message(STATUS "Target 'doc' disabled because doxygen not found")
+    return ()
+  endif ()
+
+  find_program(MKDOCS mkdocs)
+  if (NOT MKDOCS)
+    message(STATUS "Target 'doc' disabled because mkdocs not found")
+    return ()
+  endif ()
+
+  set(sources )
+  foreach (source api.md index.md syntax.md get-started.md fmt.css fmt.js)
+    set(sources ${sources} doc/${source})
+  endforeach()
+
+  add_custom_target(
+    doc
+    COMMAND
+      ${CMAKE_COMMAND}
+        -E env PYTHONPATH=${CMAKE_CURRENT_SOURCE_DIR}/support/python
+        ${MKDOCS} build -f ${CMAKE_CURRENT_SOURCE_DIR}/support/mkdocs.yml
+        # MkDocs requires the site dir to be outside of the doc dir.
+                        --site-dir ${CMAKE_CURRENT_BINARY_DIR}/doc-html
+                        --no-directory-urls
+    SOURCES ${sources})
+
+  include(GNUInstallDirs)
+  install(DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/doc-html/
+          DESTINATION ${CMAKE_INSTALL_DATAROOTDIR}/doc/fmt
+          COMPONENT fmt-doc OPTIONAL)
+endfunction()
+
+if (FMT_DOC)
+  add_doc_target()
+endif ()
 
-  install(FILES "${pkgconfig}" DESTINATION "${FMT_PKGCONFIG_DIR}")
+if (FMT_TEST)
+  enable_testing()
+  add_subdirectory(test)
 endif ()
 
 # Control fuzzing independent of the unit tests.
@@ -421,8 +520,7 @@ if (FMT_MASTER_PROJECT AND EXISTS ${gitignore})
     string(REPLACE "*" ".*" line "${line}")
     set(ignored_files ${ignored_files} "${line}$" "${line}/")
   endforeach ()
-  set(ignored_files ${ignored_files}
-    /.git /breathe /format-benchmark sphinx/ .buildinfo .doctrees)
+  set(ignored_files ${ignored_files} /.git /build/doxyxml .vagrant)
 
   set(CPACK_SOURCE_GENERATOR ZIP)
   set(CPACK_SOURCE_IGNORE_FILES ${ignored_files})
diff --git a/3rdparty/fmt/ChangeLog.md b/3rdparty/fmt/ChangeLog.md
index 515f9fdc1d90e..08ded7d65db15 100644
--- a/3rdparty/fmt/ChangeLog.md
+++ b/3rdparty/fmt/ChangeLog.md
@@ -1,5533 +1,2891 @@
-# 10.2.1 - 2024-01-03
+# 11.1.2 - 2025-01-12
+
+- Fixed ABI compatibility with earlier 11.x versions
+  (https://github.com/fmtlib/fmt/issues/4292).
+
+- Added `wchar_t` support to the `std::bitset` formatter
+  (https://github.com/fmtlib/fmt/issues/4285,
+  https://github.com/fmtlib/fmt/pull/4286,
+  https://github.com/fmtlib/fmt/issues/4289,
+  https://github.com/fmtlib/fmt/pull/4290). Thanks @phprus.
 
--   Fixed ABI compatibility with earlier 10.x versions
-    (https://github.com/fmtlib/fmt/pull/3786). Thanks @saraedum.
+- Prefixed CMake components with `fmt-` to simplify usage of {fmt} via
+  `add_subdirectory` (https://github.com/fmtlib/fmt/issues/4283).
 
-# 10.2.0 - 2024-01-01
+- Updated docs for meson (https://github.com/fmtlib/fmt/pull/4291).
+  Thanks @trim21.
+
+- Fixed a compilation error in chrono on nvcc
+  (https://github.com/fmtlib/fmt/issues/4297,
+  https://github.com/fmtlib/fmt/pull/4301). Thanks @breyerml.
+
+- Fixed various warnings
+  (https://github.com/fmtlib/fmt/pull/4288,
+  https://github.com/fmtlib/fmt/pull/4299). Thanks @GamesTrap and @edo9300.
+
+# 11.1.1 - 2024-12-27
+
+- Fixed ABI compatibility with earlier 11.x versions
+  (https://github.com/fmtlib/fmt/issues/4278).
+
+- Defined CMake components (`core` and `doc`) to allow docs to be installed
+  separately (https://github.com/fmtlib/fmt/pull/4276).
+  Thanks @carlsmedstad.
+
+# 11.1.0 - 2024-12-25
+
+- Improved C++20 module support
+  (https://github.com/fmtlib/fmt/issues/4081,
+  https://github.com/fmtlib/fmt/pull/4083,
+  https://github.com/fmtlib/fmt/pull/4084,
+  https://github.com/fmtlib/fmt/pull/4152,
+  https://github.com/fmtlib/fmt/issues/4153,
+  https://github.com/fmtlib/fmt/pull/4169,
+  https://github.com/fmtlib/fmt/issues/4190,
+  https://github.com/fmtlib/fmt/issues/4234,
+  https://github.com/fmtlib/fmt/pull/4239).
+  Thanks @kamrann and @Arghnews.
+
+- Reduced debug (unoptimized) binary code size and the number of template
+  instantiations when passing formatting arguments. For example, unoptimized
+  binary code size for `fmt::print("{}", 42)` was reduced by ~40% on GCC and
+  ~60% on clang (x86-64).
+
+  GCC:
+  - Before: 161 instructions of which 105 are in reusable functions
+    ([godbolt](https://www.godbolt.org/z/s9bGoo4ze)).
+  - After: 116 instructions of which 60 are in reusable functions
+    ([godbolt](https://www.godbolt.org/z/r7GGGxMs6)).
 
--   Added support for the `%j` specifier (the number of days) for
-    `std::chrono::duration` (https://github.com/fmtlib/fmt/issues/3643,
-    https://github.com/fmtlib/fmt/pull/3732). Thanks @intelfx.
+  Clang:
+  - Before: 310 instructions of which 251 are in reusable functions
+    ([godbolt](https://www.godbolt.org/z/Ts88b7M9o)).
+  - After: 194 instructions of which 135 are in reusable functions
+    ([godbolt](https://www.godbolt.org/z/vcrjP8ceW)).
 
--   Added support for the chrono suffix for days and changed
-    the suffix for minutes from "m" to the correct "min"
-    (https://github.com/fmtlib/fmt/issues/3662,
-    https://github.com/fmtlib/fmt/pull/3664).
-    For example ([godbolt](https://godbolt.org/z/9KhMnq9ba)):
+- Added an experimental `fmt::writer` API that can be used for writing to
+  different destinations such as files or strings
+  (https://github.com/fmtlib/fmt/issues/2354).
+  For example ([godbolt](https://www.godbolt.org/z/rWoKfbP7e)):
 
-    ```c++
-    #include <fmt/chrono.h>
+  ```c++
+  #include <fmt/os.h>
 
-    int main() {
-      fmt::print("{}\n", std::chrono::days(42)); // prints "42d"
-    }
-    ```
+  void write_text(fmt::writer w) {
+    w.print("The answer is {}.", 42);
+  }
 
-    Thanks @Richardk2n.
+  int main() {
+    // Write to FILE.
+    write_text(stdout);
+
+    // Write to fmt::ostream.
+    auto f = fmt::output_file("myfile");
+    write_text(f);
+
+    // Write to std::string.
+    auto sb = fmt::string_buffer();
+    write_text(sb);
+    std::string s = sb.str();
+  }
+  ```
+
+- Added width and alignment support to the formatter of `std::error_code`.
 
--   Fixed an overflow in `std::chrono::time_point` formatting with large dates
-    (https://github.com/fmtlib/fmt/issues/3725,
-    https://github.com/fmtlib/fmt/pull/3727). Thanks @cschreib.
+- Made `std::expected<void, E>` formattable
+  (https://github.com/fmtlib/fmt/issues/4145,
+  https://github.com/fmtlib/fmt/pull/4148).
+  For example ([godbolt](https://www.godbolt.org/z/hrj5c6G86)):
 
--   Added a formatter for `std::source_location`
-    (https://github.com/fmtlib/fmt/pull/3730).
-    For example ([godbolt](https://godbolt.org/z/YajfKjhhr)):
+  ```c++
+  fmt::print("{}", std::expected<void, int>());
+  ```
 
-    ```c++
-    #include <source_location>
-    #include <fmt/std.h>
+  prints
 
-    int main() {
-      fmt::print("{}\n", std::source_location::current());
-    }
-    ```
+  ```
+  expected()
+  ```
 
-    prints
+  Thanks @phprus.
 
-    ```
-    /app/example.cpp:5:51: int main()
-    ```
+- Made `fmt::is_formattable<void>` SFINAE-friendly
+  (https://github.com/fmtlib/fmt/issues/4147).
 
-    Thanks @felix642.
+- Added support for `_BitInt` formatting when using clang
+  (https://github.com/fmtlib/fmt/issues/4007,
+  https://github.com/fmtlib/fmt/pull/4072,
+  https://github.com/fmtlib/fmt/issues/4140,
+  https://github.com/fmtlib/fmt/issues/4173,
+  https://github.com/fmtlib/fmt/pull/4176).
+  For example ([godbolt](https://www.godbolt.org/z/KWjbWec5z)):
 
--   Added a formatter for `std::bitset`
-    (https://github.com/fmtlib/fmt/pull/3660).
-    For example ([godbolt](https://godbolt.org/z/bdEaGeYxe)):
+  ```c++
+  using int42 = _BitInt(42);
+  fmt::print("{}", int42(100));
+  ```
 
-    ```c++
-    #include <bitset>
-    #include <fmt/std.h>
+  Thanks @Arghnews.
+
+- Added the `n` specifier for tuples and pairs
+  (https://github.com/fmtlib/fmt/pull/4107). Thanks @someonewithpc.
+
+- Added support for tuple-like types to `fmt::join`
+  (https://github.com/fmtlib/fmt/issues/4226,
+  https://github.com/fmtlib/fmt/pull/4230). Thanks @phprus.
+
+- Made more types formattable at compile time
+  (https://github.com/fmtlib/fmt/pull/4127). Thanks @AnthonyVH.
+
+- Implemented a more efficient compile-time `fmt::formatted_size`
+  (https://github.com/fmtlib/fmt/issues/4102,
+  https://github.com/fmtlib/fmt/pull/4103). Thanks @phprus.
+
+- Fixed compile-time formatting of some string types
+  (https://github.com/fmtlib/fmt/pull/4065). Thanks @torshepherd.
+
+- Made compiled version of `fmt::format_to` work with
+  `std::back_insert_iterator<std::vector<char>>`
+  (https://github.com/fmtlib/fmt/issues/4206,
+  https://github.com/fmtlib/fmt/pull/4211). Thanks @phprus.
+
+- Added a formatter for `std::reference_wrapper`
+  (https://github.com/fmtlib/fmt/pull/4163,
+  https://github.com/fmtlib/fmt/pull/4164). Thanks @yfeldblum and @phprus.
+
+- Added experimental padding support (glibc `strftime` extension) to `%m`, `%j`
+  and `%Y` (https://github.com/fmtlib/fmt/pull/4161). Thanks @KKhanhH.
+
+- Made microseconds formatted as `us` instead of `Âµs` if the Unicode support is
+  disabled (https://github.com/fmtlib/fmt/issues/4088).
+
+- Fixed an unreleased regression in transcoding of surrogate pairs
+  (https://github.com/fmtlib/fmt/issues/4094,
+  https://github.com/fmtlib/fmt/pull/4095). Thanks @phprus.
+
+- Made `fmt::appender` satisfy `std::output_iterator` concept
+  (https://github.com/fmtlib/fmt/issues/4092,
+  https://github.com/fmtlib/fmt/pull/4093). Thanks @phprus.
+
+- Made `std::iterator_traits<fmt::appender>` standard-conforming
+  (https://github.com/fmtlib/fmt/pull/4185). Thanks @CaseyCarter.
+
+- Made it easier to reuse `fmt::formatter<std::string_view>` for types with
+  an implicit conversion to `std::string_view`
+  (https://github.com/fmtlib/fmt/issues/4036,
+  https://github.com/fmtlib/fmt/pull/4055). Thanks @Arghnews.
+
+- Made it possible to disable `<filesystem>` use via `FMT_CPP_LIB_FILESYSTEM`
+  for compatibility with some video game console SDKs, e.g. Nintendo Switch SDK
+  (https://github.com/fmtlib/fmt/issues/4257,
+  https://github.com/fmtlib/fmt/pull/4258,
+  https://github.com/fmtlib/fmt/pull/4259). Thanks @W4RH4WK and @phprus.
+
+- Fixed compatibility with platforms that use 80-bit `long double`
+  (https://github.com/fmtlib/fmt/issues/4245,
+  https://github.com/fmtlib/fmt/pull/4246). Thanks @jsirpoma.
+
+- Added support for UTF-32 code units greater than `0xFFFF` in fill
+  (https://github.com/fmtlib/fmt/issues/4201).
+
+- Fixed handling of legacy encodings on Windows with GCC
+  (https://github.com/fmtlib/fmt/issues/4162).
+
+- Made `fmt::to_string` take `fmt::basic_memory_buffer` by const reference
+  (https://github.com/fmtlib/fmt/issues/4261,
+  https://github.com/fmtlib/fmt/pull/4262). Thanks @sascha-devel.
+
+- Added `fmt::dynamic_format_arg_store::size`
+  (https://github.com/fmtlib/fmt/pull/4270). Thanks @hannes-harnisch.
+
+- Removed the ability to control locale usage via an undocumented
+  `FMT_STATIC_THOUSANDS_SEPARATOR` in favor of `FMT_USE_LOCALE`.
+
+- Renamed `FMT_EXCEPTIONS` to `FMT_USE_EXCEPTIONS` for consistency with other
+  similar macros.
+
+- Improved include directory ordering to reduce the chance of including
+  incorrect headers when using multiple versions of {fmt}
+  (https://github.com/fmtlib/fmt/pull/4116). Thanks @cdzhan.
+
+- Made it possible to compile a subset of {fmt} without the C++ runtime.
+
+- Improved documentation and README
+  (https://github.com/fmtlib/fmt/pull/4066,
+  https://github.com/fmtlib/fmt/issues/4117,
+  https://github.com/fmtlib/fmt/issues/4203,
+  https://github.com/fmtlib/fmt/pull/4235). Thanks @zyctree and @nikola-sh.
+
+- Improved the documentation generator (https://github.com/fmtlib/fmt/pull/4110,
+  https://github.com/fmtlib/fmt/pull/4115). Thanks @rturrado.
+
+- Improved CI (https://github.com/fmtlib/fmt/pull/4155,
+  https://github.com/fmtlib/fmt/pull/4151). Thanks @phprus.
+
+- Fixed various warnings and compilation issues
+  (https://github.com/fmtlib/fmt/issues/2708,
+  https://github.com/fmtlib/fmt/issues/4091,
+  https://github.com/fmtlib/fmt/issues/4109,
+  https://github.com/fmtlib/fmt/issues/4113,
+  https://github.com/fmtlib/fmt/issues/4125,
+  https://github.com/fmtlib/fmt/issues/4129,
+  https://github.com/fmtlib/fmt/pull/4130,
+  https://github.com/fmtlib/fmt/pull/4131,
+  https://github.com/fmtlib/fmt/pull/4132,
+  https://github.com/fmtlib/fmt/issues/4133,
+  https://github.com/fmtlib/fmt/issues/4144,
+  https://github.com/fmtlib/fmt/issues/4150,
+  https://github.com/fmtlib/fmt/issues/4158,
+  https://github.com/fmtlib/fmt/pull/4159,
+  https://github.com/fmtlib/fmt/issues/4160,
+  https://github.com/fmtlib/fmt/pull/4170,
+  https://github.com/fmtlib/fmt/issues/4177,
+  https://github.com/fmtlib/fmt/pull/4187,
+  https://github.com/fmtlib/fmt/pull/4188,
+  https://github.com/fmtlib/fmt/pull/4194,
+  https://github.com/fmtlib/fmt/pull/4200,
+  https://github.com/fmtlib/fmt/issues/4205,
+  https://github.com/fmtlib/fmt/issues/4207,
+  https://github.com/fmtlib/fmt/pull/4208,
+  https://github.com/fmtlib/fmt/pull/4210,
+  https://github.com/fmtlib/fmt/issues/4220,
+  https://github.com/fmtlib/fmt/issues/4231,
+  https://github.com/fmtlib/fmt/issues/4232,
+  https://github.com/fmtlib/fmt/pull/4233,
+  https://github.com/fmtlib/fmt/pull/4236,
+  https://github.com/fmtlib/fmt/pull/4267,
+  https://github.com/fmtlib/fmt/pull/4271).
+  Thanks @torsten48, @Arghnews, @tinfoilboy, @aminya, @Ottani, @zeroomega,
+  @c4v4, @kongy, @vinayyadav3016, @sergio-nsk, @phprus and @YexuanXiao.
+
+# 11.0.2 - 2024-07-20
+
+- Fixed compatibility with non-POSIX systems
+  (https://github.com/fmtlib/fmt/issues/4054,
+  https://github.com/fmtlib/fmt/issues/4060).
+
+- Fixed performance regressions when using `std::back_insert_iterator` with
+  `fmt::format_to` (https://github.com/fmtlib/fmt/issues/4070).
+
+- Fixed handling of `std::generator` and move-only iterators
+  (https://github.com/fmtlib/fmt/issues/4053,
+  https://github.com/fmtlib/fmt/pull/4057). Thanks @Arghnews.
+
+- Made `formatter<std::string_view>::parse` work with types convertible to
+  `std::string_view` (https://github.com/fmtlib/fmt/issues/4036,
+  https://github.com/fmtlib/fmt/pull/4055). Thanks @Arghnews.
+
+- Made `volatile void*` formattable
+  (https://github.com/fmtlib/fmt/issues/4049,
+  https://github.com/fmtlib/fmt/pull/4056). Thanks @Arghnews.
+
+- Made `Glib::ustring` not be confused with `std::string`
+  (https://github.com/fmtlib/fmt/issues/4052).
+
+- Made `fmt::context` iterator compatible with STL algorithms that rely on
+  iterator category (https://github.com/fmtlib/fmt/issues/4079).
+
+# 11.0.1 - 2024-07-05
+
+- Fixed version number in the inline namespace
+  (https://github.com/fmtlib/fmt/issues/4047).
+
+- Fixed disabling Unicode support via CMake
+  (https://github.com/fmtlib/fmt/issues/4051).
+
+- Fixed deprecated `visit_format_arg` (https://github.com/fmtlib/fmt/pull/4043).
+  Thanks @nebkat.
+
+- Fixed handling of a sign and improved the `std::complex` formater
+  (https://github.com/fmtlib/fmt/pull/4034,
+  https://github.com/fmtlib/fmt/pull/4050). Thanks @tesch1 and @phprus.
+
+- Fixed ADL issues in `fmt::printf` when using C++20
+  (https://github.com/fmtlib/fmt/pull/4042). Thanks @toge.
+
+- Removed a redundant check in the formatter for `std::expected`
+  (https://github.com/fmtlib/fmt/pull/4040). Thanks @phprus.
+
+# 11.0.0 - 2024-07-01
+
+- Added `fmt/base.h` which provides a subset of the API with minimal include
+  dependencies and enough functionality to replace all uses of the `printf`
+  family of functions. This brings the compile time of code using {fmt} much
+  closer to the equivalent `printf` code as shown on the following benchmark
+  that compiles 100 source files:
+
+  | Method       | Compile Time (s) |
+  |--------------|------------------|
+  | printf       | 1.6              |
+  | IOStreams    | 25.9             |
+  | fmt 10.x     | 19.0             |
+  | fmt 11.0     | 4.8              |
+  | tinyformat   | 29.1             |
+  | Boost Format | 55.0             |
+
+  This gives almost 4x improvement in build speed compared to version 10.
+  Note that the benchmark is purely formatting code and includes. In real
+  projects the difference from `printf` will be smaller partly because common
+  standard headers will be included in almost any translation unit (TU) anyway.
+  In particular, in every case except `printf` above ~1s is spent in total on
+  including `<type_traits>` in all TUs.
+
+- Optimized includes in other headers such as `fmt/format.h` which is now
+  roughly equivalent to the old `fmt/core.h` in terms of build speed.
+
+- Migrated the documentation at https://fmt.dev/ from Sphinx to MkDocs.
+
+- Improved C++20 module support
+  (https://github.com/fmtlib/fmt/issues/3990,
+  https://github.com/fmtlib/fmt/pull/3991,
+  https://github.com/fmtlib/fmt/issues/3993,
+  https://github.com/fmtlib/fmt/pull/3994,
+  https://github.com/fmtlib/fmt/pull/3997,
+  https://github.com/fmtlib/fmt/pull/3998,
+  https://github.com/fmtlib/fmt/pull/4004,
+  https://github.com/fmtlib/fmt/pull/4005,
+  https://github.com/fmtlib/fmt/pull/4006,
+  https://github.com/fmtlib/fmt/pull/4013,
+  https://github.com/fmtlib/fmt/pull/4027,
+  https://github.com/fmtlib/fmt/pull/4029). In particular, native CMake support
+  for modules is now used if available. Thanks @yujincheng08 and @matt77hias.
+
+- Added an option to replace standard includes with `import std` enabled via
+  the `FMT_IMPORT_STD` macro (https://github.com/fmtlib/fmt/issues/3921,
+  https://github.com/fmtlib/fmt/pull/3928). Thanks @matt77hias.
+
+- Exported `fmt::range_format`, `fmt::range_format_kind` and
+  `fmt::compiled_string` from the `fmt` module
+  (https://github.com/fmtlib/fmt/pull/3970,
+  https://github.com/fmtlib/fmt/pull/3999).
+  Thanks @matt77hias and @yujincheng08.
+
+- Improved integration with stdio in `fmt::print`, enabling direct writes
+  into a C stream buffer in common cases. This may give significant
+  performance improvements ranging from tens of percent to [2x](
+  https://stackoverflow.com/a/78457454/471164) and eliminates dynamic memory
+  allocations on the buffer level. It is currently enabled for built-in and
+  string types with wider availability coming up in future releases.
+
+  For example, it gives ~24% improvement on a [simple benchmark](
+  https://isocpp.org/files/papers/P3107R5.html#perf) compiled with Apple clang
+  version 15.0.0 (clang-1500.1.0.2.5) and run on macOS 14.2.1:
+
+  ```
+  -------------------------------------------------------
+  Benchmark             Time             CPU   Iterations
+  -------------------------------------------------------
+  printf             81.8 ns         81.5 ns      8496899
+  fmt::print (10.x)  63.8 ns         61.9 ns     11524151
+  fmt::print (11.0)  51.3 ns         51.0 ns     13846580
+  ```
+
+- Improved safety of `fmt::format_to` when writing to an array
+  (https://github.com/fmtlib/fmt/pull/3805).
+  For example ([godbolt](https://www.godbolt.org/z/cYrn8dWY8)):
+
+  ```c++
+  auto volkswagen = char[4];
+  auto result = fmt::format_to(volkswagen, "elephant");
+  ```
+
+  no longer results in a buffer overflow. Instead the output will be truncated
+  and you can get the end iterator and whether truncation occurred from the
+  `result` object. Thanks @ThePhD.
+
+- Enabled Unicode support by default in MSVC, bringing it on par with other
+  compilers and making it unnecessary for users to enable it explicitly.
+  Most of {fmt} is encoding-agnostic but this prevents mojibake in places
+  where encoding matters such as path formatting and terminal output.
+  You can control the Unicode support via the CMake `FMT_UNICODE` option.
+  Note that some {fmt} packages such as the one in vcpkg have already been
+  compiled with Unicode enabled.
+
+- Added a formatter for `std::expected`
+  (https://github.com/fmtlib/fmt/pull/3834). Thanks @dominicpoeschko.
+
+- Added a formatter for `std::complex`
+  (https://github.com/fmtlib/fmt/issues/1467,
+  https://github.com/fmtlib/fmt/issues/3886,
+  https://github.com/fmtlib/fmt/pull/3892,
+  https://github.com/fmtlib/fmt/pull/3900). Thanks @phprus.
+
+- Added a formatter for `std::type_info`
+  (https://github.com/fmtlib/fmt/pull/3978). Thanks @matt77hias.
+
+- Specialized `formatter` for `std::basic_string` types with custom traits
+  and allocators (https://github.com/fmtlib/fmt/issues/3938,
+  https://github.com/fmtlib/fmt/pull/3943). Thanks @dieram3.
+
+- Added formatters for `std::chrono::day`, `std::chrono::month`,
+  `std::chrono::year` and `std::chrono::year_month_day`
+  (https://github.com/fmtlib/fmt/issues/3758,
+  https://github.com/fmtlib/fmt/issues/3772,
+  https://github.com/fmtlib/fmt/pull/3906,
+  https://github.com/fmtlib/fmt/pull/3913). For example:
+
+  ```c++
+  #include <fmt/chrono.h>
+  #include <fmt/color.h>
+
+  int main() {
+    fmt::print(fg(fmt::color::green), "{}\n", std::chrono::day(7));
+  }
+  ```
+
+  prints a green day:
+
+  <img width="306" alt="image" src="https://github.com/fmtlib/fmt/assets/576385/6e395f8b-451a-4cf7-bccc-ee92ca0dec65">
+
+  Thanks @zivshek.
+
+- Fixed handling of precision in `%S` (https://github.com/fmtlib/fmt/issues/3794,
+  https://github.com/fmtlib/fmt/pull/3814). Thanks @js324.
 
-    int main() {
-      fmt::print("{}\n", std::bitset<6>(42)); // prints "101010"
-    }
-    ```
+- Added support for the `-` specifier (glibc `strftime` extension) to day of
+  the month (`%d`) and week of the year (`%W`, `%U`, `%V`) specifiers
+  (https://github.com/fmtlib/fmt/pull/3976). Thanks @ZaheenJ.
 
-    Thanks @muggenhor.
+- Fixed the scope of the `-` extension in chrono formatting so that it doesn't
+  apply to subsequent specifiers (https://github.com/fmtlib/fmt/issues/3811,
+  https://github.com/fmtlib/fmt/pull/3812). Thanks @phprus.
 
--   Added an experimental `nested_formatter` that provides an easy way of
-    applying a formatter to one or more subobjects while automatically handling
-    width, fill and alignment. For example:
+- Improved handling of `time_point::min()`
+  (https://github.com/fmtlib/fmt/issues/3282).
 
-    ```c++
-    #include <fmt/format.h>
+- Added support for character range formatting
+  (https://github.com/fmtlib/fmt/issues/3857,
+  https://github.com/fmtlib/fmt/pull/3863). Thanks @js324.
 
-    struct point {
-      double x, y;
-    };
+- Added `string` and `debug_string` range formatters
+  (https://github.com/fmtlib/fmt/pull/3973,
+  https://github.com/fmtlib/fmt/pull/4024). Thanks @matt77hias.
+
+- Enabled ADL for `begin` and `end` in `fmt::join`
+  (https://github.com/fmtlib/fmt/issues/3813,
+  https://github.com/fmtlib/fmt/pull/3824). Thanks @bbolli.
+
+- Made contiguous iterator optimizations apply to `std::basic_string` iterators
+  (https://github.com/fmtlib/fmt/pull/3798). Thanks @phprus.
+
+- Added support for ranges with mutable `begin` and `end`
+  (https://github.com/fmtlib/fmt/issues/3752,
+  https://github.com/fmtlib/fmt/pull/3800,
+  https://github.com/fmtlib/fmt/pull/3955). Thanks @tcbrindle and @Arghnews.
+
+- Added support for move-only iterators to `fmt::join`
+  (https://github.com/fmtlib/fmt/issues/3802,
+  https://github.com/fmtlib/fmt/pull/3946). Thanks @Arghnews.
+
+- Moved range and iterator overloads of `fmt::join` to `fmt/ranges.h`, next
+  to other overloads.
+
+- Fixed handling of types with `begin` returning `void` such as Eigen matrices
+  (https://github.com/fmtlib/fmt/issues/3839,
+  https://github.com/fmtlib/fmt/pull/3964). Thanks @Arghnews.
+
+- Added an `fmt::formattable` concept (https://github.com/fmtlib/fmt/pull/3974).
+  Thanks @matt77hias.
+
+- Added support for `__float128` (https://github.com/fmtlib/fmt/issues/3494).
+
+- Fixed rounding issues when formatting `long double` with fixed precision
+  (https://github.com/fmtlib/fmt/issues/3539).
+
+- Made `fmt::isnan` not trigger floating-point exception for NaN values
+  (https://github.com/fmtlib/fmt/issues/3948,
+  https://github.com/fmtlib/fmt/pull/3951). Thanks @alexdewar.
+
+- Removed dependency on `<memory>` for `std::allocator_traits` when possible
+  (https://github.com/fmtlib/fmt/pull/3804). Thanks @phprus.
+
+- Enabled compile-time checks in formatting functions that take text colors and
+  styles.
+
+- Deprecated wide stream overloads of `fmt::print` that take text styles.
+
+- Made format string compilation work with clang 12 and later despite
+  only partial non-type template parameter support
+  (https://github.com/fmtlib/fmt/issues/4000,
+  https://github.com/fmtlib/fmt/pull/4001). Thanks @yujincheng08.
+
+- Made `fmt::iterator_buffer`'s move constructor `noexcept`
+  (https://github.com/fmtlib/fmt/pull/3808). Thanks @waywardmonkeys.
+
+- Started enforcing that `formatter::format` is const for compatibility
+  with `std::format` (https://github.com/fmtlib/fmt/issues/3447).
+
+- Added `fmt::basic_format_arg::visit` and deprecated `fmt::visit_format_arg`.
+
+- Made `fmt::basic_string_view` not constructible from `nullptr` for
+  consistency with `std::string_view` in C++23
+  (https://github.com/fmtlib/fmt/pull/3846). Thanks @dalle.
+
+- Fixed `fmt::group_digits` for negative integers
+  (https://github.com/fmtlib/fmt/issues/3891,
+  https://github.com/fmtlib/fmt/pull/3901). Thanks @phprus.
+
+- Fixed handling of negative ids in `fmt::basic_format_args::get`
+  (https://github.com/fmtlib/fmt/pull/3945). Thanks @marlenecota.
+
+- Fixed handling of a buffer boundary on flush
+  (https://github.com/fmtlib/fmt/issues/4229).
+
+- Improved named argument validation
+  (https://github.com/fmtlib/fmt/issues/3817).
+
+- Disabled copy construction/assignment for `fmt::format_arg_store` and
+  fixed moved construction (https://github.com/fmtlib/fmt/pull/3833).
+  Thanks @ivafanas.
+
+- Worked around a locale issue in RHEL/devtoolset
+  (https://github.com/fmtlib/fmt/issues/3858,
+  https://github.com/fmtlib/fmt/pull/3859). Thanks @g199209.
+
+- Added RTTI detection for MSVC (https://github.com/fmtlib/fmt/pull/3821,
+  https://github.com/fmtlib/fmt/pull/3963). Thanks @edo9300.
+
+- Migrated the documentation from Sphinx to MkDocs.
+
+- Improved documentation and README
+  (https://github.com/fmtlib/fmt/issues/3775,
+  https://github.com/fmtlib/fmt/pull/3784,
+  https://github.com/fmtlib/fmt/issues/3788,
+  https://github.com/fmtlib/fmt/pull/3789,
+  https://github.com/fmtlib/fmt/pull/3793,
+  https://github.com/fmtlib/fmt/issues/3818,
+  https://github.com/fmtlib/fmt/pull/3820,
+  https://github.com/fmtlib/fmt/pull/3822,
+  https://github.com/fmtlib/fmt/pull/3843,
+  https://github.com/fmtlib/fmt/pull/3890,
+  https://github.com/fmtlib/fmt/issues/3894,
+  https://github.com/fmtlib/fmt/pull/3895,
+  https://github.com/fmtlib/fmt/pull/3905,
+  https://github.com/fmtlib/fmt/issues/3942,
+  https://github.com/fmtlib/fmt/pull/4008).
+  Thanks @zencatalyst, WolleTD, @tupaschoal, @Dobiasd, @frank-weinberg, @bbolli,
+  @phprus, @waywardmonkeys, @js324 and @tchaikov.
+
+- Improved CI and tests
+  (https://github.com/fmtlib/fmt/issues/3878,
+  https://github.com/fmtlib/fmt/pull/3883,
+  https://github.com/fmtlib/fmt/issues/3897,
+  https://github.com/fmtlib/fmt/pull/3979,
+  https://github.com/fmtlib/fmt/pull/3980,
+  https://github.com/fmtlib/fmt/pull/3988,
+  https://github.com/fmtlib/fmt/pull/4010,
+  https://github.com/fmtlib/fmt/pull/4012,
+  https://github.com/fmtlib/fmt/pull/4038).
+  Thanks @vgorrX, @waywardmonkeys, @tchaikov and @phprus.
+
+- Fixed buffer overflow when using format string compilation with debug format
+  and `std::back_insert_iterator` (https://github.com/fmtlib/fmt/issues/3795,
+  https://github.com/fmtlib/fmt/pull/3797). Thanks @phprus.
+
+- Improved Bazel support
+  (https://github.com/fmtlib/fmt/pull/3792,
+  https://github.com/fmtlib/fmt/pull/3801,
+  https://github.com/fmtlib/fmt/pull/3962,
+  https://github.com/fmtlib/fmt/pull/3965). Thanks @Vertexwahn.
+
+- Improved/fixed the CMake config
+  (https://github.com/fmtlib/fmt/issues/3777,
+  https://github.com/fmtlib/fmt/pull/3783,
+  https://github.com/fmtlib/fmt/issues/3847,
+  https://github.com/fmtlib/fmt/pull/3907). Thanks @phprus and @xTachyon.
+
+- Fixed various warnings and compilation issues
+  (https://github.com/fmtlib/fmt/issues/3685,
+  https://github.com/fmtlib/fmt/issues/3769,
+  https://github.com/fmtlib/fmt/issues/3796,
+  https://github.com/fmtlib/fmt/issues/3803,
+  https://github.com/fmtlib/fmt/pull/3806,
+  https://github.com/fmtlib/fmt/pull/3807,
+  https://github.com/fmtlib/fmt/issues/3809,
+  https://github.com/fmtlib/fmt/pull/3810,
+  https://github.com/fmtlib/fmt/issues/3830,
+  https://github.com/fmtlib/fmt/pull/3832,
+  https://github.com/fmtlib/fmt/issues/3835,
+  https://github.com/fmtlib/fmt/pull/3844,
+  https://github.com/fmtlib/fmt/issues/3854,
+  https://github.com/fmtlib/fmt/pull/3856,
+  https://github.com/fmtlib/fmt/pull/3865,
+  https://github.com/fmtlib/fmt/pull/3866,
+  https://github.com/fmtlib/fmt/pull/3880,
+  https://github.com/fmtlib/fmt/issues/3881,
+  https://github.com/fmtlib/fmt/issues/3884,
+  https://github.com/fmtlib/fmt/issues/3898,
+  https://github.com/fmtlib/fmt/pull/3899,
+  https://github.com/fmtlib/fmt/pull/3909,
+  https://github.com/fmtlib/fmt/pull/3917,
+  https://github.com/fmtlib/fmt/pull/3923,
+  https://github.com/fmtlib/fmt/pull/3924,
+  https://github.com/fmtlib/fmt/issues/3925,
+  https://github.com/fmtlib/fmt/pull/3930,
+  https://github.com/fmtlib/fmt/pull/3931,
+  https://github.com/fmtlib/fmt/pull/3933,
+  https://github.com/fmtlib/fmt/issues/3935,
+  https://github.com/fmtlib/fmt/pull/3937,
+  https://github.com/fmtlib/fmt/pull/3967,
+  https://github.com/fmtlib/fmt/pull/3968,
+  https://github.com/fmtlib/fmt/pull/3972,
+  https://github.com/fmtlib/fmt/pull/3983,
+  https://github.com/fmtlib/fmt/issues/3992,
+  https://github.com/fmtlib/fmt/pull/3995,
+  https://github.com/fmtlib/fmt/pull/4009,
+  https://github.com/fmtlib/fmt/pull/4023).
+  Thanks @hmbj, @phprus, @res2k, @Baardi, @matt77hias, @waywardmonkeys, @hmbj,
+  @yakra, @prlw1, @Arghnews, @mtillmann0, @ShifftC, @eepp, @jimmy-park and
+  @ChristianGebhardt.
+
+# 10.2.1 - 2024-01-04
+
+- Fixed ABI compatibility with earlier 10.x versions
+  (https://github.com/fmtlib/fmt/issues/3785,
+  https://github.com/fmtlib/fmt/pull/3786). Thanks @saraedum.
 
-    template <>
-    struct fmt::formatter<point> : nested_formatter<double> {
-      auto format(point p, format_context& ctx) const {
-        return write_padded(ctx, [=](auto out) {
-          return format_to(out, "({}, {})", nested(p.x), nested(p.y));
-        });
-      }
-    };
+# 10.2.0 - 2024-01-01
 
-    int main() {
-      fmt::print("[{:>20.2f}]", point{1, 2});
-    }
-    ```
+- Added support for the `%j` specifier (the number of days) for
+  `std::chrono::duration` (https://github.com/fmtlib/fmt/issues/3643,
+  https://github.com/fmtlib/fmt/pull/3732). Thanks @intelfx.
 
-    prints
+- Added support for the chrono suffix for days and changed
+  the suffix for minutes from "m" to the correct "min"
+  (https://github.com/fmtlib/fmt/issues/3662,
+  https://github.com/fmtlib/fmt/pull/3664).
+  For example ([godbolt](https://godbolt.org/z/9KhMnq9ba)):
 
-    ```
-    [          (1.00, 2.00)]
-    ```
+  ```c++
+  #include <fmt/chrono.h>
 
--   Added the generic representation (`g`) to `std::filesystem::path`
-    (https://github.com/fmtlib/fmt/issues/3715,
-    https://github.com/fmtlib/fmt/pull/3729). For example:
+  int main() {
+    fmt::print("{}\n", std::chrono::days(42)); // prints "42d"
+  }
+  ```
 
-    ```c++
-    #include <filesystem>
-    #include <fmt/std.h>
+  Thanks @Richardk2n.
 
-    int main() {
-      fmt::print("{:g}\n", std::filesystem::path("C:\\foo"));
-    }
-    ```
-
-    prints `"C:/foo"` on Windows.
-
-    Thanks @js324.
-
--   Made `format_as` work with references
-    (https://github.com/fmtlib/fmt/pull/3739). Thanks @tchaikov.
-
--   Fixed formatting of invalid UTF-8 with precision
-    (https://github.com/fmtlib/fmt/issues/3284).
-
--   Fixed an inconsistency between `fmt::to_string` and `fmt::format`
-    (https://github.com/fmtlib/fmt/issues/3684).
-
--   Disallowed unsafe uses of `fmt::styled`
-    (https://github.com/fmtlib/fmt/issues/3625):
-
-    ```c++
-    auto s = fmt::styled(std::string("dangle"), fmt::emphasis::bold);
-    fmt::print("{}\n", s); // compile error
-    ```
-
-    Pass `fmt::styled(...)` as a parameter instead.
-
--   Added a null check when formatting a C string with the `s` specifier
-    (https://github.com/fmtlib/fmt/issues/3706).
-
--   Disallowed the `c` specifier for `bool`
-    (https://github.com/fmtlib/fmt/issues/3726,
-    https://github.com/fmtlib/fmt/pull/3734). Thanks @js324.
-
--   Made the default formatting unlocalized in `fmt::ostream_formatter` for
-    consistency with the rest of the library
-    (https://github.com/fmtlib/fmt/issues/3460).
-
--   Fixed localized formatting in bases other than decimal
-    (https://github.com/fmtlib/fmt/issues/3693,
-    https://github.com/fmtlib/fmt/pull/3750). Thanks @js324.
-
--   Fixed a performance regression in experimental `fmt::ostream::print`
-    (https://github.com/fmtlib/fmt/issues/3674).
-
--   Added synchronization with the underlying output stream when writing to
-    the Windows console
-    (https://github.com/fmtlib/fmt/pull/3668,
-    https://github.com/fmtlib/fmt/issues/3688,
-    https://github.com/fmtlib/fmt/pull/3689).
-    Thanks @Roman-Koshelev and @dimztimz.
-
--   Changed to only export `format_error` when {fmt} is built as a shared
-    library (https://github.com/fmtlib/fmt/issues/3626,
-    https://github.com/fmtlib/fmt/pull/3627). Thanks @phprus.
-
--   Made `fmt::streamed` `constexpr`.
-    (https://github.com/fmtlib/fmt/pull/3650). Thanks @muggenhor.
-
--   Enabled `consteval` on older versions of MSVC
-    (https://github.com/fmtlib/fmt/pull/3757). Thanks @phprus.
-
--   Added an option to build without `wchar_t` support on Windows
-    (https://github.com/fmtlib/fmt/issues/3631,
-    https://github.com/fmtlib/fmt/pull/3636). Thanks @glebm.
-
--   Improved build and CI configuration
-    (https://github.com/fmtlib/fmt/pull/3679,
-    https://github.com/fmtlib/fmt/issues/3701,
-    https://github.com/fmtlib/fmt/pull/3702,
-    https://github.com/fmtlib/fmt/pull/3749).
-    Thanks @jcar87, @pklima and @tchaikov.
-
--   Fixed various warnings, compilation and test issues
-    (https://github.com/fmtlib/fmt/issues/3607,
-    https://github.com/fmtlib/fmt/pull/3610,
-    https://github.com/fmtlib/fmt/pull/3624,
-    https://github.com/fmtlib/fmt/pull/3630,
-    https://github.com/fmtlib/fmt/pull/3634,
-    https://github.com/fmtlib/fmt/pull/3638,
-    https://github.com/fmtlib/fmt/issues/3645,
-    https://github.com/fmtlib/fmt/issues/3646,
-    https://github.com/fmtlib/fmt/pull/3647,
-    https://github.com/fmtlib/fmt/pull/3652,
-    https://github.com/fmtlib/fmt/issues/3654,
-    https://github.com/fmtlib/fmt/pull/3663,
-    https://github.com/fmtlib/fmt/issues/3670,
-    https://github.com/fmtlib/fmt/pull/3680,
-    https://github.com/fmtlib/fmt/issues/3694,
-    https://github.com/fmtlib/fmt/pull/3695,
-    https://github.com/fmtlib/fmt/pull/3699,
-    https://github.com/fmtlib/fmt/issues/3705,
-    https://github.com/fmtlib/fmt/issues/3710,
-    https://github.com/fmtlib/fmt/issues/3712,
-    https://github.com/fmtlib/fmt/pull/3713,
-    https://github.com/fmtlib/fmt/issues/3714,
-    https://github.com/fmtlib/fmt/pull/3716,
-    https://github.com/fmtlib/fmt/pull/3723,
-    https://github.com/fmtlib/fmt/issues/3738,
-    https://github.com/fmtlib/fmt/issues/3740,
-    https://github.com/fmtlib/fmt/pull/3741,
-    https://github.com/fmtlib/fmt/pull/3743,
-    https://github.com/fmtlib/fmt/issues/3745,
-    https://github.com/fmtlib/fmt/pull/3747,
-    https://github.com/fmtlib/fmt/pull/3748,
-    https://github.com/fmtlib/fmt/pull/3751,
-    https://github.com/fmtlib/fmt/pull/3754,
-    https://github.com/fmtlib/fmt/pull/3755,
-    https://github.com/fmtlib/fmt/issues/3760,
-    https://github.com/fmtlib/fmt/pull/3762,
-    https://github.com/fmtlib/fmt/issues/3763,
-    https://github.com/fmtlib/fmt/pull/3764,
-    https://github.com/fmtlib/fmt/issues/3774,
-    https://github.com/fmtlib/fmt/pull/3779).
-    Thanks @danakj, @vinayyadav3016, @cyyever, @phprus, @qimiko, @saschasc,
-    @gsjaardema, @lazka, @Zhaojun-Liu, @carlsmedstad, @hotwatermorning,
-    @cptFracassa, @kuguma, @PeterJohnson, @H1X4Dev, @asantoni, @eltociear,
-    @msimberg, @tchaikov, @waywardmonkeys.
-
--   Improved documentation and README
-    (https://github.com/fmtlib/fmt/issues/2086,
-    https://github.com/fmtlib/fmt/issues/3637,
-    https://github.com/fmtlib/fmt/pull/3642,
-    https://github.com/fmtlib/fmt/pull/3653,
-    https://github.com/fmtlib/fmt/pull/3655,
-    https://github.com/fmtlib/fmt/pull/3661,
-    https://github.com/fmtlib/fmt/issues/3673,
-    https://github.com/fmtlib/fmt/pull/3677,
-    https://github.com/fmtlib/fmt/pull/3737,
-    https://github.com/fmtlib/fmt/issues/3742,
-    https://github.com/fmtlib/fmt/pull/3744).
-    Thanks @idzm, @perlun, @joycebrum, @fennewald, @reinhardt1053, @GeorgeLS.
-
--   Updated CI dependencies
-    (https://github.com/fmtlib/fmt/pull/3615,
-    https://github.com/fmtlib/fmt/pull/3622,
-    https://github.com/fmtlib/fmt/pull/3623,
-    https://github.com/fmtlib/fmt/pull/3666,
-    https://github.com/fmtlib/fmt/pull/3696,
-    https://github.com/fmtlib/fmt/pull/3697,
-    https://github.com/fmtlib/fmt/pull/3759,
-    https://github.com/fmtlib/fmt/pull/3782).
+- Fixed an overflow in `std::chrono::time_point` formatting with large dates
+  (https://github.com/fmtlib/fmt/issues/3725,
+  https://github.com/fmtlib/fmt/pull/3727). Thanks @cschreib.
 
-# 10.1.1 - 2023-08-28
+- Added a formatter for `std::source_location`
+  (https://github.com/fmtlib/fmt/pull/3730).
+  For example ([godbolt](https://godbolt.org/z/YajfKjhhr)):
 
--   Added formatters for `std::atomic` and `atomic_flag`
-    (https://github.com/fmtlib/fmt/pull/3574,
-    https://github.com/fmtlib/fmt/pull/3594).
-    Thanks @wangzw and @AlexGuteniev.
--   Fixed an error about partial specialization of `formatter<string>`
-    after instantiation when compiled with gcc and C++20
-    (https://github.com/fmtlib/fmt/issues/3584).
--   Fixed compilation as a C++20 module with gcc and clang
-    (https://github.com/fmtlib/fmt/issues/3587,
-    https://github.com/fmtlib/fmt/pull/3597,
-    https://github.com/fmtlib/fmt/pull/3605).
-    Thanks @MathewBensonCode.
--   Made `fmt::to_string` work with types that have `format_as`
-    overloads (https://github.com/fmtlib/fmt/pull/3575). Thanks @phprus.
--   Made `formatted_size` work with integral format specifiers at
-    compile time (https://github.com/fmtlib/fmt/pull/3591).
-    Thanks @elbeno.
--   Fixed a warning about the `no_unique_address` attribute on clang-cl
-    (https://github.com/fmtlib/fmt/pull/3599). Thanks @lukester1975.
--   Improved compatibility with the legacy GBK encoding
-    (https://github.com/fmtlib/fmt/issues/3598,
-    https://github.com/fmtlib/fmt/pull/3599). Thanks @YuHuanTin.
--   Added OpenSSF Scorecard analysis
-    (https://github.com/fmtlib/fmt/issues/3530,
-    https://github.com/fmtlib/fmt/pull/3571). Thanks @joycebrum.
--   Updated CI dependencies
-    (https://github.com/fmtlib/fmt/pull/3591,
-    https://github.com/fmtlib/fmt/pull/3592,
-    https://github.com/fmtlib/fmt/pull/3593,
-    https://github.com/fmtlib/fmt/pull/3602).
+  ```c++
+  #include <source_location>
+  #include <fmt/std.h>
 
-# 10.1.0 - 2023-08-12
+  int main() {
+    fmt::print("{}\n", std::source_location::current());
+  }
+  ```
 
--   Optimized format string compilation resulting in up to 40% speed up
-    in compiled `format_to` and \~4x speed up in compiled `format_to_n`
-    on a concatenation benchmark
-    (https://github.com/fmtlib/fmt/issues/3133,
-    https://github.com/fmtlib/fmt/issues/3484).
+  prints
 
-    {fmt} 10.0:
+  ```
+  /app/example.cpp:5:51: int main()
+  ```
 
-        ---------------------------------------------------------
-        Benchmark               Time             CPU   Iterations
-        ---------------------------------------------------------
-        BM_format_to         78.9 ns         78.9 ns      8881746
-        BM_format_to_n        568 ns          568 ns      1232089
+  Thanks @felix642.
 
-    {fmt} 10.1:
+- Added a formatter for `std::bitset`
+  (https://github.com/fmtlib/fmt/pull/3660).
+  For example ([godbolt](https://godbolt.org/z/bdEaGeYxe)):
 
-        ---------------------------------------------------------
-        Benchmark               Time             CPU   Iterations
-        ---------------------------------------------------------
-        BM_format_to         54.9 ns         54.9 ns     12727944
-        BM_format_to_n        133 ns          133 ns      5257795
+  ```c++
+  #include <bitset>
+  #include <fmt/std.h>
 
--   Optimized storage of an empty allocator in `basic_memory_buffer`
-    (https://github.com/fmtlib/fmt/pull/3485). Thanks @Minty-Meeo.
+  int main() {
+    fmt::print("{}\n", std::bitset<6>(42)); // prints "101010"
+  }
+  ```
 
--   Added formatters for proxy references to elements of
-    `std::vector<bool>` and `std::bitset<N>`
-    (https://github.com/fmtlib/fmt/issues/3567,
-    https://github.com/fmtlib/fmt/pull/3570). For example
-    ([godbolt](https://godbolt.org/z/zYb79Pvn8)):
+  Thanks @muggenhor.
 
-    ```c++
-    #include <vector>
-    #include <fmt/std.h>
+- Added an experimental `nested_formatter` that provides an easy way of
+  applying a formatter to one or more subobjects while automatically handling
+  width, fill and alignment. For example:
 
-    int main() {
-      auto v = std::vector<bool>{true};
-      fmt::print("{}", v[0]);
-    }
-    ```
-
-    Thanks @phprus and @felix642.
-
--   Fixed an ambiguous formatter specialization for containers that look
-    like container adaptors such as `boost::flat_set`
-    (https://github.com/fmtlib/fmt/issues/3556,
-    https://github.com/fmtlib/fmt/pull/3561). Thanks @5chmidti.
-
--   Fixed compilation when formatting durations not convertible from
-    `std::chrono::seconds`
-    (https://github.com/fmtlib/fmt/pull/3430). Thanks @patlkli.
-
--   Made the `formatter` specialization for `char*` const-correct
-    (https://github.com/fmtlib/fmt/pull/3432). Thanks @timsong-cpp.
-
--   Made `{}` and `{:}` handled consistently during compile-time checks
-    (https://github.com/fmtlib/fmt/issues/3526).
-
--   Disallowed passing temporaries to `make_format_args` to improve API
-    safety by preventing dangling references.
-
--   Improved the compile-time error for unformattable types
-    (https://github.com/fmtlib/fmt/pull/3478). Thanks @BRevzin.
-
--   Improved the floating-point formatter
-    (https://github.com/fmtlib/fmt/pull/3448,
-    https://github.com/fmtlib/fmt/pull/3450).
-    Thanks @florimond-collette.
-
--   Fixed handling of precision for `long double` larger than 64 bits.
-    (https://github.com/fmtlib/fmt/issues/3539,
-    https://github.com/fmtlib/fmt/issues/3564).
-
--   Made floating-point and chrono tests less platform-dependent
-    (https://github.com/fmtlib/fmt/issues/3337,
-    https://github.com/fmtlib/fmt/issues/3433,
-    https://github.com/fmtlib/fmt/pull/3434). Thanks @phprus.
-
--   Removed the remnants of the Grisu floating-point formatter that has
-    been replaced by Dragonbox in earlier versions.
-
--   Added `throw_format_error` to the public API
-    (https://github.com/fmtlib/fmt/pull/3551). Thanks @mjerabek.
-
--   Made `FMT_THROW` assert even if assertions are disabled when
-    compiling with exceptions disabled
-    (https://github.com/fmtlib/fmt/issues/3418,
-    https://github.com/fmtlib/fmt/pull/3439). Thanks @BRevzin.
-
--   Made `format_as` and `std::filesystem::path` formatter work with
-    exotic code unit types.
-    (https://github.com/fmtlib/fmt/pull/3457,
-    https://github.com/fmtlib/fmt/pull/3476). Thanks @gix and @hmbj.
-
--   Added support for the `?` format specifier to
-    `std::filesystem::path` and made the default unescaped for
-    consistency with strings.
-
--   Deprecated the wide stream overload of `printf`.
-
--   Removed unused `basic_printf_parse_context`.
-
--   Improved RTTI detection used when formatting exceptions
-    (https://github.com/fmtlib/fmt/pull/3468). Thanks @danakj.
-
--   Improved compatibility with VxWorks7
-    (https://github.com/fmtlib/fmt/pull/3467). Thanks @wenshan1.
-
--   Improved documentation
-    (https://github.com/fmtlib/fmt/issues/3174,
-    https://github.com/fmtlib/fmt/issues/3423,
-    https://github.com/fmtlib/fmt/pull/3454,
-    https://github.com/fmtlib/fmt/issues/3458,
-    https://github.com/fmtlib/fmt/pull/3461,
-    https://github.com/fmtlib/fmt/issues/3487,
-    https://github.com/fmtlib/fmt/pull/3515).
-    Thanks @zencatalyst, @rlalik and @mikecrowe.
-
--   Improved build and CI configurations
-    (https://github.com/fmtlib/fmt/issues/3449,
-    https://github.com/fmtlib/fmt/pull/3451,
-    https://github.com/fmtlib/fmt/pull/3452,
-    https://github.com/fmtlib/fmt/pull/3453,
-    https://github.com/fmtlib/fmt/pull/3459,
-    https://github.com/fmtlib/fmt/issues/3481,
-    https://github.com/fmtlib/fmt/pull/3486,
-    https://github.com/fmtlib/fmt/issues/3489,
-    https://github.com/fmtlib/fmt/pull/3496,
-    https://github.com/fmtlib/fmt/issues/3517,
-    https://github.com/fmtlib/fmt/pull/3523,
-    https://github.com/fmtlib/fmt/pull/3563).
-    Thanks @joycebrum, @glebm, @phprus, @petrmanek, @setoye and @abouvier.
-
--   Fixed various warnings and compilation issues
-    (https://github.com/fmtlib/fmt/issues/3408,
-    https://github.com/fmtlib/fmt/issues/3424,
-    https://github.com/fmtlib/fmt/issues/3444,
-    https://github.com/fmtlib/fmt/pull/3446,
-    https://github.com/fmtlib/fmt/pull/3475,
-    https://github.com/fmtlib/fmt/pull/3482,
-    https://github.com/fmtlib/fmt/issues/3492,
-    https://github.com/fmtlib/fmt/pull/3493,
-    https://github.com/fmtlib/fmt/pull/3508,
-    https://github.com/fmtlib/fmt/issues/3509,
-    https://github.com/fmtlib/fmt/issues/3533,
-    https://github.com/fmtlib/fmt/pull/3542,
-    https://github.com/fmtlib/fmt/issues/3543,
-    https://github.com/fmtlib/fmt/issues/3540,
-    https://github.com/fmtlib/fmt/pull/3544,
-    https://github.com/fmtlib/fmt/issues/3548,
-    https://github.com/fmtlib/fmt/pull/3549,
-    https://github.com/fmtlib/fmt/pull/3550,
-    https://github.com/fmtlib/fmt/pull/3552).
-    Thanks @adesitter, @hmbj, @Minty-Meeo, @phprus, @TobiSchluter,
-    @kieranclancy, @alexeedm, @jurihock, @Ozomahtli and @razaqq.
+  ```c++
+  #include <fmt/format.h>
 
-# 10.0.0 - 2023-05-09
+  struct point {
+    double x, y;
+  };
 
--   Replaced Grisu with a new floating-point formatting algorithm for
-    given precision (https://github.com/fmtlib/fmt/issues/3262,
-    https://github.com/fmtlib/fmt/issues/2750,
-    https://github.com/fmtlib/fmt/pull/3269,
-    https://github.com/fmtlib/fmt/pull/3276). The new algorithm
-    is based on Dragonbox already used for the shortest representation
-    and gives substantial performance improvement:
-
-    ![](https://user-images.githubusercontent.com/33922675/211956670-84891a09-6867-47d9-82fc-3230da7abe0f.png)
-
-    -   Red: new algorithm
-    -   Green: new algorithm with `FMT_USE_FULL_CACHE_DRAGONBOX` defined
-        to 1
-    -   Blue: old algorithm
-
-    Thanks @jk-jeon.
-
--   Replaced `snprintf`-based hex float formatter with an internal
-    implementation (https://github.com/fmtlib/fmt/pull/3179,
-    https://github.com/fmtlib/fmt/pull/3203). This removes the
-    last usage of `s(n)printf` in {fmt}. Thanks @phprus.
-
--   Fixed alignment of floating-point numbers with localization
-    (https://github.com/fmtlib/fmt/issues/3263,
-    https://github.com/fmtlib/fmt/pull/3272). Thanks @ShawnZhong.
-
--   Made handling of `#` consistent with `std::format`.
-
--   Improved C++20 module support
-    (https://github.com/fmtlib/fmt/pull/3134,
-    https://github.com/fmtlib/fmt/pull/3254,
-    https://github.com/fmtlib/fmt/pull/3386,
-    https://github.com/fmtlib/fmt/pull/3387,
-    https://github.com/fmtlib/fmt/pull/3388,
-    https://github.com/fmtlib/fmt/pull/3392,
-    https://github.com/fmtlib/fmt/pull/3397,
-    https://github.com/fmtlib/fmt/pull/3399,
-    https://github.com/fmtlib/fmt/pull/3400).
-    Thanks @laitingsheng, @Orvid and @DanielaE.
-    
--   Switched to the [modules CMake library](https://github.com/vitaut/modules)
-    which allows building {fmt} as a C++20 module with clang:
-
-        CXX=clang++ cmake -DFMT_MODULE=ON .
-        make
-
--   Made `format_as` work with any user-defined type and not just enums.
-    For example ([godbolt](https://godbolt.org/z/b7rqhq5Kh)):
-
-    ```c++
-    #include <fmt/format.h>
-
-    struct floaty_mc_floatface {
-      double value;
-    };
-
-    auto format_as(floaty_mc_floatface f) { return f.value; }
-
-    int main() {
-      fmt::print("{:8}\n", floaty_mc_floatface{0.42}); // prints "    0.42"
+  template <>
+  struct fmt::formatter<point> : nested_formatter<double> {
+    auto format(point p, format_context& ctx) const {
+      return write_padded(ctx, [=](auto out) {
+        return format_to(out, "({}, {})", nested(p.x), nested(p.y));
+      });
     }
-    ```
-
--   Removed deprecated implicit conversions for enums and conversions to
-    primitive types for compatibility with `std::format` and to prevent
-    potential ODR violations. Use `format_as` instead.
+  };
 
--   Added support for fill, align and width to the time point formatter
-    (https://github.com/fmtlib/fmt/issues/3237,
-    https://github.com/fmtlib/fmt/pull/3260,
-    https://github.com/fmtlib/fmt/pull/3275). For example
-    ([godbolt](https://godbolt.org/z/rKP6MGz6c)):
-
-    ```c++
-    #include <fmt/chrono.h>
-
-    int main() {
-      // prints "    2023"
-      fmt::print("{:>8%Y}\n", std::chrono::system_clock::now());
-    }
-    ```
+  int main() {
+    fmt::print("[{:>20.2f}]", point{1, 2});
+  }
+  ```
 
-    Thanks @ShawnZhong.
+  prints
 
--   Implemented formatting of subseconds
-    (https://github.com/fmtlib/fmt/issues/2207,
-    https://github.com/fmtlib/fmt/issues/3117,
-    https://github.com/fmtlib/fmt/pull/3115,
-    https://github.com/fmtlib/fmt/pull/3143,
-    https://github.com/fmtlib/fmt/pull/3144,
-    https://github.com/fmtlib/fmt/pull/3349). For example
-    ([godbolt](https://godbolt.org/z/45738oGEo)):
+  ```
+  [          (1.00, 2.00)]
+  ```
 
-    ```c++
-    #include <fmt/chrono.h>
+- Added the generic representation (`g`) to `std::filesystem::path`
+  (https://github.com/fmtlib/fmt/issues/3715,
+  https://github.com/fmtlib/fmt/pull/3729). For example:
+
+  ```c++
+  #include <filesystem>
+  #include <fmt/std.h>
+
+  int main() {
+    fmt::print("{:g}\n", std::filesystem::path("C:\\foo"));
+  }
+  ```
+
+  prints `"C:/foo"` on Windows.
+
+  Thanks @js324.
+
+- Made `format_as` work with references
+  (https://github.com/fmtlib/fmt/pull/3739). Thanks @tchaikov.
+
+- Fixed formatting of invalid UTF-8 with precision
+  (https://github.com/fmtlib/fmt/issues/3284).
+
+- Fixed an inconsistency between `fmt::to_string` and `fmt::format`
+  (https://github.com/fmtlib/fmt/issues/3684).
+
+- Disallowed unsafe uses of `fmt::styled`
+  (https://github.com/fmtlib/fmt/issues/3625):
+
+  ```c++
+  auto s = fmt::styled(std::string("dangle"), fmt::emphasis::bold);
+  fmt::print("{}\n", s); // compile error
+  ```
+
+  Pass `fmt::styled(...)` as a parameter instead.
+
+- Added a null check when formatting a C string with the `s` specifier
+  (https://github.com/fmtlib/fmt/issues/3706).
+
+- Disallowed the `c` specifier for `bool`
+  (https://github.com/fmtlib/fmt/issues/3726,
+  https://github.com/fmtlib/fmt/pull/3734). Thanks @js324.
+
+- Made the default formatting unlocalized in `fmt::ostream_formatter` for
+  consistency with the rest of the library
+  (https://github.com/fmtlib/fmt/issues/3460).
+
+- Fixed localized formatting in bases other than decimal
+  (https://github.com/fmtlib/fmt/issues/3693,
+  https://github.com/fmtlib/fmt/pull/3750). Thanks @js324.
+
+- Fixed a performance regression in experimental `fmt::ostream::print`
+  (https://github.com/fmtlib/fmt/issues/3674).
+
+- Added synchronization with the underlying output stream when writing to
+  the Windows console
+  (https://github.com/fmtlib/fmt/pull/3668,
+  https://github.com/fmtlib/fmt/issues/3688,
+  https://github.com/fmtlib/fmt/pull/3689).
+  Thanks @Roman-Koshelev and @dimztimz.
+
+- Changed to only export `format_error` when {fmt} is built as a shared
+  library (https://github.com/fmtlib/fmt/issues/3626,
+  https://github.com/fmtlib/fmt/pull/3627). Thanks @phprus.
+
+- Made `fmt::streamed` `constexpr`.
+  (https://github.com/fmtlib/fmt/pull/3650). Thanks @muggenhor.
+
+- Made `fmt::format_int` `constexpr`
+  (https://github.com/fmtlib/fmt/issues/4031,
+  https://github.com/fmtlib/fmt/pull/4032). Thanks @dixlorenz.
+
+- Enabled `consteval` on older versions of MSVC
+  (https://github.com/fmtlib/fmt/pull/3757). Thanks @phprus.
+
+- Added an option to build without `wchar_t` support on Windows
+  (https://github.com/fmtlib/fmt/issues/3631,
+  https://github.com/fmtlib/fmt/pull/3636). Thanks @glebm.
+
+- Improved build and CI configuration
+  (https://github.com/fmtlib/fmt/pull/3679,
+  https://github.com/fmtlib/fmt/issues/3701,
+  https://github.com/fmtlib/fmt/pull/3702,
+  https://github.com/fmtlib/fmt/pull/3749).
+  Thanks @jcar87, @pklima and @tchaikov.
+
+- Fixed various warnings, compilation and test issues
+  (https://github.com/fmtlib/fmt/issues/3607,
+  https://github.com/fmtlib/fmt/pull/3610,
+  https://github.com/fmtlib/fmt/pull/3624,
+  https://github.com/fmtlib/fmt/pull/3630,
+  https://github.com/fmtlib/fmt/pull/3634,
+  https://github.com/fmtlib/fmt/pull/3638,
+  https://github.com/fmtlib/fmt/issues/3645,
+  https://github.com/fmtlib/fmt/issues/3646,
+  https://github.com/fmtlib/fmt/pull/3647,
+  https://github.com/fmtlib/fmt/pull/3652,
+  https://github.com/fmtlib/fmt/issues/3654,
+  https://github.com/fmtlib/fmt/pull/3663,
+  https://github.com/fmtlib/fmt/issues/3670,
+  https://github.com/fmtlib/fmt/pull/3680,
+  https://github.com/fmtlib/fmt/issues/3694,
+  https://github.com/fmtlib/fmt/pull/3695,
+  https://github.com/fmtlib/fmt/pull/3699,
+  https://github.com/fmtlib/fmt/issues/3705,
+  https://github.com/fmtlib/fmt/issues/3710,
+  https://github.com/fmtlib/fmt/issues/3712,
+  https://github.com/fmtlib/fmt/pull/3713,
+  https://github.com/fmtlib/fmt/issues/3714,
+  https://github.com/fmtlib/fmt/pull/3716,
+  https://github.com/fmtlib/fmt/pull/3723,
+  https://github.com/fmtlib/fmt/issues/3738,
+  https://github.com/fmtlib/fmt/issues/3740,
+  https://github.com/fmtlib/fmt/pull/3741,
+  https://github.com/fmtlib/fmt/pull/3743,
+  https://github.com/fmtlib/fmt/issues/3745,
+  https://github.com/fmtlib/fmt/pull/3747,
+  https://github.com/fmtlib/fmt/pull/3748,
+  https://github.com/fmtlib/fmt/pull/3751,
+  https://github.com/fmtlib/fmt/pull/3754,
+  https://github.com/fmtlib/fmt/pull/3755,
+  https://github.com/fmtlib/fmt/issues/3760,
+  https://github.com/fmtlib/fmt/pull/3762,
+  https://github.com/fmtlib/fmt/issues/3763,
+  https://github.com/fmtlib/fmt/pull/3764,
+  https://github.com/fmtlib/fmt/issues/3774,
+  https://github.com/fmtlib/fmt/pull/3779).
+  Thanks @danakj, @vinayyadav3016, @cyyever, @phprus, @qimiko, @saschasc,
+  @gsjaardema, @lazka, @Zhaojun-Liu, @carlsmedstad, @hotwatermorning,
+  @cptFracassa, @kuguma, @PeterJohnson, @H1X4Dev, @asantoni, @eltociear,
+  @msimberg, @tchaikov, @waywardmonkeys.
+
+- Improved documentation and README
+  (https://github.com/fmtlib/fmt/issues/2086,
+  https://github.com/fmtlib/fmt/issues/3637,
+  https://github.com/fmtlib/fmt/pull/3642,
+  https://github.com/fmtlib/fmt/pull/3653,
+  https://github.com/fmtlib/fmt/pull/3655,
+  https://github.com/fmtlib/fmt/pull/3661,
+  https://github.com/fmtlib/fmt/issues/3673,
+  https://github.com/fmtlib/fmt/pull/3677,
+  https://github.com/fmtlib/fmt/pull/3737,
+  https://github.com/fmtlib/fmt/issues/3742,
+  https://github.com/fmtlib/fmt/pull/3744).
+  Thanks @idzm, @perlun, @joycebrum, @fennewald, @reinhardt1053, @GeorgeLS.
+
+- Updated CI dependencies
+  (https://github.com/fmtlib/fmt/pull/3615,
+  https://github.com/fmtlib/fmt/pull/3622,
+  https://github.com/fmtlib/fmt/pull/3623,
+  https://github.com/fmtlib/fmt/pull/3666,
+  https://github.com/fmtlib/fmt/pull/3696,
+  https://github.com/fmtlib/fmt/pull/3697,
+  https://github.com/fmtlib/fmt/pull/3759,
+  https://github.com/fmtlib/fmt/pull/3782).
 
-    int main() {
-      // prints 01.234567
-      fmt::print("{:%S}\n", std::chrono::microseconds(1234567));
-    }
-    ```
+# 10.1.1 - 2023-08-28
 
-    Thanks @patrickroocks @phprus and @BRevzin.
+- Added formatters for `std::atomic` and `atomic_flag`
+  (https://github.com/fmtlib/fmt/pull/3574,
+  https://github.com/fmtlib/fmt/pull/3594).
+  Thanks @wangzw and @AlexGuteniev.
+- Fixed an error about partial specialization of `formatter<string>`
+  after instantiation when compiled with gcc and C++20
+  (https://github.com/fmtlib/fmt/issues/3584).
+- Fixed compilation as a C++20 module with gcc and clang
+  (https://github.com/fmtlib/fmt/issues/3587,
+  https://github.com/fmtlib/fmt/pull/3597,
+  https://github.com/fmtlib/fmt/pull/3605).
+  Thanks @MathewBensonCode.
+- Made `fmt::to_string` work with types that have `format_as`
+  overloads (https://github.com/fmtlib/fmt/pull/3575). Thanks @phprus.
+- Made `formatted_size` work with integral format specifiers at
+  compile time (https://github.com/fmtlib/fmt/pull/3591).
+  Thanks @elbeno.
+- Fixed a warning about the `no_unique_address` attribute on clang-cl
+  (https://github.com/fmtlib/fmt/pull/3599). Thanks @lukester1975.
+- Improved compatibility with the legacy GBK encoding
+  (https://github.com/fmtlib/fmt/issues/3598,
+  https://github.com/fmtlib/fmt/pull/3599). Thanks @YuHuanTin.
+- Added OpenSSF Scorecard analysis
+  (https://github.com/fmtlib/fmt/issues/3530,
+  https://github.com/fmtlib/fmt/pull/3571). Thanks @joycebrum.
+- Updated CI dependencies
+  (https://github.com/fmtlib/fmt/pull/3591,
+  https://github.com/fmtlib/fmt/pull/3592,
+  https://github.com/fmtlib/fmt/pull/3593,
+  https://github.com/fmtlib/fmt/pull/3602).
 
--   Added precision support to `%S`
-    (https://github.com/fmtlib/fmt/pull/3148). Thanks @SappyJoy
+# 10.1.0 - 2023-08-12
 
--   Added support for `std::utc_time`
-    (https://github.com/fmtlib/fmt/issues/3098,
-    https://github.com/fmtlib/fmt/pull/3110). Thanks @patrickroocks.
+- Optimized format string compilation resulting in up to 40% speed up
+  in compiled `format_to` and \~4x speed up in compiled `format_to_n`
+  on a concatenation benchmark
+  (https://github.com/fmtlib/fmt/issues/3133,
+  https://github.com/fmtlib/fmt/issues/3484).
 
--   Switched formatting of `std::chrono::system_clock` from local time
-    to UTC for compatibility with the standard
-    (https://github.com/fmtlib/fmt/issues/3199,
-    https://github.com/fmtlib/fmt/pull/3230). Thanks @ned14.
+  {fmt} 10.0:
 
--   Added support for `%Ez` and `%Oz` to chrono formatters.
-    (https://github.com/fmtlib/fmt/issues/3220,
-    https://github.com/fmtlib/fmt/pull/3222). Thanks @phprus.
+      ---------------------------------------------------------
+      Benchmark               Time             CPU   Iterations
+      ---------------------------------------------------------
+      BM_format_to         78.9 ns         78.9 ns      8881746
+      BM_format_to_n        568 ns          568 ns      1232089
 
--   Improved validation of format specifiers for `std::chrono::duration`
-    (https://github.com/fmtlib/fmt/issues/3219,
-    https://github.com/fmtlib/fmt/pull/3232). Thanks @ShawnZhong.
+  {fmt} 10.1:
 
--   Fixed formatting of time points before the epoch
-    (https://github.com/fmtlib/fmt/issues/3117,
-    https://github.com/fmtlib/fmt/pull/3261). For example
-    ([godbolt](https://godbolt.org/z/f7bcznb3W)):
+      ---------------------------------------------------------
+      Benchmark               Time             CPU   Iterations
+      ---------------------------------------------------------
+      BM_format_to         54.9 ns         54.9 ns     12727944
+      BM_format_to_n        133 ns          133 ns      5257795
 
-    ```c++
-    #include <fmt/chrono.h>
+- Optimized storage of an empty allocator in `basic_memory_buffer`
+  (https://github.com/fmtlib/fmt/pull/3485). Thanks @Minty-Meeo.
+
+- Added formatters for proxy references to elements of
+  `std::vector<bool>` and `std::bitset<N>`
+  (https://github.com/fmtlib/fmt/issues/3567,
+  https://github.com/fmtlib/fmt/pull/3570). For example
+  ([godbolt](https://godbolt.org/z/zYb79Pvn8)):
+
+  ```c++
+  #include <vector>
+  #include <fmt/std.h>
+
+  int main() {
+    auto v = std::vector<bool>{true};
+    fmt::print("{}", v[0]);
+  }
+  ```
+
+  Thanks @phprus and @felix642.
+
+- Fixed an ambiguous formatter specialization for containers that look
+  like container adaptors such as `boost::flat_set`
+  (https://github.com/fmtlib/fmt/issues/3556,
+  https://github.com/fmtlib/fmt/pull/3561). Thanks @5chmidti.
+
+- Fixed compilation when formatting durations not convertible from
+  `std::chrono::seconds`
+  (https://github.com/fmtlib/fmt/pull/3430). Thanks @patlkli.
+
+- Made the `formatter` specialization for `char*` const-correct
+  (https://github.com/fmtlib/fmt/pull/3432). Thanks @timsong-cpp.
+
+- Made `{}` and `{:}` handled consistently during compile-time checks
+  (https://github.com/fmtlib/fmt/issues/3526).
+
+- Disallowed passing temporaries to `make_format_args` to improve API
+  safety by preventing dangling references.
+
+- Improved the compile-time error for unformattable types
+  (https://github.com/fmtlib/fmt/pull/3478). Thanks @BRevzin.
+
+- Improved the floating-point formatter
+  (https://github.com/fmtlib/fmt/pull/3448,
+  https://github.com/fmtlib/fmt/pull/3450).
+  Thanks @florimond-collette.
+
+- Fixed handling of precision for `long double` larger than 64 bits.
+  (https://github.com/fmtlib/fmt/issues/3539,
+  https://github.com/fmtlib/fmt/issues/3564).
+
+- Made floating-point and chrono tests less platform-dependent
+  (https://github.com/fmtlib/fmt/issues/3337,
+  https://github.com/fmtlib/fmt/issues/3433,
+  https://github.com/fmtlib/fmt/pull/3434). Thanks @phprus.
+
+- Removed the remnants of the Grisu floating-point formatter that has
+  been replaced by Dragonbox in earlier versions.
+
+- Added `throw_format_error` to the public API
+  (https://github.com/fmtlib/fmt/pull/3551). Thanks @mjerabek.
+
+- Made `FMT_THROW` assert even if assertions are disabled when
+  compiling with exceptions disabled
+  (https://github.com/fmtlib/fmt/issues/3418,
+  https://github.com/fmtlib/fmt/pull/3439). Thanks @BRevzin.
+
+- Made `format_as` and `std::filesystem::path` formatter work with
+  exotic code unit types.
+  (https://github.com/fmtlib/fmt/pull/3457,
+  https://github.com/fmtlib/fmt/pull/3476). Thanks @gix and @hmbj.
+
+- Added support for the `?` format specifier to
+  `std::filesystem::path` and made the default unescaped for
+  consistency with strings.
+
+- Deprecated the wide stream overload of `printf`.
+
+- Removed unused `basic_printf_parse_context`.
+
+- Improved RTTI detection used when formatting exceptions
+  (https://github.com/fmtlib/fmt/pull/3468). Thanks @danakj.
+
+- Improved compatibility with VxWorks7
+  (https://github.com/fmtlib/fmt/pull/3467). Thanks @wenshan1.
+
+- Improved documentation
+  (https://github.com/fmtlib/fmt/issues/3174,
+  https://github.com/fmtlib/fmt/issues/3423,
+  https://github.com/fmtlib/fmt/pull/3454,
+  https://github.com/fmtlib/fmt/issues/3458,
+  https://github.com/fmtlib/fmt/pull/3461,
+  https://github.com/fmtlib/fmt/issues/3487,
+  https://github.com/fmtlib/fmt/pull/3515).
+  Thanks @zencatalyst, @rlalik and @mikecrowe.
+
+- Improved build and CI configurations
+  (https://github.com/fmtlib/fmt/issues/3449,
+  https://github.com/fmtlib/fmt/pull/3451,
+  https://github.com/fmtlib/fmt/pull/3452,
+  https://github.com/fmtlib/fmt/pull/3453,
+  https://github.com/fmtlib/fmt/pull/3459,
+  https://github.com/fmtlib/fmt/issues/3481,
+  https://github.com/fmtlib/fmt/pull/3486,
+  https://github.com/fmtlib/fmt/issues/3489,
+  https://github.com/fmtlib/fmt/pull/3496,
+  https://github.com/fmtlib/fmt/issues/3517,
+  https://github.com/fmtlib/fmt/pull/3523,
+  https://github.com/fmtlib/fmt/pull/3563).
+  Thanks @joycebrum, @glebm, @phprus, @petrmanek, @setoye and @abouvier.
+
+- Fixed various warnings and compilation issues
+  (https://github.com/fmtlib/fmt/issues/3408,
+  https://github.com/fmtlib/fmt/issues/3424,
+  https://github.com/fmtlib/fmt/issues/3444,
+  https://github.com/fmtlib/fmt/pull/3446,
+  https://github.com/fmtlib/fmt/pull/3475,
+  https://github.com/fmtlib/fmt/pull/3482,
+  https://github.com/fmtlib/fmt/issues/3492,
+  https://github.com/fmtlib/fmt/pull/3493,
+  https://github.com/fmtlib/fmt/pull/3508,
+  https://github.com/fmtlib/fmt/issues/3509,
+  https://github.com/fmtlib/fmt/issues/3533,
+  https://github.com/fmtlib/fmt/pull/3542,
+  https://github.com/fmtlib/fmt/issues/3543,
+  https://github.com/fmtlib/fmt/issues/3540,
+  https://github.com/fmtlib/fmt/pull/3544,
+  https://github.com/fmtlib/fmt/issues/3548,
+  https://github.com/fmtlib/fmt/pull/3549,
+  https://github.com/fmtlib/fmt/pull/3550,
+  https://github.com/fmtlib/fmt/pull/3552).
+  Thanks @adesitter, @hmbj, @Minty-Meeo, @phprus, @TobiSchluter,
+  @kieranclancy, @alexeedm, @jurihock, @Ozomahtli and @razaqq.
 
-    int main() {
-      auto t = std::chrono::system_clock::from_time_t(0) -
-               std::chrono::milliseconds(250);
-      fmt::print("{:%S}\n", t); // prints 59.750000000
-    }
-    ```
-
-    Thanks @ShawnZhong.
-
--   Experimental: implemented glibc extension for padding seconds,
-    minutes and hours
-    (https://github.com/fmtlib/fmt/issues/2959,
-    https://github.com/fmtlib/fmt/pull/3271). Thanks @ShawnZhong.
-
--   Added a formatter for `std::exception`
-    (https://github.com/fmtlib/fmt/issues/2977,
-    https://github.com/fmtlib/fmt/issues/3012,
-    https://github.com/fmtlib/fmt/pull/3062,
-    https://github.com/fmtlib/fmt/pull/3076,
-    https://github.com/fmtlib/fmt/pull/3119). For example
-    ([godbolt](https://godbolt.org/z/8xoWGs9e4)):
-
-    ```c++
-    #include <fmt/std.h>
-    #include <vector>
-
-    int main() {
-      try {
-        std::vector<bool>().at(0);
-      } catch(const std::exception& e) {
-        fmt::print("{}", e);
-      }
-    }
-    ```
+# 10.0.0 - 2023-05-09
 
-    prints:
+- Replaced Grisu with a new floating-point formatting algorithm for
+  given precision (https://github.com/fmtlib/fmt/issues/3262,
+  https://github.com/fmtlib/fmt/issues/2750,
+  https://github.com/fmtlib/fmt/pull/3269,
+  https://github.com/fmtlib/fmt/pull/3276). The new algorithm
+  is based on Dragonbox already used for the shortest representation
+  and gives substantial performance improvement:
+
+  ![](https://user-images.githubusercontent.com/33922675/211956670-84891a09-6867-47d9-82fc-3230da7abe0f.png)
+
+  -   Red: new algorithm
+  -   Green: new algorithm with `FMT_USE_FULL_CACHE_DRAGONBOX` defined
+      to 1
+  -   Blue: old algorithm
+
+  Thanks @jk-jeon.
+
+- Replaced `snprintf`-based hex float formatter with an internal
+  implementation (https://github.com/fmtlib/fmt/pull/3179,
+  https://github.com/fmtlib/fmt/pull/3203). This removes the
+  last usage of `s(n)printf` in {fmt}. Thanks @phprus.
+
+- Fixed alignment of floating-point numbers with localization
+  (https://github.com/fmtlib/fmt/issues/3263,
+  https://github.com/fmtlib/fmt/pull/3272). Thanks @ShawnZhong.
+
+- Made handling of `#` consistent with `std::format`.
+
+- Improved C++20 module support
+  (https://github.com/fmtlib/fmt/pull/3134,
+  https://github.com/fmtlib/fmt/pull/3254,
+  https://github.com/fmtlib/fmt/pull/3386,
+  https://github.com/fmtlib/fmt/pull/3387,
+  https://github.com/fmtlib/fmt/pull/3388,
+  https://github.com/fmtlib/fmt/pull/3392,
+  https://github.com/fmtlib/fmt/pull/3397,
+  https://github.com/fmtlib/fmt/pull/3399,
+  https://github.com/fmtlib/fmt/pull/3400).
+  Thanks @laitingsheng, @Orvid and @DanielaE.
+  
+- Switched to the [modules CMake library](https://github.com/vitaut/modules)
+  which allows building {fmt} as a C++20 module with clang:
+
+      CXX=clang++ cmake -DFMT_MODULE=ON .
+      make
+
+- Made `format_as` work with any user-defined type and not just enums.
+  For example ([godbolt](https://godbolt.org/z/b7rqhq5Kh)):
+
+  ```c++
+  #include <fmt/format.h>
+
+  struct floaty_mc_floatface {
+    double value;
+  };
+
+  auto format_as(floaty_mc_floatface f) { return f.value; }
+
+  int main() {
+    fmt::print("{:8}\n", floaty_mc_floatface{0.42}); // prints "    0.42"
+  }
+  ```
+
+- Removed deprecated implicit conversions for enums and conversions to
+  primitive types for compatibility with `std::format` and to prevent
+  potential ODR violations. Use `format_as` instead.
+
+- Added support for fill, align and width to the time point formatter
+  (https://github.com/fmtlib/fmt/issues/3237,
+  https://github.com/fmtlib/fmt/pull/3260,
+  https://github.com/fmtlib/fmt/pull/3275). For example
+  ([godbolt](https://godbolt.org/z/rKP6MGz6c)):
+
+  ```c++
+  #include <fmt/chrono.h>
+
+  int main() {
+    // prints "    2023"
+    fmt::print("{:>8%Y}\n", std::chrono::system_clock::now());
+  }
+  ```
+
+  Thanks @ShawnZhong.
+
+- Implemented formatting of subseconds
+  (https://github.com/fmtlib/fmt/issues/2207,
+  https://github.com/fmtlib/fmt/issues/3117,
+  https://github.com/fmtlib/fmt/pull/3115,
+  https://github.com/fmtlib/fmt/pull/3143,
+  https://github.com/fmtlib/fmt/pull/3144,
+  https://github.com/fmtlib/fmt/pull/3349). For example
+  ([godbolt](https://godbolt.org/z/45738oGEo)):
+
+  ```c++
+  #include <fmt/chrono.h>
+
+  int main() {
+    // prints 01.234567
+    fmt::print("{:%S}\n", std::chrono::microseconds(1234567));
+  }
+  ```
+
+  Thanks @patrickroocks @phprus and @BRevzin.
+
+- Added precision support to `%S`
+  (https://github.com/fmtlib/fmt/pull/3148). Thanks @SappyJoy
+
+- Added support for `std::utc_time`
+  (https://github.com/fmtlib/fmt/issues/3098,
+  https://github.com/fmtlib/fmt/pull/3110). Thanks @patrickroocks.
+
+- Switched formatting of `std::chrono::system_clock` from local time
+  to UTC for compatibility with the standard
+  (https://github.com/fmtlib/fmt/issues/3199,
+  https://github.com/fmtlib/fmt/pull/3230). Thanks @ned14.
+
+- Added support for `%Ez` and `%Oz` to chrono formatters.
+  (https://github.com/fmtlib/fmt/issues/3220,
+  https://github.com/fmtlib/fmt/pull/3222). Thanks @phprus.
+
+- Improved validation of format specifiers for `std::chrono::duration`
+  (https://github.com/fmtlib/fmt/issues/3219,
+  https://github.com/fmtlib/fmt/pull/3232). Thanks @ShawnZhong.
+
+- Fixed formatting of time points before the epoch
+  (https://github.com/fmtlib/fmt/issues/3117,
+  https://github.com/fmtlib/fmt/pull/3261). For example
+  ([godbolt](https://godbolt.org/z/f7bcznb3W)):
+
+  ```c++
+  #include <fmt/chrono.h>
+
+  int main() {
+    auto t = std::chrono::system_clock::from_time_t(0) -
+             std::chrono::milliseconds(250);
+    fmt::print("{:%S}\n", t); // prints 59.750000000
+  }
+  ```
+
+  Thanks @ShawnZhong.
 
-        vector<bool>::_M_range_check: __n (which is 0) >= this->size() (which is 0)
+- Experimental: implemented glibc extension for padding seconds,
+  minutes and hours
+  (https://github.com/fmtlib/fmt/issues/2959,
+  https://github.com/fmtlib/fmt/pull/3271). Thanks @ShawnZhong.
+
+- Added a formatter for `std::exception`
+  (https://github.com/fmtlib/fmt/issues/2977,
+  https://github.com/fmtlib/fmt/issues/3012,
+  https://github.com/fmtlib/fmt/pull/3062,
+  https://github.com/fmtlib/fmt/pull/3076,
+  https://github.com/fmtlib/fmt/pull/3119). For example
+  ([godbolt](https://godbolt.org/z/8xoWGs9e4)):
+
+  ```c++
+  #include <fmt/std.h>
+  #include <vector>
+
+  int main() {
+    try {
+      std::vector<bool>().at(0);
+    } catch(const std::exception& e) {
+      fmt::print("{}", e);
+    }
+  }
+  ```
 
-    on libstdc++. Thanks @zach2good and @phprus.
+  prints:
+
+      vector<bool>::_M_range_check: __n (which is 0) >= this->size() (which is 0)
 
--   Moved `std::error_code` formatter from `fmt/os.h` to `fmt/std.h`.
-    (https://github.com/fmtlib/fmt/pull/3125). Thanks @phprus.
+  on libstdc++. Thanks @zach2good and @phprus.
 
--   Added formatters for standard container adapters:
-    `std::priority_queue`, `std::queue` and `std::stack`
-    (https://github.com/fmtlib/fmt/issues/3215,
-    https://github.com/fmtlib/fmt/pull/3279). For example
-    ([godbolt](https://godbolt.org/z/74h1xY9qK)):
+- Moved `std::error_code` formatter from `fmt/os.h` to `fmt/std.h`.
+  (https://github.com/fmtlib/fmt/pull/3125). Thanks @phprus.
 
-    ```c++
-    #include <fmt/ranges.h>
-    #include <stack>
-    #include <vector>
+- Added formatters for standard container adapters:
+  `std::priority_queue`, `std::queue` and `std::stack`
+  (https://github.com/fmtlib/fmt/issues/3215,
+  https://github.com/fmtlib/fmt/pull/3279). For example
+  ([godbolt](https://godbolt.org/z/74h1xY9qK)):
 
-    int main() {
-      auto s = std::stack<bool, std::vector<bool>>();
-      for (auto b: {true, false, true}) s.push(b);
-      fmt::print("{}\n", s); // prints [true, false, true]
-    }
-    ```
-
-    Thanks @ShawnZhong.
-
--   Added a formatter for `std::optional` to `fmt/std.h`
-    (https://github.com/fmtlib/fmt/issues/1367,
-    https://github.com/fmtlib/fmt/pull/3303).
-    Thanks @tom-huntington.
-
--   Fixed formatting of valueless by exception variants
-    (https://github.com/fmtlib/fmt/pull/3347). Thanks @TheOmegaCarrot.
-
--   Made `fmt::ptr` accept `unique_ptr` with a custom deleter
-    (https://github.com/fmtlib/fmt/pull/3177). Thanks @hmbj.
-
--   Fixed formatting of noncopyable ranges and nested ranges of chars
-    (https://github.com/fmtlib/fmt/pull/3158
-    https://github.com/fmtlib/fmt/issues/3286,
-    https://github.com/fmtlib/fmt/pull/3290). Thanks @BRevzin.
-
--   Fixed issues with formatting of paths and ranges of paths
-    (https://github.com/fmtlib/fmt/issues/3319,
-    https://github.com/fmtlib/fmt/pull/3321
-    https://github.com/fmtlib/fmt/issues/3322). Thanks @phprus.
-
--   Improved handling of invalid Unicode in paths.
-
--   Enabled compile-time checks on Apple clang 14 and later
-    (https://github.com/fmtlib/fmt/pull/3331). Thanks @cloyce.
-
--   Improved compile-time checks of named arguments
-    (https://github.com/fmtlib/fmt/issues/3105,
-    https://github.com/fmtlib/fmt/pull/3214). Thanks @rbrich.
-
--   Fixed formatting when both alignment and `0` are given
-    (https://github.com/fmtlib/fmt/issues/3236,
-    https://github.com/fmtlib/fmt/pull/3248). Thanks @ShawnZhong.
-
--   Improved Unicode support in the experimental file API on Windows
-    (https://github.com/fmtlib/fmt/issues/3234,
-    https://github.com/fmtlib/fmt/pull/3293). Thanks @Fros1er.
-
--   Unified UTF transcoding
-    (https://github.com/fmtlib/fmt/pull/3416). Thanks @phprus.
-
--   Added support for UTF-8 digit separators via an experimental locale
-    facet (https://github.com/fmtlib/fmt/issues/1861). For
-    example ([godbolt](https://godbolt.org/z/f7bcznb3W)):
-
-    ```c++
-    auto loc = std::locale(
-      std::locale(), new fmt::format_facet<std::locale>("â"));
-    auto s = fmt::format(loc, "{:L}", 1000);
-    ```
-
-    where `â` is U+2019 used as a digit separator in the de_CH locale.
-
--   Added an overload of `formatted_size` that takes a locale
-    (https://github.com/fmtlib/fmt/issues/3084,
-    https://github.com/fmtlib/fmt/pull/3087). Thanks @gerboengels.
-
--   Removed the deprecated `FMT_DEPRECATED_OSTREAM`.
-
--   Fixed a UB when using a null `std::string_view` with
-    `fmt::to_string` or format string compilation
-    (https://github.com/fmtlib/fmt/issues/3241,
-    https://github.com/fmtlib/fmt/pull/3244). Thanks @phprus.
-
--   Added `starts_with` to the fallback `string_view` implementation
-    (https://github.com/fmtlib/fmt/pull/3080). Thanks @phprus.
-
--   Added `fmt::basic_format_string::get()` for compatibility with
-    `basic_format_string`
-    (https://github.com/fmtlib/fmt/pull/3111). Thanks @huangqinjin.
-
--   Added `println` for compatibility with C++23
-    (https://github.com/fmtlib/fmt/pull/3267). Thanks @ShawnZhong.
-
--   Renamed the `FMT_EXPORT` macro for shared library usage to
-    `FMT_LIB_EXPORT`.
-
--   Improved documentation
-    (https://github.com/fmtlib/fmt/issues/3108,
-    https://github.com/fmtlib/fmt/issues/3169,
-    https://github.com/fmtlib/fmt/pull/3243).
-    https://github.com/fmtlib/fmt/pull/3404).
-    Thanks @Cleroth and @Vertexwahn.
-
--   Improved build configuration and tests
-    (https://github.com/fmtlib/fmt/pull/3118,
-    https://github.com/fmtlib/fmt/pull/3120,
-    https://github.com/fmtlib/fmt/pull/3188,
-    https://github.com/fmtlib/fmt/issues/3189,
-    https://github.com/fmtlib/fmt/pull/3198,
-    https://github.com/fmtlib/fmt/pull/3205,
-    https://github.com/fmtlib/fmt/pull/3207,
-    https://github.com/fmtlib/fmt/pull/3210,
-    https://github.com/fmtlib/fmt/pull/3240,
-    https://github.com/fmtlib/fmt/pull/3256,
-    https://github.com/fmtlib/fmt/pull/3264,
-    https://github.com/fmtlib/fmt/issues/3299,
-    https://github.com/fmtlib/fmt/pull/3302,
-    https://github.com/fmtlib/fmt/pull/3312,
-    https://github.com/fmtlib/fmt/issues/3317,
-    https://github.com/fmtlib/fmt/pull/3328,
-    https://github.com/fmtlib/fmt/pull/3333,
-    https://github.com/fmtlib/fmt/pull/3369,
-    https://github.com/fmtlib/fmt/issues/3373,
-    https://github.com/fmtlib/fmt/pull/3395,
-    https://github.com/fmtlib/fmt/pull/3406,
-    https://github.com/fmtlib/fmt/pull/3411).
-    Thanks @dimztimz, @phprus, @DavidKorczynski, @ChrisThrasher,
-    @FrancoisCarouge, @kennyweiss, @luzpaz, @codeinred, @Mixaill, @joycebrum,
-    @kevinhwang and @Vertexwahn.
-
--   Fixed a regression in handling empty format specifiers after a colon
-    (`{:}`) (https://github.com/fmtlib/fmt/pull/3086). Thanks @oxidase.
-
--   Worked around a broken implementation of
-    `std::is_constant_evaluated` in some versions of libstdc++ on clang
-    (https://github.com/fmtlib/fmt/issues/3247,
-    https://github.com/fmtlib/fmt/pull/3281). Thanks @phprus.
-
--   Fixed formatting of volatile variables
-    (https://github.com/fmtlib/fmt/pull/3068).
-
--   Fixed various warnings and compilation issues
-    (https://github.com/fmtlib/fmt/pull/3057,
-    https://github.com/fmtlib/fmt/pull/3066,
-    https://github.com/fmtlib/fmt/pull/3072,
-    https://github.com/fmtlib/fmt/pull/3082,
-    https://github.com/fmtlib/fmt/pull/3091,
-    https://github.com/fmtlib/fmt/issues/3092,
-    https://github.com/fmtlib/fmt/pull/3093,
-    https://github.com/fmtlib/fmt/pull/3095,
-    https://github.com/fmtlib/fmt/issues/3096,
-    https://github.com/fmtlib/fmt/pull/3097,
-    https://github.com/fmtlib/fmt/issues/3128,
-    https://github.com/fmtlib/fmt/pull/3129,
-    https://github.com/fmtlib/fmt/pull/3137,
-    https://github.com/fmtlib/fmt/pull/3139,
-    https://github.com/fmtlib/fmt/issues/3140,
-    https://github.com/fmtlib/fmt/pull/3142,
-    https://github.com/fmtlib/fmt/issues/3149,
-    https://github.com/fmtlib/fmt/pull/3150,
-    https://github.com/fmtlib/fmt/issues/3154,
-    https://github.com/fmtlib/fmt/issues/3163,
-    https://github.com/fmtlib/fmt/issues/3178,
-    https://github.com/fmtlib/fmt/pull/3184,
-    https://github.com/fmtlib/fmt/pull/3196,
-    https://github.com/fmtlib/fmt/issues/3204,
-    https://github.com/fmtlib/fmt/pull/3206,
-    https://github.com/fmtlib/fmt/pull/3208,
-    https://github.com/fmtlib/fmt/issues/3213,
-    https://github.com/fmtlib/fmt/pull/3216,
-    https://github.com/fmtlib/fmt/issues/3224,
-    https://github.com/fmtlib/fmt/issues/3226,
-    https://github.com/fmtlib/fmt/issues/3228,
-    https://github.com/fmtlib/fmt/pull/3229,
-    https://github.com/fmtlib/fmt/pull/3259,
-    https://github.com/fmtlib/fmt/issues/3274,
-    https://github.com/fmtlib/fmt/issues/3287,
-    https://github.com/fmtlib/fmt/pull/3288,
-    https://github.com/fmtlib/fmt/issues/3292,
-    https://github.com/fmtlib/fmt/pull/3295,
-    https://github.com/fmtlib/fmt/pull/3296,
-    https://github.com/fmtlib/fmt/issues/3298,
-    https://github.com/fmtlib/fmt/issues/3325,
-    https://github.com/fmtlib/fmt/pull/3326,
-    https://github.com/fmtlib/fmt/issues/3334,
-    https://github.com/fmtlib/fmt/issues/3342,
-    https://github.com/fmtlib/fmt/pull/3343,
-    https://github.com/fmtlib/fmt/issues/3351,
-    https://github.com/fmtlib/fmt/pull/3352,
-    https://github.com/fmtlib/fmt/pull/3362,
-    https://github.com/fmtlib/fmt/issues/3365,
-    https://github.com/fmtlib/fmt/pull/3366,
-    https://github.com/fmtlib/fmt/pull/3374,
-    https://github.com/fmtlib/fmt/issues/3377,
-    https://github.com/fmtlib/fmt/pull/3378,
-    https://github.com/fmtlib/fmt/issues/3381,
-    https://github.com/fmtlib/fmt/pull/3398,
-    https://github.com/fmtlib/fmt/pull/3413,
-    https://github.com/fmtlib/fmt/issues/3415).
-    Thanks @phprus, @gsjaardema, @NewbieOrange, @EngineLessCC, @asmaloney,
-    @HazardyKnusperkeks, @sergiud, @Youw, @thesmurph, @czudziakm,
-    @Roman-Koshelev, @chronoxor, @ShawnZhong, @russelltg, @glebm, @tmartin-gh,
-    @Zhaojun-Liu, @louiswins and @mogemimi.
+  ```c++
+  #include <fmt/ranges.h>
+  #include <stack>
+  #include <vector>
+
+  int main() {
+    auto s = std::stack<bool, std::vector<bool>>();
+    for (auto b: {true, false, true}) s.push(b);
+    fmt::print("{}\n", s); // prints [true, false, true]
+  }
+  ```
+
+  Thanks @ShawnZhong.
+
+- Added a formatter for `std::optional` to `fmt/std.h`
+  (https://github.com/fmtlib/fmt/issues/1367,
+  https://github.com/fmtlib/fmt/pull/3303).
+  Thanks @tom-huntington.
+
+- Fixed formatting of valueless by exception variants
+  (https://github.com/fmtlib/fmt/pull/3347). Thanks @TheOmegaCarrot.
+
+- Made `fmt::ptr` accept `unique_ptr` with a custom deleter
+  (https://github.com/fmtlib/fmt/pull/3177). Thanks @hmbj.
+
+- Fixed formatting of noncopyable ranges and nested ranges of chars
+  (https://github.com/fmtlib/fmt/pull/3158
+  https://github.com/fmtlib/fmt/issues/3286,
+  https://github.com/fmtlib/fmt/pull/3290). Thanks @BRevzin.
+
+- Fixed issues with formatting of paths and ranges of paths
+  (https://github.com/fmtlib/fmt/issues/3319,
+  https://github.com/fmtlib/fmt/pull/3321
+  https://github.com/fmtlib/fmt/issues/3322). Thanks @phprus.
+
+- Improved handling of invalid Unicode in paths.
+
+- Enabled compile-time checks on Apple clang 14 and later
+  (https://github.com/fmtlib/fmt/pull/3331). Thanks @cloyce.
+
+- Improved compile-time checks of named arguments
+  (https://github.com/fmtlib/fmt/issues/3105,
+  https://github.com/fmtlib/fmt/pull/3214). Thanks @rbrich.
+
+- Fixed formatting when both alignment and `0` are given
+  (https://github.com/fmtlib/fmt/issues/3236,
+  https://github.com/fmtlib/fmt/pull/3248). Thanks @ShawnZhong.
+
+- Improved Unicode support in the experimental file API on Windows
+  (https://github.com/fmtlib/fmt/issues/3234,
+  https://github.com/fmtlib/fmt/pull/3293). Thanks @Fros1er.
+
+- Unified UTF transcoding
+  (https://github.com/fmtlib/fmt/pull/3416). Thanks @phprus.
+
+- Added support for UTF-8 digit separators via an experimental locale
+  facet (https://github.com/fmtlib/fmt/issues/1861). For
+  example ([godbolt](https://godbolt.org/z/f7bcznb3W)):
+
+  ```c++
+  auto loc = std::locale(
+    std::locale(), new fmt::format_facet<std::locale>("â"));
+  auto s = fmt::format(loc, "{:L}", 1000);
+  ```
+
+  where `â` is U+2019 used as a digit separator in the de_CH locale.
+
+- Added an overload of `formatted_size` that takes a locale
+  (https://github.com/fmtlib/fmt/issues/3084,
+  https://github.com/fmtlib/fmt/pull/3087). Thanks @gerboengels.
+
+- Removed the deprecated `FMT_DEPRECATED_OSTREAM`.
+
+- Fixed a UB when using a null `std::string_view` with
+  `fmt::to_string` or format string compilation
+  (https://github.com/fmtlib/fmt/issues/3241,
+  https://github.com/fmtlib/fmt/pull/3244). Thanks @phprus.
+
+- Added `starts_with` to the fallback `string_view` implementation
+  (https://github.com/fmtlib/fmt/pull/3080). Thanks @phprus.
+
+- Added `fmt::basic_format_string::get()` for compatibility with
+  `basic_format_string`
+  (https://github.com/fmtlib/fmt/pull/3111). Thanks @huangqinjin.
+
+- Added `println` for compatibility with C++23
+  (https://github.com/fmtlib/fmt/pull/3267). Thanks @ShawnZhong.
+
+- Renamed the `FMT_EXPORT` macro for shared library usage to
+  `FMT_LIB_EXPORT`.
+
+- Improved documentation
+  (https://github.com/fmtlib/fmt/issues/3108,
+  https://github.com/fmtlib/fmt/issues/3169,
+  https://github.com/fmtlib/fmt/pull/3243).
+  https://github.com/fmtlib/fmt/pull/3404,
+  https://github.com/fmtlib/fmt/pull/4002).
+  Thanks @Cleroth, @Vertexwahn and @yujincheng08.
+
+- Improved build configuration and tests
+  (https://github.com/fmtlib/fmt/pull/3118,
+  https://github.com/fmtlib/fmt/pull/3120,
+  https://github.com/fmtlib/fmt/pull/3188,
+  https://github.com/fmtlib/fmt/issues/3189,
+  https://github.com/fmtlib/fmt/pull/3198,
+  https://github.com/fmtlib/fmt/pull/3205,
+  https://github.com/fmtlib/fmt/pull/3207,
+  https://github.com/fmtlib/fmt/pull/3210,
+  https://github.com/fmtlib/fmt/pull/3240,
+  https://github.com/fmtlib/fmt/pull/3256,
+  https://github.com/fmtlib/fmt/pull/3264,
+  https://github.com/fmtlib/fmt/issues/3299,
+  https://github.com/fmtlib/fmt/pull/3302,
+  https://github.com/fmtlib/fmt/pull/3312,
+  https://github.com/fmtlib/fmt/issues/3317,
+  https://github.com/fmtlib/fmt/pull/3328,
+  https://github.com/fmtlib/fmt/pull/3333,
+  https://github.com/fmtlib/fmt/pull/3369,
+  https://github.com/fmtlib/fmt/issues/3373,
+  https://github.com/fmtlib/fmt/pull/3395,
+  https://github.com/fmtlib/fmt/pull/3406,
+  https://github.com/fmtlib/fmt/pull/3411).
+  Thanks @dimztimz, @phprus, @DavidKorczynski, @ChrisThrasher,
+  @FrancoisCarouge, @kennyweiss, @luzpaz, @codeinred, @Mixaill, @joycebrum,
+  @kevinhwang and @Vertexwahn.
+
+- Fixed a regression in handling empty format specifiers after a colon
+  (`{:}`) (https://github.com/fmtlib/fmt/pull/3086). Thanks @oxidase.
+
+- Worked around a broken implementation of
+  `std::is_constant_evaluated` in some versions of libstdc++ on clang
+  (https://github.com/fmtlib/fmt/issues/3247,
+  https://github.com/fmtlib/fmt/pull/3281). Thanks @phprus.
+
+- Fixed formatting of volatile variables
+  (https://github.com/fmtlib/fmt/pull/3068).
+
+- Fixed various warnings and compilation issues
+  (https://github.com/fmtlib/fmt/pull/3057,
+  https://github.com/fmtlib/fmt/pull/3066,
+  https://github.com/fmtlib/fmt/pull/3072,
+  https://github.com/fmtlib/fmt/pull/3082,
+  https://github.com/fmtlib/fmt/pull/3091,
+  https://github.com/fmtlib/fmt/issues/3092,
+  https://github.com/fmtlib/fmt/pull/3093,
+  https://github.com/fmtlib/fmt/pull/3095,
+  https://github.com/fmtlib/fmt/issues/3096,
+  https://github.com/fmtlib/fmt/pull/3097,
+  https://github.com/fmtlib/fmt/issues/3128,
+  https://github.com/fmtlib/fmt/pull/3129,
+  https://github.com/fmtlib/fmt/pull/3137,
+  https://github.com/fmtlib/fmt/pull/3139,
+  https://github.com/fmtlib/fmt/issues/3140,
+  https://github.com/fmtlib/fmt/pull/3142,
+  https://github.com/fmtlib/fmt/issues/3149,
+  https://github.com/fmtlib/fmt/pull/3150,
+  https://github.com/fmtlib/fmt/issues/3154,
+  https://github.com/fmtlib/fmt/issues/3163,
+  https://github.com/fmtlib/fmt/issues/3178,
+  https://github.com/fmtlib/fmt/pull/3184,
+  https://github.com/fmtlib/fmt/pull/3196,
+  https://github.com/fmtlib/fmt/issues/3204,
+  https://github.com/fmtlib/fmt/pull/3206,
+  https://github.com/fmtlib/fmt/pull/3208,
+  https://github.com/fmtlib/fmt/issues/3213,
+  https://github.com/fmtlib/fmt/pull/3216,
+  https://github.com/fmtlib/fmt/issues/3224,
+  https://github.com/fmtlib/fmt/issues/3226,
+  https://github.com/fmtlib/fmt/issues/3228,
+  https://github.com/fmtlib/fmt/pull/3229,
+  https://github.com/fmtlib/fmt/pull/3259,
+  https://github.com/fmtlib/fmt/issues/3274,
+  https://github.com/fmtlib/fmt/issues/3287,
+  https://github.com/fmtlib/fmt/pull/3288,
+  https://github.com/fmtlib/fmt/issues/3292,
+  https://github.com/fmtlib/fmt/pull/3295,
+  https://github.com/fmtlib/fmt/pull/3296,
+  https://github.com/fmtlib/fmt/issues/3298,
+  https://github.com/fmtlib/fmt/issues/3325,
+  https://github.com/fmtlib/fmt/pull/3326,
+  https://github.com/fmtlib/fmt/issues/3334,
+  https://github.com/fmtlib/fmt/issues/3342,
+  https://github.com/fmtlib/fmt/pull/3343,
+  https://github.com/fmtlib/fmt/issues/3351,
+  https://github.com/fmtlib/fmt/pull/3352,
+  https://github.com/fmtlib/fmt/pull/3362,
+  https://github.com/fmtlib/fmt/issues/3365,
+  https://github.com/fmtlib/fmt/pull/3366,
+  https://github.com/fmtlib/fmt/pull/3374,
+  https://github.com/fmtlib/fmt/issues/3377,
+  https://github.com/fmtlib/fmt/pull/3378,
+  https://github.com/fmtlib/fmt/issues/3381,
+  https://github.com/fmtlib/fmt/pull/3398,
+  https://github.com/fmtlib/fmt/pull/3413,
+  https://github.com/fmtlib/fmt/issues/3415).
+  Thanks @phprus, @gsjaardema, @NewbieOrange, @EngineLessCC, @asmaloney,
+  @HazardyKnusperkeks, @sergiud, @Youw, @thesmurph, @czudziakm,
+  @Roman-Koshelev, @chronoxor, @ShawnZhong, @russelltg, @glebm, @tmartin-gh,
+  @Zhaojun-Liu, @louiswins and @mogemimi.
 
 # 9.1.0 - 2022-08-27
 
--   `fmt::formatted_size` now works at compile time
-    (https://github.com/fmtlib/fmt/pull/3026). For example
-    ([godbolt](https://godbolt.org/z/1MW5rMdf8)):
-
-    ```c++
-    #include <fmt/compile.h>
-
-    int main() {
-      using namespace fmt::literals;
-      constexpr size_t n = fmt::formatted_size("{}"_cf, 42);
-      fmt::print("{}\n", n); // prints 2
-    }
-    ```
-
-    Thanks @marksantaniello.
-
--   Fixed handling of invalid UTF-8
-    (https://github.com/fmtlib/fmt/pull/3038,
-    https://github.com/fmtlib/fmt/pull/3044,
-    https://github.com/fmtlib/fmt/pull/3056).
-    Thanks @phprus and @skeeto.
-
--   Improved Unicode support in `ostream` overloads of `print`
-    (https://github.com/fmtlib/fmt/pull/2994,
-    https://github.com/fmtlib/fmt/pull/3001,
-    https://github.com/fmtlib/fmt/pull/3025). Thanks @dimztimz.
-
--   Fixed handling of the sign specifier in localized formatting on
-    systems with 32-bit `wchar_t`
-    (https://github.com/fmtlib/fmt/issues/3041).
+- `fmt::formatted_size` now works at compile time
+  (https://github.com/fmtlib/fmt/pull/3026). For example
+  ([godbolt](https://godbolt.org/z/1MW5rMdf8)):
 
--   Added support for wide streams to `fmt::streamed`
-    (https://github.com/fmtlib/fmt/pull/2994). Thanks @phprus.
+  ```c++
+  #include <fmt/compile.h>
 
--   Added the `n` specifier that disables the output of delimiters when
-    formatting ranges (https://github.com/fmtlib/fmt/pull/2981,
-    https://github.com/fmtlib/fmt/pull/2983). For example
-    ([godbolt](https://godbolt.org/z/roKqGdj8c)):
-
-    ```c++
-    #include <fmt/ranges.h>
-    #include <vector>
-
-    int main() {
-      auto v = std::vector{1, 2, 3};
-      fmt::print("{:n}\n", v); // prints 1, 2, 3
-    }
-    ```
-
-    Thanks @BRevzin.
-
--   Worked around problematic `std::string_view` constructors introduced
-    in C++23 (https://github.com/fmtlib/fmt/issues/3030,
-    https://github.com/fmtlib/fmt/issues/3050). Thanks @strega-nil-ms.
-
--   Improve handling (exclusion) of recursive ranges
-    (https://github.com/fmtlib/fmt/issues/2968,
-    https://github.com/fmtlib/fmt/pull/2974). Thanks @Dani-Hub.
-
--   Improved error reporting in format string compilation
-    (https://github.com/fmtlib/fmt/issues/3055).
-
--   Improved the implementation of
-    [Dragonbox](https://github.com/jk-jeon/dragonbox), the algorithm
-    used for the default floating-point formatting
-    (https://github.com/fmtlib/fmt/pull/2984). Thanks @jk-jeon.
-
--   Fixed issues with floating-point formatting on exotic platforms.
-
--   Improved the implementation of chrono formatting
-    (https://github.com/fmtlib/fmt/pull/3010). Thanks @phprus.
-
--   Improved documentation
-    (https://github.com/fmtlib/fmt/pull/2966,
-    https://github.com/fmtlib/fmt/pull/3009,
-    https://github.com/fmtlib/fmt/issues/3020,
-    https://github.com/fmtlib/fmt/pull/3037).
-    Thanks @mwinterb, @jcelerier and @remiburtin.
-
--   Improved build configuration
-    (https://github.com/fmtlib/fmt/pull/2991,
-    https://github.com/fmtlib/fmt/pull/2995,
-    https://github.com/fmtlib/fmt/issues/3004,
-    https://github.com/fmtlib/fmt/pull/3007,
-    https://github.com/fmtlib/fmt/pull/3040).
-    Thanks @dimztimz and @hwhsu1231.
-
--   Fixed various warnings and compilation issues
-    (https://github.com/fmtlib/fmt/issues/2969,
-    https://github.com/fmtlib/fmt/pull/2971,
-    https://github.com/fmtlib/fmt/issues/2975,
-    https://github.com/fmtlib/fmt/pull/2982,
-    https://github.com/fmtlib/fmt/pull/2985,
-    https://github.com/fmtlib/fmt/issues/2988,
-    https://github.com/fmtlib/fmt/issues/2989,
-    https://github.com/fmtlib/fmt/issues/3000,
-    https://github.com/fmtlib/fmt/issues/3006,
-    https://github.com/fmtlib/fmt/issues/3014,
-    https://github.com/fmtlib/fmt/issues/3015,
-    https://github.com/fmtlib/fmt/pull/3021,
-    https://github.com/fmtlib/fmt/issues/3023,
-    https://github.com/fmtlib/fmt/pull/3024,
-    https://github.com/fmtlib/fmt/pull/3029,
-    https://github.com/fmtlib/fmt/pull/3043,
-    https://github.com/fmtlib/fmt/issues/3052,
-    https://github.com/fmtlib/fmt/pull/3053,
-    https://github.com/fmtlib/fmt/pull/3054).
-    Thanks @h-friederich, @dimztimz, @olupton, @bernhardmgruber and @phprus.
+  int main() {
+    using namespace fmt::literals;
+    constexpr size_t n = fmt::formatted_size("{}"_cf, 42);
+    fmt::print("{}\n", n); // prints 2
+  }
+  ```
+
+  Thanks @marksantaniello.
+
+- Fixed handling of invalid UTF-8
+  (https://github.com/fmtlib/fmt/pull/3038,
+  https://github.com/fmtlib/fmt/pull/3044,
+  https://github.com/fmtlib/fmt/pull/3056).
+  Thanks @phprus and @skeeto.
+
+- Improved Unicode support in `ostream` overloads of `print`
+  (https://github.com/fmtlib/fmt/pull/2994,
+  https://github.com/fmtlib/fmt/pull/3001,
+  https://github.com/fmtlib/fmt/pull/3025). Thanks @dimztimz.
+
+- Fixed handling of the sign specifier in localized formatting on
+  systems with 32-bit `wchar_t`
+  (https://github.com/fmtlib/fmt/issues/3041).
+
+- Added support for wide streams to `fmt::streamed`
+  (https://github.com/fmtlib/fmt/pull/2994). Thanks @phprus.
+
+- Added the `n` specifier that disables the output of delimiters when
+  formatting ranges (https://github.com/fmtlib/fmt/pull/2981,
+  https://github.com/fmtlib/fmt/pull/2983). For example
+  ([godbolt](https://godbolt.org/z/roKqGdj8c)):
+
+  ```c++
+  #include <fmt/ranges.h>
+  #include <vector>
+
+  int main() {
+    auto v = std::vector{1, 2, 3};
+    fmt::print("{:n}\n", v); // prints 1, 2, 3
+  }
+  ```
+
+  Thanks @BRevzin.
+
+- Worked around problematic `std::string_view` constructors introduced
+  in C++23 (https://github.com/fmtlib/fmt/issues/3030,
+  https://github.com/fmtlib/fmt/issues/3050). Thanks @strega-nil-ms.
+
+- Improve handling (exclusion) of recursive ranges
+  (https://github.com/fmtlib/fmt/issues/2968,
+  https://github.com/fmtlib/fmt/pull/2974). Thanks @Dani-Hub.
+
+- Improved error reporting in format string compilation
+  (https://github.com/fmtlib/fmt/issues/3055).
+
+- Improved the implementation of
+  [Dragonbox](https://github.com/jk-jeon/dragonbox), the algorithm
+  used for the default floating-point formatting
+  (https://github.com/fmtlib/fmt/pull/2984). Thanks @jk-jeon.
+
+- Fixed issues with floating-point formatting on exotic platforms.
+
+- Improved the implementation of chrono formatting
+  (https://github.com/fmtlib/fmt/pull/3010). Thanks @phprus.
+
+- Improved documentation
+  (https://github.com/fmtlib/fmt/pull/2966,
+  https://github.com/fmtlib/fmt/pull/3009,
+  https://github.com/fmtlib/fmt/issues/3020,
+  https://github.com/fmtlib/fmt/pull/3037).
+  Thanks @mwinterb, @jcelerier and @remiburtin.
+
+- Improved build configuration
+  (https://github.com/fmtlib/fmt/pull/2991,
+  https://github.com/fmtlib/fmt/pull/2995,
+  https://github.com/fmtlib/fmt/issues/3004,
+  https://github.com/fmtlib/fmt/pull/3007,
+  https://github.com/fmtlib/fmt/pull/3040).
+  Thanks @dimztimz and @hwhsu1231.
+
+- Fixed various warnings and compilation issues
+  (https://github.com/fmtlib/fmt/issues/2969,
+  https://github.com/fmtlib/fmt/pull/2971,
+  https://github.com/fmtlib/fmt/issues/2975,
+  https://github.com/fmtlib/fmt/pull/2982,
+  https://github.com/fmtlib/fmt/pull/2985,
+  https://github.com/fmtlib/fmt/issues/2988,
+  https://github.com/fmtlib/fmt/issues/2989,
+  https://github.com/fmtlib/fmt/issues/3000,
+  https://github.com/fmtlib/fmt/issues/3006,
+  https://github.com/fmtlib/fmt/issues/3014,
+  https://github.com/fmtlib/fmt/issues/3015,
+  https://github.com/fmtlib/fmt/pull/3021,
+  https://github.com/fmtlib/fmt/issues/3023,
+  https://github.com/fmtlib/fmt/pull/3024,
+  https://github.com/fmtlib/fmt/pull/3029,
+  https://github.com/fmtlib/fmt/pull/3043,
+  https://github.com/fmtlib/fmt/issues/3052,
+  https://github.com/fmtlib/fmt/pull/3053,
+  https://github.com/fmtlib/fmt/pull/3054).
+  Thanks @h-friederich, @dimztimz, @olupton, @bernhardmgruber and @phprus.
 
 # 9.0.0 - 2022-07-04
 
--   Switched to the internal floating point formatter for all decimal
-    presentation formats. In particular this results in consistent
-    rounding on all platforms and removing the `s[n]printf` fallback for
-    decimal FP formatting.
-
--   Compile-time floating point formatting no longer requires the
-    header-only mode. For example
-    ([godbolt](https://godbolt.org/z/G37PTeG3b)):
-
-    ```c++
-    #include <array>
-    #include <fmt/compile.h>
-
-    consteval auto compile_time_dtoa(double value) -> std::array<char, 10> {
-      auto result = std::array<char, 10>();
-      fmt::format_to(result.data(), FMT_COMPILE("{}"), value);
-      return result;
-    }
+- Switched to the internal floating point formatter for all decimal
+  presentation formats. In particular this results in consistent
+  rounding on all platforms and removing the `s[n]printf` fallback for
+  decimal FP formatting.
 
-    constexpr auto answer = compile_time_dtoa(0.42);
-    ```
+- Compile-time floating point formatting no longer requires the
+  header-only mode. For example
+  ([godbolt](https://godbolt.org/z/G37PTeG3b)):
 
-    works with the default settings.
+  ```c++
+  #include <array>
+  #include <fmt/compile.h>
 
--   Improved the implementation of
-    [Dragonbox](https://github.com/jk-jeon/dragonbox), the algorithm
-    used for the default floating-point formatting
-    (https://github.com/fmtlib/fmt/pull/2713,
-    https://github.com/fmtlib/fmt/pull/2750). Thanks @jk-jeon.
+  consteval auto compile_time_dtoa(double value) -> std::array<char, 10> {
+    auto result = std::array<char, 10>();
+    fmt::format_to(result.data(), FMT_COMPILE("{}"), value);
+    return result;
+  }
 
--   Made `fmt::to_string` work with `__float128`. This uses the internal
-    FP formatter and works even on system without `__float128` support
-    in `[s]printf`.
+  constexpr auto answer = compile_time_dtoa(0.42);
+  ```
 
--   Disabled automatic `std::ostream` insertion operator (`operator<<`)
-    discovery when `fmt/ostream.h` is included to prevent ODR
-    violations. You can get the old behavior by defining
-    `FMT_DEPRECATED_OSTREAM` but this will be removed in the next major
-    release. Use `fmt::streamed` or `fmt::ostream_formatter` to enable
-    formatting via `std::ostream` instead.
+  works with the default settings.
 
--   Added `fmt::ostream_formatter` that can be used to write `formatter`
-    specializations that perform formatting via `std::ostream`. For
-    example ([godbolt](https://godbolt.org/z/5sEc5qMsf)):
+- Improved the implementation of
+  [Dragonbox](https://github.com/jk-jeon/dragonbox), the algorithm
+  used for the default floating-point formatting
+  (https://github.com/fmtlib/fmt/pull/2713,
+  https://github.com/fmtlib/fmt/pull/2750). Thanks @jk-jeon.
 
-    ```c++
-    #include <fmt/ostream.h>
+- Made `fmt::to_string` work with `__float128`. This uses the internal
+  FP formatter and works even on system without `__float128` support
+  in `[s]printf`.
 
-    struct date {
-      int year, month, day;
+- Disabled automatic `std::ostream` insertion operator (`operator<<`)
+  discovery when `fmt/ostream.h` is included to prevent ODR
+  violations. You can get the old behavior by defining
+  `FMT_DEPRECATED_OSTREAM` but this will be removed in the next major
+  release. Use `fmt::streamed` or `fmt::ostream_formatter` to enable
+  formatting via `std::ostream` instead.
 
-      friend std::ostream& operator<<(std::ostream& os, const date& d) {
-        return os << d.year << '-' << d.month << '-' << d.day;
-      }
-    };
+- Added `fmt::ostream_formatter` that can be used to write `formatter`
+  specializations that perform formatting via `std::ostream`. For
+  example ([godbolt](https://godbolt.org/z/5sEc5qMsf)):
 
-    template <> struct fmt::formatter<date> : ostream_formatter {};
+  ```c++
+  #include <fmt/ostream.h>
 
-    std::string s = fmt::format("The date is {}", date{2012, 12, 9});
-    // s == "The date is 2012-12-9"
-    ```
+  struct date {
+    int year, month, day;
 
--   Added the `fmt::streamed` function that takes an object and formats
-    it via `std::ostream`. For example
-    ([godbolt](https://godbolt.org/z/5G3346G1f)):
-
-    ```c++
-    #include <thread>
-    #include <fmt/ostream.h>
-
-    int main() {
-      fmt::print("Current thread id: {}\n",
-                 fmt::streamed(std::this_thread::get_id()));
+    friend std::ostream& operator<<(std::ostream& os, const date& d) {
+      return os << d.year << '-' << d.month << '-' << d.day;
     }
-    ```
+  };
 
-    Note that `fmt/std.h` provides a `formatter` specialization for
-    `std::thread::id` so you don\'t need to format it via
-    `std::ostream`.
+  template <> struct fmt::formatter<date> : ostream_formatter {};
 
--   Deprecated implicit conversions of unscoped enums to integers for
-    consistency with scoped enums.
+  std::string s = fmt::format("The date is {}", date{2012, 12, 9});
+  // s == "The date is 2012-12-9"
+  ```
 
--   Added an argument-dependent lookup based `format_as` extension API
-    to simplify formatting of enums.
+- Added the `fmt::streamed` function that takes an object and formats
+  it via `std::ostream`. For example
+  ([godbolt](https://godbolt.org/z/5G3346G1f)):
 
--   Added experimental `std::variant` formatting support
-    (https://github.com/fmtlib/fmt/pull/2941). For example
-    ([godbolt](https://godbolt.org/z/KG9z6cq68)):
+  ```c++
+  #include <thread>
+  #include <fmt/ostream.h>
 
-    ```c++
-    #include <variant>
-    #include <fmt/std.h>
+  int main() {
+    fmt::print("Current thread id: {}\n",
+               fmt::streamed(std::this_thread::get_id()));
+  }
+  ```
 
-    int main() {
-      auto v = std::variant<int, std::string>(42);
-      fmt::print("{}\n", v);
-    }
-    ```
+  Note that `fmt/std.h` provides a `formatter` specialization for
+  `std::thread::id` so you don\'t need to format it via
+  `std::ostream`.
 
-    prints:
+- Deprecated implicit conversions of unscoped enums to integers for
+  consistency with scoped enums.
 
-        variant(42)
+- Added an argument-dependent lookup based `format_as` extension API
+  to simplify formatting of enums.
 
-    Thanks @jehelset.
+- Added experimental `std::variant` formatting support
+  (https://github.com/fmtlib/fmt/pull/2941). For example
+  ([godbolt](https://godbolt.org/z/KG9z6cq68)):
 
--   Added experimental `std::filesystem::path` formatting support
-    (https://github.com/fmtlib/fmt/issues/2865,
-    https://github.com/fmtlib/fmt/pull/2902,
-    https://github.com/fmtlib/fmt/issues/2917,
-    https://github.com/fmtlib/fmt/pull/2918). For example
-    ([godbolt](https://godbolt.org/z/o44dMexEb)):
+  ```c++
+  #include <variant>
+  #include <fmt/std.h>
 
-    ```c++
-    #include <filesystem>
-    #include <fmt/std.h>
+  int main() {
+    auto v = std::variant<int, std::string>(42);
+    fmt::print("{}\n", v);
+  }
+  ```
 
-    int main() {
-      fmt::print("There is no place like {}.", std::filesystem::path("/home"));
-    }
-    ```
+  prints:
 
-    prints:
+      variant(42)
 
-        There is no place like "/home".
+  Thanks @jehelset.
 
-    Thanks @phprus.
+- Added experimental `std::filesystem::path` formatting support
+  (https://github.com/fmtlib/fmt/issues/2865,
+  https://github.com/fmtlib/fmt/pull/2902,
+  https://github.com/fmtlib/fmt/issues/2917,
+  https://github.com/fmtlib/fmt/pull/2918). For example
+  ([godbolt](https://godbolt.org/z/o44dMexEb)):
 
--   Added a `std::thread::id` formatter to `fmt/std.h`. For example
-    ([godbolt](https://godbolt.org/z/j1azbYf3E)):
+  ```c++
+  #include <filesystem>
+  #include <fmt/std.h>
 
-    ```c++
-    #include <thread>
-    #include <fmt/std.h>
+  int main() {
+    fmt::print("There is no place like {}.", std::filesystem::path("/home"));
+  }
+  ```
 
-    int main() {
-      fmt::print("Current thread id: {}\n", std::this_thread::get_id());
-    }
-    ```
-
--   Added `fmt::styled` that applies a text style to an individual
-    argument (https://github.com/fmtlib/fmt/pull/2793). For
-    example ([godbolt](https://godbolt.org/z/vWGW7v5M6)):
-
-    ```c++
-    #include <fmt/chrono.h>
-    #include <fmt/color.h>
-
-    int main() {
-      auto now = std::chrono::system_clock::now();
-      fmt::print(
-        "[{}] {}: {}\n",
-        fmt::styled(now, fmt::emphasis::bold),
-        fmt::styled("error", fg(fmt::color::red)),
-        "something went wrong");
-    }
-    ```
+  prints:
 
-    prints
+      There is no place like "/home".
 
-    ![](https://user-images.githubusercontent.com/576385/175071215-12809244-dab0-4005-96d8-7cd911c964d5.png)
+  Thanks @phprus.
 
-    Thanks @rbrugo.
+- Added a `std::thread::id` formatter to `fmt/std.h`. For example
+  ([godbolt](https://godbolt.org/z/j1azbYf3E)):
 
--   Made `fmt::print` overload for text styles correctly handle UTF-8
-    (https://github.com/fmtlib/fmt/issues/2681,
-    https://github.com/fmtlib/fmt/pull/2701). Thanks @AlexGuteniev.
+  ```c++
+  #include <thread>
+  #include <fmt/std.h>
 
--   Fixed Unicode handling when writing to an ostream.
+  int main() {
+    fmt::print("Current thread id: {}\n", std::this_thread::get_id());
+  }
+  ```
 
--   Added support for nested specifiers to range formatting
-    (https://github.com/fmtlib/fmt/pull/2673). For example
-    ([godbolt](https://godbolt.org/z/xd3Gj38cf)):
+- Added `fmt::styled` that applies a text style to an individual
+  argument (https://github.com/fmtlib/fmt/pull/2793). For
+  example ([godbolt](https://godbolt.org/z/vWGW7v5M6)):
 
-    ```c++
-    #include <vector>
-    #include <fmt/ranges.h>
+  ```c++
+  #include <fmt/chrono.h>
+  #include <fmt/color.h>
 
-    int main() {
-      fmt::print("{::#x}\n", std::vector{10, 20, 30});
-    }
-    ```
-
-    prints `[0xa, 0x14, 0x1e]`.
-
-    Thanks @BRevzin.
-
--   Implemented escaping of wide strings in ranges
-    (https://github.com/fmtlib/fmt/pull/2904). Thanks @phprus.
-
--   Added support for ranges with `begin` / `end` found via the
-    argument-dependent lookup
-    (https://github.com/fmtlib/fmt/pull/2807). Thanks @rbrugo.
-
--   Fixed formatting of certain kinds of ranges of ranges
-    (https://github.com/fmtlib/fmt/pull/2787). Thanks @BRevzin.
-
--   Fixed handling of maps with element types other than `std::pair`
-    (https://github.com/fmtlib/fmt/pull/2944). Thanks @BrukerJWD.
-
--   Made tuple formatter enabled only if elements are formattable
-    (https://github.com/fmtlib/fmt/issues/2939,
-    https://github.com/fmtlib/fmt/pull/2940). Thanks @jehelset.
-
--   Made `fmt::join` compatible with format string compilation
-    (https://github.com/fmtlib/fmt/issues/2719,
-    https://github.com/fmtlib/fmt/pull/2720). Thanks @phprus.
-
--   Made compile-time checks work with named arguments of custom types
-    and `std::ostream` `print` overloads
-    (https://github.com/fmtlib/fmt/issues/2816,
-    https://github.com/fmtlib/fmt/issues/2817,
-    https://github.com/fmtlib/fmt/pull/2819). Thanks @timsong-cpp.
-
--   Removed `make_args_checked` because it is no longer needed for
-    compile-time checks
-    (https://github.com/fmtlib/fmt/pull/2760). Thanks @phprus.
-
--   Removed the following deprecated APIs: `_format`, `arg_join`, the
-    `format_to` overload that takes a memory buffer, `[v]fprintf` that
-    takes an `ostream`.
-
--   Removed the deprecated implicit conversion of `[const] signed char*`
-    and `[const] unsigned char*` to C strings.
-
--   Removed the deprecated `fmt/locale.h`.
-
--   Replaced the deprecated `fileno()` with `descriptor()` in
-    `buffered_file`.
-
--   Moved `to_string_view` to the `detail` namespace since it\'s an
-    implementation detail.
-
--   Made access mode of a created file consistent with `fopen` by
-    setting `S_IWGRP` and `S_IWOTH`
-    (https://github.com/fmtlib/fmt/pull/2733). Thanks @arogge.
-
--   Removed a redundant buffer resize when formatting to `std::ostream`
-    (https://github.com/fmtlib/fmt/issues/2842,
-    https://github.com/fmtlib/fmt/pull/2843). Thanks @jcelerier.
-
--   Made precision computation for strings consistent with width
-    (https://github.com/fmtlib/fmt/issues/2888).
-
--   Fixed handling of locale separators in floating point formatting
-    (https://github.com/fmtlib/fmt/issues/2830).
-
--   Made sign specifiers work with `__int128_t`
-    (https://github.com/fmtlib/fmt/issues/2773).
-
--   Improved support for systems such as CHERI with extra data stored in
-    pointers (https://github.com/fmtlib/fmt/pull/2932).
-    Thanks @davidchisnall.
-
--   Improved documentation
-    (https://github.com/fmtlib/fmt/pull/2706,
-    https://github.com/fmtlib/fmt/pull/2712,
-    https://github.com/fmtlib/fmt/pull/2789,
-    https://github.com/fmtlib/fmt/pull/2803,
-    https://github.com/fmtlib/fmt/pull/2805,
-    https://github.com/fmtlib/fmt/pull/2815,
-    https://github.com/fmtlib/fmt/pull/2924).
-    Thanks @BRevzin, @Pokechu22, @setoye, @rtobar, @rbrugo, @anoonD and
-    @leha-bot.
-
--   Improved build configuration
-    (https://github.com/fmtlib/fmt/pull/2766,
-    https://github.com/fmtlib/fmt/pull/2772,
-    https://github.com/fmtlib/fmt/pull/2836,
-    https://github.com/fmtlib/fmt/pull/2852,
-    https://github.com/fmtlib/fmt/pull/2907,
-    https://github.com/fmtlib/fmt/pull/2913,
-    https://github.com/fmtlib/fmt/pull/2914).
-    Thanks @kambala-decapitator, @mattiasljungstrom, @kieselnb, @nathannaveen
-    and @Vertexwahn.
-
--   Fixed various warnings and compilation issues
-    (https://github.com/fmtlib/fmt/issues/2408,
-    https://github.com/fmtlib/fmt/issues/2507,
-    https://github.com/fmtlib/fmt/issues/2697,
-    https://github.com/fmtlib/fmt/issues/2715,
-    https://github.com/fmtlib/fmt/issues/2717,
-    https://github.com/fmtlib/fmt/pull/2722,
-    https://github.com/fmtlib/fmt/pull/2724,
-    https://github.com/fmtlib/fmt/pull/2725,
-    https://github.com/fmtlib/fmt/issues/2726,
-    https://github.com/fmtlib/fmt/pull/2728,
-    https://github.com/fmtlib/fmt/pull/2732,
-    https://github.com/fmtlib/fmt/issues/2738,
-    https://github.com/fmtlib/fmt/pull/2742,
-    https://github.com/fmtlib/fmt/issues/2744,
-    https://github.com/fmtlib/fmt/issues/2745,
-    https://github.com/fmtlib/fmt/issues/2746,
-    https://github.com/fmtlib/fmt/issues/2754,
-    https://github.com/fmtlib/fmt/pull/2755,
-    https://github.com/fmtlib/fmt/issues/2757,
-    https://github.com/fmtlib/fmt/pull/2758,
-    https://github.com/fmtlib/fmt/issues/2761,
-    https://github.com/fmtlib/fmt/pull/2762,
-    https://github.com/fmtlib/fmt/issues/2763,
-    https://github.com/fmtlib/fmt/pull/2765,
-    https://github.com/fmtlib/fmt/issues/2769,
-    https://github.com/fmtlib/fmt/pull/2770,
-    https://github.com/fmtlib/fmt/issues/2771,
-    https://github.com/fmtlib/fmt/issues/2777,
-    https://github.com/fmtlib/fmt/pull/2779,
-    https://github.com/fmtlib/fmt/pull/2782,
-    https://github.com/fmtlib/fmt/pull/2783,
-    https://github.com/fmtlib/fmt/issues/2794,
-    https://github.com/fmtlib/fmt/issues/2796,
-    https://github.com/fmtlib/fmt/pull/2797,
-    https://github.com/fmtlib/fmt/pull/2801,
-    https://github.com/fmtlib/fmt/pull/2802,
-    https://github.com/fmtlib/fmt/issues/2808,
-    https://github.com/fmtlib/fmt/issues/2818,
-    https://github.com/fmtlib/fmt/pull/2819,
-    https://github.com/fmtlib/fmt/issues/2829,
-    https://github.com/fmtlib/fmt/issues/2835,
-    https://github.com/fmtlib/fmt/issues/2848,
-    https://github.com/fmtlib/fmt/issues/2860,
-    https://github.com/fmtlib/fmt/pull/2861,
-    https://github.com/fmtlib/fmt/pull/2882,
-    https://github.com/fmtlib/fmt/issues/2886,
-    https://github.com/fmtlib/fmt/issues/2891,
-    https://github.com/fmtlib/fmt/pull/2892,
-    https://github.com/fmtlib/fmt/issues/2895,
-    https://github.com/fmtlib/fmt/issues/2896,
-    https://github.com/fmtlib/fmt/pull/2903,
-    https://github.com/fmtlib/fmt/issues/2906,
-    https://github.com/fmtlib/fmt/issues/2908,
-    https://github.com/fmtlib/fmt/pull/2909,
-    https://github.com/fmtlib/fmt/issues/2920,
-    https://github.com/fmtlib/fmt/pull/2922,
-    https://github.com/fmtlib/fmt/pull/2927,
-    https://github.com/fmtlib/fmt/pull/2929,
-    https://github.com/fmtlib/fmt/issues/2936,
-    https://github.com/fmtlib/fmt/pull/2937,
-    https://github.com/fmtlib/fmt/pull/2938,
-    https://github.com/fmtlib/fmt/pull/2951,
-    https://github.com/fmtlib/fmt/issues/2954,
-    https://github.com/fmtlib/fmt/pull/2957,
-    https://github.com/fmtlib/fmt/issues/2958,
-    https://github.com/fmtlib/fmt/pull/2960).
-    Thanks @matrackif @Tobi823, @ivan-volnov, @VasiliPupkin256,
-    @federico-busato, @barcharcraz, @jk-jeon, @HazardyKnusperkeks, @dalboris,
-    @seanm, @gsjaardema, @timsong-cpp, @seanm, @frithrah, @chronoxor, @Agga,
-    @madmaxoft, @JurajX, @phprus and @Dani-Hub.
+  int main() {
+    auto now = std::chrono::system_clock::now();
+    fmt::print(
+      "[{}] {}: {}\n",
+      fmt::styled(now, fmt::emphasis::bold),
+      fmt::styled("error", fg(fmt::color::red)),
+      "something went wrong");
+  }
+  ```
 
-# 8.1.1 - 2022-01-06
-
--   Restored ABI compatibility with version 8.0.x
-    (https://github.com/fmtlib/fmt/issues/2695,
-    https://github.com/fmtlib/fmt/pull/2696). Thanks @saraedum.
--   Fixed chrono formatting on big endian systems
-    (https://github.com/fmtlib/fmt/issues/2698,
-    https://github.com/fmtlib/fmt/pull/2699).
-    Thanks @phprus and @xvitaly.
--   Fixed a linkage error with mingw
-    (https://github.com/fmtlib/fmt/issues/2691,
-    https://github.com/fmtlib/fmt/pull/2692). Thanks @rbberger.
+  prints
 
-# 8.1.0 - 2022-01-02
+  ![](https://user-images.githubusercontent.com/576385/175071215-12809244-dab0-4005-96d8-7cd911c964d5.png)
 
--   Optimized chrono formatting
-    (https://github.com/fmtlib/fmt/pull/2500,
-    https://github.com/fmtlib/fmt/pull/2537,
-    https://github.com/fmtlib/fmt/issues/2541,
-    https://github.com/fmtlib/fmt/pull/2544,
-    https://github.com/fmtlib/fmt/pull/2550,
-    https://github.com/fmtlib/fmt/pull/2551,
-    https://github.com/fmtlib/fmt/pull/2576,
-    https://github.com/fmtlib/fmt/issues/2577,
-    https://github.com/fmtlib/fmt/pull/2586,
-    https://github.com/fmtlib/fmt/pull/2591,
-    https://github.com/fmtlib/fmt/pull/2594,
-    https://github.com/fmtlib/fmt/pull/2602,
-    https://github.com/fmtlib/fmt/pull/2617,
-    https://github.com/fmtlib/fmt/issues/2628,
-    https://github.com/fmtlib/fmt/pull/2633,
-    https://github.com/fmtlib/fmt/issues/2670,
-    https://github.com/fmtlib/fmt/pull/2671).
-
-    Processing of some specifiers such as `%z` and `%Y` is now up to
-    10-20 times faster, for example on GCC 11 with libstdc++:
-
-        ----------------------------------------------------------------------------
-        Benchmark                                  Before             After
-        ----------------------------------------------------------------------------
-        FMTFormatter_z                             261 ns             26.3 ns
-        FMTFormatterCompile_z                      246 ns             11.6 ns
-        FMTFormatter_Y                             263 ns             26.1 ns
-        FMTFormatterCompile_Y                      244 ns             10.5 ns
-        ----------------------------------------------------------------------------
-
-    Thanks @phprus and @toughengineer.
-
--   Implemented subsecond formatting for chrono durations
-    (https://github.com/fmtlib/fmt/pull/2623). For example
-    ([godbolt](https://godbolt.org/z/es7vWTETe)):
-
-    ```c++
-    #include <fmt/chrono.h>
-
-    int main() {
-      fmt::print("{:%S}", std::chrono::milliseconds(1234));
-    }
-    ```
+  Thanks @rbrugo.
 
-    prints \"01.234\".
+- Made `fmt::print` overload for text styles correctly handle UTF-8
+  (https://github.com/fmtlib/fmt/issues/2681,
+  https://github.com/fmtlib/fmt/pull/2701). Thanks @AlexGuteniev.
 
-    Thanks @matrackif.
+- Fixed Unicode handling when writing to an ostream.
 
--   Fixed handling of precision 0 when formatting chrono durations
-    (https://github.com/fmtlib/fmt/issues/2587,
-    https://github.com/fmtlib/fmt/pull/2588). Thanks @lukester1975.
+- Added support for nested specifiers to range formatting
+  (https://github.com/fmtlib/fmt/pull/2673). For example
+  ([godbolt](https://godbolt.org/z/xd3Gj38cf)):
 
--   Fixed an overflow on invalid inputs in the `tm` formatter
-    (https://github.com/fmtlib/fmt/pull/2564). Thanks @phprus.
+  ```c++
+  #include <vector>
+  #include <fmt/ranges.h>
 
--   Added `fmt::group_digits` that formats integers with a non-localized
-    digit separator (comma) for groups of three digits. For example
-    ([godbolt](https://godbolt.org/z/TxGxG9Poq)):
-
-    ```c++
-    #include <fmt/format.h>
-
-    int main() {
-      fmt::print("{} dollars", fmt::group_digits(1000000));
-    }
-    ```
+  int main() {
+    fmt::print("{::#x}\n", std::vector{10, 20, 30});
+  }
+  ```
 
-    prints \"1,000,000 dollars\".
+  prints `[0xa, 0x14, 0x1e]`.
 
--   Added support for faint, conceal, reverse and blink text styles
-    (https://github.com/fmtlib/fmt/pull/2394):
+  Thanks @BRevzin.
+
+- Implemented escaping of wide strings in ranges
+  (https://github.com/fmtlib/fmt/pull/2904). Thanks @phprus.
+
+- Added support for ranges with `begin` / `end` found via the
+  argument-dependent lookup
+  (https://github.com/fmtlib/fmt/pull/2807). Thanks @rbrugo.
+
+- Fixed formatting of certain kinds of ranges of ranges
+  (https://github.com/fmtlib/fmt/pull/2787). Thanks @BRevzin.
+
+- Fixed handling of maps with element types other than `std::pair`
+  (https://github.com/fmtlib/fmt/pull/2944). Thanks @BrukerJWD.
+
+- Made tuple formatter enabled only if elements are formattable
+  (https://github.com/fmtlib/fmt/issues/2939,
+  https://github.com/fmtlib/fmt/pull/2940). Thanks @jehelset.
+
+- Made `fmt::join` compatible with format string compilation
+  (https://github.com/fmtlib/fmt/issues/2719,
+  https://github.com/fmtlib/fmt/pull/2720). Thanks @phprus.
+
+- Made compile-time checks work with named arguments of custom types
+  and `std::ostream` `print` overloads
+  (https://github.com/fmtlib/fmt/issues/2816,
+  https://github.com/fmtlib/fmt/issues/2817,
+  https://github.com/fmtlib/fmt/pull/2819). Thanks @timsong-cpp.
+
+- Removed `make_args_checked` because it is no longer needed for
+  compile-time checks
+  (https://github.com/fmtlib/fmt/pull/2760). Thanks @phprus.
+
+- Removed the following deprecated APIs: `_format`, `arg_join`, the
+  `format_to` overload that takes a memory buffer, `[v]fprintf` that
+  takes an `ostream`.
+
+- Removed the deprecated implicit conversion of `[const] signed char*`
+  and `[const] unsigned char*` to C strings.
+
+- Removed the deprecated `fmt/locale.h`.
+
+- Replaced the deprecated `fileno()` with `descriptor()` in
+  `buffered_file`.
+
+- Moved `to_string_view` to the `detail` namespace since it\'s an
+  implementation detail.
+
+- Made access mode of a created file consistent with `fopen` by
+  setting `S_IWGRP` and `S_IWOTH`
+  (https://github.com/fmtlib/fmt/pull/2733). Thanks @arogge.
+
+- Removed a redundant buffer resize when formatting to `std::ostream`
+  (https://github.com/fmtlib/fmt/issues/2842,
+  https://github.com/fmtlib/fmt/pull/2843). Thanks @jcelerier.
+
+- Made precision computation for strings consistent with width
+  (https://github.com/fmtlib/fmt/issues/2888).
+
+- Fixed handling of locale separators in floating point formatting
+  (https://github.com/fmtlib/fmt/issues/2830).
+
+- Made sign specifiers work with `__int128_t`
+  (https://github.com/fmtlib/fmt/issues/2773).
+
+- Improved support for systems such as CHERI with extra data stored in
+  pointers (https://github.com/fmtlib/fmt/pull/2932).
+  Thanks @davidchisnall.
+
+- Improved documentation
+  (https://github.com/fmtlib/fmt/pull/2706,
+  https://github.com/fmtlib/fmt/pull/2712,
+  https://github.com/fmtlib/fmt/pull/2789,
+  https://github.com/fmtlib/fmt/pull/2803,
+  https://github.com/fmtlib/fmt/pull/2805,
+  https://github.com/fmtlib/fmt/pull/2815,
+  https://github.com/fmtlib/fmt/pull/2924).
+  Thanks @BRevzin, @Pokechu22, @setoye, @rtobar, @rbrugo, @anoonD and
+  @leha-bot.
+
+- Improved build configuration
+  (https://github.com/fmtlib/fmt/pull/2766,
+  https://github.com/fmtlib/fmt/pull/2772,
+  https://github.com/fmtlib/fmt/pull/2836,
+  https://github.com/fmtlib/fmt/pull/2852,
+  https://github.com/fmtlib/fmt/pull/2907,
+  https://github.com/fmtlib/fmt/pull/2913,
+  https://github.com/fmtlib/fmt/pull/2914).
+  Thanks @kambala-decapitator, @mattiasljungstrom, @kieselnb, @nathannaveen
+  and @Vertexwahn.
+
+- Fixed various warnings and compilation issues
+  (https://github.com/fmtlib/fmt/issues/2408,
+  https://github.com/fmtlib/fmt/issues/2507,
+  https://github.com/fmtlib/fmt/issues/2697,
+  https://github.com/fmtlib/fmt/issues/2715,
+  https://github.com/fmtlib/fmt/issues/2717,
+  https://github.com/fmtlib/fmt/pull/2722,
+  https://github.com/fmtlib/fmt/pull/2724,
+  https://github.com/fmtlib/fmt/pull/2725,
+  https://github.com/fmtlib/fmt/issues/2726,
+  https://github.com/fmtlib/fmt/pull/2728,
+  https://github.com/fmtlib/fmt/pull/2732,
+  https://github.com/fmtlib/fmt/issues/2738,
+  https://github.com/fmtlib/fmt/pull/2742,
+  https://github.com/fmtlib/fmt/issues/2744,
+  https://github.com/fmtlib/fmt/issues/2745,
+  https://github.com/fmtlib/fmt/issues/2746,
+  https://github.com/fmtlib/fmt/issues/2754,
+  https://github.com/fmtlib/fmt/pull/2755,
+  https://github.com/fmtlib/fmt/issues/2757,
+  https://github.com/fmtlib/fmt/pull/2758,
+  https://github.com/fmtlib/fmt/issues/2761,
+  https://github.com/fmtlib/fmt/pull/2762,
+  https://github.com/fmtlib/fmt/issues/2763,
+  https://github.com/fmtlib/fmt/pull/2765,
+  https://github.com/fmtlib/fmt/issues/2769,
+  https://github.com/fmtlib/fmt/pull/2770,
+  https://github.com/fmtlib/fmt/issues/2771,
+  https://github.com/fmtlib/fmt/issues/2777,
+  https://github.com/fmtlib/fmt/pull/2779,
+  https://github.com/fmtlib/fmt/pull/2782,
+  https://github.com/fmtlib/fmt/pull/2783,
+  https://github.com/fmtlib/fmt/issues/2794,
+  https://github.com/fmtlib/fmt/issues/2796,
+  https://github.com/fmtlib/fmt/pull/2797,
+  https://github.com/fmtlib/fmt/pull/2801,
+  https://github.com/fmtlib/fmt/pull/2802,
+  https://github.com/fmtlib/fmt/issues/2808,
+  https://github.com/fmtlib/fmt/issues/2818,
+  https://github.com/fmtlib/fmt/pull/2819,
+  https://github.com/fmtlib/fmt/issues/2829,
+  https://github.com/fmtlib/fmt/issues/2835,
+  https://github.com/fmtlib/fmt/issues/2848,
+  https://github.com/fmtlib/fmt/issues/2860,
+  https://github.com/fmtlib/fmt/pull/2861,
+  https://github.com/fmtlib/fmt/pull/2882,
+  https://github.com/fmtlib/fmt/issues/2886,
+  https://github.com/fmtlib/fmt/issues/2891,
+  https://github.com/fmtlib/fmt/pull/2892,
+  https://github.com/fmtlib/fmt/issues/2895,
+  https://github.com/fmtlib/fmt/issues/2896,
+  https://github.com/fmtlib/fmt/pull/2903,
+  https://github.com/fmtlib/fmt/issues/2906,
+  https://github.com/fmtlib/fmt/issues/2908,
+  https://github.com/fmtlib/fmt/pull/2909,
+  https://github.com/fmtlib/fmt/issues/2920,
+  https://github.com/fmtlib/fmt/pull/2922,
+  https://github.com/fmtlib/fmt/pull/2927,
+  https://github.com/fmtlib/fmt/pull/2929,
+  https://github.com/fmtlib/fmt/issues/2936,
+  https://github.com/fmtlib/fmt/pull/2937,
+  https://github.com/fmtlib/fmt/pull/2938,
+  https://github.com/fmtlib/fmt/pull/2951,
+  https://github.com/fmtlib/fmt/issues/2954,
+  https://github.com/fmtlib/fmt/pull/2957,
+  https://github.com/fmtlib/fmt/issues/2958,
+  https://github.com/fmtlib/fmt/pull/2960).
+  Thanks @matrackif @Tobi823, @ivan-volnov, @VasiliPupkin256,
+  @federico-busato, @barcharcraz, @jk-jeon, @HazardyKnusperkeks, @dalboris,
+  @seanm, @gsjaardema, @timsong-cpp, @seanm, @frithrah, @chronoxor, @Agga,
+  @madmaxoft, @JurajX, @phprus and @Dani-Hub.
 
-    <https://user-images.githubusercontent.com/576385/147710227-c68f5317-f8fa-42c3-9123-7c4ba3c398cb.mp4>
+# 8.1.1 - 2022-01-06
 
-    Thanks @benit8 and @data-man.
+- Restored ABI compatibility with version 8.0.x
+  (https://github.com/fmtlib/fmt/issues/2695,
+  https://github.com/fmtlib/fmt/pull/2696). Thanks @saraedum.
+- Fixed chrono formatting on big endian systems
+  (https://github.com/fmtlib/fmt/issues/2698,
+  https://github.com/fmtlib/fmt/pull/2699).
+  Thanks @phprus and @xvitaly.
+- Fixed a linkage error with mingw
+  (https://github.com/fmtlib/fmt/issues/2691,
+  https://github.com/fmtlib/fmt/pull/2692). Thanks @rbberger.
 
--   Added experimental support for compile-time floating point
-    formatting (https://github.com/fmtlib/fmt/pull/2426,
-    https://github.com/fmtlib/fmt/pull/2470). It is currently
-    limited to the header-only mode. Thanks @alexezeder.
+# 8.1.0 - 2022-01-02
 
--   Added UDL-based named argument support to compile-time format string
-    checks (https://github.com/fmtlib/fmt/issues/2640,
-    https://github.com/fmtlib/fmt/pull/2649). For example
-    ([godbolt](https://godbolt.org/z/ohGbbvonv)):
+- Optimized chrono formatting
+  (https://github.com/fmtlib/fmt/pull/2500,
+  https://github.com/fmtlib/fmt/pull/2537,
+  https://github.com/fmtlib/fmt/issues/2541,
+  https://github.com/fmtlib/fmt/pull/2544,
+  https://github.com/fmtlib/fmt/pull/2550,
+  https://github.com/fmtlib/fmt/pull/2551,
+  https://github.com/fmtlib/fmt/pull/2576,
+  https://github.com/fmtlib/fmt/issues/2577,
+  https://github.com/fmtlib/fmt/pull/2586,
+  https://github.com/fmtlib/fmt/pull/2591,
+  https://github.com/fmtlib/fmt/pull/2594,
+  https://github.com/fmtlib/fmt/pull/2602,
+  https://github.com/fmtlib/fmt/pull/2617,
+  https://github.com/fmtlib/fmt/issues/2628,
+  https://github.com/fmtlib/fmt/pull/2633,
+  https://github.com/fmtlib/fmt/issues/2670,
+  https://github.com/fmtlib/fmt/pull/2671).
+
+  Processing of some specifiers such as `%z` and `%Y` is now up to
+  10-20 times faster, for example on GCC 11 with libstdc++:
+
+      ----------------------------------------------------------------------------
+      Benchmark                                  Before             After
+      ----------------------------------------------------------------------------
+      FMTFormatter_z                             261 ns             26.3 ns
+      FMTFormatterCompile_z                      246 ns             11.6 ns
+      FMTFormatter_Y                             263 ns             26.1 ns
+      FMTFormatterCompile_Y                      244 ns             10.5 ns
+      ----------------------------------------------------------------------------
+
+  Thanks @phprus and @toughengineer.
+
+- Implemented subsecond formatting for chrono durations
+  (https://github.com/fmtlib/fmt/pull/2623). For example
+  ([godbolt](https://godbolt.org/z/es7vWTETe)):
+
+  ```c++
+  #include <fmt/chrono.h>
+
+  int main() {
+    fmt::print("{:%S}", std::chrono::milliseconds(1234));
+  }
+  ```
+
+  prints \"01.234\".
+
+  Thanks @matrackif.
+
+- Fixed handling of precision 0 when formatting chrono durations
+  (https://github.com/fmtlib/fmt/issues/2587,
+  https://github.com/fmtlib/fmt/pull/2588). Thanks @lukester1975.
+
+- Fixed an overflow on invalid inputs in the `tm` formatter
+  (https://github.com/fmtlib/fmt/pull/2564). Thanks @phprus.
+
+- Added `fmt::group_digits` that formats integers with a non-localized
+  digit separator (comma) for groups of three digits. For example
+  ([godbolt](https://godbolt.org/z/TxGxG9Poq)):
+
+  ```c++
+  #include <fmt/format.h>
+
+  int main() {
+    fmt::print("{} dollars", fmt::group_digits(1000000));
+  }
+  ```
+
+  prints \"1,000,000 dollars\".
+
+- Added support for faint, conceal, reverse and blink text styles
+  (https://github.com/fmtlib/fmt/pull/2394):
+
+  <https://user-images.githubusercontent.com/576385/147710227-c68f5317-f8fa-42c3-9123-7c4ba3c398cb.mp4>
+
+  Thanks @benit8 and @data-man.
+
+- Added experimental support for compile-time floating point
+  formatting (https://github.com/fmtlib/fmt/pull/2426,
+  https://github.com/fmtlib/fmt/pull/2470). It is currently
+  limited to the header-only mode. Thanks @alexezeder.
+
+- Added UDL-based named argument support to compile-time format string
+  checks (https://github.com/fmtlib/fmt/issues/2640,
+  https://github.com/fmtlib/fmt/pull/2649). For example
+  ([godbolt](https://godbolt.org/z/ohGbbvonv)):
+
+  ```c++
+  #include <fmt/format.h>
+
+  int main() {
+    using namespace fmt::literals;
+    fmt::print("{answer:s}", "answer"_a=42);
+  }
+  ```
 
-    ```c++
-    #include <fmt/format.h>
+  gives a compile-time error on compilers with C++20 `consteval` and
+  non-type template parameter support (gcc 10+) because `s` is not a
+  valid format specifier for an integer.
 
-    int main() {
-      using namespace fmt::literals;
-      fmt::print("{answer:s}", "answer"_a=42);
-    }
-    ```
+  Thanks @alexezeder.
 
-    gives a compile-time error on compilers with C++20 `consteval` and
-    non-type template parameter support (gcc 10+) because `s` is not a
-    valid format specifier for an integer.
+- Implemented escaping of string range elements. For example
+  ([godbolt](https://godbolt.org/z/rKvM1vKf3)):
 
-    Thanks @alexezeder.
+  ```c++
+  #include <fmt/ranges.h>
+  #include <vector>
 
--   Implemented escaping of string range elements. For example
-    ([godbolt](https://godbolt.org/z/rKvM1vKf3)):
+  int main() {
+    fmt::print("{}", std::vector<std::string>{"\naan"});
+  }
+  ```
 
-    ```c++
-    #include <fmt/ranges.h>
-    #include <vector>
+  is now printed as:
 
-    int main() {
-      fmt::print("{}", std::vector<std::string>{"\naan"});
-    }
-    ```
+      ["\naan"]
 
-    is now printed as:
+  instead of:
 
-        ["\naan"]
+      ["
+      aan"]
 
-    instead of:
+- Added an experimental `?` specifier for escaping strings.
+  (https://github.com/fmtlib/fmt/pull/2674). Thanks @BRevzin.
 
-        ["
-        aan"]
+- Switched to JSON-like representation of maps and sets for
+  consistency with Python\'s `str.format`. For example
+  ([godbolt](https://godbolt.org/z/seKjoY9W5)):
 
--   Added an experimental `?` specifier for escaping strings.
-    (https://github.com/fmtlib/fmt/pull/2674). Thanks @BRevzin.
+  ```c++
+  #include <fmt/ranges.h>
+  #include <map>
 
--   Switched to JSON-like representation of maps and sets for
-    consistency with Python\'s `str.format`. For example
-    ([godbolt](https://godbolt.org/z/seKjoY9W5)):
+  int main() {
+    fmt::print("{}", std::map<std::string, int>{{"answer", 42}});
+  }
+  ```
 
-    ```c++
-    #include <fmt/ranges.h>
-    #include <map>
+  is now printed as:
 
-    int main() {
-      fmt::print("{}", std::map<std::string, int>{{"answer", 42}});
-    }
-    ```
+      {"answer": 42}
 
-    is now printed as:
+- Extended `fmt::join` to support C++20-only ranges
+  (https://github.com/fmtlib/fmt/pull/2549). Thanks @BRevzin.
 
-        {"answer": 42}
+- Optimized handling of non-const-iterable ranges and implemented
+  initial support for non-const-formattable types.
 
--   Extended `fmt::join` to support C++20-only ranges
-    (https://github.com/fmtlib/fmt/pull/2549). Thanks @BRevzin.
+- Disabled implicit conversions of scoped enums to integers that was
+  accidentally introduced in earlier versions
+  (https://github.com/fmtlib/fmt/pull/1841).
 
--   Optimized handling of non-const-iterable ranges and implemented
-    initial support for non-const-formattable types.
+- Deprecated implicit conversion of `[const] signed char*` and
+  `[const] unsigned char*` to C strings.
 
--   Disabled implicit conversions of scoped enums to integers that was
-    accidentally introduced in earlier versions
-    (https://github.com/fmtlib/fmt/pull/1841).
+- Deprecated `_format`, a legacy UDL-based format API
+  (https://github.com/fmtlib/fmt/pull/2646). Thanks @alexezeder.
 
--   Deprecated implicit conversion of `[const] signed char*` and
-    `[const] unsigned char*` to C strings.
+- Marked `format`, `formatted_size` and `to_string` as `[[nodiscard]]`
+  (https://github.com/fmtlib/fmt/pull/2612). @0x8000-0000.
 
--   Deprecated `_format`, a legacy UDL-based format API
-    (https://github.com/fmtlib/fmt/pull/2646). Thanks @alexezeder.
-
--   Marked `format`, `formatted_size` and `to_string` as `[[nodiscard]]`
-    (https://github.com/fmtlib/fmt/pull/2612). @0x8000-0000.
-
--   Added missing diagnostic when trying to format function and member
-    pointers as well as objects convertible to pointers which is
-    explicitly disallowed
-    (https://github.com/fmtlib/fmt/issues/2598,
-    https://github.com/fmtlib/fmt/pull/2609,
-    https://github.com/fmtlib/fmt/pull/2610). Thanks @AlexGuteniev.
-
--   Optimized writing to a contiguous buffer with `format_to_n`
-    (https://github.com/fmtlib/fmt/pull/2489). Thanks @Roman-Koshelev.
-
--   Optimized writing to non-`char` buffers
-    (https://github.com/fmtlib/fmt/pull/2477). Thanks @Roman-Koshelev.
-
--   Decimal point is now localized when using the `L` specifier.
-
--   Improved floating point formatter implementation
-    (https://github.com/fmtlib/fmt/pull/2498,
-    https://github.com/fmtlib/fmt/pull/2499). Thanks @Roman-Koshelev.
-
--   Fixed handling of very large precision in fixed format
-    (https://github.com/fmtlib/fmt/pull/2616).
-
--   Made a table of cached powers used in FP formatting static
-    (https://github.com/fmtlib/fmt/pull/2509). Thanks @jk-jeon.
-
--   Resolved a lookup ambiguity with C++20 format-related functions due
-    to ADL (https://github.com/fmtlib/fmt/issues/2639,
-    https://github.com/fmtlib/fmt/pull/2641). Thanks @mkurdej.
-
--   Removed unnecessary inline namespace qualification
-    (https://github.com/fmtlib/fmt/issues/2642,
-    https://github.com/fmtlib/fmt/pull/2643). Thanks @mkurdej.
-
--   Implemented argument forwarding in `format_to_n`
-    (https://github.com/fmtlib/fmt/issues/2462,
-    https://github.com/fmtlib/fmt/pull/2463). Thanks @owent.
-
--   Fixed handling of implicit conversions in `fmt::to_string` and
-    format string compilation
-    (https://github.com/fmtlib/fmt/issues/2565).
-
--   Changed the default access mode of files created by
-    `fmt::output_file` to `-rw-r--r--` for consistency with `fopen`
-    (https://github.com/fmtlib/fmt/issues/2530).
-
--   Make `fmt::ostream::flush` public
-    (https://github.com/fmtlib/fmt/issues/2435).
-
--   Improved C++14/17 attribute detection
-    (https://github.com/fmtlib/fmt/pull/2615). Thanks @AlexGuteniev.
-
--   Improved `consteval` detection for MSVC
-    (https://github.com/fmtlib/fmt/pull/2559). Thanks @DanielaE.
-
--   Improved documentation
-    (https://github.com/fmtlib/fmt/issues/2406,
-    https://github.com/fmtlib/fmt/pull/2446,
-    https://github.com/fmtlib/fmt/issues/2493,
-    https://github.com/fmtlib/fmt/issues/2513,
-    https://github.com/fmtlib/fmt/pull/2515,
-    https://github.com/fmtlib/fmt/issues/2522,
-    https://github.com/fmtlib/fmt/pull/2562,
-    https://github.com/fmtlib/fmt/pull/2575,
-    https://github.com/fmtlib/fmt/pull/2606,
-    https://github.com/fmtlib/fmt/pull/2620,
-    https://github.com/fmtlib/fmt/issues/2676).
-    Thanks @sobolevn, @UnePierre, @zhsj, @phprus, @ericcurtin and @Lounarok.
-
--   Improved fuzzers and added a fuzzer for chrono timepoint formatting
-    (https://github.com/fmtlib/fmt/pull/2461,
-    https://github.com/fmtlib/fmt/pull/2469). @pauldreik,
-
--   Added the `FMT_SYSTEM_HEADERS` CMake option setting which marks
-    {fmt}\'s headers as system. It can be used to suppress warnings
-    (https://github.com/fmtlib/fmt/issues/2644,
-    https://github.com/fmtlib/fmt/pull/2651). Thanks @alexezeder.
-
--   Added the Bazel build system support
-    (https://github.com/fmtlib/fmt/pull/2505,
-    https://github.com/fmtlib/fmt/pull/2516). Thanks @Vertexwahn.
-
--   Improved build configuration and tests
-    (https://github.com/fmtlib/fmt/issues/2437,
-    https://github.com/fmtlib/fmt/pull/2558,
-    https://github.com/fmtlib/fmt/pull/2648,
-    https://github.com/fmtlib/fmt/pull/2650,
-    https://github.com/fmtlib/fmt/pull/2663,
-    https://github.com/fmtlib/fmt/pull/2677).
-    Thanks @DanielaE, @alexezeder and @phprus.
-
--   Fixed various warnings and compilation issues
-    (https://github.com/fmtlib/fmt/pull/2353,
-    https://github.com/fmtlib/fmt/pull/2356,
-    https://github.com/fmtlib/fmt/pull/2399,
-    https://github.com/fmtlib/fmt/issues/2408,
-    https://github.com/fmtlib/fmt/pull/2414,
-    https://github.com/fmtlib/fmt/pull/2427,
-    https://github.com/fmtlib/fmt/pull/2432,
-    https://github.com/fmtlib/fmt/pull/2442,
-    https://github.com/fmtlib/fmt/pull/2434,
-    https://github.com/fmtlib/fmt/issues/2439,
-    https://github.com/fmtlib/fmt/pull/2447,
-    https://github.com/fmtlib/fmt/pull/2450,
-    https://github.com/fmtlib/fmt/issues/2455,
-    https://github.com/fmtlib/fmt/issues/2465,
-    https://github.com/fmtlib/fmt/issues/2472,
-    https://github.com/fmtlib/fmt/issues/2474,
-    https://github.com/fmtlib/fmt/pull/2476,
-    https://github.com/fmtlib/fmt/issues/2478,
-    https://github.com/fmtlib/fmt/issues/2479,
-    https://github.com/fmtlib/fmt/issues/2481,
-    https://github.com/fmtlib/fmt/pull/2482,
-    https://github.com/fmtlib/fmt/pull/2483,
-    https://github.com/fmtlib/fmt/issues/2490,
-    https://github.com/fmtlib/fmt/pull/2491,
-    https://github.com/fmtlib/fmt/pull/2510,
-    https://github.com/fmtlib/fmt/pull/2518,
-    https://github.com/fmtlib/fmt/issues/2528,
-    https://github.com/fmtlib/fmt/pull/2529,
-    https://github.com/fmtlib/fmt/pull/2539,
-    https://github.com/fmtlib/fmt/issues/2540,
-    https://github.com/fmtlib/fmt/pull/2545,
-    https://github.com/fmtlib/fmt/pull/2555,
-    https://github.com/fmtlib/fmt/issues/2557,
-    https://github.com/fmtlib/fmt/issues/2570,
-    https://github.com/fmtlib/fmt/pull/2573,
-    https://github.com/fmtlib/fmt/pull/2582,
-    https://github.com/fmtlib/fmt/issues/2605,
-    https://github.com/fmtlib/fmt/pull/2611,
-    https://github.com/fmtlib/fmt/pull/2647,
-    https://github.com/fmtlib/fmt/issues/2627,
-    https://github.com/fmtlib/fmt/pull/2630,
-    https://github.com/fmtlib/fmt/issues/2635,
-    https://github.com/fmtlib/fmt/issues/2638,
-    https://github.com/fmtlib/fmt/issues/2653,
-    https://github.com/fmtlib/fmt/issues/2654,
-    https://github.com/fmtlib/fmt/issues/2661,
-    https://github.com/fmtlib/fmt/pull/2664,
-    https://github.com/fmtlib/fmt/pull/2684).
-    Thanks @DanielaE, @mwinterb, @cdacamar, @TrebledJ, @bodomartin, @cquammen,
-    @white238, @mmarkeloff, @palacaze, @jcelerier, @mborn-adi, @BrukerJWD,
-    @spyridon97, @phprus, @oliverlee, @joshessman-llnl, @akohlmey, @timkalu,
-    @olupton, @Acretock, @alexezeder, @andrewcorrigan, @lucpelletier and
-    @HazardyKnusperkeks.
+- Added missing diagnostic when trying to format function and member
+  pointers as well as objects convertible to pointers which is
+  explicitly disallowed
+  (https://github.com/fmtlib/fmt/issues/2598,
+  https://github.com/fmtlib/fmt/pull/2609,
+  https://github.com/fmtlib/fmt/pull/2610). Thanks @AlexGuteniev.
+
+- Optimized writing to a contiguous buffer with `format_to_n`
+  (https://github.com/fmtlib/fmt/pull/2489). Thanks @Roman-Koshelev.
+
+- Optimized writing to non-`char` buffers
+  (https://github.com/fmtlib/fmt/pull/2477). Thanks @Roman-Koshelev.
+
+- Decimal point is now localized when using the `L` specifier.
+
+- Improved floating point formatter implementation
+  (https://github.com/fmtlib/fmt/pull/2498,
+  https://github.com/fmtlib/fmt/pull/2499). Thanks @Roman-Koshelev.
+
+- Fixed handling of very large precision in fixed format
+  (https://github.com/fmtlib/fmt/pull/2616).
+
+- Made a table of cached powers used in FP formatting static
+  (https://github.com/fmtlib/fmt/pull/2509). Thanks @jk-jeon.
+
+- Resolved a lookup ambiguity with C++20 format-related functions due
+  to ADL (https://github.com/fmtlib/fmt/issues/2639,
+  https://github.com/fmtlib/fmt/pull/2641). Thanks @mkurdej.
+
+- Removed unnecessary inline namespace qualification
+  (https://github.com/fmtlib/fmt/issues/2642,
+  https://github.com/fmtlib/fmt/pull/2643). Thanks @mkurdej.
+
+- Implemented argument forwarding in `format_to_n`
+  (https://github.com/fmtlib/fmt/issues/2462,
+  https://github.com/fmtlib/fmt/pull/2463). Thanks @owent.
+
+- Fixed handling of implicit conversions in `fmt::to_string` and
+  format string compilation
+  (https://github.com/fmtlib/fmt/issues/2565).
+
+- Changed the default access mode of files created by
+  `fmt::output_file` to `-rw-r--r--` for consistency with `fopen`
+  (https://github.com/fmtlib/fmt/issues/2530).
+
+- Make `fmt::ostream::flush` public
+  (https://github.com/fmtlib/fmt/issues/2435).
+
+- Improved C++14/17 attribute detection
+  (https://github.com/fmtlib/fmt/pull/2615). Thanks @AlexGuteniev.
+
+- Improved `consteval` detection for MSVC
+  (https://github.com/fmtlib/fmt/pull/2559). Thanks @DanielaE.
+
+- Improved documentation
+  (https://github.com/fmtlib/fmt/issues/2406,
+  https://github.com/fmtlib/fmt/pull/2446,
+  https://github.com/fmtlib/fmt/issues/2493,
+  https://github.com/fmtlib/fmt/issues/2513,
+  https://github.com/fmtlib/fmt/pull/2515,
+  https://github.com/fmtlib/fmt/issues/2522,
+  https://github.com/fmtlib/fmt/pull/2562,
+  https://github.com/fmtlib/fmt/pull/2575,
+  https://github.com/fmtlib/fmt/pull/2606,
+  https://github.com/fmtlib/fmt/pull/2620,
+  https://github.com/fmtlib/fmt/issues/2676).
+  Thanks @sobolevn, @UnePierre, @zhsj, @phprus, @ericcurtin and @Lounarok.
+
+- Improved fuzzers and added a fuzzer for chrono timepoint formatting
+  (https://github.com/fmtlib/fmt/pull/2461,
+  https://github.com/fmtlib/fmt/pull/2469). @pauldreik,
+
+- Added the `FMT_SYSTEM_HEADERS` CMake option setting which marks
+  {fmt}\'s headers as system. It can be used to suppress warnings
+  (https://github.com/fmtlib/fmt/issues/2644,
+  https://github.com/fmtlib/fmt/pull/2651). Thanks @alexezeder.
+
+- Added the Bazel build system support
+  (https://github.com/fmtlib/fmt/pull/2505,
+  https://github.com/fmtlib/fmt/pull/2516). Thanks @Vertexwahn.
+
+- Improved build configuration and tests
+  (https://github.com/fmtlib/fmt/issues/2437,
+  https://github.com/fmtlib/fmt/pull/2558,
+  https://github.com/fmtlib/fmt/pull/2648,
+  https://github.com/fmtlib/fmt/pull/2650,
+  https://github.com/fmtlib/fmt/pull/2663,
+  https://github.com/fmtlib/fmt/pull/2677).
+  Thanks @DanielaE, @alexezeder and @phprus.
+
+- Fixed various warnings and compilation issues
+  (https://github.com/fmtlib/fmt/pull/2353,
+  https://github.com/fmtlib/fmt/pull/2356,
+  https://github.com/fmtlib/fmt/pull/2399,
+  https://github.com/fmtlib/fmt/issues/2408,
+  https://github.com/fmtlib/fmt/pull/2414,
+  https://github.com/fmtlib/fmt/pull/2427,
+  https://github.com/fmtlib/fmt/pull/2432,
+  https://github.com/fmtlib/fmt/pull/2442,
+  https://github.com/fmtlib/fmt/pull/2434,
+  https://github.com/fmtlib/fmt/issues/2439,
+  https://github.com/fmtlib/fmt/pull/2447,
+  https://github.com/fmtlib/fmt/pull/2450,
+  https://github.com/fmtlib/fmt/issues/2455,
+  https://github.com/fmtlib/fmt/issues/2465,
+  https://github.com/fmtlib/fmt/issues/2472,
+  https://github.com/fmtlib/fmt/issues/2474,
+  https://github.com/fmtlib/fmt/pull/2476,
+  https://github.com/fmtlib/fmt/issues/2478,
+  https://github.com/fmtlib/fmt/issues/2479,
+  https://github.com/fmtlib/fmt/issues/2481,
+  https://github.com/fmtlib/fmt/pull/2482,
+  https://github.com/fmtlib/fmt/pull/2483,
+  https://github.com/fmtlib/fmt/issues/2490,
+  https://github.com/fmtlib/fmt/pull/2491,
+  https://github.com/fmtlib/fmt/pull/2510,
+  https://github.com/fmtlib/fmt/pull/2518,
+  https://github.com/fmtlib/fmt/issues/2528,
+  https://github.com/fmtlib/fmt/pull/2529,
+  https://github.com/fmtlib/fmt/pull/2539,
+  https://github.com/fmtlib/fmt/issues/2540,
+  https://github.com/fmtlib/fmt/pull/2545,
+  https://github.com/fmtlib/fmt/pull/2555,
+  https://github.com/fmtlib/fmt/issues/2557,
+  https://github.com/fmtlib/fmt/issues/2570,
+  https://github.com/fmtlib/fmt/pull/2573,
+  https://github.com/fmtlib/fmt/pull/2582,
+  https://github.com/fmtlib/fmt/issues/2605,
+  https://github.com/fmtlib/fmt/pull/2611,
+  https://github.com/fmtlib/fmt/pull/2647,
+  https://github.com/fmtlib/fmt/issues/2627,
+  https://github.com/fmtlib/fmt/pull/2630,
+  https://github.com/fmtlib/fmt/issues/2635,
+  https://github.com/fmtlib/fmt/issues/2638,
+  https://github.com/fmtlib/fmt/issues/2653,
+  https://github.com/fmtlib/fmt/issues/2654,
+  https://github.com/fmtlib/fmt/issues/2661,
+  https://github.com/fmtlib/fmt/pull/2664,
+  https://github.com/fmtlib/fmt/pull/2684).
+  Thanks @DanielaE, @mwinterb, @cdacamar, @TrebledJ, @bodomartin, @cquammen,
+  @white238, @mmarkeloff, @palacaze, @jcelerier, @mborn-adi, @BrukerJWD,
+  @spyridon97, @phprus, @oliverlee, @joshessman-llnl, @akohlmey, @timkalu,
+  @olupton, @Acretock, @alexezeder, @andrewcorrigan, @lucpelletier and
+  @HazardyKnusperkeks.
 
 # 8.0.1 - 2021-07-02
 
--   Fixed the version number in the inline namespace
-    (https://github.com/fmtlib/fmt/issues/2374).
--   Added a missing presentation type check for `std::string`
-    (https://github.com/fmtlib/fmt/issues/2402).
--   Fixed a linkage error when mixing code built with clang and gcc
-    (https://github.com/fmtlib/fmt/issues/2377).
--   Fixed documentation issues
-    (https://github.com/fmtlib/fmt/pull/2396,
-    https://github.com/fmtlib/fmt/issues/2403,
-    https://github.com/fmtlib/fmt/issues/2406). Thanks @mkurdej.
--   Removed dead code in FP formatter (
-    https://github.com/fmtlib/fmt/pull/2398). Thanks @javierhonduco.
--   Fixed various warnings and compilation issues
-    (https://github.com/fmtlib/fmt/issues/2351,
-    https://github.com/fmtlib/fmt/issues/2359,
-    https://github.com/fmtlib/fmt/pull/2365,
-    https://github.com/fmtlib/fmt/issues/2368,
-    https://github.com/fmtlib/fmt/pull/2370,
-    https://github.com/fmtlib/fmt/pull/2376,
-    https://github.com/fmtlib/fmt/pull/2381,
-    https://github.com/fmtlib/fmt/pull/2382,
-    https://github.com/fmtlib/fmt/issues/2386,
-    https://github.com/fmtlib/fmt/pull/2389,
-    https://github.com/fmtlib/fmt/pull/2395,
-    https://github.com/fmtlib/fmt/pull/2397,
-    https://github.com/fmtlib/fmt/issues/2400,
-    https://github.com/fmtlib/fmt/issues/2401,
-    https://github.com/fmtlib/fmt/pull/2407).
-    Thanks @zx2c4, @AidanSun05, @mattiasljungstrom, @joemmett, @erengy,
-    @patlkli, @gsjaardema and @phprus.
+- Fixed the version number in the inline namespace
+  (https://github.com/fmtlib/fmt/issues/2374).
+- Added a missing presentation type check for `std::string`
+  (https://github.com/fmtlib/fmt/issues/2402).
+- Fixed a linkage error when mixing code built with clang and gcc
+  (https://github.com/fmtlib/fmt/issues/2377).
+- Fixed documentation issues
+  (https://github.com/fmtlib/fmt/pull/2396,
+  https://github.com/fmtlib/fmt/issues/2403,
+  https://github.com/fmtlib/fmt/issues/2406). Thanks @mkurdej.
+- Removed dead code in FP formatter (
+  https://github.com/fmtlib/fmt/pull/2398). Thanks @javierhonduco.
+- Fixed various warnings and compilation issues
+  (https://github.com/fmtlib/fmt/issues/2351,
+  https://github.com/fmtlib/fmt/issues/2359,
+  https://github.com/fmtlib/fmt/pull/2365,
+  https://github.com/fmtlib/fmt/issues/2368,
+  https://github.com/fmtlib/fmt/pull/2370,
+  https://github.com/fmtlib/fmt/pull/2376,
+  https://github.com/fmtlib/fmt/pull/2381,
+  https://github.com/fmtlib/fmt/pull/2382,
+  https://github.com/fmtlib/fmt/issues/2386,
+  https://github.com/fmtlib/fmt/pull/2389,
+  https://github.com/fmtlib/fmt/pull/2395,
+  https://github.com/fmtlib/fmt/pull/2397,
+  https://github.com/fmtlib/fmt/issues/2400,
+  https://github.com/fmtlib/fmt/issues/2401,
+  https://github.com/fmtlib/fmt/pull/2407).
+  Thanks @zx2c4, @AidanSun05, @mattiasljungstrom, @joemmett, @erengy,
+  @patlkli, @gsjaardema and @phprus.
 
 # 8.0.0 - 2021-06-21
 
--   Enabled compile-time format string checks by default. For example
-    ([godbolt](https://godbolt.org/z/sMxcohGjz)):
-
-    ```c++
-    #include <fmt/core.h>
-
-    int main() {
-      fmt::print("{:d}", "I am not a number");
-    }
-    ```
-
-    gives a compile-time error on compilers with C++20 `consteval`
-    support (gcc 10+, clang 11+) because `d` is not a valid format
-    specifier for a string.
-
-    To pass a runtime string wrap it in `fmt::runtime`:
-
-    ```c++
-    fmt::print(fmt::runtime("{:d}"), "I am not a number");
-    ```
-
--   Added compile-time formatting
-    (https://github.com/fmtlib/fmt/pull/2019,
-    https://github.com/fmtlib/fmt/pull/2044,
-    https://github.com/fmtlib/fmt/pull/2056,
-    https://github.com/fmtlib/fmt/pull/2072,
-    https://github.com/fmtlib/fmt/pull/2075,
-    https://github.com/fmtlib/fmt/issues/2078,
-    https://github.com/fmtlib/fmt/pull/2129,
-    https://github.com/fmtlib/fmt/pull/2326). For example
-    ([godbolt](https://godbolt.org/z/Mxx9d89jM)):
-
-    ```c++
-    #include <fmt/compile.h>
-
-    consteval auto compile_time_itoa(int value) -> std::array<char, 10> {
-      auto result = std::array<char, 10>();
-      fmt::format_to(result.data(), FMT_COMPILE("{}"), value);
-      return result;
-    }
-
-    constexpr auto answer = compile_time_itoa(42);
-    ```
-
-    Most of the formatting functionality is available at compile time
-    with a notable exception of floating-point numbers and pointers.
-    Thanks @alexezeder.
-
--   Optimized handling of format specifiers during format string
-    compilation. For example, hexadecimal formatting (`"{:x}"`) is now
-    3-7x faster than before when using `format_to` with format string
-    compilation and a stack-allocated buffer
-    (https://github.com/fmtlib/fmt/issues/1944).
-
-    Before (7.1.3):
-
-        ----------------------------------------------------------------------------
-        Benchmark                                  Time             CPU   Iterations
-        ----------------------------------------------------------------------------
-        FMTCompileOld/0                         15.5 ns         15.5 ns     43302898
-        FMTCompileOld/42                        16.6 ns         16.6 ns     43278267
-        FMTCompileOld/273123                    18.7 ns         18.6 ns     37035861
-        FMTCompileOld/9223372036854775807       19.4 ns         19.4 ns     35243000
-        ----------------------------------------------------------------------------
-
-    After (8.x):
-
-        ----------------------------------------------------------------------------
-        Benchmark                                  Time             CPU   Iterations
-        ----------------------------------------------------------------------------
-        FMTCompileNew/0                         1.99 ns         1.99 ns    360523686
-        FMTCompileNew/42                        2.33 ns         2.33 ns    279865664
-        FMTCompileNew/273123                    3.72 ns         3.71 ns    190230315
-        FMTCompileNew/9223372036854775807       5.28 ns         5.26 ns    130711631
-        ----------------------------------------------------------------------------
-
-    It is even faster than `std::to_chars` from libc++ compiled with
-    clang on macOS:
-
-        ----------------------------------------------------------------------------
-        Benchmark                                  Time             CPU   Iterations
-        ----------------------------------------------------------------------------
-        ToChars/0                               4.42 ns         4.41 ns    160196630
-        ToChars/42                              5.00 ns         4.98 ns    140735201
-        ToChars/273123                          7.26 ns         7.24 ns     95784130
-        ToChars/9223372036854775807             8.77 ns         8.75 ns     75872534
-        ----------------------------------------------------------------------------
-
-    In other cases, especially involving `std::string` construction, the
-    speed up is usually lower because handling format specifiers takes a
-    smaller fraction of the total time.
-
--   Added the `_cf` user-defined literal to represent a compiled format
-    string. It can be used instead of the `FMT_COMPILE` macro
-    (https://github.com/fmtlib/fmt/pull/2043,
-    https://github.com/fmtlib/fmt/pull/2242):
-
-    ```c++
-    #include <fmt/compile.h>
-
-    using namespace fmt::literals;
-    auto s = fmt::format(FMT_COMPILE("{}"), 42); // ð not modern
-    auto s = fmt::format("{}"_cf, 42);           // ð modern as hell
-    ```
-
-    It requires compiler support for class types in non-type template
-    parameters (a C++20 feature) which is available in GCC 9.3+.
-    Thanks @alexezeder.
-
--   Format string compilation now requires `format` functions of
-    `formatter` specializations for user-defined types to be `const`:
-
-    ```c++
-    template <> struct fmt::formatter<my_type>: formatter<string_view> {
-      template <typename FormatContext>
-      auto format(my_type obj, FormatContext& ctx) const {  // Note const here.
-        // ...
-      }
-    };
-    ```
-
--   Added UDL-based named argument support to format string compilation
-    (https://github.com/fmtlib/fmt/pull/2243,
-    https://github.com/fmtlib/fmt/pull/2281). For example:
-
-    ```c++
-    #include <fmt/compile.h>
-
-    using namespace fmt::literals;
-    auto s = fmt::format(FMT_COMPILE("{answer}"), "answer"_a = 42);
-    ```
-
-    Here the argument named \"answer\" is resolved at compile time with
-    no runtime overhead. Thanks @alexezeder.
-
--   Added format string compilation support to `fmt::print`
-    (https://github.com/fmtlib/fmt/issues/2280,
-    https://github.com/fmtlib/fmt/pull/2304). Thanks @alexezeder.
-
--   Added initial support for compiling {fmt} as a C++20 module
-    (https://github.com/fmtlib/fmt/pull/2235,
-    https://github.com/fmtlib/fmt/pull/2240,
-    https://github.com/fmtlib/fmt/pull/2260,
-    https://github.com/fmtlib/fmt/pull/2282,
-    https://github.com/fmtlib/fmt/pull/2283,
-    https://github.com/fmtlib/fmt/pull/2288,
-    https://github.com/fmtlib/fmt/pull/2298,
-    https://github.com/fmtlib/fmt/pull/2306,
-    https://github.com/fmtlib/fmt/pull/2307,
-    https://github.com/fmtlib/fmt/pull/2309,
-    https://github.com/fmtlib/fmt/pull/2318,
-    https://github.com/fmtlib/fmt/pull/2324,
-    https://github.com/fmtlib/fmt/pull/2332,
-    https://github.com/fmtlib/fmt/pull/2340). Thanks @DanielaE.
-
--   Made symbols private by default reducing shared library size
-    (https://github.com/fmtlib/fmt/pull/2301). For example
-    there was a \~15% reported reduction on one platform. Thanks @sergiud.
-
--   Optimized includes making the result of preprocessing `fmt/format.h`
-    \~20% smaller with libstdc++/C++20 and slightly improving build
-    times (https://github.com/fmtlib/fmt/issues/1998).
-
--   Added support of ranges with non-const `begin` / `end`
-    (https://github.com/fmtlib/fmt/pull/1953). Thanks @kitegi.
-
--   Added support of `std::byte` and other formattable types to
-    `fmt::join` (https://github.com/fmtlib/fmt/issues/1981,
-    https://github.com/fmtlib/fmt/issues/2040,
-    https://github.com/fmtlib/fmt/pull/2050,
-    https://github.com/fmtlib/fmt/issues/2262). For example:
-
-    ```c++
-    #include <fmt/format.h>
-    #include <cstddef>
-    #include <vector>
-
-    int main() {
-      auto bytes = std::vector{std::byte(4), std::byte(2)};
-      fmt::print("{}", fmt::join(bytes, ""));
-    }
-    ```
-
-    prints \"42\".
-
-    Thanks @kamibo.
-
--   Implemented the default format for `std::chrono::system_clock`
-    (https://github.com/fmtlib/fmt/issues/2319,
-    https://github.com/fmtlib/fmt/pull/2345). For example:
-
-    ```c++
-    #include <fmt/chrono.h>
-
-    int main() {
-      fmt::print("{}", std::chrono::system_clock::now());
-    }
-    ```
-
-    prints \"2021-06-18 15:22:00\" (the output depends on the current
-    date and time). Thanks @sunmy2019.
-
--   Made more chrono specifiers locale independent by default. Use the
-    `'L'` specifier to get localized formatting. For example:
-
-    ```c++
-    #include <fmt/chrono.h>
-
-    int main() {
-      std::locale::global(std::locale("ru_RU.UTF-8"));
-      auto monday = std::chrono::weekday(1);
-      fmt::print("{}\n", monday);   // prints "Mon"
-      fmt::print("{:L}\n", monday); // prints "Ð¿Ð½"
-    }
-    ```
-
--   Improved locale handling in chrono formatting
-    (https://github.com/fmtlib/fmt/issues/2337,
-    https://github.com/fmtlib/fmt/pull/2349,
-    https://github.com/fmtlib/fmt/pull/2350). Thanks @phprus.
-
--   Deprecated `fmt/locale.h` moving the formatting functions that take
-    a locale to `fmt/format.h` (`char`) and `fmt/xchar` (other
-    overloads). This doesn\'t introduce a dependency on `<locale>` so
-    there is virtually no compile time effect.
-
--   Deprecated an undocumented `format_to` overload that takes
-    `basic_memory_buffer`.
-
--   Made parameter order in `vformat_to` consistent with `format_to`
-    (https://github.com/fmtlib/fmt/issues/2327).
-
--   Added support for time points with arbitrary durations
-    (https://github.com/fmtlib/fmt/issues/2208). For example:
-
-    ```c++
-    #include <fmt/chrono.h>
-
-    int main() {
-      using tp = std::chrono::time_point<
-        std::chrono::system_clock, std::chrono::seconds>;
-      fmt::print("{:%S}", tp(std::chrono::seconds(42)));
-    }
-    ```
-
-    prints \"42\".
-
--   Formatting floating-point numbers no longer produces trailing zeros
-    by default for consistency with `std::format`. For example:
-
-    ```c++
-    #include <fmt/core.h>
-
-    int main() {
-      fmt::print("{0:.3}", 1.1);
-    }
-    ```
-
-    prints \"1.1\". Use the `'#'` specifier to keep trailing zeros.
-
--   Dropped a limit on the number of elements in a range and replaced
-    `{}` with `[]` as range delimiters for consistency with Python\'s
-    `str.format`.
-
--   The `'L'` specifier for locale-specific numeric formatting can now
-    be combined with presentation specifiers as in `std::format`. For
-    example:
-
-    ```c++
-    #include <fmt/core.h>
-    #include <locale>
-
-    int main() {
-      std::locale::global(std::locale("fr_FR.UTF-8"));
-      fmt::print("{0:.2Lf}", 0.42);
-    }
-    ```
-
-    prints \"0,42\". The deprecated `'n'` specifier has been removed.
-
--   Made the `0` specifier ignored for infinity and NaN
-    (https://github.com/fmtlib/fmt/issues/2305,
-    https://github.com/fmtlib/fmt/pull/2310). Thanks @Liedtke.
-
--   Made the hexfloat formatting use the right alignment by default
-    (https://github.com/fmtlib/fmt/issues/2308,
-    https://github.com/fmtlib/fmt/pull/2317). Thanks @Liedtke.
-
--   Removed the deprecated numeric alignment (`'='`). Use the `'0'`
-    specifier instead.
-
--   Removed the deprecated `fmt/posix.h` header that has been replaced
-    with `fmt/os.h`.
-
--   Removed the deprecated `format_to_n_context`, `format_to_n_args` and
-    `make_format_to_n_args`. They have been replaced with
-    `format_context`, `` format_args` and ``make_format_args\`\`
-    respectively.
-
--   Moved `wchar_t`-specific functions and types to `fmt/xchar.h`. You
-    can define `FMT_DEPRECATED_INCLUDE_XCHAR` to automatically include
-    `fmt/xchar.h` from `fmt/format.h` but this will be disabled in the
-    next major release.
-
--   Fixed handling of the `'+'` specifier in localized formatting
-    (https://github.com/fmtlib/fmt/issues/2133).
-
--   Added support for the `'s'` format specifier that gives textual
-    representation of `bool`
-    (https://github.com/fmtlib/fmt/issues/2094,
-    https://github.com/fmtlib/fmt/pull/2109). For example:
-
-    ```c++
-    #include <fmt/core.h>
-
-    int main() {
-      fmt::print("{:s}", true);
-    }
-    ```
-
-    prints \"true\". Thanks @powercoderlol.
-
--   Made `fmt::ptr` work with function pointers
-    (https://github.com/fmtlib/fmt/pull/2131). For example:
-
-    ```c++
-    #include <fmt/format.h>
-
-    int main() {
-      fmt::print("My main: {}\n", fmt::ptr(main));
-    }
-    ```
-
-    Thanks @mikecrowe.
-
--   The undocumented support for specializing `formatter` for pointer
-    types has been removed.
-
--   Fixed `fmt::formatted_size` with format string compilation
-    (https://github.com/fmtlib/fmt/pull/2141,
-    https://github.com/fmtlib/fmt/pull/2161). Thanks @alexezeder.
-
--   Fixed handling of empty format strings during format string
-    compilation (https://github.com/fmtlib/fmt/issues/2042):
-
-    ```c++
-    auto s = fmt::format(FMT_COMPILE(""));
-    ```
-
-    Thanks @alexezeder.
-
--   Fixed handling of enums in `fmt::to_string`
-    (https://github.com/fmtlib/fmt/issues/2036).
-
--   Improved width computation
-    (https://github.com/fmtlib/fmt/issues/2033,
-    https://github.com/fmtlib/fmt/issues/2091). For example:
-
-    ```c++
-    #include <fmt/core.h>
-
-    int main() {
-      fmt::print("{:-<10}{}\n", "ä½ å¥½", "ä¸ç");
-      fmt::print("{:-<10}{}\n", "hello", "world");
-    }
-    ```
-
-    prints
-
-    ![](https://user-images.githubusercontent.com/576385/119840373-cea3ca80-beb9-11eb-91e0-54266c48e181.png)
-
-    on a modern terminal.
-
--   The experimental fast output stream (`fmt::ostream`) is now
-    truncated by default for consistency with `fopen`
-    (https://github.com/fmtlib/fmt/issues/2018). For example:
-
-    ```c++
-    #include <fmt/os.h>
-
-    int main() {
-      fmt::ostream out1 = fmt::output_file("guide");
-      out1.print("Zaphod");
-      out1.close();
-      fmt::ostream out2 = fmt::output_file("guide");
-      out2.print("Ford");
-    }
-    ```
-
-    writes \"Ford\" to the file \"guide\". To preserve the old file
-    content if any pass `fmt::file::WRONLY | fmt::file::CREATE` flags to
-    `fmt::output_file`.
-
--   Fixed moving of `fmt::ostream` that holds buffered data
-    (https://github.com/fmtlib/fmt/issues/2197,
-    https://github.com/fmtlib/fmt/pull/2198). Thanks @vtta.
-
--   Replaced the `fmt::system_error` exception with a function of the
-    same name that constructs `std::system_error`
-    (https://github.com/fmtlib/fmt/issues/2266).
-
--   Replaced the `fmt::windows_error` exception with a function of the
-    same name that constructs `std::system_error` with the category
-    returned by `fmt::system_category()`
-    (https://github.com/fmtlib/fmt/issues/2274,
-    https://github.com/fmtlib/fmt/pull/2275). The latter is
-    similar to `std::sytem_category` but correctly handles UTF-8.
-    Thanks @phprus.
-
--   Replaced `fmt::error_code` with `std::error_code` and made it
-    formattable (https://github.com/fmtlib/fmt/issues/2269,
-    https://github.com/fmtlib/fmt/pull/2270,
-    https://github.com/fmtlib/fmt/pull/2273). Thanks @phprus.
-
--   Added speech synthesis support
-    (https://github.com/fmtlib/fmt/pull/2206).
-
--   Made `format_to` work with a memory buffer that has a custom
-    allocator (https://github.com/fmtlib/fmt/pull/2300).
-    Thanks @voxmea.
-
--   Added `Allocator::max_size` support to `basic_memory_buffer`.
-    (https://github.com/fmtlib/fmt/pull/1960). Thanks @phprus.
-
--   Added wide string support to `fmt::join`
-    (https://github.com/fmtlib/fmt/pull/2236). Thanks @crbrz.
-
--   Made iterators passed to `formatter` specializations via a format
-    context satisfy C++20 `std::output_iterator` requirements
-    (https://github.com/fmtlib/fmt/issues/2156,
-    https://github.com/fmtlib/fmt/pull/2158,
-    https://github.com/fmtlib/fmt/issues/2195,
-    https://github.com/fmtlib/fmt/pull/2204). Thanks @randomnetcat.
-
--   Optimized the `printf` implementation
-    (https://github.com/fmtlib/fmt/pull/1982,
-    https://github.com/fmtlib/fmt/pull/1984,
-    https://github.com/fmtlib/fmt/pull/2016,
-    https://github.com/fmtlib/fmt/pull/2164).
-    Thanks @rimathia and @moiwi.
-
--   Improved detection of `constexpr` `char_traits`
-    (https://github.com/fmtlib/fmt/pull/2246,
-    https://github.com/fmtlib/fmt/pull/2257). Thanks @phprus.
-
--   Fixed writing to `stdout` when it is redirected to `NUL` on Windows
-    (https://github.com/fmtlib/fmt/issues/2080).
-
--   Fixed exception propagation from iterators
-    (https://github.com/fmtlib/fmt/issues/2097).
-
--   Improved `strftime` error handling
-    (https://github.com/fmtlib/fmt/issues/2238,
-    https://github.com/fmtlib/fmt/pull/2244). Thanks @yumeyao.
-
--   Stopped using deprecated GCC UDL template extension.
-
--   Added `fmt/args.h` to the install target
-    (https://github.com/fmtlib/fmt/issues/2096).
-
--   Error messages are now passed to assert when exceptions are disabled
-    (https://github.com/fmtlib/fmt/pull/2145). Thanks @NobodyXu.
-
--   Added the `FMT_MASTER_PROJECT` CMake option to control build and
-    install targets when {fmt} is included via `add_subdirectory`
-    (https://github.com/fmtlib/fmt/issues/2098,
-    https://github.com/fmtlib/fmt/pull/2100).
-    Thanks @randomizedthinking.
-
--   Improved build configuration
-    (https://github.com/fmtlib/fmt/pull/2026,
-    https://github.com/fmtlib/fmt/pull/2122).
-    Thanks @luncliff and @ibaned.
-
--   Fixed various warnings and compilation issues
-    (https://github.com/fmtlib/fmt/issues/1947,
-    https://github.com/fmtlib/fmt/pull/1959,
-    https://github.com/fmtlib/fmt/pull/1963,
-    https://github.com/fmtlib/fmt/pull/1965,
-    https://github.com/fmtlib/fmt/issues/1966,
-    https://github.com/fmtlib/fmt/pull/1974,
-    https://github.com/fmtlib/fmt/pull/1975,
-    https://github.com/fmtlib/fmt/pull/1990,
-    https://github.com/fmtlib/fmt/issues/2000,
-    https://github.com/fmtlib/fmt/pull/2001,
-    https://github.com/fmtlib/fmt/issues/2002,
-    https://github.com/fmtlib/fmt/issues/2004,
-    https://github.com/fmtlib/fmt/pull/2006,
-    https://github.com/fmtlib/fmt/pull/2009,
-    https://github.com/fmtlib/fmt/pull/2010,
-    https://github.com/fmtlib/fmt/issues/2038,
-    https://github.com/fmtlib/fmt/issues/2039,
-    https://github.com/fmtlib/fmt/issues/2047,
-    https://github.com/fmtlib/fmt/pull/2053,
-    https://github.com/fmtlib/fmt/issues/2059,
-    https://github.com/fmtlib/fmt/pull/2065,
-    https://github.com/fmtlib/fmt/pull/2067,
-    https://github.com/fmtlib/fmt/pull/2068,
-    https://github.com/fmtlib/fmt/pull/2073,
-    https://github.com/fmtlib/fmt/issues/2103,
-    https://github.com/fmtlib/fmt/issues/2105,
-    https://github.com/fmtlib/fmt/pull/2106,
-    https://github.com/fmtlib/fmt/pull/2107,
-    https://github.com/fmtlib/fmt/issues/2116,
-    https://github.com/fmtlib/fmt/pull/2117,
-    https://github.com/fmtlib/fmt/issues/2118,
-    https://github.com/fmtlib/fmt/pull/2119,
-    https://github.com/fmtlib/fmt/issues/2127,
-    https://github.com/fmtlib/fmt/pull/2128,
-    https://github.com/fmtlib/fmt/issues/2140,
-    https://github.com/fmtlib/fmt/issues/2142,
-    https://github.com/fmtlib/fmt/pull/2143,
-    https://github.com/fmtlib/fmt/pull/2144,
-    https://github.com/fmtlib/fmt/issues/2147,
-    https://github.com/fmtlib/fmt/issues/2148,
-    https://github.com/fmtlib/fmt/issues/2149,
-    https://github.com/fmtlib/fmt/pull/2152,
-    https://github.com/fmtlib/fmt/pull/2160,
-    https://github.com/fmtlib/fmt/issues/2170,
-    https://github.com/fmtlib/fmt/issues/2175,
-    https://github.com/fmtlib/fmt/issues/2176,
-    https://github.com/fmtlib/fmt/pull/2177,
-    https://github.com/fmtlib/fmt/issues/2178,
-    https://github.com/fmtlib/fmt/pull/2179,
-    https://github.com/fmtlib/fmt/issues/2180,
-    https://github.com/fmtlib/fmt/issues/2181,
-    https://github.com/fmtlib/fmt/pull/2183,
-    https://github.com/fmtlib/fmt/issues/2184,
-    https://github.com/fmtlib/fmt/issues/2185,
-    https://github.com/fmtlib/fmt/pull/2186,
-    https://github.com/fmtlib/fmt/pull/2187,
-    https://github.com/fmtlib/fmt/pull/2190,
-    https://github.com/fmtlib/fmt/pull/2192,
-    https://github.com/fmtlib/fmt/pull/2194,
-    https://github.com/fmtlib/fmt/pull/2205,
-    https://github.com/fmtlib/fmt/issues/2210,
-    https://github.com/fmtlib/fmt/pull/2211,
-    https://github.com/fmtlib/fmt/pull/2215,
-    https://github.com/fmtlib/fmt/pull/2216,
-    https://github.com/fmtlib/fmt/pull/2218,
-    https://github.com/fmtlib/fmt/pull/2220,
-    https://github.com/fmtlib/fmt/issues/2228,
-    https://github.com/fmtlib/fmt/pull/2229,
-    https://github.com/fmtlib/fmt/pull/2230,
-    https://github.com/fmtlib/fmt/issues/2233,
-    https://github.com/fmtlib/fmt/pull/2239,
-    https://github.com/fmtlib/fmt/issues/2248,
-    https://github.com/fmtlib/fmt/issues/2252,
-    https://github.com/fmtlib/fmt/pull/2253,
-    https://github.com/fmtlib/fmt/pull/2255,
-    https://github.com/fmtlib/fmt/issues/2261,
-    https://github.com/fmtlib/fmt/issues/2278,
-    https://github.com/fmtlib/fmt/issues/2284,
-    https://github.com/fmtlib/fmt/pull/2287,
-    https://github.com/fmtlib/fmt/pull/2289,
-    https://github.com/fmtlib/fmt/pull/2290,
-    https://github.com/fmtlib/fmt/pull/2293,
-    https://github.com/fmtlib/fmt/issues/2295,
-    https://github.com/fmtlib/fmt/pull/2296,
-    https://github.com/fmtlib/fmt/pull/2297,
-    https://github.com/fmtlib/fmt/issues/2311,
-    https://github.com/fmtlib/fmt/pull/2313,
-    https://github.com/fmtlib/fmt/pull/2315,
-    https://github.com/fmtlib/fmt/issues/2320,
-    https://github.com/fmtlib/fmt/pull/2321,
-    https://github.com/fmtlib/fmt/pull/2323,
-    https://github.com/fmtlib/fmt/issues/2328,
-    https://github.com/fmtlib/fmt/pull/2329,
-    https://github.com/fmtlib/fmt/pull/2333,
-    https://github.com/fmtlib/fmt/pull/2338,
-    https://github.com/fmtlib/fmt/pull/2341).
-    Thanks @darklukee, @fagg, @killerbot242, @jgopel, @yeswalrus, @Finkman,
-    @HazardyKnusperkeks, @dkavolis, @concatime, @chronoxor, @summivox, @yNeo,
-    @Apache-HB, @alexezeder, @toojays, @Brainy0207, @vadz, @imsherlock, @phprus,
-    @white238, @yafshar, @BillyDonahue, @jstaahl, @denchat, @DanielaE,
-    @ilyakurdyukov, @ilmai, @JessyDL, @sergiud, @mwinterb, @sven-herrmann,
-    @jmelas, @twoixter, @crbrz and @upsj.
-
--   Improved documentation
-    (https://github.com/fmtlib/fmt/issues/1986,
-    https://github.com/fmtlib/fmt/pull/2051,
-    https://github.com/fmtlib/fmt/issues/2057,
-    https://github.com/fmtlib/fmt/pull/2081,
-    https://github.com/fmtlib/fmt/issues/2084,
-    https://github.com/fmtlib/fmt/pull/2312).
-    Thanks @imba-tjd, @0x416c69 and @mordante.
-
--   Continuous integration and test improvements
-    (https://github.com/fmtlib/fmt/issues/1969,
-    https://github.com/fmtlib/fmt/pull/1991,
-    https://github.com/fmtlib/fmt/pull/2020,
-    https://github.com/fmtlib/fmt/pull/2110,
-    https://github.com/fmtlib/fmt/pull/2114,
-    https://github.com/fmtlib/fmt/issues/2196,
-    https://github.com/fmtlib/fmt/pull/2217,
-    https://github.com/fmtlib/fmt/pull/2247,
-    https://github.com/fmtlib/fmt/pull/2256,
-    https://github.com/fmtlib/fmt/pull/2336,
-    https://github.com/fmtlib/fmt/pull/2346).
-    Thanks @jgopel, @alexezeder and @DanielaE.
-
-# 7.1.3 - 2020-11-24
-
--   Fixed handling of buffer boundaries in `format_to_n`
-    (https://github.com/fmtlib/fmt/issues/1996,
-    https://github.com/fmtlib/fmt/issues/2029).
--   Fixed linkage errors when linking with a shared library
-    (https://github.com/fmtlib/fmt/issues/2011).
--   Reintroduced ostream support to range formatters
-    (https://github.com/fmtlib/fmt/issues/2014).
--   Worked around an issue with mixing std versions in gcc
-    (https://github.com/fmtlib/fmt/issues/2017).
-
-# 7.1.2 - 2020-11-04
-
--   Fixed floating point formatting with large precision
-    (https://github.com/fmtlib/fmt/issues/1976).
-
-# 7.1.1 - 2020-11-01
-
--   Fixed ABI compatibility with 7.0.x
-    (https://github.com/fmtlib/fmt/issues/1961).
--   Added the `FMT_ARM_ABI_COMPATIBILITY` macro to work around ABI
-    incompatibility between GCC and Clang on ARM
-    (https://github.com/fmtlib/fmt/issues/1919).
--   Worked around a SFINAE bug in GCC 8
-    (https://github.com/fmtlib/fmt/issues/1957).
--   Fixed linkage errors when building with GCC\'s LTO
-    (https://github.com/fmtlib/fmt/issues/1955).
--   Fixed a compilation error when building without `__builtin_clz` or
-    equivalent (https://github.com/fmtlib/fmt/pull/1968).
-    Thanks @tohammer.
--   Fixed a sign conversion warning
-    (https://github.com/fmtlib/fmt/pull/1964). Thanks @OptoCloud.
-
-# 7.1.0 - 2020-10-25
-
--   Switched from
-    [Grisu3](https://www.cs.tufts.edu/~nr/cs257/archive/florian-loitsch/printf.pdf)
-    to [Dragonbox](https://github.com/jk-jeon/dragonbox) for the default
-    floating-point formatting which gives the shortest decimal
-    representation with round-trip guarantee and correct rounding
-    (https://github.com/fmtlib/fmt/pull/1882,
-    https://github.com/fmtlib/fmt/pull/1887,
-    https://github.com/fmtlib/fmt/pull/1894). This makes {fmt}
-    up to 20-30x faster than common implementations of
-    `std::ostringstream` and `sprintf` on
-    [dtoa-benchmark](https://github.com/fmtlib/dtoa-benchmark) and
-    faster than double-conversion and RyÅ«:
-
-    ![](https://user-images.githubusercontent.com/576385/95684665-11719600-0ba8-11eb-8e5b-972ff4e49428.png)
-
-    It is possible to get even better performance at the cost of larger
-    binary size by compiling with the `FMT_USE_FULL_CACHE_DRAGONBOX`
-    macro set to 1.
-
-    Thanks @jk-jeon.
-
--   Added an experimental unsynchronized file output API which, together
-    with [format string
-    compilation](https://fmt.dev/latest/api.html#compile-api), can give
-    [5-9 times speed up compared to
-    fprintf](https://www.zverovich.net/2020/08/04/optimal-file-buffer-size.html)
-    on common platforms ([godbolt](https://godbolt.org/z/nsTcG8)):
-
-    ```c++
-    #include <fmt/os.h>
-
-    int main() {
-      auto f = fmt::output_file("guide");
-      f.print("The answer is {}.", 42);
-    }
-    ```
-
--   Added a formatter for `std::chrono::time_point<system_clock>`
-    (https://github.com/fmtlib/fmt/issues/1819,
-    https://github.com/fmtlib/fmt/pull/1837). For example
-    ([godbolt](https://godbolt.org/z/c4M6fh)):
-
-    ```c++
-    #include <fmt/chrono.h>
-
-    int main() {
-      auto now = std::chrono::system_clock::now();
-      fmt::print("The time is {:%H:%M:%S}.\n", now);
-    }
-    ```
-
-    Thanks @adamburgess.
-
--   Added support for ranges with non-const `begin`/`end` to `fmt::join`
-    (https://github.com/fmtlib/fmt/issues/1784,
-    https://github.com/fmtlib/fmt/pull/1786). For example
-    ([godbolt](https://godbolt.org/z/jP63Tv)):
-
-    ```c++
-    #include <fmt/ranges.h>
-    #include <range/v3/view/filter.hpp>
-
-    int main() {
-      using std::literals::string_literals::operator""s;
-      auto strs = std::array{"a"s, "bb"s, "ccc"s};
-      auto range = strs | ranges::views::filter(
-        [] (const std::string &x) { return x.size() != 2; }
-      );
-      fmt::print("{}\n", fmt::join(range, ""));
-    }
-    ```
-
-    prints \"accc\".
-
-    Thanks @tonyelewis.
-
--   Added a `memory_buffer::append` overload that takes a range
-    (https://github.com/fmtlib/fmt/pull/1806). Thanks @BRevzin.
-
--   Improved handling of single code units in `FMT_COMPILE`. For
-    example:
-
-    ```c++
-    #include <fmt/compile.h>
-
-    char* f(char* buf) {
-      return fmt::format_to(buf, FMT_COMPILE("x{}"), 42);
-    }
-    ```
-
-    compiles to just ([godbolt](https://godbolt.org/z/5vncz3)):
-
-    ```asm
-    _Z1fPc:
-      movb $120, (%rdi)
-      xorl %edx, %edx
-      cmpl $42, _ZN3fmt2v76detail10basic_dataIvE23zero_or_powers_of_10_32E+8(%rip)
-      movl $3, %eax
-      seta %dl
-      subl %edx, %eax
-      movzwl _ZN3fmt2v76detail10basic_dataIvE6digitsE+84(%rip), %edx
-      cltq
-      addq %rdi, %rax
-      movw %dx, -2(%rax)
-      ret
-    ```
-
-    Here a single `mov` instruction writes `'x'` (`$120`) to the output
-    buffer.
-
--   Added dynamic width support to format string compilation
-    (https://github.com/fmtlib/fmt/issues/1809).
-
--   Improved error reporting for unformattable types: now you\'ll get
-    the type name directly in the error message instead of the note:
-
-    ```c++
-    #include <fmt/core.h>
-
-    struct how_about_no {};
-
-    int main() {
-      fmt::print("{}", how_about_no());
-    }
-    ```
-
-    Error ([godbolt](https://godbolt.org/z/GoxM4e)):
-
-    `fmt/core.h:1438:3: error: static_assert failed due to requirement 'fmt::v7::formattable<how_about_no>()' "Cannot format an argument. To make type T formattable provide a formatter<T> specialization: https://fmt.dev/latest/api.html#udt" ...`
-
--   Added the
-    [make_args_checked](https://fmt.dev/7.1.0/api.html#argument-lists)
-    function template that allows you to write formatting functions with
-    compile-time format string checks and avoid binary code bloat
-    ([godbolt](https://godbolt.org/z/PEf9qr)):
-
-    ```c++
-    void vlog(const char* file, int line, fmt::string_view format,
-              fmt::format_args args) {
-      fmt::print("{}: {}: ", file, line);
-      fmt::vprint(format, args);
-    }
-
-    template <typename S, typename... Args>
-    void log(const char* file, int line, const S& format, Args&&... args) {
-      vlog(file, line, format,
-          fmt::make_args_checked<Args...>(format, args...));
-    }
-
-    #define MY_LOG(format, ...) \
-      log(__FILE__, __LINE__, FMT_STRING(format), __VA_ARGS__)
-
-    MY_LOG("invalid squishiness: {}", 42);
-    ```
-
--   Replaced `snprintf` fallback with a faster internal IEEE 754 `float`
-    and `double` formatter for arbitrary precision. For example
-    ([godbolt](https://godbolt.org/z/dPhWvj)):
-
-    ```c++
-    #include <fmt/core.h>
-
-    int main() {
-      fmt::print("{:.500}\n", 4.9406564584124654E-324);
-    }
-    ```
-
-    prints
-
-    `4.9406564584124654417656879286822137236505980261432476442558568250067550727020875186529983636163599237979656469544571773092665671035593979639877479601078187812630071319031140452784581716784898210368871863605699873072305000638740915356498438731247339727316961514003171538539807412623856559117102665855668676818703956031062493194527159149245532930545654440112748012970999954193198940908041656332452475714786901472678015935523861155013480352649347201937902681071074917033322268447533357208324319360923829e-324`.
-
--   Made `format_to_n` and `formatted_size` part of the [core
-    API](https://fmt.dev/latest/api.html#core-api)
-    ([godbolt](https://godbolt.org/z/sPjY1K)):
-
-    ```c++
-    #include <fmt/core.h>
-
-    int main() {
-      char buffer[10];
-      auto result = fmt::format_to_n(buffer, sizeof(buffer), "{}", 42);
-    }
-    ```
-
--   Added `fmt::format_to_n` overload with format string compilation
-    (https://github.com/fmtlib/fmt/issues/1764,
-    https://github.com/fmtlib/fmt/pull/1767,
-    https://github.com/fmtlib/fmt/pull/1869). For example
-    ([godbolt](https://godbolt.org/z/93h86q)):
-
-    ```c++
-    #include <fmt/compile.h>
-
-    int main() {
-      char buffer[8];
-      fmt::format_to_n(buffer, sizeof(buffer), FMT_COMPILE("{}"), 42);
-    }
-    ```
-
-    Thanks @Kurkin and @alexezeder.
-
--   Added `fmt::format_to` overload that take `text_style`
-    (https://github.com/fmtlib/fmt/issues/1593,
-    https://github.com/fmtlib/fmt/issues/1842,
-    https://github.com/fmtlib/fmt/pull/1843). For example
-    ([godbolt](https://godbolt.org/z/91153r)):
-
-    ```c++
-    #include <fmt/color.h>
-
-    int main() {
-      std::string out;
-      fmt::format_to(std::back_inserter(out),
-                     fmt::emphasis::bold | fg(fmt::color::red),
-                     "The answer is {}.", 42);
-    }
-    ```
-
-    Thanks @Naios.
-
--   Made the `'#'` specifier emit trailing zeros in addition to the
-    decimal point (https://github.com/fmtlib/fmt/issues/1797).
-    For example ([godbolt](https://godbolt.org/z/bhdcW9)):
-
-    ```c++
-    #include <fmt/core.h>
-
-    int main() {
-      fmt::print("{:#.2g}", 0.5);
-    }
-    ```
-
-    prints `0.50`.
-
--   Changed the default floating point format to not include `.0` for
-    consistency with `std::format` and `std::to_chars`
-    (https://github.com/fmtlib/fmt/issues/1893,
-    https://github.com/fmtlib/fmt/issues/1943). It is possible
-    to get the decimal point and trailing zero with the `#` specifier.
-
--   Fixed an issue with floating-point formatting that could result in
-    addition of a non-significant trailing zero in rare cases e.g.
-    `1.00e-34` instead of `1.0e-34`
-    (https://github.com/fmtlib/fmt/issues/1873,
-    https://github.com/fmtlib/fmt/issues/1917).
-
--   Made `fmt::to_string` fallback on `ostream` insertion operator if
-    the `formatter` specialization is not provided
-    (https://github.com/fmtlib/fmt/issues/1815,
-    https://github.com/fmtlib/fmt/pull/1829). Thanks @alexezeder.
-
--   Added support for the append mode to the experimental file API and
-    improved `fcntl.h` detection.
-    (https://github.com/fmtlib/fmt/pull/1847,
-    https://github.com/fmtlib/fmt/pull/1848). Thanks @t-wiser.
-
--   Fixed handling of types that have both an implicit conversion
-    operator and an overloaded `ostream` insertion operator
-    (https://github.com/fmtlib/fmt/issues/1766).
-
--   Fixed a slicing issue in an internal iterator type
-    (https://github.com/fmtlib/fmt/pull/1822). Thanks @BRevzin.
-
--   Fixed an issue in locale-specific integer formatting
-    (https://github.com/fmtlib/fmt/issues/1927).
-
--   Fixed handling of exotic code unit types
-    (https://github.com/fmtlib/fmt/issues/1870,
-    https://github.com/fmtlib/fmt/issues/1932).
-
--   Improved `FMT_ALWAYS_INLINE`
-    (https://github.com/fmtlib/fmt/pull/1878). Thanks @jk-jeon.
-
--   Removed dependency on `windows.h`
-    (https://github.com/fmtlib/fmt/pull/1900). Thanks @bernd5.
-
--   Optimized counting of decimal digits on MSVC
-    (https://github.com/fmtlib/fmt/pull/1890). Thanks @mwinterb.
-
--   Improved documentation
-    (https://github.com/fmtlib/fmt/issues/1772,
-    https://github.com/fmtlib/fmt/pull/1775,
-    https://github.com/fmtlib/fmt/pull/1792,
-    https://github.com/fmtlib/fmt/pull/1838,
-    https://github.com/fmtlib/fmt/pull/1888,
-    https://github.com/fmtlib/fmt/pull/1918,
-    https://github.com/fmtlib/fmt/pull/1939).
-    Thanks @leolchat, @pepsiman, @Klaim, @ravijanjam, @francesco-st and @udnaan.
-
--   Added the `FMT_REDUCE_INT_INSTANTIATIONS` CMake option that reduces
-    the binary code size at the cost of some integer formatting
-    performance. This can be useful for extremely memory-constrained
-    embedded systems
-    (https://github.com/fmtlib/fmt/issues/1778,
-    https://github.com/fmtlib/fmt/pull/1781). Thanks @kammce.
-
--   Added the `FMT_USE_INLINE_NAMESPACES` macro to control usage of
-    inline namespaces
-    (https://github.com/fmtlib/fmt/pull/1945). Thanks @darklukee.
-
--   Improved build configuration
-    (https://github.com/fmtlib/fmt/pull/1760,
-    https://github.com/fmtlib/fmt/pull/1770,
-    https://github.com/fmtlib/fmt/issues/1779,
-    https://github.com/fmtlib/fmt/pull/1783,
-    https://github.com/fmtlib/fmt/pull/1823).
-    Thanks @dvetutnev, @xvitaly, @tambry, @medithe and @martinwuehrer.
-
--   Fixed various warnings and compilation issues
-    (https://github.com/fmtlib/fmt/pull/1790,
-    https://github.com/fmtlib/fmt/pull/1802,
-    https://github.com/fmtlib/fmt/pull/1808,
-    https://github.com/fmtlib/fmt/issues/1810,
-    https://github.com/fmtlib/fmt/issues/1811,
-    https://github.com/fmtlib/fmt/pull/1812,
-    https://github.com/fmtlib/fmt/pull/1814,
-    https://github.com/fmtlib/fmt/pull/1816,
-    https://github.com/fmtlib/fmt/pull/1817,
-    https://github.com/fmtlib/fmt/pull/1818,
-    https://github.com/fmtlib/fmt/issues/1825,
-    https://github.com/fmtlib/fmt/pull/1836,
-    https://github.com/fmtlib/fmt/pull/1855,
-    https://github.com/fmtlib/fmt/pull/1856,
-    https://github.com/fmtlib/fmt/pull/1860,
-    https://github.com/fmtlib/fmt/pull/1877,
-    https://github.com/fmtlib/fmt/pull/1879,
-    https://github.com/fmtlib/fmt/pull/1880,
-    https://github.com/fmtlib/fmt/issues/1896,
-    https://github.com/fmtlib/fmt/pull/1897,
-    https://github.com/fmtlib/fmt/pull/1898,
-    https://github.com/fmtlib/fmt/issues/1904,
-    https://github.com/fmtlib/fmt/pull/1908,
-    https://github.com/fmtlib/fmt/issues/1911,
-    https://github.com/fmtlib/fmt/issues/1912,
-    https://github.com/fmtlib/fmt/issues/1928,
-    https://github.com/fmtlib/fmt/pull/1929,
-    https://github.com/fmtlib/fmt/issues/1935,
-    https://github.com/fmtlib/fmt/pull/1937,
-    https://github.com/fmtlib/fmt/pull/1942,
-    https://github.com/fmtlib/fmt/issues/1949).
-    Thanks @TheQwertiest, @medithe, @martinwuehrer, @n16h7hunt3r, @Othereum,
-    @gsjaardema, @AlexanderLanin, @gcerretani, @chronoxor, @noizefloor,
-    @akohlmey, @jk-jeon, @rimathia, @rglarix, @moiwi, @heckad, @MarcDirven.
-    @BartSiwek and @darklukee.
-
-# 7.0.3 - 2020-08-06
-
--   Worked around broken `numeric_limits` for 128-bit integers
-    (https://github.com/fmtlib/fmt/issues/1787).
--   Added error reporting on missing named arguments
-    (https://github.com/fmtlib/fmt/issues/1796).
--   Stopped using 128-bit integers with clang-cl
-    (https://github.com/fmtlib/fmt/pull/1800). Thanks @Kingcom.
--   Fixed issues in locale-specific integer formatting
-    (https://github.com/fmtlib/fmt/issues/1782,
-    https://github.com/fmtlib/fmt/issues/1801).
-
-# 7.0.2 - 2020-07-29
-
--   Worked around broken `numeric_limits` for 128-bit integers
-    (https://github.com/fmtlib/fmt/issues/1725).
--   Fixed compatibility with CMake 3.4
-    (https://github.com/fmtlib/fmt/issues/1779).
--   Fixed handling of digit separators in locale-specific formatting
-    (https://github.com/fmtlib/fmt/issues/1782).
-
-# 7.0.1 - 2020-07-07
-
--   Updated the inline version namespace name.
--   Worked around a gcc bug in mangling of alias templates
-    (https://github.com/fmtlib/fmt/issues/1753).
--   Fixed a linkage error on Windows
-    (https://github.com/fmtlib/fmt/issues/1757). Thanks @Kurkin.
--   Fixed minor issues with the documentation.
-
-# 7.0.0 - 2020-07-05
-
--   Reduced the library size. For example, on macOS a stripped test
-    binary statically linked with {fmt} [shrank from \~368k to less than
-    100k](http://www.zverovich.net/2020/05/21/reducing-library-size.html).
-
--   Added a simpler and more efficient [format string compilation
-    API](https://fmt.dev/7.0.0/api.html#compile-api):
-
-    ```c++
-    #include <fmt/compile.h>
-
-    // Converts 42 into std::string using the most efficient method and no
-    // runtime format string processing.
-    std::string s = fmt::format(FMT_COMPILE("{}"), 42);
-    ```
-
-    The old `fmt::compile` API is now deprecated.
-
--   Optimized integer formatting: `format_to` with format string
-    compilation and a stack-allocated buffer is now [faster than
-    to_chars on both libc++ and
-    libstdc++](http://www.zverovich.net/2020/06/13/fast-int-to-string-revisited.html).
-
--   Optimized handling of small format strings. For example,
-
-    ```c++
-    fmt::format("Result: {}: ({},{},{},{})", str1, str2, str3, str4, str5)
-    ```
-
-    is now \~40% faster
-    (https://github.com/fmtlib/fmt/issues/1685).
-
--   Applied extern templates to improve compile times when using the
-    core API and `fmt/format.h`
-    (https://github.com/fmtlib/fmt/issues/1452). For example,
-    on macOS with clang the compile time of a test translation unit
-    dropped from 2.3s to 0.3s with `-O2` and from 0.6s to 0.3s with the
-    default settings (`-O0`).
-
-    Before (`-O2`):
-
-        % time c++ -c test.cc -I include -std=c++17 -O2
-        c++ -c test.cc -I include -std=c++17 -O2  2.22s user 0.08s system 99% cpu 2.311 total
-
-    After (`-O2`):
-
-        % time c++ -c test.cc -I include -std=c++17 -O2
-        c++ -c test.cc -I include -std=c++17 -O2  0.26s user 0.04s system 98% cpu 0.303 total
-
-    Before (default):
-
-        % time c++ -c test.cc -I include -std=c++17
-        c++ -c test.cc -I include -std=c++17  0.53s user 0.06s system 98% cpu 0.601 total
-
-    After (default):
-
-        % time c++ -c test.cc -I include -std=c++17
-        c++ -c test.cc -I include -std=c++17  0.24s user 0.06s system 98% cpu 0.301 total
-
-    It is still recommended to use `fmt/core.h` instead of
-    `fmt/format.h` but the compile time difference is now smaller.
-    Thanks @alex3d for the suggestion.
-
--   Named arguments are now stored on stack (no dynamic memory
-    allocations) and the compiled code is more compact and efficient.
-    For example
-
-    ```c++
-    #include <fmt/core.h>
-
-    int main() {
-      fmt::print("The answer is {answer}\n", fmt::arg("answer", 42));
-    }
-    ```
-
-    compiles to just ([godbolt](https://godbolt.org/z/NcfEp_))
-
-    ```asm
-    .LC0:
-            .string "answer"
-    .LC1:
-            .string "The answer is {answer}\n"
-    main:
-            sub     rsp, 56
-            mov     edi, OFFSET FLAT:.LC1
-            mov     esi, 23
-            movabs  rdx, 4611686018427387905
-            lea     rax, [rsp+32]
-            lea     rcx, [rsp+16]
-            mov     QWORD PTR [rsp+8], 1
-            mov     QWORD PTR [rsp], rax
-            mov     DWORD PTR [rsp+16], 42
-            mov     QWORD PTR [rsp+32], OFFSET FLAT:.LC0
-            mov     DWORD PTR [rsp+40], 0
-            call    fmt::v6::vprint(fmt::v6::basic_string_view<char>,
-                                    fmt::v6::format_args)
-            xor     eax, eax
-            add     rsp, 56
-            ret
-
-        .L.str.1:
-                .asciz  "answer"
-    ```
-
--   Implemented compile-time checks for dynamic width and precision
-    (https://github.com/fmtlib/fmt/issues/1614):
-
-    ```c++
-    #include <fmt/format.h>
-
-    int main() {
-      fmt::print(FMT_STRING("{0:{1}}"), 42);
-    }
-    ```
-
-    now gives a compilation error because argument 1 doesn\'t exist:
-
-        In file included from test.cc:1:
-        include/fmt/format.h:2726:27: error: constexpr variable 'invalid_format' must be
-        initialized by a constant expression
-          FMT_CONSTEXPR_DECL bool invalid_format =
-                                  ^
-        ...
-        include/fmt/core.h:569:26: note: in call to
-        '&checker(s, {}).context_->on_error(&"argument not found"[0])'
-            if (id >= num_args_) on_error("argument not found");
-                                ^
-
--   Added sentinel support to `fmt::join`
-    (https://github.com/fmtlib/fmt/pull/1689)
-
-    ```c++
-    struct zstring_sentinel {};
-    bool operator==(const char* p, zstring_sentinel) { return *p == '\0'; }
-    bool operator!=(const char* p, zstring_sentinel) { return *p != '\0'; }
-
-    struct zstring {
-      const char* p;
-      const char* begin() const { return p; }
-      zstring_sentinel end() const { return {}; }
-    };
-
-    auto s = fmt::format("{}", fmt::join(zstring{"hello"}, "_"));
-    // s == "h_e_l_l_o"
-    ```
-
-    Thanks @BRevzin.
-
--   Added support for named arguments, `clear` and `reserve` to
-    `dynamic_format_arg_store`
-    (https://github.com/fmtlib/fmt/issues/1655,
-    https://github.com/fmtlib/fmt/pull/1663,
-    https://github.com/fmtlib/fmt/pull/1674,
-    https://github.com/fmtlib/fmt/pull/1677). Thanks @vsolontsov-ll.
-
--   Added support for the `'c'` format specifier to integral types for
-    compatibility with `std::format`
-    (https://github.com/fmtlib/fmt/issues/1652).
-
--   Replaced the `'n'` format specifier with `'L'` for compatibility
-    with `std::format`
-    (https://github.com/fmtlib/fmt/issues/1624). The `'n'`
-    specifier can be enabled via the `FMT_DEPRECATED_N_SPECIFIER` macro.
-
--   The `'='` format specifier is now disabled by default for
-    compatibility with `std::format`. It can be enabled via the
-    `FMT_DEPRECATED_NUMERIC_ALIGN` macro.
-
--   Removed the following deprecated APIs:
-
-    -   `FMT_STRING_ALIAS` and `fmt` macros - replaced by `FMT_STRING`
-    -   `fmt::basic_string_view::char_type` - replaced by
-        `fmt::basic_string_view::value_type`
-    -   `convert_to_int`
-    -   `format_arg_store::types`
-    -   `*parse_context` - replaced by `*format_parse_context`
-    -   `FMT_DEPRECATED_INCLUDE_OS`
-    -   `FMT_DEPRECATED_PERCENT` - incompatible with `std::format`
-    -   `*writer` - replaced by compiled format API
-
--   Renamed the `internal` namespace to `detail`
-    (https://github.com/fmtlib/fmt/issues/1538). The former is
-    still provided as an alias if the `FMT_USE_INTERNAL` macro is
-    defined.
-
--   Improved compatibility between `fmt::printf` with the standard specs
-    (https://github.com/fmtlib/fmt/issues/1595,
-    https://github.com/fmtlib/fmt/pull/1682,
-    https://github.com/fmtlib/fmt/pull/1683,
-    https://github.com/fmtlib/fmt/pull/1687,
-    https://github.com/fmtlib/fmt/pull/1699). Thanks @rimathia.
-
--   Fixed handling of `operator<<` overloads that use `copyfmt`
-    (https://github.com/fmtlib/fmt/issues/1666).
-
--   Added the `FMT_OS` CMake option to control inclusion of OS-specific
-    APIs in the fmt target. This can be useful for embedded platforms
-    (https://github.com/fmtlib/fmt/issues/1654,
-    https://github.com/fmtlib/fmt/pull/1656). Thanks @kwesolowski.
-
--   Replaced `FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION` with the
-    `FMT_FUZZ` macro to prevent interfering with fuzzing of projects
-    using {fmt} (https://github.com/fmtlib/fmt/pull/1650).
-    Thanks @asraa.
-
--   Fixed compatibility with emscripten
-    (https://github.com/fmtlib/fmt/issues/1636,
-    https://github.com/fmtlib/fmt/pull/1637). Thanks @ArthurSonzogni.
-
--   Improved documentation
-    (https://github.com/fmtlib/fmt/issues/704,
-    https://github.com/fmtlib/fmt/pull/1643,
-    https://github.com/fmtlib/fmt/pull/1660,
-    https://github.com/fmtlib/fmt/pull/1681,
-    https://github.com/fmtlib/fmt/pull/1691,
-    https://github.com/fmtlib/fmt/pull/1706,
-    https://github.com/fmtlib/fmt/pull/1714,
-    https://github.com/fmtlib/fmt/pull/1721,
-    https://github.com/fmtlib/fmt/pull/1739,
-    https://github.com/fmtlib/fmt/pull/1740,
-    https://github.com/fmtlib/fmt/pull/1741,
-    https://github.com/fmtlib/fmt/pull/1751).
-    Thanks @senior7515, @lsr0, @puetzk, @fpelliccioni, Alexey Kuzmenko, @jelly,
-    @claremacrae, @jiapengwen, @gsjaardema and @alexey-milovidov.
-
--   Implemented various build configuration fixes and improvements
-    (https://github.com/fmtlib/fmt/pull/1603,
-    https://github.com/fmtlib/fmt/pull/1657,
-    https://github.com/fmtlib/fmt/pull/1702,
-    https://github.com/fmtlib/fmt/pull/1728).
-    Thanks @scramsby, @jtojnar, @orivej and @flagarde.
-
--   Fixed various warnings and compilation issues
-    (https://github.com/fmtlib/fmt/pull/1616,
-    https://github.com/fmtlib/fmt/issues/1620,
-    https://github.com/fmtlib/fmt/issues/1622,
-    https://github.com/fmtlib/fmt/issues/1625,
-    https://github.com/fmtlib/fmt/pull/1627,
-    https://github.com/fmtlib/fmt/issues/1628,
-    https://github.com/fmtlib/fmt/pull/1629,
-    https://github.com/fmtlib/fmt/issues/1631,
-    https://github.com/fmtlib/fmt/pull/1633,
-    https://github.com/fmtlib/fmt/pull/1649,
-    https://github.com/fmtlib/fmt/issues/1658,
-    https://github.com/fmtlib/fmt/pull/1661,
-    https://github.com/fmtlib/fmt/pull/1667,
-    https://github.com/fmtlib/fmt/issues/1668,
-    https://github.com/fmtlib/fmt/pull/1669,
-    https://github.com/fmtlib/fmt/issues/1692,
-    https://github.com/fmtlib/fmt/pull/1696,
-    https://github.com/fmtlib/fmt/pull/1697,
-    https://github.com/fmtlib/fmt/issues/1707,
-    https://github.com/fmtlib/fmt/pull/1712,
-    https://github.com/fmtlib/fmt/pull/1716,
-    https://github.com/fmtlib/fmt/pull/1722,
-    https://github.com/fmtlib/fmt/issues/1724,
-    https://github.com/fmtlib/fmt/pull/1729,
-    https://github.com/fmtlib/fmt/pull/1738,
-    https://github.com/fmtlib/fmt/issues/1742,
-    https://github.com/fmtlib/fmt/issues/1743,
-    https://github.com/fmtlib/fmt/pull/1744,
-    https://github.com/fmtlib/fmt/issues/1747,
-    https://github.com/fmtlib/fmt/pull/1750).
-    Thanks @gsjaardema, @gabime, @johnor, @Kurkin, @invexed, @peterbell10,
-    @daixtrose, @petrutlucian94, @Neargye, @ambitslix, @gabime, @erthink,
-    @tohammer and @0x8000-0000.
-
-# 6.2.1 - 2020-05-09
-
--   Fixed ostream support in `sprintf`
-    (https://github.com/fmtlib/fmt/issues/1631).
--   Fixed type detection when using implicit conversion to `string_view`
-    and ostream `operator<<` inconsistently
-    (https://github.com/fmtlib/fmt/issues/1662).
-
-# 6.2.0 - 2020-04-05
-
--   Improved error reporting when trying to format an object of a
-    non-formattable type:
-
-    ```c++
-    fmt::format("{}", S());
-    ```
-
-    now gives:
-
-        include/fmt/core.h:1015:5: error: static_assert failed due to requirement
-        'formattable' "Cannot format argument. To make type T formattable provide a
-        formatter<T> specialization:
-        https://fmt.dev/latest/api.html#formatting-user-defined-types"
-            static_assert(
-            ^
-        ...
-        note: in instantiation of function template specialization
-        'fmt::v6::format<char [3], S, char>' requested here
-          fmt::format("{}", S());
-               ^
-
-    if `S` is not formattable.
-
--   Reduced the library size by \~10%.
-
--   Always print decimal point if `#` is specified
-    (https://github.com/fmtlib/fmt/issues/1476,
-    https://github.com/fmtlib/fmt/issues/1498):
-
-    ```c++
-    fmt::print("{:#.0f}", 42.0);
-    ```
-
-    now prints `42.`
-
--   Implemented the `'L'` specifier for locale-specific numeric
-    formatting to improve compatibility with `std::format`. The `'n'`
-    specifier is now deprecated and will be removed in the next major
-    release.
-
--   Moved OS-specific APIs such as `windows_error` from `fmt/format.h`
-    to `fmt/os.h`. You can define `FMT_DEPRECATED_INCLUDE_OS` to
-    automatically include `fmt/os.h` from `fmt/format.h` for
-    compatibility but this will be disabled in the next major release.
-
--   Added precision overflow detection in floating-point formatting.
-
--   Implemented detection of invalid use of `fmt::arg`.
-
--   Used `type_identity` to block unnecessary template argument
-    deduction. Thanks Tim Song.
-
--   Improved UTF-8 handling
-    (https://github.com/fmtlib/fmt/issues/1109):
-
-    ```c++
-    fmt::print("â{0:â^{2}}â\n"
-               "â{1: ^{2}}â\n"
-               "â{0:â^{2}}â\n", "", "ÐÑÐ¸Ð²ÐµÑ, Ð¼Ð¸Ñ!", 20);
-    ```
-
-    now prints:
-
-        ââââââââââââââââââââââ
-        â    ÐÑÐ¸Ð²ÐµÑ, Ð¼Ð¸Ñ!    â
-        ââââââââââââââââââââââ
-
-    on systems that support Unicode.
-
--   Added experimental dynamic argument storage
-    (https://github.com/fmtlib/fmt/issues/1170,
-    https://github.com/fmtlib/fmt/pull/1584):
-
-    ```c++
-    fmt::dynamic_format_arg_store<fmt::format_context> store;
-    store.push_back("answer");
-    store.push_back(42);
-    fmt::vprint("The {} is {}.\n", store);
-    ```
-
-    prints:
-
-        The answer is 42.
-
-    Thanks @vsolontsov-ll.
-
--   Made `fmt::join` accept `initializer_list`
-    (https://github.com/fmtlib/fmt/pull/1591). Thanks @Rapotkinnik.
-
--   Fixed handling of empty tuples
-    (https://github.com/fmtlib/fmt/issues/1588).
-
--   Fixed handling of output iterators in `format_to_n`
-    (https://github.com/fmtlib/fmt/issues/1506).
-
--   Fixed formatting of `std::chrono::duration` types to wide output
-    (https://github.com/fmtlib/fmt/pull/1533). Thanks @zeffy.
-
--   Added const `begin` and `end` overload to buffers
-    (https://github.com/fmtlib/fmt/pull/1553). Thanks @dominicpoeschko.
-
--   Added the ability to disable floating-point formatting via
-    `FMT_USE_FLOAT`, `FMT_USE_DOUBLE` and `FMT_USE_LONG_DOUBLE` macros
-    for extremely memory-constrained embedded system
-    (https://github.com/fmtlib/fmt/pull/1590). Thanks @albaguirre.
-
--   Made `FMT_STRING` work with `constexpr` `string_view`
-    (https://github.com/fmtlib/fmt/pull/1589). Thanks @scramsby.
-
--   Implemented a minor optimization in the format string parser
-    (https://github.com/fmtlib/fmt/pull/1560). Thanks @IkarusDeveloper.
-
--   Improved attribute detection
-    (https://github.com/fmtlib/fmt/pull/1469,
-    https://github.com/fmtlib/fmt/pull/1475,
-    https://github.com/fmtlib/fmt/pull/1576).
-    Thanks @federico-busato, @chronoxor and @refnum.
-
--   Improved documentation
-    (https://github.com/fmtlib/fmt/pull/1481,
-    https://github.com/fmtlib/fmt/pull/1523).
-    Thanks @JackBoosY and @imba-tjd.
-
--   Fixed symbol visibility on Linux when compiling with
-    `-fvisibility=hidden`
-    (https://github.com/fmtlib/fmt/pull/1535). Thanks @milianw.
-
--   Implemented various build configuration fixes and improvements
-    (https://github.com/fmtlib/fmt/issues/1264,
-    https://github.com/fmtlib/fmt/issues/1460,
-    https://github.com/fmtlib/fmt/pull/1534,
-    https://github.com/fmtlib/fmt/issues/1536,
-    https://github.com/fmtlib/fmt/issues/1545,
-    https://github.com/fmtlib/fmt/pull/1546,
-    https://github.com/fmtlib/fmt/issues/1566,
-    https://github.com/fmtlib/fmt/pull/1582,
-    https://github.com/fmtlib/fmt/issues/1597,
-    https://github.com/fmtlib/fmt/pull/1598).
-    Thanks @ambitslix, @jwillikers and @stac47.
-
--   Fixed various warnings and compilation issues
-    (https://github.com/fmtlib/fmt/pull/1433,
-    https://github.com/fmtlib/fmt/issues/1461,
-    https://github.com/fmtlib/fmt/pull/1470,
-    https://github.com/fmtlib/fmt/pull/1480,
-    https://github.com/fmtlib/fmt/pull/1485,
-    https://github.com/fmtlib/fmt/pull/1492,
-    https://github.com/fmtlib/fmt/issues/1493,
-    https://github.com/fmtlib/fmt/issues/1504,
-    https://github.com/fmtlib/fmt/pull/1505,
-    https://github.com/fmtlib/fmt/pull/1512,
-    https://github.com/fmtlib/fmt/issues/1515,
-    https://github.com/fmtlib/fmt/pull/1516,
-    https://github.com/fmtlib/fmt/pull/1518,
-    https://github.com/fmtlib/fmt/pull/1519,
-    https://github.com/fmtlib/fmt/pull/1520,
-    https://github.com/fmtlib/fmt/pull/1521,
-    https://github.com/fmtlib/fmt/pull/1522,
-    https://github.com/fmtlib/fmt/issues/1524,
-    https://github.com/fmtlib/fmt/pull/1530,
-    https://github.com/fmtlib/fmt/issues/1531,
-    https://github.com/fmtlib/fmt/pull/1532,
-    https://github.com/fmtlib/fmt/issues/1539,
-    https://github.com/fmtlib/fmt/issues/1547,
-    https://github.com/fmtlib/fmt/issues/1548,
-    https://github.com/fmtlib/fmt/pull/1554,
-    https://github.com/fmtlib/fmt/issues/1567,
-    https://github.com/fmtlib/fmt/pull/1568,
-    https://github.com/fmtlib/fmt/pull/1569,
-    https://github.com/fmtlib/fmt/pull/1571,
-    https://github.com/fmtlib/fmt/pull/1573,
-    https://github.com/fmtlib/fmt/pull/1575,
-    https://github.com/fmtlib/fmt/pull/1581,
-    https://github.com/fmtlib/fmt/issues/1583,
-    https://github.com/fmtlib/fmt/issues/1586,
-    https://github.com/fmtlib/fmt/issues/1587,
-    https://github.com/fmtlib/fmt/issues/1594,
-    https://github.com/fmtlib/fmt/pull/1596,
-    https://github.com/fmtlib/fmt/issues/1604,
-    https://github.com/fmtlib/fmt/pull/1606,
-    https://github.com/fmtlib/fmt/issues/1607,
-    https://github.com/fmtlib/fmt/issues/1609).
-    Thanks @marti4d, @iPherian, @parkertomatoes, @gsjaardema, @chronoxor,
-    @DanielaE, @torsten48, @tohammer, @lefticus, @ryusakki, @adnsv, @fghzxm,
-    @refnum, @pramodk, @Spirrwell and @scramsby.
-
-# 6.1.2 - 2019-12-11
-
--   Fixed ABI compatibility with `libfmt.so.6.0.0`
-    (https://github.com/fmtlib/fmt/issues/1471).
--   Fixed handling types convertible to `std::string_view`
-    (https://github.com/fmtlib/fmt/pull/1451). Thanks @denizevrenci.
--   Made CUDA test an opt-in enabled via the `FMT_CUDA_TEST` CMake
-    option.
--   Fixed sign conversion warnings
-    (https://github.com/fmtlib/fmt/pull/1440). Thanks @0x8000-0000.
-
-# 6.1.1 - 2019-12-04
-
--   Fixed shared library build on Windows
-    (https://github.com/fmtlib/fmt/pull/1443,
-    https://github.com/fmtlib/fmt/issues/1445,
-    https://github.com/fmtlib/fmt/pull/1446,
-    https://github.com/fmtlib/fmt/issues/1450).
-    Thanks @egorpugin and @bbolli.
--   Added a missing decimal point in exponent notation with trailing
-    zeros.
--   Removed deprecated `format_arg_store::TYPES`.
-
-# 6.1.0 - 2019-12-01
-
--   {fmt} now formats IEEE 754 `float` and `double` using the shortest
-    decimal representation with correct rounding by default:
-
-    ```c++
-    #include <cmath>
-    #include <fmt/core.h>
-
-    int main() {
-      fmt::print("{}", M_PI);
-    }
-    ```
-
-    prints `3.141592653589793`.
-
--   Made the fast binary to decimal floating-point formatter the
-    default, simplified it and improved performance. {fmt} is now 15
-    times faster than libc++\'s `std::ostringstream`, 11 times faster
-    than `printf` and 10% faster than double-conversion on
-    [dtoa-benchmark](https://github.com/fmtlib/dtoa-benchmark):
-
-    | Function      | Time (ns) | Speedup |
-    | ------------- | --------: | ------: |
-    | ostringstream | 1,346.30  | 1.00x   |
-    | ostrstream    | 1,195.74  | 1.13x   |
-    | sprintf       | 995.08    | 1.35x   |
-    | doubleconv    | 99.10     | 13.59x  |
-    | fmt           | 88.34     | 15.24x  |
-
-    ![](https://user-images.githubusercontent.com/576385/69767160-cdaca400-112f-11ea-9fc5-347c9f83caad.png)
-
--   {fmt} no longer converts `float` arguments to `double`. In
-    particular this improves the default (shortest) representation of
-    floats and makes `fmt::format` consistent with `std::format` specs
-    (https://github.com/fmtlib/fmt/issues/1336,
-    https://github.com/fmtlib/fmt/issues/1353,
-    https://github.com/fmtlib/fmt/pull/1360,
-    https://github.com/fmtlib/fmt/pull/1361):
-
-    ```c++
-    fmt::print("{}", 0.1f);
-    ```
-
-    prints `0.1` instead of `0.10000000149011612`.
-
-    Thanks @orivej.
-
--   Made floating-point formatting output consistent with
-    `printf`/iostreams
-    (https://github.com/fmtlib/fmt/issues/1376,
-    https://github.com/fmtlib/fmt/issues/1417).
-
--   Added support for 128-bit integers
-    (https://github.com/fmtlib/fmt/pull/1287):
-
-    ```c++
-    fmt::print("{}", std::numeric_limits<__int128_t>::max());
-    ```
-
-    prints `170141183460469231731687303715884105727`.
-
-    Thanks @denizevrenci.
-
--   The overload of `print` that takes `text_style` is now atomic, i.e.
-    the output from different threads doesn\'t interleave
-    (https://github.com/fmtlib/fmt/pull/1351). Thanks @tankiJong.
-
--   Made compile time in the header-only mode \~20% faster by reducing
-    the number of template instantiations. `wchar_t` overload of
-    `vprint` was moved from `fmt/core.h` to `fmt/format.h`.
-
--   Added an overload of `fmt::join` that works with tuples
-    (https://github.com/fmtlib/fmt/issues/1322,
-    https://github.com/fmtlib/fmt/pull/1330):
-
-    ```c++
-    #include <tuple>
-    #include <fmt/ranges.h>
-
-    int main() {
-      std::tuple<char, int, float> t{'a', 1, 2.0f};
-      fmt::print("{}", t);
-    }
-    ```
-
-    prints `('a', 1, 2.0)`.
-
-    Thanks @jeremyong.
-
--   Changed formatting of octal zero with prefix from \"00\" to \"0\":
-
-    ```c++
-    fmt::print("{:#o}", 0);
-    ```
-
-    prints `0`.
-
--   The locale is now passed to ostream insertion (`<<`) operators
-    (https://github.com/fmtlib/fmt/pull/1406):
-
-    ```c++
-    #include <fmt/locale.h>
-    #include <fmt/ostream.h>
-
-    struct S {
-      double value;
-    };
-
-    std::ostream& operator<<(std::ostream& os, S s) {
-      return os << s.value;
-    }
-
-    int main() {
-      auto s = fmt::format(std::locale("fr_FR.UTF-8"), "{}", S{0.42});
-      // s == "0,42"
-    }
-    ```
-
-    Thanks @dlaugt.
-
--   Locale-specific number formatting now uses grouping
-    (https://github.com/fmtlib/fmt/issues/1393,
-    https://github.com/fmtlib/fmt/pull/1394). Thanks @skrdaniel.
-
--   Fixed handling of types with deleted implicit rvalue conversion to
-    `const char**` (https://github.com/fmtlib/fmt/issues/1421):
-
-    ```c++
-    struct mystring {
-      operator const char*() const&;
-      operator const char*() &;
-      operator const char*() const&& = delete;
-      operator const char*() && = delete;
-    };
-    mystring str;
-    fmt::print("{}", str); // now compiles
-    ```
-
--   Enums are now mapped to correct underlying types instead of `int`
-    (https://github.com/fmtlib/fmt/pull/1286). Thanks @agmt.
-
--   Enum classes are no longer implicitly converted to `int`
-    (https://github.com/fmtlib/fmt/issues/1424).
-
--   Added `basic_format_parse_context` for consistency with C++20
-    `std::format` and deprecated `basic_parse_context`.
-
--   Fixed handling of UTF-8 in precision
-    (https://github.com/fmtlib/fmt/issues/1389,
-    https://github.com/fmtlib/fmt/pull/1390). Thanks @tajtiattila.
-
--   {fmt} can now be installed on Linux, macOS and Windows with
-    [Conda](https://docs.conda.io/en/latest/) using its
-    [conda-forge](https://conda-forge.org)
-    [package](https://github.com/conda-forge/fmt-feedstock)
-    (https://github.com/fmtlib/fmt/pull/1410):
-
-        conda install -c conda-forge fmt
-
-    Thanks @tdegeus.
-
--   Added a CUDA test (https://github.com/fmtlib/fmt/pull/1285,
-    https://github.com/fmtlib/fmt/pull/1317).
-    Thanks @luncliff and @risa2000.
-
--   Improved documentation
-    (https://github.com/fmtlib/fmt/pull/1276,
-    https://github.com/fmtlib/fmt/issues/1291,
-    https://github.com/fmtlib/fmt/issues/1296,
-    https://github.com/fmtlib/fmt/pull/1315,
-    https://github.com/fmtlib/fmt/pull/1332,
-    https://github.com/fmtlib/fmt/pull/1337,
-    https://github.com/fmtlib/fmt/issues/1395
-    https://github.com/fmtlib/fmt/pull/1418).
-    Thanks @waywardmonkeys, @pauldreik and @jackoalan.
-
--   Various code improvements
-    (https://github.com/fmtlib/fmt/pull/1358,
-    https://github.com/fmtlib/fmt/pull/1407).
-    Thanks @orivej and @dpacbach.
-
--   Fixed compile-time format string checks for user-defined types
-    (https://github.com/fmtlib/fmt/issues/1292).
-
--   Worked around a false positive in `unsigned-integer-overflow` sanitizer
-    (https://github.com/fmtlib/fmt/issues/1377).
-
--   Fixed various warnings and compilation issues
-    (https://github.com/fmtlib/fmt/issues/1273,
-    https://github.com/fmtlib/fmt/pull/1278,
-    https://github.com/fmtlib/fmt/pull/1280,
-    https://github.com/fmtlib/fmt/issues/1281,
-    https://github.com/fmtlib/fmt/issues/1288,
-    https://github.com/fmtlib/fmt/pull/1290,
-    https://github.com/fmtlib/fmt/pull/1301,
-    https://github.com/fmtlib/fmt/issues/1305,
-    https://github.com/fmtlib/fmt/issues/1306,
-    https://github.com/fmtlib/fmt/issues/1309,
-    https://github.com/fmtlib/fmt/pull/1312,
-    https://github.com/fmtlib/fmt/issues/1313,
-    https://github.com/fmtlib/fmt/issues/1316,
-    https://github.com/fmtlib/fmt/issues/1319,
-    https://github.com/fmtlib/fmt/pull/1320,
-    https://github.com/fmtlib/fmt/pull/1326,
-    https://github.com/fmtlib/fmt/pull/1328,
-    https://github.com/fmtlib/fmt/issues/1344,
-    https://github.com/fmtlib/fmt/pull/1345,
-    https://github.com/fmtlib/fmt/pull/1347,
-    https://github.com/fmtlib/fmt/pull/1349,
-    https://github.com/fmtlib/fmt/issues/1354,
-    https://github.com/fmtlib/fmt/issues/1362,
-    https://github.com/fmtlib/fmt/issues/1366,
-    https://github.com/fmtlib/fmt/pull/1364,
-    https://github.com/fmtlib/fmt/pull/1370,
-    https://github.com/fmtlib/fmt/pull/1371,
-    https://github.com/fmtlib/fmt/issues/1385,
-    https://github.com/fmtlib/fmt/issues/1388,
-    https://github.com/fmtlib/fmt/pull/1397,
-    https://github.com/fmtlib/fmt/pull/1414,
-    https://github.com/fmtlib/fmt/pull/1416,
-    https://github.com/fmtlib/fmt/issues/1422
-    https://github.com/fmtlib/fmt/pull/1427,
-    https://github.com/fmtlib/fmt/issues/1431,
-    https://github.com/fmtlib/fmt/pull/1433).
-    Thanks @hhb, @gsjaardema, @gabime, @neheb, @vedranmiletic, @dkavolis,
-    @mwinterb, @orivej, @denizevrenci, @leonklingele, @chronoxor, @kent-tri,
-    @0x8000-0000 and @marti4d.
-
-# 6.0.0 - 2019-08-26
-
--   Switched to the [MIT license](
-    https://github.com/fmtlib/fmt/blob/5a4b24613ba16cc689977c3b5bd8274a3ba1dd1f/LICENSE.rst)
-    with an optional exception that allows distributing binary code
-    without attribution.
-
--   Floating-point formatting is now locale-independent by default:
-
-    ```c++
-    #include <locale>
-    #include <fmt/core.h>
-
-    int main() {
-      std::locale::global(std::locale("ru_RU.UTF-8"));
-      fmt::print("value = {}", 4.2);
-    }
-    ```
-
-    prints \"value = 4.2\" regardless of the locale.
-
-    For locale-specific formatting use the `n` specifier:
-
-    ```c++
+- Enabled compile-time format string checks by default. For example
+  ([godbolt](https://godbolt.org/z/sMxcohGjz)):
+
+  ```c++
+  #include <fmt/core.h>
+
+  int main() {
+    fmt::print("{:d}", "I am not a number");
+  }
+  ```
+
+  gives a compile-time error on compilers with C++20 `consteval`
+  support (gcc 10+, clang 11+) because `d` is not a valid format
+  specifier for a string.
+
+  To pass a runtime string wrap it in `fmt::runtime`:
+
+  ```c++
+  fmt::print(fmt::runtime("{:d}"), "I am not a number");
+  ```
+
+- Added compile-time formatting
+  (https://github.com/fmtlib/fmt/pull/2019,
+  https://github.com/fmtlib/fmt/pull/2044,
+  https://github.com/fmtlib/fmt/pull/2056,
+  https://github.com/fmtlib/fmt/pull/2072,
+  https://github.com/fmtlib/fmt/pull/2075,
+  https://github.com/fmtlib/fmt/issues/2078,
+  https://github.com/fmtlib/fmt/pull/2129,
+  https://github.com/fmtlib/fmt/pull/2326). For example
+  ([godbolt](https://godbolt.org/z/Mxx9d89jM)):
+
+  ```c++
+  #include <fmt/compile.h>
+
+  consteval auto compile_time_itoa(int value) -> std::array<char, 10> {
+    auto result = std::array<char, 10>();
+    fmt::format_to(result.data(), FMT_COMPILE("{}"), value);
+    return result;
+  }
+
+  constexpr auto answer = compile_time_itoa(42);
+  ```
+
+  Most of the formatting functionality is available at compile time
+  with a notable exception of floating-point numbers and pointers.
+  Thanks @alexezeder.
+
+- Optimized handling of format specifiers during format string
+  compilation. For example, hexadecimal formatting (`"{:x}"`) is now
+  3-7x faster than before when using `format_to` with format string
+  compilation and a stack-allocated buffer
+  (https://github.com/fmtlib/fmt/issues/1944).
+
+  Before (7.1.3):
+
+      ----------------------------------------------------------------------------
+      Benchmark                                  Time             CPU   Iterations
+      ----------------------------------------------------------------------------
+      FMTCompileOld/0                         15.5 ns         15.5 ns     43302898
+      FMTCompileOld/42                        16.6 ns         16.6 ns     43278267
+      FMTCompileOld/273123                    18.7 ns         18.6 ns     37035861
+      FMTCompileOld/9223372036854775807       19.4 ns         19.4 ns     35243000
+      ----------------------------------------------------------------------------
+
+  After (8.x):
+
+      ----------------------------------------------------------------------------
+      Benchmark                                  Time             CPU   Iterations
+      ----------------------------------------------------------------------------
+      FMTCompileNew/0                         1.99 ns         1.99 ns    360523686
+      FMTCompileNew/42                        2.33 ns         2.33 ns    279865664
+      FMTCompileNew/273123                    3.72 ns         3.71 ns    190230315
+      FMTCompileNew/9223372036854775807       5.28 ns         5.26 ns    130711631
+      ----------------------------------------------------------------------------
+
+  It is even faster than `std::to_chars` from libc++ compiled with
+  clang on macOS:
+
+      ----------------------------------------------------------------------------
+      Benchmark                                  Time             CPU   Iterations
+      ----------------------------------------------------------------------------
+      ToChars/0                               4.42 ns         4.41 ns    160196630
+      ToChars/42                              5.00 ns         4.98 ns    140735201
+      ToChars/273123                          7.26 ns         7.24 ns     95784130
+      ToChars/9223372036854775807             8.77 ns         8.75 ns     75872534
+      ----------------------------------------------------------------------------
+
+  In other cases, especially involving `std::string` construction, the
+  speed up is usually lower because handling format specifiers takes a
+  smaller fraction of the total time.
+
+- Added the `_cf` user-defined literal to represent a compiled format
+  string. It can be used instead of the `FMT_COMPILE` macro
+  (https://github.com/fmtlib/fmt/pull/2043,
+  https://github.com/fmtlib/fmt/pull/2242):
+
+  ```c++
+  #include <fmt/compile.h>
+
+  using namespace fmt::literals;
+  auto s = fmt::format(FMT_COMPILE("{}"), 42); // ð not modern
+  auto s = fmt::format("{}"_cf, 42);           // ð modern as hell
+  ```
+
+  It requires compiler support for class types in non-type template
+  parameters (a C++20 feature) which is available in GCC 9.3+.
+  Thanks @alexezeder.
+
+- Format string compilation now requires `format` functions of
+  `formatter` specializations for user-defined types to be `const`:
+
+  ```c++
+  template <> struct fmt::formatter<my_type>: formatter<string_view> {
+    template <typename FormatContext>
+    auto format(my_type obj, FormatContext& ctx) const {  // Note const here.
+      // ...
+    }
+  };
+  ```
+
+- Added UDL-based named argument support to format string compilation
+  (https://github.com/fmtlib/fmt/pull/2243,
+  https://github.com/fmtlib/fmt/pull/2281). For example:
+
+  ```c++
+  #include <fmt/compile.h>
+
+  using namespace fmt::literals;
+  auto s = fmt::format(FMT_COMPILE("{answer}"), "answer"_a = 42);
+  ```
+
+  Here the argument named \"answer\" is resolved at compile time with
+  no runtime overhead. Thanks @alexezeder.
+
+- Added format string compilation support to `fmt::print`
+  (https://github.com/fmtlib/fmt/issues/2280,
+  https://github.com/fmtlib/fmt/pull/2304). Thanks @alexezeder.
+
+- Added initial support for compiling {fmt} as a C++20 module
+  (https://github.com/fmtlib/fmt/pull/2235,
+  https://github.com/fmtlib/fmt/pull/2240,
+  https://github.com/fmtlib/fmt/pull/2260,
+  https://github.com/fmtlib/fmt/pull/2282,
+  https://github.com/fmtlib/fmt/pull/2283,
+  https://github.com/fmtlib/fmt/pull/2288,
+  https://github.com/fmtlib/fmt/pull/2298,
+  https://github.com/fmtlib/fmt/pull/2306,
+  https://github.com/fmtlib/fmt/pull/2307,
+  https://github.com/fmtlib/fmt/pull/2309,
+  https://github.com/fmtlib/fmt/pull/2318,
+  https://github.com/fmtlib/fmt/pull/2324,
+  https://github.com/fmtlib/fmt/pull/2332,
+  https://github.com/fmtlib/fmt/pull/2340). Thanks @DanielaE.
+
+- Made symbols private by default reducing shared library size
+  (https://github.com/fmtlib/fmt/pull/2301). For example
+  there was a \~15% reported reduction on one platform. Thanks @sergiud.
+
+- Optimized includes making the result of preprocessing `fmt/format.h`
+  \~20% smaller with libstdc++/C++20 and slightly improving build
+  times (https://github.com/fmtlib/fmt/issues/1998).
+
+- Added support of ranges with non-const `begin` / `end`
+  (https://github.com/fmtlib/fmt/pull/1953). Thanks @kitegi.
+
+- Added support of `std::byte` and other formattable types to
+  `fmt::join` (https://github.com/fmtlib/fmt/issues/1981,
+  https://github.com/fmtlib/fmt/issues/2040,
+  https://github.com/fmtlib/fmt/pull/2050,
+  https://github.com/fmtlib/fmt/issues/2262). For example:
+
+  ```c++
+  #include <fmt/format.h>
+  #include <cstddef>
+  #include <vector>
+
+  int main() {
+    auto bytes = std::vector{std::byte(4), std::byte(2)};
+    fmt::print("{}", fmt::join(bytes, ""));
+  }
+  ```
+
+  prints \"42\".
+
+  Thanks @kamibo.
+
+- Implemented the default format for `std::chrono::system_clock`
+  (https://github.com/fmtlib/fmt/issues/2319,
+  https://github.com/fmtlib/fmt/pull/2345). For example:
+
+  ```c++
+  #include <fmt/chrono.h>
+
+  int main() {
+    fmt::print("{}", std::chrono::system_clock::now());
+  }
+  ```
+
+  prints \"2021-06-18 15:22:00\" (the output depends on the current
+  date and time). Thanks @sunmy2019.
+
+- Made more chrono specifiers locale independent by default. Use the
+  `'L'` specifier to get localized formatting. For example:
+
+  ```c++
+  #include <fmt/chrono.h>
+
+  int main() {
     std::locale::global(std::locale("ru_RU.UTF-8"));
-    fmt::print("value = {:n}", 4.2);
-    ```
-
-    prints \"value = 4,2\".
-
--   Added an experimental Grisu floating-point formatting algorithm
-    implementation (disabled by default). To enable it compile with the
-    `FMT_USE_GRISU` macro defined to 1:
-
-    ```c++
-    #define FMT_USE_GRISU 1
-    #include <fmt/format.h>
-
-    auto s = fmt::format("{}", 4.2); // formats 4.2 using Grisu
-    ```
-
-    With Grisu enabled, {fmt} is 13x faster than `std::ostringstream`
-    (libc++) and 10x faster than `sprintf` on
-    [dtoa-benchmark](https://github.com/fmtlib/dtoa-benchmark) ([full
-    results](https://fmt.dev/unknown_mac64_clang10.0.html)):
-
-    ![](https://user-images.githubusercontent.com/576385/54883977-9fe8c000-4e28-11e9-8bde-272d122e7c52.jpg)
-
--   Separated formatting and parsing contexts for consistency with
-    [C++20 std::format](http://eel.is/c++draft/format), removing the
-    undocumented `basic_format_context::parse_context()` function.
-
--   Added [oss-fuzz](https://github.com/google/oss-fuzz) support
-    (https://github.com/fmtlib/fmt/pull/1199). Thanks @pauldreik.
-
--   `formatter` specializations now always take precedence over
-    `operator<<` (https://github.com/fmtlib/fmt/issues/952):
-
-    ```c++
-    #include <iostream>
-    #include <fmt/ostream.h>
-
-    struct S {};
-
-    std::ostream& operator<<(std::ostream& os, S) {
-      return os << 1;
-    }
-
-    template <>
-    struct fmt::formatter<S> : fmt::formatter<int> {
-      auto format(S, format_context& ctx) {
-        return formatter<int>::format(2, ctx);
-      }
-    };
-
-    int main() {
-      std::cout << S() << "\n"; // prints 1 using operator<<
-      fmt::print("{}\n", S());  // prints 2 using formatter
-    }
-    ```
-
--   Introduced the experimental `fmt::compile` function that does format
-    string compilation
-    (https://github.com/fmtlib/fmt/issues/618,
-    https://github.com/fmtlib/fmt/issues/1169,
-    https://github.com/fmtlib/fmt/pull/1171):
-
-    ```c++
-    #include <fmt/compile.h>
-
-    auto f = fmt::compile<int>("{}");
-    std::string s = fmt::format(f, 42); // can be called multiple times to
-                                        // format different values
-    // s == "42"
-    ```
-
-    It moves the cost of parsing a format string outside of the format
-    function which can be beneficial when identically formatting many
-    objects of the same types. Thanks @stryku.
-
--   Added experimental `%` format specifier that formats floating-point
-    values as percentages
-    (https://github.com/fmtlib/fmt/pull/1060,
-    https://github.com/fmtlib/fmt/pull/1069,
-    https://github.com/fmtlib/fmt/pull/1071):
-
-    ```c++
-    auto s = fmt::format("{:.1%}", 0.42); // s == "42.0%"
-    ```
-
-    Thanks @gawain-bolton.
-
--   Implemented precision for floating-point durations
-    (https://github.com/fmtlib/fmt/issues/1004,
-    https://github.com/fmtlib/fmt/pull/1012):
-
-    ```c++
-    auto s = fmt::format("{:.1}", std::chrono::duration<double>(1.234));
-    // s == 1.2s
-    ```
-
-    Thanks @DanielaE.
-
--   Implemented `chrono` format specifiers `%Q` and `%q` that give the
-    value and the unit respectively
-    (https://github.com/fmtlib/fmt/pull/1019):
-
-    ```c++
-    auto value = fmt::format("{:%Q}", 42s); // value == "42"
-    auto unit  = fmt::format("{:%q}", 42s); // unit == "s"
-    ```
-
-    Thanks @DanielaE.
-
--   Fixed handling of dynamic width in chrono formatter:
-
-    ```c++
-    auto s = fmt::format("{0:{1}%H:%M:%S}", std::chrono::seconds(12345), 12);
-    //                        ^ width argument index                     ^ width
-    // s == "03:25:45    "
-    ```
-
-    Thanks Howard Hinnant.
-
--   Removed deprecated `fmt/time.h`. Use `fmt/chrono.h` instead.
-
--   Added `fmt::format` and `fmt::vformat` overloads that take
-    `text_style` (https://github.com/fmtlib/fmt/issues/993,
-    https://github.com/fmtlib/fmt/pull/994):
-
-    ```c++
-    #include <fmt/color.h>
-
-    std::string message = fmt::format(fmt::emphasis::bold | fg(fmt::color::red),
-                                      "The answer is {}.", 42);
-    ```
-
-    Thanks @Naios.
-
--   Removed the deprecated color API (`print_colored`). Use the new API,
-    namely `print` overloads that take `text_style` instead.
-
--   Made `std::unique_ptr` and `std::shared_ptr` formattable as pointers
-    via `fmt::ptr` (https://github.com/fmtlib/fmt/pull/1121):
-
-    ```c++
-    std::unique_ptr<int> p = ...;
-    fmt::print("{}", fmt::ptr(p)); // prints p as a pointer
-    ```
-
-    Thanks @sighingnow.
-
--   Made `print` and `vprint` report I/O errors
-    (https://github.com/fmtlib/fmt/issues/1098,
-    https://github.com/fmtlib/fmt/pull/1099). Thanks @BillyDonahue.
-
--   Marked deprecated APIs with the `[[deprecated]]` attribute and
-    removed internal uses of deprecated APIs
-    (https://github.com/fmtlib/fmt/pull/1022). Thanks @eliaskosunen.
-
--   Modernized the codebase using more C++11 features and removing
-    workarounds. Most importantly, `buffer_context` is now an alias
-    template, so use `buffer_context<T>` instead of
-    `buffer_context<T>::type`. These features require GCC 4.8 or later.
-
--   `formatter` specializations now always take precedence over implicit
-    conversions to `int` and the undocumented `convert_to_int` trait is
-    now deprecated.
-
--   Moved the undocumented `basic_writer`, `writer`, and `wwriter` types
-    to the `internal` namespace.
-
--   Removed deprecated `basic_format_context::begin()`. Use `out()`
-    instead.
-
--   Disallowed passing the result of `join` as an lvalue to prevent
-    misuse.
-
--   Refactored the undocumented structs that represent parsed format
-    specifiers to simplify the API and allow multibyte fill.
-
--   Moved SFINAE to template parameters to reduce symbol sizes.
-
--   Switched to `fputws` for writing wide strings so that it\'s no
-    longer required to call `_setmode` on Windows
-    (https://github.com/fmtlib/fmt/issues/1229,
-    https://github.com/fmtlib/fmt/pull/1243). Thanks @jackoalan.
-
--   Improved literal-based API
-    (https://github.com/fmtlib/fmt/pull/1254). Thanks @sylveon.
-
--   Added support for exotic platforms without `uintptr_t` such as IBM i
-    (AS/400) which has 128-bit pointers and only 64-bit integers
-    (https://github.com/fmtlib/fmt/issues/1059).
-
--   Added [Sublime Text syntax highlighting config](
-    https://github.com/fmtlib/fmt/blob/master/support/C%2B%2B.sublime-syntax)
-    (https://github.com/fmtlib/fmt/issues/1037). Thanks @Kronuz.
-
--   Added the `FMT_ENFORCE_COMPILE_STRING` macro to enforce the use of
-    compile-time format strings
-    (https://github.com/fmtlib/fmt/pull/1231). Thanks @jackoalan.
-
--   Stopped setting `CMAKE_BUILD_TYPE` if {fmt} is a subproject
-    (https://github.com/fmtlib/fmt/issues/1081).
-
--   Various build improvements
-    (https://github.com/fmtlib/fmt/pull/1039,
-    https://github.com/fmtlib/fmt/pull/1078,
-    https://github.com/fmtlib/fmt/pull/1091,
-    https://github.com/fmtlib/fmt/pull/1103,
-    https://github.com/fmtlib/fmt/pull/1177).
-    Thanks @luncliff, @jasonszang, @olafhering, @Lecetem and @pauldreik.
-
--   Improved documentation
-    (https://github.com/fmtlib/fmt/issues/1049,
-    https://github.com/fmtlib/fmt/pull/1051,
-    https://github.com/fmtlib/fmt/pull/1083,
-    https://github.com/fmtlib/fmt/pull/1113,
-    https://github.com/fmtlib/fmt/pull/1114,
-    https://github.com/fmtlib/fmt/issues/1146,
-    https://github.com/fmtlib/fmt/issues/1180,
-    https://github.com/fmtlib/fmt/pull/1250,
-    https://github.com/fmtlib/fmt/pull/1252,
-    https://github.com/fmtlib/fmt/pull/1265).
-    Thanks @mikelui, @foonathan, @BillyDonahue, @jwakely, @kaisbe and
-    @sdebionne.
-
--   Fixed ambiguous formatter specialization in `fmt/ranges.h`
-    (https://github.com/fmtlib/fmt/issues/1123).
-
--   Fixed formatting of a non-empty `std::filesystem::path` which is an
-    infinitely deep range of its components
-    (https://github.com/fmtlib/fmt/issues/1268).
-
--   Fixed handling of general output iterators when formatting
-    characters (https://github.com/fmtlib/fmt/issues/1056,
-    https://github.com/fmtlib/fmt/pull/1058). Thanks @abolz.
-
--   Fixed handling of output iterators in `formatter` specialization for
-    ranges (https://github.com/fmtlib/fmt/issues/1064).
-
--   Fixed handling of exotic character types
-    (https://github.com/fmtlib/fmt/issues/1188).
-
--   Made chrono formatting work with exceptions disabled
-    (https://github.com/fmtlib/fmt/issues/1062).
-
--   Fixed DLL visibility issues
-    (https://github.com/fmtlib/fmt/pull/1134,
-    https://github.com/fmtlib/fmt/pull/1147). Thanks @denchat.
-
--   Disabled the use of UDL template extension on GCC 9
-    (https://github.com/fmtlib/fmt/issues/1148).
-
--   Removed misplaced `format` compile-time checks from `printf`
-    (https://github.com/fmtlib/fmt/issues/1173).
-
--   Fixed issues in the experimental floating-point formatter
-    (https://github.com/fmtlib/fmt/issues/1072,
-    https://github.com/fmtlib/fmt/issues/1129,
-    https://github.com/fmtlib/fmt/issues/1153,
-    https://github.com/fmtlib/fmt/pull/1155,
-    https://github.com/fmtlib/fmt/issues/1210,
-    https://github.com/fmtlib/fmt/issues/1222). Thanks @alabuzhev.
-
--   Fixed bugs discovered by fuzzing or during fuzzing integration
-    (https://github.com/fmtlib/fmt/issues/1124,
-    https://github.com/fmtlib/fmt/issues/1127,
-    https://github.com/fmtlib/fmt/issues/1132,
-    https://github.com/fmtlib/fmt/pull/1135,
-    https://github.com/fmtlib/fmt/issues/1136,
-    https://github.com/fmtlib/fmt/issues/1141,
-    https://github.com/fmtlib/fmt/issues/1142,
-    https://github.com/fmtlib/fmt/issues/1178,
-    https://github.com/fmtlib/fmt/issues/1179,
-    https://github.com/fmtlib/fmt/issues/1194). Thanks @pauldreik.
-
--   Fixed building tests on FreeBSD and Hurd
-    (https://github.com/fmtlib/fmt/issues/1043). Thanks @jackyf.
-
--   Fixed various warnings and compilation issues
-    (https://github.com/fmtlib/fmt/pull/998,
-    https://github.com/fmtlib/fmt/pull/1006,
-    https://github.com/fmtlib/fmt/issues/1008,
-    https://github.com/fmtlib/fmt/issues/1011,
-    https://github.com/fmtlib/fmt/issues/1025,
-    https://github.com/fmtlib/fmt/pull/1027,
-    https://github.com/fmtlib/fmt/pull/1028,
-    https://github.com/fmtlib/fmt/pull/1029,
-    https://github.com/fmtlib/fmt/pull/1030,
-    https://github.com/fmtlib/fmt/pull/1031,
-    https://github.com/fmtlib/fmt/pull/1054,
-    https://github.com/fmtlib/fmt/issues/1063,
-    https://github.com/fmtlib/fmt/pull/1068,
-    https://github.com/fmtlib/fmt/pull/1074,
-    https://github.com/fmtlib/fmt/pull/1075,
-    https://github.com/fmtlib/fmt/pull/1079,
-    https://github.com/fmtlib/fmt/pull/1086,
-    https://github.com/fmtlib/fmt/issues/1088,
-    https://github.com/fmtlib/fmt/pull/1089,
-    https://github.com/fmtlib/fmt/pull/1094,
-    https://github.com/fmtlib/fmt/issues/1101,
-    https://github.com/fmtlib/fmt/pull/1102,
-    https://github.com/fmtlib/fmt/issues/1105,
-    https://github.com/fmtlib/fmt/pull/1107,
-    https://github.com/fmtlib/fmt/issues/1115,
-    https://github.com/fmtlib/fmt/issues/1117,
-    https://github.com/fmtlib/fmt/issues/1118,
-    https://github.com/fmtlib/fmt/issues/1120,
-    https://github.com/fmtlib/fmt/issues/1123,
-    https://github.com/fmtlib/fmt/pull/1139,
-    https://github.com/fmtlib/fmt/issues/1140,
-    https://github.com/fmtlib/fmt/issues/1143,
-    https://github.com/fmtlib/fmt/pull/1144,
-    https://github.com/fmtlib/fmt/pull/1150,
-    https://github.com/fmtlib/fmt/pull/1151,
-    https://github.com/fmtlib/fmt/issues/1152,
-    https://github.com/fmtlib/fmt/issues/1154,
-    https://github.com/fmtlib/fmt/issues/1156,
-    https://github.com/fmtlib/fmt/pull/1159,
-    https://github.com/fmtlib/fmt/issues/1175,
-    https://github.com/fmtlib/fmt/issues/1181,
-    https://github.com/fmtlib/fmt/issues/1186,
-    https://github.com/fmtlib/fmt/pull/1187,
-    https://github.com/fmtlib/fmt/pull/1191,
-    https://github.com/fmtlib/fmt/issues/1197,
-    https://github.com/fmtlib/fmt/issues/1200,
-    https://github.com/fmtlib/fmt/issues/1203,
-    https://github.com/fmtlib/fmt/issues/1205,
-    https://github.com/fmtlib/fmt/pull/1206,
-    https://github.com/fmtlib/fmt/issues/1213,
-    https://github.com/fmtlib/fmt/issues/1214,
-    https://github.com/fmtlib/fmt/pull/1217,
-    https://github.com/fmtlib/fmt/issues/1228,
-    https://github.com/fmtlib/fmt/pull/1230,
-    https://github.com/fmtlib/fmt/issues/1232,
-    https://github.com/fmtlib/fmt/pull/1235,
-    https://github.com/fmtlib/fmt/pull/1236,
-    https://github.com/fmtlib/fmt/issues/1240).
-    Thanks @DanielaE, @mwinterb, @eliaskosunen, @morinmorin, @ricco19,
-    @waywardmonkeys, @chronoxor, @remyabel, @pauldreik, @gsjaardema, @rcane,
-    @mocabe, @denchat, @cjdb, @HazardyKnusperkeks, @vedranmiletic, @jackoalan,
-    @DaanDeMeyer and @starkmapper.
-
-# 5.3.0 - 2018-12-28
-
--   Introduced experimental chrono formatting support:
-
-    ```c++
-    #include <fmt/chrono.h>
-
-    int main() {
-      using namespace std::literals::chrono_literals;
-      fmt::print("Default format: {} {}\n", 42s, 100ms);
-      fmt::print("strftime-like format: {:%H:%M:%S}\n", 3h + 15min + 30s);
-    }
-    ```
-
-    prints:
-
-        Default format: 42s 100ms
-        strftime-like format: 03:15:30
-
--   Added experimental support for emphasis (bold, italic, underline,
-    strikethrough), colored output to a file stream, and improved
-    colored formatting API
-    (https://github.com/fmtlib/fmt/pull/961,
-    https://github.com/fmtlib/fmt/pull/967,
-    https://github.com/fmtlib/fmt/pull/973):
-
-    ```c++
-    #include <fmt/color.h>
-
-    int main() {
-      print(fg(fmt::color::crimson) | fmt::emphasis::bold,
-            "Hello, {}!\n", "world");
-      print(fg(fmt::color::floral_white) | bg(fmt::color::slate_gray) |
-            fmt::emphasis::underline, "Hello, {}!\n", "Ð¼Ð¸Ñ");
-      print(fg(fmt::color::steel_blue) | fmt::emphasis::italic,
-            "Hello, {}!\n", "ä¸ç");
-    }
-    ```
-
-    prints the following on modern terminals with RGB color support:
-
-    ![](https://user-images.githubusercontent.com/576385/50405788-b66e7500-076e-11e9-9592-7324d1f951d8.png)
-
-    Thanks @Rakete1111.
-
--   Added support for 4-bit terminal colors
-    (https://github.com/fmtlib/fmt/issues/968,
-    https://github.com/fmtlib/fmt/pull/974)
-
-    ```c++
-    #include <fmt/color.h>
-
-    int main() {
-      print(fg(fmt::terminal_color::red), "stop\n");
-    }
-    ```
-
-    Note that these colors vary by terminal:
-
-    ![](https://user-images.githubusercontent.com/576385/50405925-dbfc7e00-0770-11e9-9b85-333fab0af9ac.png)
-
-    Thanks @Rakete1111.
-
--   Parameterized formatting functions on the type of the format string
-    (https://github.com/fmtlib/fmt/issues/880,
-    https://github.com/fmtlib/fmt/pull/881,
-    https://github.com/fmtlib/fmt/pull/883,
-    https://github.com/fmtlib/fmt/pull/885,
-    https://github.com/fmtlib/fmt/pull/897,
-    https://github.com/fmtlib/fmt/issues/920). Any object of
-    type `S` that has an overloaded `to_string_view(const S&)` returning
-    `fmt::string_view` can be used as a format string:
-
-    ```c++
-    namespace my_ns {
-    inline string_view to_string_view(const my_string& s) {
-      return {s.data(), s.length()};
-    }
-    }
-
-    std::string message = fmt::format(my_string("The answer is {}."), 42);
-    ```
-
-    Thanks @DanielaE.
-
--   Made `std::string_view` work as a format string
-    (https://github.com/fmtlib/fmt/pull/898):
-
-    ```c++
-    auto message = fmt::format(std::string_view("The answer is {}."), 42);
-    ```
-
-    Thanks @DanielaE.
-
--   Added wide string support to compile-time format string checks
-    (https://github.com/fmtlib/fmt/pull/924):
-
-    ```c++
-    print(fmt(L"{:f}"), 42); // compile-time error: invalid type specifier
-    ```
-
-    Thanks @XZiar.
-
--   Made colored print functions work with wide strings
-    (https://github.com/fmtlib/fmt/pull/867):
-
-    ```c++
-    #include <fmt/color.h>
-
-    int main() {
-      print(fg(fmt::color::red), L"{}\n", 42);
-    }
-    ```
-
-    Thanks @DanielaE.
-
--   Introduced experimental Unicode support
-    (https://github.com/fmtlib/fmt/issues/628,
-    https://github.com/fmtlib/fmt/pull/891):
-
-    ```c++
-    using namespace fmt::literals;
-    auto s = fmt::format("{:*^5}"_u, "ð¤¡"_u); // s == "**ð¤¡**"_u
-    ```
-
--   Improved locale support:
-
-    ```c++
-    #include <fmt/locale.h>
-
-    struct numpunct : std::numpunct<char> {
-     protected:
-      char do_thousands_sep() const override { return '~'; }
-    };
-
-    std::locale loc;
-    auto s = fmt::format(std::locale(loc, new numpunct()), "{:n}", 1234567);
-    // s == "1~234~567"
-    ```
-
--   Constrained formatting functions on proper iterator types
-    (https://github.com/fmtlib/fmt/pull/921). Thanks @DanielaE.
-
--   Added `make_printf_args` and `make_wprintf_args` functions
-    (https://github.com/fmtlib/fmt/pull/934). Thanks @tnovotny.
-
--   Deprecated `fmt::visit`, `parse_context`, and `wparse_context`. Use
-    `fmt::visit_format_arg`, `format_parse_context`, and
-    `wformat_parse_context` instead.
-
--   Removed undocumented `basic_fixed_buffer` which has been superseded
-    by the iterator-based API
-    (https://github.com/fmtlib/fmt/issues/873,
-    https://github.com/fmtlib/fmt/pull/902). Thanks @superfunc.
-
--   Disallowed repeated leading zeros in an argument ID:
-
-    ```c++
-    fmt::print("{000}", 42); // error
-    ```
-
--   Reintroduced support for gcc 4.4.
-
--   Fixed compilation on platforms with exotic `double`
-    (https://github.com/fmtlib/fmt/issues/878).
-
--   Improved documentation
-    (https://github.com/fmtlib/fmt/issues/164,
-    https://github.com/fmtlib/fmt/issues/877,
-    https://github.com/fmtlib/fmt/pull/901,
-    https://github.com/fmtlib/fmt/pull/906,
-    https://github.com/fmtlib/fmt/pull/979).
-    Thanks @kookjr, @DarkDimius and @HecticSerenity.
-
--   Added pkgconfig support which makes it easier to consume the library
-    from meson and other build systems
-    (https://github.com/fmtlib/fmt/pull/916). Thanks @colemickens.
-
--   Various build improvements
-    (https://github.com/fmtlib/fmt/pull/909,
-    https://github.com/fmtlib/fmt/pull/926,
-    https://github.com/fmtlib/fmt/pull/937,
-    https://github.com/fmtlib/fmt/pull/953,
-    https://github.com/fmtlib/fmt/pull/959).
-    Thanks @tchaikov, @luncliff, @AndreasSchoenle, @hotwatermorning and @Zefz.
-
--   Improved `string_view` construction performance
-    (https://github.com/fmtlib/fmt/pull/914). Thanks @gabime.
-
--   Fixed non-matching char types
-    (https://github.com/fmtlib/fmt/pull/895). Thanks @DanielaE.
-
--   Fixed `format_to_n` with `std::back_insert_iterator`
-    (https://github.com/fmtlib/fmt/pull/913). Thanks @DanielaE.
-
--   Fixed locale-dependent formatting
-    (https://github.com/fmtlib/fmt/issues/905).
-
--   Fixed various compiler warnings and errors
-    (https://github.com/fmtlib/fmt/pull/882,
-    https://github.com/fmtlib/fmt/pull/886,
-    https://github.com/fmtlib/fmt/pull/933,
-    https://github.com/fmtlib/fmt/pull/941,
-    https://github.com/fmtlib/fmt/issues/931,
-    https://github.com/fmtlib/fmt/pull/943,
-    https://github.com/fmtlib/fmt/pull/954,
-    https://github.com/fmtlib/fmt/pull/956,
-    https://github.com/fmtlib/fmt/pull/962,
-    https://github.com/fmtlib/fmt/issues/965,
-    https://github.com/fmtlib/fmt/issues/977,
-    https://github.com/fmtlib/fmt/pull/983,
-    https://github.com/fmtlib/fmt/pull/989).
-    Thanks @Luthaf, @stevenhoving, @christinaa, @lgritz, @DanielaE,
-    @0x8000-0000 and @liuping1997.
-
-# 5.2.1 - 2018-09-21
-
--   Fixed `visit` lookup issues on gcc 7 & 8
-    (https://github.com/fmtlib/fmt/pull/870). Thanks @medithe.
--   Fixed linkage errors on older gcc.
--   Prevented `fmt/range.h` from specializing `fmt::basic_string_view`
-    (https://github.com/fmtlib/fmt/issues/865,
-    https://github.com/fmtlib/fmt/pull/868). Thanks @hhggit.
--   Improved error message when formatting unknown types
-    (https://github.com/fmtlib/fmt/pull/872). Thanks @foonathan.
--   Disabled templated user-defined literals when compiled under nvcc
-    (https://github.com/fmtlib/fmt/pull/875). Thanks @CandyGumdrop.
--   Fixed `format_to` formatting to `wmemory_buffer`
-    (https://github.com/fmtlib/fmt/issues/874).
-
-# 5.2.0 - 2018-09-13
-
--   Optimized format string parsing and argument processing which
-    resulted in up to 5x speed up on long format strings and significant
-    performance boost on various benchmarks. For example, version 5.2 is
-    2.22x faster than 5.1 on decimal integer formatting with `format_to`
-    (macOS, clang-902.0.39.2):
-
-    | Method                     | Time, s         | Speedup |
-    | -------------------------- | --------------: | ------: |
-    | fmt::format 5.1            | 0.58            |         |
-    | fmt::format 5.2            | 0.35            |   1.66x |
-    | fmt::format_to 5.1         | 0.51            |         |
-    | fmt::format_to 5.2         | 0.23            |   2.22x |
-    | sprintf                    | 0.71            |         |
-    | std::to_string             | 1.01            |         |
-    | std::stringstream          | 1.73            |         |
-
--   Changed the `fmt` macro from opt-out to opt-in to prevent name
-    collisions. To enable it define the `FMT_STRING_ALIAS` macro to 1
-    before including `fmt/format.h`:
-
-    ```c++
-    #define FMT_STRING_ALIAS 1
-    #include <fmt/format.h>
-    std::string answer = format(fmt("{}"), 42);
-    ```
-
--   Added compile-time format string checks to `format_to` overload that
-    takes `fmt::memory_buffer`
-    (https://github.com/fmtlib/fmt/issues/783):
-
-    ```c++
-    fmt::memory_buffer buf;
-    // Compile-time error: invalid type specifier.
-    fmt::format_to(buf, fmt("{:d}"), "foo");
-    ```
-
--   Moved experimental color support to `fmt/color.h` and enabled the
-    new API by default. The old API can be enabled by defining the
-    `FMT_DEPRECATED_COLORS` macro.
-
--   Added formatting support for types explicitly convertible to
-    `fmt::string_view`:
-
-    ```c++
-    struct foo {
-      explicit operator fmt::string_view() const { return "foo"; }
-    };
-    auto s = format("{}", foo());
-    ```
-
-    In particular, this makes formatting function work with
-    `folly::StringPiece`.
-
--   Implemented preliminary support for `char*_t` by replacing the
-    `format` function overloads with a single function template
-    parameterized on the string type.
-
--   Added support for dynamic argument lists
-    (https://github.com/fmtlib/fmt/issues/814,
-    https://github.com/fmtlib/fmt/pull/819). Thanks @MikePopoloski.
-
--   Reduced executable size overhead for embedded targets using newlib
-    nano by making locale dependency optional
-    (https://github.com/fmtlib/fmt/pull/839). Thanks @teajay-fr.
-
--   Keep `noexcept` specifier when exceptions are disabled
-    (https://github.com/fmtlib/fmt/issues/801,
-    https://github.com/fmtlib/fmt/pull/810). Thanks @qis.
-
--   Fixed formatting of user-defined types providing `operator<<` with
-    `format_to_n` (https://github.com/fmtlib/fmt/pull/806).
-    Thanks @mkurdej.
-
--   Fixed dynamic linkage of new symbols
-    (https://github.com/fmtlib/fmt/issues/808).
-
--   Fixed global initialization issue
-    (https://github.com/fmtlib/fmt/issues/807):
-
-    ```c++
-    // This works on compilers with constexpr support.
-    static const std::string answer = fmt::format("{}", 42);
-    ```
-
--   Fixed various compiler warnings and errors
-    (https://github.com/fmtlib/fmt/pull/804,
-    https://github.com/fmtlib/fmt/issues/809,
-    https://github.com/fmtlib/fmt/pull/811,
-    https://github.com/fmtlib/fmt/issues/822,
-    https://github.com/fmtlib/fmt/pull/827,
-    https://github.com/fmtlib/fmt/issues/830,
-    https://github.com/fmtlib/fmt/pull/838,
-    https://github.com/fmtlib/fmt/issues/843,
-    https://github.com/fmtlib/fmt/pull/844,
-    https://github.com/fmtlib/fmt/issues/851,
-    https://github.com/fmtlib/fmt/pull/852,
-    https://github.com/fmtlib/fmt/pull/854).
-    Thanks @henryiii, @medithe, and @eliasdaler.
-
-# 5.1.0 - 2018-07-05
-
--   Added experimental support for RGB color output enabled with the
-    `FMT_EXTENDED_COLORS` macro:
-
-    ```c++
-    #define FMT_EXTENDED_COLORS
-    #define FMT_HEADER_ONLY // or compile fmt with FMT_EXTENDED_COLORS defined
-    #include <fmt/format.h>
-
-    fmt::print(fmt::color::steel_blue, "Some beautiful text");
-    ```
-
-    The old API (the `print_colored` and `vprint_colored` functions and
-    the `color` enum) is now deprecated.
-    (https://github.com/fmtlib/fmt/issues/762
-    https://github.com/fmtlib/fmt/pull/767). thanks @Remotion.
-
--   Added quotes to strings in ranges and tuples
-    (https://github.com/fmtlib/fmt/pull/766). Thanks @Remotion.
-
--   Made `format_to` work with `basic_memory_buffer`
-    (https://github.com/fmtlib/fmt/issues/776).
-
--   Added `vformat_to_n` and `wchar_t` overload of `format_to_n`
-    (https://github.com/fmtlib/fmt/issues/764,
-    https://github.com/fmtlib/fmt/issues/769).
-
--   Made `is_range` and `is_tuple_like` part of public (experimental)
-    API to allow specialization for user-defined types
-    (https://github.com/fmtlib/fmt/issues/751,
-    https://github.com/fmtlib/fmt/pull/759). Thanks @drrlvn.
-
--   Added more compilers to continuous integration and increased
-    `FMT_PEDANTIC` warning levels
-    (https://github.com/fmtlib/fmt/pull/736). Thanks @eliaskosunen.
-
--   Fixed compilation with MSVC 2013.
-
--   Fixed handling of user-defined types in `format_to`
-    (https://github.com/fmtlib/fmt/issues/793).
-
--   Forced linking of inline `vformat` functions into the library
-    (https://github.com/fmtlib/fmt/issues/795).
-
--   Fixed incorrect call to on_align in `'{:}='`
-    (https://github.com/fmtlib/fmt/issues/750).
-
--   Fixed floating-point formatting to a non-back_insert_iterator with
-    sign & numeric alignment specified
-    (https://github.com/fmtlib/fmt/issues/756).
-
--   Fixed formatting to an array with `format_to_n`
-    (https://github.com/fmtlib/fmt/issues/778).
-
--   Fixed formatting of more than 15 named arguments
-    (https://github.com/fmtlib/fmt/issues/754).
-
--   Fixed handling of compile-time strings when including
-    `fmt/ostream.h`. (https://github.com/fmtlib/fmt/issues/768).
-
--   Fixed various compiler warnings and errors
-    (https://github.com/fmtlib/fmt/issues/742,
-    https://github.com/fmtlib/fmt/issues/748,
-    https://github.com/fmtlib/fmt/issues/752,
-    https://github.com/fmtlib/fmt/issues/770,
-    https://github.com/fmtlib/fmt/pull/775,
-    https://github.com/fmtlib/fmt/issues/779,
-    https://github.com/fmtlib/fmt/pull/780,
-    https://github.com/fmtlib/fmt/pull/790,
-    https://github.com/fmtlib/fmt/pull/792,
-    https://github.com/fmtlib/fmt/pull/800).
-    Thanks @Remotion, @gabime, @foonathan, @Dark-Passenger and @0x8000-0000.
-
-# 5.0.0 - 2018-05-21
-
--   Added a requirement for partial C++11 support, most importantly
-    variadic templates and type traits, and dropped `FMT_VARIADIC_*`
-    emulation macros. Variadic templates are available since GCC 4.4,
-    Clang 2.9 and MSVC 18.0 (2013). For older compilers use {fmt}
-    [version 4.x](https://github.com/fmtlib/fmt/releases/tag/4.1.0)
-    which continues to be maintained and works with C++98 compilers.
-
--   Renamed symbols to follow standard C++ naming conventions and
-    proposed a subset of the library for standardization in [P0645R2
-    Text Formatting](https://wg21.link/P0645).
-
--   Implemented `constexpr` parsing of format strings and [compile-time
-    format string
-    checks](https://fmt.dev/latest/api.html#compile-time-format-string-checks).
-    For example
-
-    ```c++
-    #include <fmt/format.h>
-
-    std::string s = format(fmt("{:d}"), "foo");
-    ```
-
-    gives a compile-time error because `d` is an invalid specifier for
-    strings ([godbolt](https://godbolt.org/g/rnCy9Q)):
-
-        ...
-        <source>:4:19: note: in instantiation of function template specialization 'fmt::v5::format<S, char [4]>' requested here
-          std::string s = format(fmt("{:d}"), "foo");
-                          ^
-        format.h:1337:13: note: non-constexpr function 'on_error' cannot be used in a constant expression
-            handler.on_error("invalid type specifier");
-
-    Compile-time checks require relaxed `constexpr` (C++14 feature)
-    support. If the latter is not available, checks will be performed at
-    runtime.
-
--   Separated format string parsing and formatting in the extension API
-    to enable compile-time format string processing. For example
-
-    ```c++
-    struct Answer {};
-
-    namespace fmt {
-    template <>
-    struct formatter<Answer> {
-      constexpr auto parse(parse_context& ctx) {
-        auto it = ctx.begin();
-        spec = *it;
-        if (spec != 'd' && spec != 's')
-          throw format_error("invalid specifier");
-        return ++it;
-      }
-
-      template <typename FormatContext>
-      auto format(Answer, FormatContext& ctx) {
-        return spec == 's' ?
-          format_to(ctx.begin(), "{}", "fourty-two") :
-          format_to(ctx.begin(), "{}", 42);
-      }
-
-      char spec = 0;
-    };
-    }
-
-    std::string s = format(fmt("{:x}"), Answer());
-    ```
-
-    gives a compile-time error due to invalid format specifier
-    ([godbolt](https://godbolt.org/g/2jQ1Dv)):
-
-        ...
-        <source>:12:45: error: expression '<throw-expression>' is not a constant expression
-               throw format_error("invalid specifier");
-
--   Added [iterator
-    support](https://fmt.dev/latest/api.html#output-iterator-support):
-
-    ```c++
-    #include <vector>
-    #include <fmt/format.h>
-
-    std::vector<char> out;
-    fmt::format_to(std::back_inserter(out), "{}", 42);
-    ```
-
--   Added the
-    [format_to_n](https://fmt.dev/latest/api.html#_CPPv2N3fmt11format_to_nE8OutputItNSt6size_tE11string_viewDpRK4Args)
-    function that restricts the output to the specified number of
-    characters (https://github.com/fmtlib/fmt/issues/298):
-
-    ```c++
-    char out[4];
-    fmt::format_to_n(out, sizeof(out), "{}", 12345);
-    // out == "1234" (without terminating '\0')
-    ```
-
--   Added the [formatted_size](
-    https://fmt.dev/latest/api.html#_CPPv2N3fmt14formatted_sizeE11string_viewDpRK4Args)
-    function for computing the output size:
-
-    ```c++
-    #include <fmt/format.h>
-
-    auto size = fmt::formatted_size("{}", 12345); // size == 5
-    ```
-
--   Improved compile times by reducing dependencies on standard headers
-    and providing a lightweight [core
-    API](https://fmt.dev/latest/api.html#core-api):
-
-    ```c++
-    #include <fmt/core.h>
-
-    fmt::print("The answer is {}.", 42);
-    ```
-
-    See [Compile time and code
-    bloat](https://github.com/fmtlib/fmt#compile-time-and-code-bloat).
-
--   Added the [make_format_args](
-    https://fmt.dev/latest/api.html#_CPPv2N3fmt16make_format_argsEDpRK4Args)
-    function for capturing formatting arguments:
-
-    ```c++
-    // Prints formatted error message.
-    void vreport_error(const char *format, fmt::format_args args) {
-      fmt::print("Error: ");
-      fmt::vprint(format, args);
-    }
-    template <typename... Args>
-    void report_error(const char *format, const Args & ... args) {
-      vreport_error(format, fmt::make_format_args(args...));
-    }
-    ```
-
--   Added the `make_printf_args` function for capturing `printf`
-    arguments (https://github.com/fmtlib/fmt/issues/687,
-    https://github.com/fmtlib/fmt/pull/694). Thanks @Kronuz.
-
--   Added prefix `v` to non-variadic functions taking `format_args` to
-    distinguish them from variadic ones:
-
-    ```c++
-    std::string vformat(string_view format_str, format_args args);
-
-    template <typename... Args>
-    std::string format(string_view format_str, const Args & ... args);
-    ```
-
--   Added experimental support for formatting ranges, containers and
-    tuple-like types in `fmt/ranges.h`
-    (https://github.com/fmtlib/fmt/pull/735):
-
-    ```c++
-    #include <fmt/ranges.h>
-
-    std::vector<int> v = {1, 2, 3};
-    fmt::print("{}", v); // prints {1, 2, 3}
-    ```
-
-    Thanks @Remotion.
+    auto monday = std::chrono::weekday(1);
+    fmt::print("{}\n", monday);   // prints "Mon"
+    fmt::print("{:L}\n", monday); // prints "Ð¿Ð½"
+  }
+  ```
 
--   Implemented `wchar_t` date and time formatting
-    (https://github.com/fmtlib/fmt/pull/712):
+- Improved locale handling in chrono formatting
+  (https://github.com/fmtlib/fmt/issues/2337,
+  https://github.com/fmtlib/fmt/pull/2349,
+  https://github.com/fmtlib/fmt/pull/2350). Thanks @phprus.
 
-    ```c++
-    #include <fmt/time.h>
+- Deprecated `fmt/locale.h` moving the formatting functions that take
+  a locale to `fmt/format.h` (`char`) and `fmt/xchar` (other
+  overloads). This doesn\'t introduce a dependency on `<locale>` so
+  there is virtually no compile time effect.
 
-    std::time_t t = std::time(nullptr);
-    auto s = fmt::format(L"The date is {:%Y-%m-%d}.", *std::localtime(&t));
-    ```
+- Deprecated an undocumented `format_to` overload that takes
+  `basic_memory_buffer`.
 
-    Thanks @DanielaE.
+- Made parameter order in `vformat_to` consistent with `format_to`
+  (https://github.com/fmtlib/fmt/issues/2327).
 
--   Provided more wide string overloads
-    (https://github.com/fmtlib/fmt/pull/724). Thanks @DanielaE.
+- Added support for time points with arbitrary durations
+  (https://github.com/fmtlib/fmt/issues/2208). For example:
 
--   Switched from a custom null-terminated string view class to
-    `string_view` in the format API and provided `fmt::string_view`
-    which implements a subset of `std::string_view` API for pre-C++17
-    systems.
+  ```c++
+  #include <fmt/chrono.h>
 
--   Added support for `std::experimental::string_view`
-    (https://github.com/fmtlib/fmt/pull/607):
+  int main() {
+    using tp = std::chrono::time_point<
+      std::chrono::system_clock, std::chrono::seconds>;
+    fmt::print("{:%S}", tp(std::chrono::seconds(42)));
+  }
+  ```
 
-    ```c++
-    #include <fmt/core.h>
-    #include <experimental/string_view>
+  prints \"42\".
 
-    fmt::print("{}", std::experimental::string_view("foo"));
-    ```
+- Formatting floating-point numbers no longer produces trailing zeros
+  by default for consistency with `std::format`. For example:
 
-    Thanks @virgiliofornazin.
+  ```c++
+  #include <fmt/core.h>
 
--   Allowed mixing named and automatic arguments:
+  int main() {
+    fmt::print("{0:.3}", 1.1);
+  }
+  ```
 
-    ```c++
-    fmt::format("{} {two}", 1, fmt::arg("two", 2));
-    ```
+  prints \"1.1\". Use the `'#'` specifier to keep trailing zeros.
 
--   Removed the write API in favor of the [format
-    API](https://fmt.dev/latest/api.html#format-api) with compile-time
-    handling of format strings.
+- Dropped a limit on the number of elements in a range and replaced
+  `{}` with `[]` as range delimiters for consistency with Python\'s
+  `str.format`.
 
--   Disallowed formatting of multibyte strings into a wide character
-    target (https://github.com/fmtlib/fmt/pull/606).
+- The `'L'` specifier for locale-specific numeric formatting can now
+  be combined with presentation specifiers as in `std::format`. For
+  example:
 
--   Improved documentation
-    (https://github.com/fmtlib/fmt/pull/515,
-    https://github.com/fmtlib/fmt/issues/614,
-    https://github.com/fmtlib/fmt/pull/617,
-    https://github.com/fmtlib/fmt/pull/661,
-    https://github.com/fmtlib/fmt/pull/680).
-    Thanks @ibell, @mihaitodor and @johnthagen.
-
--   Implemented more efficient handling of large number of format
-    arguments.
-
--   Introduced an inline namespace for symbol versioning.
-
--   Added debug postfix `d` to the `fmt` library name
-    (https://github.com/fmtlib/fmt/issues/636).
-
--   Removed unnecessary `fmt/` prefix in includes
-    (https://github.com/fmtlib/fmt/pull/397). Thanks @chronoxor.
-
--   Moved `fmt/*.h` to `include/fmt/*.h` to prevent irrelevant files and
-    directories appearing on the include search paths when fmt is used
-    as a subproject and moved source files to the `src` directory.
-
--   Added qmake project file `support/fmt.pro`
-    (https://github.com/fmtlib/fmt/pull/641). Thanks @cowo78.
-
--   Added Gradle build file `support/build.gradle`
-    (https://github.com/fmtlib/fmt/pull/649). Thanks @luncliff.
-
--   Removed `FMT_CPPFORMAT` CMake option.
-
--   Fixed a name conflict with the macro `CHAR_WIDTH` in glibc
-    (https://github.com/fmtlib/fmt/pull/616). Thanks @aroig.
-
--   Fixed handling of nested braces in `fmt::join`
-    (https://github.com/fmtlib/fmt/issues/638).
-
--   Added `SOURCELINK_SUFFIX` for compatibility with Sphinx 1.5
-    (https://github.com/fmtlib/fmt/pull/497). Thanks @ginggs.
-
--   Added a missing `inline` in the header-only mode
-    (https://github.com/fmtlib/fmt/pull/626). Thanks @aroig.
-
--   Fixed various compiler warnings
-    (https://github.com/fmtlib/fmt/pull/640,
-    https://github.com/fmtlib/fmt/pull/656,
-    https://github.com/fmtlib/fmt/pull/679,
-    https://github.com/fmtlib/fmt/pull/681,
-    https://github.com/fmtlib/fmt/pull/705,
-    https://github.com/fmtlib/fmt/issues/715,
-    https://github.com/fmtlib/fmt/pull/717,
-    https://github.com/fmtlib/fmt/pull/720,
-    https://github.com/fmtlib/fmt/pull/723,
-    https://github.com/fmtlib/fmt/pull/726,
-    https://github.com/fmtlib/fmt/pull/730,
-    https://github.com/fmtlib/fmt/pull/739).
-    Thanks @peterbell10, @LarsGullik, @foonathan, @eliaskosunen,
-    @christianparpart, @DanielaE and @mwinterb.
-
--   Worked around an MSVC bug and fixed several warnings
-    (https://github.com/fmtlib/fmt/pull/653). Thanks @alabuzhev.
-
--   Worked around GCC bug 67371
-    (https://github.com/fmtlib/fmt/issues/682).
-
--   Fixed compilation with `-fno-exceptions`
-    (https://github.com/fmtlib/fmt/pull/655). Thanks @chenxiaolong.
-
--   Made `constexpr remove_prefix` gcc version check tighter
-    (https://github.com/fmtlib/fmt/issues/648).
-
--   Renamed internal type enum constants to prevent collision with
-    poorly written C libraries
-    (https://github.com/fmtlib/fmt/issues/644).
-
--   Added detection of `wostream operator<<`
-    (https://github.com/fmtlib/fmt/issues/650).
-
--   Fixed compilation on OpenBSD
-    (https://github.com/fmtlib/fmt/pull/660). Thanks @hubslave.
-
--   Fixed compilation on FreeBSD 12
-    (https://github.com/fmtlib/fmt/pull/732). Thanks @dankm.
-
--   Fixed compilation when there is a mismatch between `-std` options
-    between the library and user code
-    (https://github.com/fmtlib/fmt/issues/664).
-
--   Fixed compilation with GCC 7 and `-std=c++11`
-    (https://github.com/fmtlib/fmt/issues/734).
-
--   Improved generated binary code on GCC 7 and older
-    (https://github.com/fmtlib/fmt/issues/668).
-
--   Fixed handling of numeric alignment with no width
-    (https://github.com/fmtlib/fmt/issues/675).
-
--   Fixed handling of empty strings in UTF8/16 converters
-    (https://github.com/fmtlib/fmt/pull/676). Thanks @vgalka-sl.
-
--   Fixed formatting of an empty `string_view`
-    (https://github.com/fmtlib/fmt/issues/689).
-
--   Fixed detection of `string_view` on libc++
-    (https://github.com/fmtlib/fmt/issues/686).
-
--   Fixed DLL issues (https://github.com/fmtlib/fmt/pull/696).
-    Thanks @sebkoenig.
-
--   Fixed compile checks for mixing narrow and wide strings
-    (https://github.com/fmtlib/fmt/issues/690).
-
--   Disabled unsafe implicit conversion to `std::string`
-    (https://github.com/fmtlib/fmt/issues/729).
-
--   Fixed handling of reused format specs (as in `fmt::join`) for
-    pointers (https://github.com/fmtlib/fmt/pull/725). Thanks @mwinterb.
-
--   Fixed installation of `fmt/ranges.h`
-    (https://github.com/fmtlib/fmt/pull/738). Thanks @sv1990.
-
-# 4.1.0 - 2017-12-20
-
--   Added `fmt::to_wstring()` in addition to `fmt::to_string()`
-    (https://github.com/fmtlib/fmt/pull/559). Thanks @alabuzhev.
--   Added support for C++17 `std::string_view`
-    (https://github.com/fmtlib/fmt/pull/571 and
-    https://github.com/fmtlib/fmt/pull/578).
-    Thanks @thelostt and @mwinterb.
--   Enabled stream exceptions to catch errors
-    (https://github.com/fmtlib/fmt/issues/581). Thanks @crusader-mike.
--   Allowed formatting of class hierarchies with `fmt::format_arg()`
-    (https://github.com/fmtlib/fmt/pull/547). Thanks @rollbear.
--   Removed limitations on character types
-    (https://github.com/fmtlib/fmt/pull/563). Thanks @Yelnats321.
--   Conditionally enabled use of `std::allocator_traits`
-    (https://github.com/fmtlib/fmt/pull/583). Thanks @mwinterb.
--   Added support for `const` variadic member function emulation with
-    `FMT_VARIADIC_CONST`
-    (https://github.com/fmtlib/fmt/pull/591). Thanks @ludekvodicka.
--   Various bugfixes: bad overflow check, unsupported implicit type
-    conversion when determining formatting function, test segfaults
-    (https://github.com/fmtlib/fmt/issues/551), ill-formed
-    macros (https://github.com/fmtlib/fmt/pull/542) and
-    ambiguous overloads
-    (https://github.com/fmtlib/fmt/issues/580). Thanks @xylosper.
--   Prevented warnings on MSVC
-    (https://github.com/fmtlib/fmt/pull/605,
-    https://github.com/fmtlib/fmt/pull/602, and
-    https://github.com/fmtlib/fmt/pull/545), clang
-    (https://github.com/fmtlib/fmt/pull/582), GCC
-    (https://github.com/fmtlib/fmt/issues/573), various
-    conversion warnings (https://github.com/fmtlib/fmt/pull/609,
-    https://github.com/fmtlib/fmt/pull/567,
-    https://github.com/fmtlib/fmt/pull/553 and
-    https://github.com/fmtlib/fmt/pull/553), and added
-    `override` and `[[noreturn]]`
-    (https://github.com/fmtlib/fmt/pull/549 and
-    https://github.com/fmtlib/fmt/issues/555).
-    Thanks @alabuzhev, @virgiliofornazin, @alexanderbock, @yumetodo, @VaderY,
-    @jpcima, @thelostt and @Manu343726.
--   Improved CMake: Used `GNUInstallDirs` to set installation location
-    (https://github.com/fmtlib/fmt/pull/610) and fixed warnings
-    (https://github.com/fmtlib/fmt/pull/536 and
-    https://github.com/fmtlib/fmt/pull/556).
-    Thanks @mikecrowe, @evgen231 and @henryiii.
-
-# 4.0.0 - 2017-06-27
-
--   Removed old compatibility headers `cppformat/*.h` and CMake options
-    (https://github.com/fmtlib/fmt/pull/527). Thanks @maddinat0r.
-
--   Added `string.h` containing `fmt::to_string()` as alternative to
-    `std::to_string()` as well as other string writer functionality
-    (https://github.com/fmtlib/fmt/issues/326 and
-    https://github.com/fmtlib/fmt/pull/441):
-
-    ```c++
-    #include "fmt/string.h"
-
-    std::string answer = fmt::to_string(42);
-    ```
-
-    Thanks @glebov-andrey.
-
--   Moved `fmt::printf()` to new `printf.h` header and allowed `%s` as
-    generic specifier (https://github.com/fmtlib/fmt/pull/453),
-    made `%.f` more conformant to regular `printf()`
-    (https://github.com/fmtlib/fmt/pull/490), added custom
-    writer support (https://github.com/fmtlib/fmt/issues/476)
-    and implemented missing custom argument formatting
-    (https://github.com/fmtlib/fmt/pull/339 and
-    https://github.com/fmtlib/fmt/pull/340):
-
-    ```c++
-    #include "fmt/printf.h"
-
-    // %s format specifier can be used with any argument type.
-    fmt::printf("%s", 42);
-    ```
-
-    Thanks @mojoBrendan, @manylegged and @spacemoose.
-    See also https://github.com/fmtlib/fmt/issues/360,
-    https://github.com/fmtlib/fmt/issues/335 and
-    https://github.com/fmtlib/fmt/issues/331.
-
--   Added `container.h` containing a `BasicContainerWriter` to write to
-    containers like `std::vector`
-    (https://github.com/fmtlib/fmt/pull/450). Thanks @polyvertex.
-
--   Added `fmt::join()` function that takes a range and formats its
-    elements separated by a given string
-    (https://github.com/fmtlib/fmt/pull/466):
-
-    ```c++
-    #include "fmt/format.h"
-
-    std::vector<double> v = {1.2, 3.4, 5.6};
-    // Prints "(+01.20, +03.40, +05.60)".
-    fmt::print("({:+06.2f})", fmt::join(v.begin(), v.end(), ", "));
-    ```
-
-    Thanks @olivier80.
-
--   Added support for custom formatting specifications to simplify
-    customization of built-in formatting
-    (https://github.com/fmtlib/fmt/pull/444). Thanks @polyvertex.
-    See also https://github.com/fmtlib/fmt/issues/439.
-
--   Added `fmt::format_system_error()` for error code formatting
-    (https://github.com/fmtlib/fmt/issues/323 and
-    https://github.com/fmtlib/fmt/pull/526). Thanks @maddinat0r.
-
--   Added thread-safe `fmt::localtime()` and `fmt::gmtime()` as
-    replacement for the standard version to `time.h`
-    (https://github.com/fmtlib/fmt/pull/396). Thanks @codicodi.
-
--   Internal improvements to `NamedArg` and `ArgLists`
-    (https://github.com/fmtlib/fmt/pull/389 and
-    https://github.com/fmtlib/fmt/pull/390). Thanks @chronoxor.
-
--   Fixed crash due to bug in `FormatBuf`
-    (https://github.com/fmtlib/fmt/pull/493). Thanks @effzeh. See also
-    https://github.com/fmtlib/fmt/issues/480 and
-    https://github.com/fmtlib/fmt/issues/491.
-
--   Fixed handling of wide strings in `fmt::StringWriter`.
-
--   Improved compiler error messages
-    (https://github.com/fmtlib/fmt/issues/357).
-
--   Fixed various warnings and issues with various compilers
-    (https://github.com/fmtlib/fmt/pull/494,
-    https://github.com/fmtlib/fmt/pull/499,
-    https://github.com/fmtlib/fmt/pull/483,
-    https://github.com/fmtlib/fmt/pull/485,
-    https://github.com/fmtlib/fmt/pull/482,
-    https://github.com/fmtlib/fmt/pull/475,
-    https://github.com/fmtlib/fmt/pull/473 and
-    https://github.com/fmtlib/fmt/pull/414).
-    Thanks @chronoxor, @zhaohuaxishi, @pkestene, @dschmidt and @0x414c.
-
--   Improved CMake: targets are now namespaced
-    (https://github.com/fmtlib/fmt/pull/511 and
-    https://github.com/fmtlib/fmt/pull/513), supported
-    header-only `printf.h`
-    (https://github.com/fmtlib/fmt/pull/354), fixed issue with
-    minimal supported library subset
-    (https://github.com/fmtlib/fmt/issues/418,
-    https://github.com/fmtlib/fmt/pull/419 and
-    https://github.com/fmtlib/fmt/pull/420).
-    Thanks @bjoernthiel, @niosHD, @LogicalKnight and @alabuzhev.
-
--   Improved documentation (https://github.com/fmtlib/fmt/pull/393).
-    Thanks @pwm1234.
-
-# 3.0.2 - 2017-06-14
-
--   Added `FMT_VERSION` macro
-    (https://github.com/fmtlib/fmt/issues/411).
--   Used `FMT_NULL` instead of literal `0`
-    (https://github.com/fmtlib/fmt/pull/409). Thanks @alabuzhev.
--   Added extern templates for `format_float`
-    (https://github.com/fmtlib/fmt/issues/413).
--   Fixed implicit conversion issue
-    (https://github.com/fmtlib/fmt/issues/507).
--   Fixed signbit detection
-    (https://github.com/fmtlib/fmt/issues/423).
--   Fixed naming collision
-    (https://github.com/fmtlib/fmt/issues/425).
--   Fixed missing intrinsic for C++/CLI
-    (https://github.com/fmtlib/fmt/pull/457). Thanks @calumr.
--   Fixed Android detection
-    (https://github.com/fmtlib/fmt/pull/458). Thanks @Gachapen.
--   Use lean `windows.h` if not in header-only mode
-    (https://github.com/fmtlib/fmt/pull/503). Thanks @Quentin01.
--   Fixed issue with CMake exporting C++11 flag
-    (https://github.com/fmtlib/fmt/pull/455). Thanks @EricWF.
--   Fixed issue with nvcc and MSVC compiler bug and MinGW
-    (https://github.com/fmtlib/fmt/issues/505).
--   Fixed DLL issues (https://github.com/fmtlib/fmt/pull/469 and
-    https://github.com/fmtlib/fmt/pull/502).
-    Thanks @richardeakin and @AndreasSchoenle.
--   Fixed test compilation under FreeBSD
-    (https://github.com/fmtlib/fmt/issues/433).
--   Fixed various warnings
-    (https://github.com/fmtlib/fmt/pull/403,
-    https://github.com/fmtlib/fmt/pull/410 and
-    https://github.com/fmtlib/fmt/pull/510).
-    Thanks @Lecetem, @chenhayat and @trozen.
--   Worked around a broken `__builtin_clz` in clang with MS codegen
-    (https://github.com/fmtlib/fmt/issues/519).
--   Removed redundant include
-    (https://github.com/fmtlib/fmt/issues/479).
--   Fixed documentation issues.
-
-# 3.0.1 - 2016-11-01
-
--   Fixed handling of thousands separator
-    (https://github.com/fmtlib/fmt/issues/353).
--   Fixed handling of `unsigned char` strings
-    (https://github.com/fmtlib/fmt/issues/373).
--   Corrected buffer growth when formatting time
-    (https://github.com/fmtlib/fmt/issues/367).
--   Removed warnings under MSVC and clang
-    (https://github.com/fmtlib/fmt/issues/318,
-    https://github.com/fmtlib/fmt/issues/250, also merged
-    https://github.com/fmtlib/fmt/pull/385 and
-    https://github.com/fmtlib/fmt/pull/361).
-    Thanks @jcelerier and @nmoehrle.
--   Fixed compilation issues under Android
-    (https://github.com/fmtlib/fmt/pull/327,
-    https://github.com/fmtlib/fmt/issues/345 and
-    https://github.com/fmtlib/fmt/pull/381), FreeBSD
-    (https://github.com/fmtlib/fmt/pull/358), Cygwin
-    (https://github.com/fmtlib/fmt/issues/388), MinGW
-    (https://github.com/fmtlib/fmt/issues/355) as well as other
-    issues (https://github.com/fmtlib/fmt/issues/350,
-    https://github.com/fmtlib/fmt/issues/355,
-    https://github.com/fmtlib/fmt/pull/348,
-    https://github.com/fmtlib/fmt/pull/402,
-    https://github.com/fmtlib/fmt/pull/405).
-    Thanks @dpantele, @hghwng, @arvedarved, @LogicalKnight and @JanHellwig.
--   Fixed some documentation issues and extended specification
-    (https://github.com/fmtlib/fmt/issues/320,
-    https://github.com/fmtlib/fmt/pull/333,
-    https://github.com/fmtlib/fmt/issues/347,
-    https://github.com/fmtlib/fmt/pull/362). Thanks @smellman.
-
-# 3.0.0 - 2016-05-07
-
--   The project has been renamed from C++ Format (cppformat) to fmt for
-    consistency with the used namespace and macro prefix
-    (https://github.com/fmtlib/fmt/issues/307). Library headers
-    are now located in the `fmt` directory:
-
-    ```c++
-    #include "fmt/format.h"
-    ```
-
-    Including `format.h` from the `cppformat` directory is deprecated
-    but works via a proxy header which will be removed in the next major
-    version.
-
-    The documentation is now available at <https://fmt.dev>.
-
--   Added support for
-    [strftime](http://en.cppreference.com/w/cpp/chrono/c/strftime)-like
-    [date and time
-    formatting](https://fmt.dev/3.0.0/api.html#date-and-time-formatting)
-    (https://github.com/fmtlib/fmt/issues/283):
-
-    ```c++
-    #include "fmt/time.h"
-
-    std::time_t t = std::time(nullptr);
-    // Prints "The date is 2016-04-29." (with the current date)
-    fmt::print("The date is {:%Y-%m-%d}.", *std::localtime(&t));
-    ```
-
--   `std::ostream` support including formatting of user-defined types
-    that provide overloaded `operator<<` has been moved to
-    `fmt/ostream.h`:
-
-    ```c++
-    #include "fmt/ostream.h"
-
-    class Date {
-      int year_, month_, day_;
-    public:
-      Date(int year, int month, int day) : year_(year), month_(month), day_(day) {}
-
-      friend std::ostream &operator<<(std::ostream &os, const Date &d) {
-        return os << d.year_ << '-' << d.month_ << '-' << d.day_;
-      }
-    };
-
-    std::string s = fmt::format("The date is {}", Date(2012, 12, 9));
-    // s == "The date is 2012-12-9"
-    ```
-
--   Added support for [custom argument
-    formatters](https://fmt.dev/3.0.0/api.html#argument-formatters)
-    (https://github.com/fmtlib/fmt/issues/235).
-
--   Added support for locale-specific integer formatting with the `n`
-    specifier (https://github.com/fmtlib/fmt/issues/305):
-
-    ```c++
-    std::setlocale(LC_ALL, "en_US.utf8");
-    fmt::print("cppformat: {:n}\n", 1234567); // prints 1,234,567
-    ```
-
--   Sign is now preserved when formatting an integer with an incorrect
-    `printf` format specifier
-    (https://github.com/fmtlib/fmt/issues/265):
-
-    ```c++
-    fmt::printf("%lld", -42); // prints -42
-    ```
-
-    Note that it would be an undefined behavior in `std::printf`.
-
--   Length modifiers such as `ll` are now optional in printf formatting
-    functions and the correct type is determined automatically
-    (https://github.com/fmtlib/fmt/issues/255):
-
-    ```c++
-    fmt::printf("%d", std::numeric_limits<long long>::max());
-    ```
-
-    Note that it would be an undefined behavior in `std::printf`.
-
--   Added initial support for custom formatters
-    (https://github.com/fmtlib/fmt/issues/231).
-
--   Fixed detection of user-defined literal support on Intel C++
-    compiler (https://github.com/fmtlib/fmt/issues/311,
-    https://github.com/fmtlib/fmt/pull/312).
-    Thanks @dean0x7d and @speth.
-
--   Reduced compile time
-    (https://github.com/fmtlib/fmt/pull/243,
-    https://github.com/fmtlib/fmt/pull/249,
-    https://github.com/fmtlib/fmt/issues/317):
-
-    ![](https://cloud.githubusercontent.com/assets/4831417/11614060/b9e826d2-9c36-11e5-8666-d4131bf503ef.png)
-
-    ![](https://cloud.githubusercontent.com/assets/4831417/11614080/6ac903cc-9c37-11e5-8165-26df6efae364.png)
-
-    Thanks @dean0x7d.
-
--   Compile test fixes (https://github.com/fmtlib/fmt/pull/313).
-    Thanks @dean0x7d.
-
--   Documentation fixes (https://github.com/fmtlib/fmt/pull/239,
-    https://github.com/fmtlib/fmt/issues/248,
-    https://github.com/fmtlib/fmt/issues/252,
-    https://github.com/fmtlib/fmt/pull/258,
-    https://github.com/fmtlib/fmt/issues/260,
-    https://github.com/fmtlib/fmt/issues/301,
-    https://github.com/fmtlib/fmt/pull/309).
-    Thanks @ReadmeCritic @Gachapen and @jwilk.
-
--   Fixed compiler and sanitizer warnings
-    (https://github.com/fmtlib/fmt/issues/244,
-    https://github.com/fmtlib/fmt/pull/256,
-    https://github.com/fmtlib/fmt/pull/259,
-    https://github.com/fmtlib/fmt/issues/263,
-    https://github.com/fmtlib/fmt/issues/274,
-    https://github.com/fmtlib/fmt/pull/277,
-    https://github.com/fmtlib/fmt/pull/286,
-    https://github.com/fmtlib/fmt/issues/291,
-    https://github.com/fmtlib/fmt/issues/296,
-    https://github.com/fmtlib/fmt/issues/308).
-    Thanks @mwinterb, @pweiskircher and @Naios.
-
--   Improved compatibility with Windows Store apps
-    (https://github.com/fmtlib/fmt/issues/280,
-    https://github.com/fmtlib/fmt/pull/285) Thanks @mwinterb.
-
--   Added tests of compatibility with older C++ standards
-    (https://github.com/fmtlib/fmt/pull/273). Thanks @niosHD.
-
--   Fixed Android build
-    (https://github.com/fmtlib/fmt/pull/271). Thanks @newnon.
-
--   Changed `ArgMap` to be backed by a vector instead of a map.
-    (https://github.com/fmtlib/fmt/issues/261,
-    https://github.com/fmtlib/fmt/pull/262). Thanks @mwinterb.
-
--   Added `fprintf` overload that writes to a `std::ostream`
-    (https://github.com/fmtlib/fmt/pull/251).
-    Thanks @nickhutchinson.
-
--   Export symbols when building a Windows DLL
-    (https://github.com/fmtlib/fmt/pull/245).
-    Thanks @macdems.
-
--   Fixed compilation on Cygwin
-    (https://github.com/fmtlib/fmt/issues/304).
-
--   Implemented a workaround for a bug in Apple LLVM version 4.2 of
-    clang (https://github.com/fmtlib/fmt/issues/276).
-
--   Implemented a workaround for Google Test bug
-    https://github.com/google/googletest/issues/705 on gcc 6
-    (https://github.com/fmtlib/fmt/issues/268). Thanks @octoploid.
-
--   Removed Biicode support because the latter has been discontinued.
-
-# 2.1.1 - 2016-04-11
-
--   The install location for generated CMake files is now configurable
-    via the `FMT_CMAKE_DIR` CMake variable
-    (https://github.com/fmtlib/fmt/pull/299). Thanks @niosHD.
--   Documentation fixes
-    (https://github.com/fmtlib/fmt/issues/252).
-
-# 2.1.0 - 2016-03-21
-
--   Project layout and build system improvements
-    (https://github.com/fmtlib/fmt/pull/267):
-
-    -   The code have been moved to the `cppformat` directory. Including
-        `format.h` from the top-level directory is deprecated but works
-        via a proxy header which will be removed in the next major
-        version.
-    -   C++ Format CMake targets now have proper interface definitions.
-    -   Installed version of the library now supports the header-only
-        configuration.
-    -   Targets `doc`, `install`, and `test` are now disabled if C++
-        Format is included as a CMake subproject. They can be enabled by
-        setting `FMT_DOC`, `FMT_INSTALL`, and `FMT_TEST` in the parent
-        project.
-
-    Thanks @niosHD.
-
-# 2.0.1 - 2016-03-13
-
--   Improved CMake find and package support
-    (https://github.com/fmtlib/fmt/issues/264). Thanks @niosHD.
--   Fix compile error with Android NDK and mingw32
-    (https://github.com/fmtlib/fmt/issues/241). Thanks @Gachapen.
--   Documentation fixes
-    (https://github.com/fmtlib/fmt/issues/248,
-    https://github.com/fmtlib/fmt/issues/260).
-
-# 2.0.0 - 2015-12-01
-
-## General
-
--   \[Breaking\] Named arguments
-    (https://github.com/fmtlib/fmt/pull/169,
-    https://github.com/fmtlib/fmt/pull/173,
-    https://github.com/fmtlib/fmt/pull/174):
-
-    ```c++
-    fmt::print("The answer is {answer}.", fmt::arg("answer", 42));
-    ```
-
-    Thanks @jamboree.
-
--   \[Experimental\] User-defined literals for format and named
-    arguments (https://github.com/fmtlib/fmt/pull/204,
-    https://github.com/fmtlib/fmt/pull/206,
-    https://github.com/fmtlib/fmt/pull/207):
-
-    ```c++
-    using namespace fmt::literals;
-    fmt::print("The answer is {answer}.", "answer"_a=42);
-    ```
-
-    Thanks @dean0x7d.
-
--   \[Breaking\] Formatting of more than 16 arguments is now supported
-    when using variadic templates
-    (https://github.com/fmtlib/fmt/issues/141). Thanks @Shauren.
-
--   Runtime width specification
-    (https://github.com/fmtlib/fmt/pull/168):
-
-    ```c++
-    fmt::format("{0:{1}}", 42, 5); // gives "   42"
-    ```
-
-    Thanks @jamboree.
-
--   \[Breaking\] Enums are now formatted with an overloaded
-    `std::ostream` insertion operator (`operator<<`) if available
-    (https://github.com/fmtlib/fmt/issues/232).
-
--   \[Breaking\] Changed default `bool` format to textual, \"true\" or
-    \"false\" (https://github.com/fmtlib/fmt/issues/170):
-
-    ```c++
-    fmt::print("{}", true); // prints "true"
-    ```
-
-    To print `bool` as a number use numeric format specifier such as
-    `d`:
-
-    ```c++
-    fmt::print("{:d}", true); // prints "1"
-    ```
-
--   `fmt::printf` and `fmt::sprintf` now support formatting of `bool`
-    with the `%s` specifier giving textual output, \"true\" or \"false\"
-    (https://github.com/fmtlib/fmt/pull/223):
-
-    ```c++
-    fmt::printf("%s", true); // prints "true"
-    ```
-
-    Thanks @LarsGullik.
-
--   \[Breaking\] `signed char` and `unsigned char` are now formatted as
-    integers by default
-    (https://github.com/fmtlib/fmt/pull/217).
-
--   \[Breaking\] Pointers to C strings can now be formatted with the `p`
-    specifier (https://github.com/fmtlib/fmt/pull/223):
-
-    ```c++
-    fmt::print("{:p}", "test"); // prints pointer value
-    ```
-
-    Thanks @LarsGullik.
-
--   \[Breaking\] `fmt::printf` and `fmt::sprintf` now print null
-    pointers as `(nil)` and null strings as `(null)` for consistency
-    with glibc (https://github.com/fmtlib/fmt/pull/226).
-    Thanks @LarsGullik.
-
--   \[Breaking\] `fmt::(s)printf` now supports formatting of objects of
-    user-defined types that provide an overloaded `std::ostream`
-    insertion operator (`operator<<`)
-    (https://github.com/fmtlib/fmt/issues/201):
-
-    ```c++
-    fmt::printf("The date is %s", Date(2012, 12, 9));
-    ```
-
--   \[Breaking\] The `Buffer` template is now part of the public API and
-    can be used to implement custom memory buffers
-    (https://github.com/fmtlib/fmt/issues/140). Thanks @polyvertex.
-
--   \[Breaking\] Improved compatibility between `BasicStringRef` and
-    [std::experimental::basic_string_view](
-    http://en.cppreference.com/w/cpp/experimental/basic_string_view)
-    (https://github.com/fmtlib/fmt/issues/100,
-    https://github.com/fmtlib/fmt/issues/159,
-    https://github.com/fmtlib/fmt/issues/183):
-
-    -   Comparison operators now compare string content, not pointers
-    -   `BasicStringRef::c_str` replaced by `BasicStringRef::data`
-    -   `BasicStringRef` is no longer assumed to be null-terminated
-
-    References to null-terminated strings are now represented by a new
-    class, `BasicCStringRef`.
-
--   Dependency on pthreads introduced by Google Test is now optional
-    (https://github.com/fmtlib/fmt/issues/185).
-
--   New CMake options `FMT_DOC`, `FMT_INSTALL` and `FMT_TEST` to control
-    generation of `doc`, `install` and `test` targets respectively, on
-    by default (https://github.com/fmtlib/fmt/issues/197,
-    https://github.com/fmtlib/fmt/issues/198,
-    https://github.com/fmtlib/fmt/issues/200). Thanks @maddinat0r.
-
--   `noexcept` is now used when compiling with MSVC2015
-    (https://github.com/fmtlib/fmt/pull/215). Thanks @dmkrepo.
-
--   Added an option to disable use of `windows.h` when
-    `FMT_USE_WINDOWS_H` is defined as 0 before including `format.h`
-    (https://github.com/fmtlib/fmt/issues/171). Thanks @alfps.
-
--   \[Breaking\] `windows.h` is now included with `NOMINMAX` unless
-    `FMT_WIN_MINMAX` is defined. This is done to prevent breaking code
-    using `std::min` and `std::max` and only affects the header-only
-    configuration (https://github.com/fmtlib/fmt/issues/152,
-    https://github.com/fmtlib/fmt/pull/153,
-    https://github.com/fmtlib/fmt/pull/154). Thanks @DevO2012.
-
--   Improved support for custom character types
-    (https://github.com/fmtlib/fmt/issues/171). Thanks @alfps.
-
--   Added an option to disable use of IOStreams when `FMT_USE_IOSTREAMS`
-    is defined as 0 before including `format.h`
-    (https://github.com/fmtlib/fmt/issues/205,
-    https://github.com/fmtlib/fmt/pull/208). Thanks @JodiTheTigger.
-
--   Improved detection of `isnan`, `isinf` and `signbit`.
-
-## Optimization
-
--   Made formatting of user-defined types more efficient with a custom
-    stream buffer (https://github.com/fmtlib/fmt/issues/92,
-    https://github.com/fmtlib/fmt/pull/230). Thanks @NotImplemented.
--   Further improved performance of `fmt::Writer` on integer formatting
-    and fixed a minor regression. Now it is \~7% faster than
-    `karma::generate` on Karma\'s benchmark
-    (https://github.com/fmtlib/fmt/issues/186).
--   \[Breaking\] Reduced [compiled code
-    size](https://github.com/fmtlib/fmt#compile-time-and-code-bloat)
-    (https://github.com/fmtlib/fmt/issues/143,
-    https://github.com/fmtlib/fmt/pull/149).
-
-## Distribution
-
--   \[Breaking\] Headers are now installed in
-    `${CMAKE_INSTALL_PREFIX}/include/cppformat`
-    (https://github.com/fmtlib/fmt/issues/178). Thanks @jackyf.
-
--   \[Breaking\] Changed the library name from `format` to `cppformat`
-    for consistency with the project name and to avoid potential
-    conflicts (https://github.com/fmtlib/fmt/issues/178).
-    Thanks @jackyf.
-
--   C++ Format is now available in [Debian](https://www.debian.org/)
-    GNU/Linux
-    ([stretch](https://packages.debian.org/source/stretch/cppformat),
-    [sid](https://packages.debian.org/source/sid/cppformat)) and derived
-    distributions such as
-    [Ubuntu](https://launchpad.net/ubuntu/+source/cppformat) 15.10 and
-    later (https://github.com/fmtlib/fmt/issues/155):
-
-        $ sudo apt-get install libcppformat1-dev
-
-    Thanks @jackyf.
-
--   [Packages for Fedora and
-    RHEL](https://admin.fedoraproject.org/pkgdb/package/cppformat/) are
-    now available. Thanks Dave Johansen.
-
--   C++ Format can now be installed via [Homebrew](http://brew.sh/) on
-    OS X (https://github.com/fmtlib/fmt/issues/157):
-
-        $ brew install cppformat
-
-    Thanks @ortho and Anatoliy Bulukin.
-
-## Documentation
-
--   Migrated from ReadTheDocs to GitHub Pages for better responsiveness
-    and reliability (https://github.com/fmtlib/fmt/issues/128).
-    New documentation address is <http://cppformat.github.io/>.
--   Added [Building thedocumentation](
-    https://fmt.dev/2.0.0/usage.html#building-the-documentation)
-    section to the documentation.
--   Documentation build script is now compatible with Python 3 and newer
-    pip versions. (https://github.com/fmtlib/fmt/pull/189,
-    https://github.com/fmtlib/fmt/issues/209).
-    Thanks @JodiTheTigger and @xentec.
--   Documentation fixes and improvements
-    (https://github.com/fmtlib/fmt/issues/36,
-    https://github.com/fmtlib/fmt/issues/75,
-    https://github.com/fmtlib/fmt/issues/125,
-    https://github.com/fmtlib/fmt/pull/160,
-    https://github.com/fmtlib/fmt/pull/161,
-    https://github.com/fmtlib/fmt/issues/162,
-    https://github.com/fmtlib/fmt/issues/165,
-    https://github.com/fmtlib/fmt/issues/210). 
-    Thanks @syohex.
--   Fixed out-of-tree documentation build
-    (https://github.com/fmtlib/fmt/issues/177). Thanks @jackyf.
-
-## Fixes
-
--   Fixed `initializer_list` detection
-    (https://github.com/fmtlib/fmt/issues/136). Thanks @Gachapen.
-
--   \[Breaking\] Fixed formatting of enums with numeric format
-    specifiers in `fmt::(s)printf`
-    (https://github.com/fmtlib/fmt/issues/131,
-    https://github.com/fmtlib/fmt/issues/139):
-
-    ```c++
-    enum { ANSWER = 42 };
-    fmt::printf("%d", ANSWER);
-    ```
-
-    Thanks @Naios.
-
--   Improved compatibility with old versions of MinGW
-    (https://github.com/fmtlib/fmt/issues/129,
-    https://github.com/fmtlib/fmt/pull/130,
-    https://github.com/fmtlib/fmt/issues/132). Thanks @cstamford.
-
--   Fixed a compile error on MSVC with disabled exceptions
-    (https://github.com/fmtlib/fmt/issues/144).
-
--   Added a workaround for broken implementation of variadic templates
-    in MSVC2012 (https://github.com/fmtlib/fmt/issues/148).
-
--   Placed the anonymous namespace within `fmt` namespace for the
-    header-only configuration (https://github.com/fmtlib/fmt/issues/171).
-    Thanks @alfps.
-
--   Fixed issues reported by Coverity Scan
-    (https://github.com/fmtlib/fmt/issues/187,
-    https://github.com/fmtlib/fmt/issues/192).
-
--   Implemented a workaround for a name lookup bug in MSVC2010
-    (https://github.com/fmtlib/fmt/issues/188).
-
--   Fixed compiler warnings
-    (https://github.com/fmtlib/fmt/issues/95,
-    https://github.com/fmtlib/fmt/issues/96,
-    https://github.com/fmtlib/fmt/pull/114,
-    https://github.com/fmtlib/fmt/issues/135,
-    https://github.com/fmtlib/fmt/issues/142,
-    https://github.com/fmtlib/fmt/issues/145,
-    https://github.com/fmtlib/fmt/issues/146,
-    https://github.com/fmtlib/fmt/issues/158,
-    https://github.com/fmtlib/fmt/issues/163,
-    https://github.com/fmtlib/fmt/issues/175,
-    https://github.com/fmtlib/fmt/issues/190,
-    https://github.com/fmtlib/fmt/pull/191,
-    https://github.com/fmtlib/fmt/issues/194,
-    https://github.com/fmtlib/fmt/pull/196,
-    https://github.com/fmtlib/fmt/issues/216,
-    https://github.com/fmtlib/fmt/pull/218,
-    https://github.com/fmtlib/fmt/pull/220,
-    https://github.com/fmtlib/fmt/pull/229,
-    https://github.com/fmtlib/fmt/issues/233,
-    https://github.com/fmtlib/fmt/issues/234,
-    https://github.com/fmtlib/fmt/pull/236,
-    https://github.com/fmtlib/fmt/issues/281,
-    https://github.com/fmtlib/fmt/issues/289).
-    Thanks @seanmiddleditch, @dixlorenz, @CarterLi, @Naios, @fmatthew5876,
-    @LevskiWeng, @rpopescu, @gabime, @cubicool, @jkflying, @LogicalKnight,
-    @inguin and @Jopie64.
-
--   Fixed portability issues (mostly causing test failures) on ARM,
-    ppc64, ppc64le, s390x and SunOS 5.11 i386
-    (https://github.com/fmtlib/fmt/issues/138,
-    https://github.com/fmtlib/fmt/issues/179,
-    https://github.com/fmtlib/fmt/issues/180,
-    https://github.com/fmtlib/fmt/issues/202,
-    https://github.com/fmtlib/fmt/issues/225, [Red Hat Bugzilla
-    Bug 1260297](https://bugzilla.redhat.com/show_bug.cgi?id=1260297)).
-    Thanks @Naios, @jackyf and Dave Johansen.
-
--   Fixed a name conflict with macro `free` defined in `crtdbg.h` when
-    `_CRTDBG_MAP_ALLOC` is set (https://github.com/fmtlib/fmt/issues/211).
-
--   Fixed shared library build on OS X
-    (https://github.com/fmtlib/fmt/pull/212). Thanks @dean0x7d.
-
--   Fixed an overload conflict on MSVC when `/Zc:wchar_t-` option is
-    specified (https://github.com/fmtlib/fmt/pull/214).
-    Thanks @slavanap.
-
--   Improved compatibility with MSVC 2008
-    (https://github.com/fmtlib/fmt/pull/236). Thanks @Jopie64.
-
--   Improved compatibility with bcc32
-    (https://github.com/fmtlib/fmt/issues/227).
-
--   Fixed `static_assert` detection on Clang
-    (https://github.com/fmtlib/fmt/pull/228). Thanks @dean0x7d.
-
-# 1.1.0 - 2015-03-06
-
--   Added `BasicArrayWriter`, a class template that provides operations
-    for formatting and writing data into a fixed-size array
-    (https://github.com/fmtlib/fmt/issues/105 and
-    https://github.com/fmtlib/fmt/issues/122):
-
-    ```c++
-    char buffer[100];
-    fmt::ArrayWriter w(buffer);
-    w.write("The answer is {}", 42);
-    ```
-
--   Added [0 A.D.](http://play0ad.com/) and [PenUltima Online
-    (POL)](http://www.polserver.com/) to the list of notable projects
-    using C++ Format.
-
--   C++ Format now uses MSVC intrinsics for better formatting performance
-    (https://github.com/fmtlib/fmt/pull/115,
-    https://github.com/fmtlib/fmt/pull/116,
-    https://github.com/fmtlib/fmt/pull/118 and
-    https://github.com/fmtlib/fmt/pull/121). Previously these
-    optimizations where only used on GCC and Clang.
-    Thanks @CarterLi and @objectx.
-
--   CMake install target
-    (https://github.com/fmtlib/fmt/pull/119). Thanks @TrentHouliston.
-
-    You can now install C++ Format with `make install` command.
-
--   Improved [Biicode](http://www.biicode.com/) support
-    (https://github.com/fmtlib/fmt/pull/98 and
-    https://github.com/fmtlib/fmt/pull/104).
-    Thanks @MariadeAnton and @franramirez688.
-
--   Improved support for building with [Android NDK](
-    https://developer.android.com/tools/sdk/ndk/index.html)
-    (https://github.com/fmtlib/fmt/pull/107). Thanks @newnon.
-
-    The [android-ndk-example](https://github.com/fmtlib/android-ndk-example)
-    repository provides and example of using C++ Format with Android NDK:
-
-    ![](https://raw.githubusercontent.com/fmtlib/android-ndk-example/master/screenshot.png)
-
--   Improved documentation of `SystemError` and `WindowsError`
-    (https://github.com/fmtlib/fmt/issues/54).
-
--   Various code improvements
-    (https://github.com/fmtlib/fmt/pull/110,
-    https://github.com/fmtlib/fmt/pull/111
-    https://github.com/fmtlib/fmt/pull/112). Thanks @CarterLi.
-
--   Improved compile-time errors when formatting wide into narrow
-    strings (https://github.com/fmtlib/fmt/issues/117).
-
--   Fixed `BasicWriter::write` without formatting arguments when C++11
-    support is disabled
-    (https://github.com/fmtlib/fmt/issues/109).
-
--   Fixed header-only build on OS X with GCC 4.9
-    (https://github.com/fmtlib/fmt/issues/124).
-
--   Fixed packaging issues (https://github.com/fmtlib/fmt/issues/94).
-
--   Added [changelog](https://github.com/fmtlib/fmt/blob/master/ChangeLog.md)
-    (https://github.com/fmtlib/fmt/issues/103).
-
-# 1.0.0 - 2015-02-05
-
--   Add support for a header-only configuration when `FMT_HEADER_ONLY`
-    is defined before including `format.h`:
-
-    ```c++
-    #define FMT_HEADER_ONLY
-    #include "format.h"
-    ```
-
--   Compute string length in the constructor of `BasicStringRef` instead
-    of the `size` method
-    (https://github.com/fmtlib/fmt/issues/79). This eliminates
-    size computation for string literals on reasonable optimizing
-    compilers.
-
--   Fix formatting of types with overloaded `operator <<` for
-    `std::wostream` (https://github.com/fmtlib/fmt/issues/86):
-
-    ```c++
-    fmt::format(L"The date is {0}", Date(2012, 12, 9));
-    ```
-
--   Fix linkage of tests on Arch Linux
-    (https://github.com/fmtlib/fmt/issues/89).
-
--   Allow precision specifier for non-float arguments
-    (https://github.com/fmtlib/fmt/issues/90):
-
-    ```c++
-    fmt::print("{:.3}\n", "Carpet"); // prints "Car"
-    ```
-
--   Fix build on Android NDK (https://github.com/fmtlib/fmt/issues/93).
-
--   Improvements to documentation build procedure.
-
--   Remove `FMT_SHARED` CMake variable in favor of standard [BUILD_SHARED_LIBS](
-    http://www.cmake.org/cmake/help/v3.0/variable/BUILD_SHARED_LIBS.html).
-
--   Fix error handling in `fmt::fprintf`.
-
--   Fix a number of warnings.
-
-# 0.12.0 - 2014-10-25
-
--   \[Breaking\] Improved separation between formatting and buffer
-    management. `Writer` is now a base class that cannot be instantiated
-    directly. The new `MemoryWriter` class implements the default buffer
-    management with small allocations done on stack. So `fmt::Writer`
-    should be replaced with `fmt::MemoryWriter` in variable
-    declarations.
-
-    Old code:
-
-    ```c++
-    fmt::Writer w;
-    ```
-
-    New code:
-
-    ```c++
-    fmt::MemoryWriter w;
-    ```
-
-    If you pass `fmt::Writer` by reference, you can continue to do so:
-
-    ```c++
-    void f(fmt::Writer &w);
-    ```
-
-    This doesn\'t affect the formatting API.
-
--   Support for custom memory allocators
-    (https://github.com/fmtlib/fmt/issues/69)
-
--   Formatting functions now accept [signed char]{.title-ref} and
-    [unsigned char]{.title-ref} strings as arguments
-    (https://github.com/fmtlib/fmt/issues/73):
-
-    ```c++
-    auto s = format("GLSL version: {}", glGetString(GL_VERSION));
-    ```
-
--   Reduced code bloat. According to the new [benchmark
-    results](https://github.com/fmtlib/fmt#compile-time-and-code-bloat),
-    cppformat is close to `printf` and by the order of magnitude better
-    than Boost Format in terms of compiled code size.
-
--   Improved appearance of the documentation on mobile by using the
-    [Sphinx Bootstrap
-    theme](http://ryan-roemer.github.io/sphinx-bootstrap-theme/):
-
-    | Old | New |
-    | --- | --- |
-    | ![](https://cloud.githubusercontent.com/assets/576385/4792130/cd256436-5de3-11e4-9a62-c077d0c2b003.png) | ![](https://cloud.githubusercontent.com/assets/576385/4792131/cd29896c-5de3-11e4-8f59-cac952942bf0.png) |
-
-# 0.11.0 - 2014-08-21
-
--   Safe printf implementation with a POSIX extension for positional
-    arguments:
-
-    ```c++
-    fmt::printf("Elapsed time: %.2f seconds", 1.23);
-    fmt::printf("%1$s, %3$d %2$s", weekday, month, day);
-    ```
-
--   Arguments of `char` type can now be formatted as integers (Issue
-    https://github.com/fmtlib/fmt/issues/55):
-
-    ```c++
-    fmt::format("0x{0:02X}", 'a');
-    ```
-
--   Deprecated parts of the API removed.
-
--   The library is now built and tested on MinGW with Appveyor in
-    addition to existing test platforms Linux/GCC, OS X/Clang,
-    Windows/MSVC.
-
-# 0.10.0 - 2014-07-01
-
-**Improved API**
-
--   All formatting methods are now implemented as variadic functions
-    instead of using `operator<<` for feeding arbitrary arguments into a
-    temporary formatter object. This works both with C++11 where
-    variadic templates are used and with older standards where variadic
-    functions are emulated by providing lightweight wrapper functions
-    defined with the `FMT_VARIADIC` macro. You can use this macro for
-    defining your own portable variadic functions:
-
-    ```c++
-    void report_error(const char *format, const fmt::ArgList &args) {
-      fmt::print("Error: {}");
-      fmt::print(format, args);
-    }
-    FMT_VARIADIC(void, report_error, const char *)
+  ```c++
+  #include <fmt/core.h>
+  #include <locale>
 
-    report_error("file not found: {}", path);
-    ```
+  int main() {
+    std::locale::global(std::locale("fr_FR.UTF-8"));
+    fmt::print("{0:.2Lf}", 0.42);
+  }
+  ```
 
-    Apart from a more natural syntax, this also improves performance as
-    there is no need to construct temporary formatter objects and
-    control arguments\' lifetimes. Because the wrapper functions are
-    very lightweight, this doesn\'t cause code bloat even in pre-C++11
-    mode.
+  prints \"0,42\". The deprecated `'n'` specifier has been removed.
 
--   Simplified common case of formatting an `std::string`. Now it
-    requires a single function call:
+- Made the `0` specifier ignored for infinity and NaN
+  (https://github.com/fmtlib/fmt/issues/2305,
+  https://github.com/fmtlib/fmt/pull/2310). Thanks @Liedtke.
 
-    ```c++
-    std::string s = format("The answer is {}.", 42);
-    ```
+- Made the hexfloat formatting use the right alignment by default
+  (https://github.com/fmtlib/fmt/issues/2308,
+  https://github.com/fmtlib/fmt/pull/2317). Thanks @Liedtke.
 
-    Previously it required 2 function calls:
+- Removed the deprecated numeric alignment (`'='`). Use the `'0'`
+  specifier instead.
 
-    ```c++
-    std::string s = str(Format("The answer is {}.") << 42);
-    ```
+- Removed the deprecated `fmt/posix.h` header that has been replaced
+  with `fmt/os.h`.
 
-    Instead of unsafe `c_str` function, `fmt::Writer` should be used
-    directly to bypass creation of `std::string`:
+- Removed the deprecated `format_to_n_context`, `format_to_n_args` and
+  `make_format_to_n_args`. They have been replaced with
+  `format_context`, `` format_args` and ``make_format_args\`\`
+  respectively.
 
-    ```c++
-    fmt::Writer w;
-    w.write("The answer is {}.", 42);
-    w.c_str();  // returns a C string
-    ```
+- Moved `wchar_t`-specific functions and types to `fmt/xchar.h`. You
+  can define `FMT_DEPRECATED_INCLUDE_XCHAR` to automatically include
+  `fmt/xchar.h` from `fmt/format.h` but this will be disabled in the
+  next major release.
 
-    This doesn\'t do dynamic memory allocation for small strings and is
-    less error prone as the lifetime of the string is the same as for
-    `std::string::c_str` which is well understood (hopefully).
+- Fixed handling of the `'+'` specifier in localized formatting
+  (https://github.com/fmtlib/fmt/issues/2133).
 
--   Improved consistency in naming functions that are a part of the
-    public API. Now all public functions are lowercase following the
-    standard library conventions. Previously it was a combination of
-    lowercase and CapitalizedWords. Issue
-    https://github.com/fmtlib/fmt/issues/50.
+- Added support for the `'s'` format specifier that gives textual
+  representation of `bool`
+  (https://github.com/fmtlib/fmt/issues/2094,
+  https://github.com/fmtlib/fmt/pull/2109). For example:
 
--   Old functions are marked as deprecated and will be removed in the
-    next release.
+  ```c++
+  #include <fmt/core.h>
 
-**Other Changes**
+  int main() {
+    fmt::print("{:s}", true);
+  }
+  ```
 
--   Experimental support for printf format specifications (work in
-    progress):
+  prints \"true\". Thanks @powercoderlol.
 
-    ```c++
-    fmt::printf("The answer is %d.", 42);
-    std::string s = fmt::sprintf("Look, a %s!", "string");
-    ```
+- Made `fmt::ptr` work with function pointers
+  (https://github.com/fmtlib/fmt/pull/2131). For example:
 
--   Support for hexadecimal floating point format specifiers `a` and
-    `A`:
+  ```c++
+  #include <fmt/format.h>
 
-    ```c++
-    print("{:a}", -42.0); // Prints -0x1.5p+5
-    print("{:A}", -42.0); // Prints -0X1.5P+5
-    ```
+  int main() {
+    fmt::print("My main: {}\n", fmt::ptr(main));
+  }
+  ```
 
--   CMake option `FMT_SHARED` that specifies whether to build format as
-    a shared library (off by default).
+  Thanks @mikecrowe.
 
-# 0.9.0 - 2014-05-13
+- The undocumented support for specializing `formatter` for pointer
+  types has been removed.
 
--   More efficient implementation of variadic formatting functions.
+- Fixed `fmt::formatted_size` with format string compilation
+  (https://github.com/fmtlib/fmt/pull/2141,
+  https://github.com/fmtlib/fmt/pull/2161). Thanks @alexezeder.
 
--   `Writer::Format` now has a variadic overload:
+- Fixed handling of empty format strings during format string
+  compilation (https://github.com/fmtlib/fmt/issues/2042):
 
-    ```c++
-    Writer out;
-    out.Format("Look, I'm {}!", "variadic");
-    ```
+  ```c++
+  auto s = fmt::format(FMT_COMPILE(""));
+  ```
 
--   For efficiency and consistency with other overloads, variadic
-    overload of the `Format` function now returns `Writer` instead of
-    `std::string`. Use the `str` function to convert it to
-    `std::string`:
+  Thanks @alexezeder.
 
-    ```c++
-    std::string s = str(Format("Look, I'm {}!", "variadic"));
-    ```
+- Fixed handling of enums in `fmt::to_string`
+  (https://github.com/fmtlib/fmt/issues/2036).
 
--   Replaced formatter actions with output sinks: `NoAction` -\>
-    `NullSink`, `Write` -\> `FileSink`, `ColorWriter` -\>
-    `ANSITerminalSink`. This improves naming consistency and shouldn\'t
-    affect client code unless these classes are used directly which
-    should be rarely needed.
+- Improved width computation
+  (https://github.com/fmtlib/fmt/issues/2033,
+  https://github.com/fmtlib/fmt/issues/2091). For example:
 
--   Added `ThrowSystemError` function that formats a message and throws
-    `SystemError` containing the formatted message and system-specific
-    error description. For example, the following code
+  ```c++
+  #include <fmt/core.h>
 
-    ```c++
-    FILE *f = fopen(filename, "r");
-    if (!f)
-      ThrowSystemError(errno, "Failed to open file '{}'") << filename;
-    ```
+  int main() {
+    fmt::print("{:-<10}{}\n", "ä½ å¥½", "ä¸ç");
+    fmt::print("{:-<10}{}\n", "hello", "world");
+  }
+  ```
 
-    will throw `SystemError` exception with description \"Failed to open
-    file \'\<filename\>\': No such file or directory\" if file doesn\'t
-    exist.
+  prints
 
--   Support for AppVeyor continuous integration platform.
+  ![](https://user-images.githubusercontent.com/576385/119840373-cea3ca80-beb9-11eb-91e0-54266c48e181.png)
 
--   `Format` now throws `SystemError` in case of I/O errors.
+  on a modern terminal.
 
--   Improve test infrastructure. Print functions are now tested by
-    redirecting the output to a pipe.
+- The experimental fast output stream (`fmt::ostream`) is now
+  truncated by default for consistency with `fopen`
+  (https://github.com/fmtlib/fmt/issues/2018). For example:
 
-# 0.8.0 - 2014-04-14
+  ```c++
+  #include <fmt/os.h>
 
--   Initial release
+  int main() {
+    fmt::ostream out1 = fmt::output_file("guide");
+    out1.print("Zaphod");
+    out1.close();
+    fmt::ostream out2 = fmt::output_file("guide");
+    out2.print("Ford");
+  }
+  ```
+
+  writes \"Ford\" to the file \"guide\". To preserve the old file
+  content if any pass `fmt::file::WRONLY | fmt::file::CREATE` flags to
+  `fmt::output_file`.
+
+- Fixed moving of `fmt::ostream` that holds buffered data
+  (https://github.com/fmtlib/fmt/issues/2197,
+  https://github.com/fmtlib/fmt/pull/2198). Thanks @vtta.
+
+- Replaced the `fmt::system_error` exception with a function of the
+  same name that constructs `std::system_error`
+  (https://github.com/fmtlib/fmt/issues/2266).
+
+- Replaced the `fmt::windows_error` exception with a function of the
+  same name that constructs `std::system_error` with the category
+  returned by `fmt::system_category()`
+  (https://github.com/fmtlib/fmt/issues/2274,
+  https://github.com/fmtlib/fmt/pull/2275). The latter is
+  similar to `std::system_category` but correctly handles UTF-8.
+  Thanks @phprus.
+
+- Replaced `fmt::error_code` with `std::error_code` and made it
+  formattable (https://github.com/fmtlib/fmt/issues/2269,
+  https://github.com/fmtlib/fmt/pull/2270,
+  https://github.com/fmtlib/fmt/pull/2273). Thanks @phprus.
+
+- Added speech synthesis support
+  (https://github.com/fmtlib/fmt/pull/2206).
+
+- Made `format_to` work with a memory buffer that has a custom
+  allocator (https://github.com/fmtlib/fmt/pull/2300).
+  Thanks @voxmea.
+
+- Added `Allocator::max_size` support to `basic_memory_buffer`.
+  (https://github.com/fmtlib/fmt/pull/1960). Thanks @phprus.
+
+- Added wide string support to `fmt::join`
+  (https://github.com/fmtlib/fmt/pull/2236). Thanks @crbrz.
+
+- Made iterators passed to `formatter` specializations via a format
+  context satisfy C++20 `std::output_iterator` requirements
+  (https://github.com/fmtlib/fmt/issues/2156,
+  https://github.com/fmtlib/fmt/pull/2158,
+  https://github.com/fmtlib/fmt/issues/2195,
+  https://github.com/fmtlib/fmt/pull/2204). Thanks @randomnetcat.
+
+- Optimized the `printf` implementation
+  (https://github.com/fmtlib/fmt/pull/1982,
+  https://github.com/fmtlib/fmt/pull/1984,
+  https://github.com/fmtlib/fmt/pull/2016,
+  https://github.com/fmtlib/fmt/pull/2164).
+  Thanks @rimathia and @moiwi.
+
+- Improved detection of `constexpr` `char_traits`
+  (https://github.com/fmtlib/fmt/pull/2246,
+  https://github.com/fmtlib/fmt/pull/2257). Thanks @phprus.
+
+- Fixed writing to `stdout` when it is redirected to `NUL` on Windows
+  (https://github.com/fmtlib/fmt/issues/2080).
+
+- Fixed exception propagation from iterators
+  (https://github.com/fmtlib/fmt/issues/2097).
+
+- Improved `strftime` error handling
+  (https://github.com/fmtlib/fmt/issues/2238,
+  https://github.com/fmtlib/fmt/pull/2244). Thanks @yumeyao.
+
+- Stopped using deprecated GCC UDL template extension.
+
+- Added `fmt/args.h` to the install target
+  (https://github.com/fmtlib/fmt/issues/2096).
+
+- Error messages are now passed to assert when exceptions are disabled
+  (https://github.com/fmtlib/fmt/pull/2145). Thanks @NobodyXu.
+
+- Added the `FMT_MASTER_PROJECT` CMake option to control build and
+  install targets when {fmt} is included via `add_subdirectory`
+  (https://github.com/fmtlib/fmt/issues/2098,
+  https://github.com/fmtlib/fmt/pull/2100).
+  Thanks @randomizedthinking.
+
+- Improved build configuration
+  (https://github.com/fmtlib/fmt/pull/2026,
+  https://github.com/fmtlib/fmt/pull/2122).
+  Thanks @luncliff and @ibaned.
+
+- Fixed various warnings and compilation issues
+  (https://github.com/fmtlib/fmt/issues/1947,
+  https://github.com/fmtlib/fmt/pull/1959,
+  https://github.com/fmtlib/fmt/pull/1963,
+  https://github.com/fmtlib/fmt/pull/1965,
+  https://github.com/fmtlib/fmt/issues/1966,
+  https://github.com/fmtlib/fmt/pull/1974,
+  https://github.com/fmtlib/fmt/pull/1975,
+  https://github.com/fmtlib/fmt/pull/1990,
+  https://github.com/fmtlib/fmt/issues/2000,
+  https://github.com/fmtlib/fmt/pull/2001,
+  https://github.com/fmtlib/fmt/issues/2002,
+  https://github.com/fmtlib/fmt/issues/2004,
+  https://github.com/fmtlib/fmt/pull/2006,
+  https://github.com/fmtlib/fmt/pull/2009,
+  https://github.com/fmtlib/fmt/pull/2010,
+  https://github.com/fmtlib/fmt/issues/2038,
+  https://github.com/fmtlib/fmt/issues/2039,
+  https://github.com/fmtlib/fmt/issues/2047,
+  https://github.com/fmtlib/fmt/pull/2053,
+  https://github.com/fmtlib/fmt/issues/2059,
+  https://github.com/fmtlib/fmt/pull/2065,
+  https://github.com/fmtlib/fmt/pull/2067,
+  https://github.com/fmtlib/fmt/pull/2068,
+  https://github.com/fmtlib/fmt/pull/2073,
+  https://github.com/fmtlib/fmt/issues/2103,
+  https://github.com/fmtlib/fmt/issues/2105,
+  https://github.com/fmtlib/fmt/pull/2106,
+  https://github.com/fmtlib/fmt/pull/2107,
+  https://github.com/fmtlib/fmt/issues/2116,
+  https://github.com/fmtlib/fmt/pull/2117,
+  https://github.com/fmtlib/fmt/issues/2118,
+  https://github.com/fmtlib/fmt/pull/2119,
+  https://github.com/fmtlib/fmt/issues/2127,
+  https://github.com/fmtlib/fmt/pull/2128,
+  https://github.com/fmtlib/fmt/issues/2140,
+  https://github.com/fmtlib/fmt/issues/2142,
+  https://github.com/fmtlib/fmt/pull/2143,
+  https://github.com/fmtlib/fmt/pull/2144,
+  https://github.com/fmtlib/fmt/issues/2147,
+  https://github.com/fmtlib/fmt/issues/2148,
+  https://github.com/fmtlib/fmt/issues/2149,
+  https://github.com/fmtlib/fmt/pull/2152,
+  https://github.com/fmtlib/fmt/pull/2160,
+  https://github.com/fmtlib/fmt/issues/2170,
+  https://github.com/fmtlib/fmt/issues/2175,
+  https://github.com/fmtlib/fmt/issues/2176,
+  https://github.com/fmtlib/fmt/pull/2177,
+  https://github.com/fmtlib/fmt/issues/2178,
+  https://github.com/fmtlib/fmt/pull/2179,
+  https://github.com/fmtlib/fmt/issues/2180,
+  https://github.com/fmtlib/fmt/issues/2181,
+  https://github.com/fmtlib/fmt/pull/2183,
+  https://github.com/fmtlib/fmt/issues/2184,
+  https://github.com/fmtlib/fmt/issues/2185,
+  https://github.com/fmtlib/fmt/pull/2186,
+  https://github.com/fmtlib/fmt/pull/2187,
+  https://github.com/fmtlib/fmt/pull/2190,
+  https://github.com/fmtlib/fmt/pull/2192,
+  https://github.com/fmtlib/fmt/pull/2194,
+  https://github.com/fmtlib/fmt/pull/2205,
+  https://github.com/fmtlib/fmt/issues/2210,
+  https://github.com/fmtlib/fmt/pull/2211,
+  https://github.com/fmtlib/fmt/pull/2215,
+  https://github.com/fmtlib/fmt/pull/2216,
+  https://github.com/fmtlib/fmt/pull/2218,
+  https://github.com/fmtlib/fmt/pull/2220,
+  https://github.com/fmtlib/fmt/issues/2228,
+  https://github.com/fmtlib/fmt/pull/2229,
+  https://github.com/fmtlib/fmt/pull/2230,
+  https://github.com/fmtlib/fmt/issues/2233,
+  https://github.com/fmtlib/fmt/pull/2239,
+  https://github.com/fmtlib/fmt/issues/2248,
+  https://github.com/fmtlib/fmt/issues/2252,
+  https://github.com/fmtlib/fmt/pull/2253,
+  https://github.com/fmtlib/fmt/pull/2255,
+  https://github.com/fmtlib/fmt/issues/2261,
+  https://github.com/fmtlib/fmt/issues/2278,
+  https://github.com/fmtlib/fmt/issues/2284,
+  https://github.com/fmtlib/fmt/pull/2287,
+  https://github.com/fmtlib/fmt/pull/2289,
+  https://github.com/fmtlib/fmt/pull/2290,
+  https://github.com/fmtlib/fmt/pull/2293,
+  https://github.com/fmtlib/fmt/issues/2295,
+  https://github.com/fmtlib/fmt/pull/2296,
+  https://github.com/fmtlib/fmt/pull/2297,
+  https://github.com/fmtlib/fmt/issues/2311,
+  https://github.com/fmtlib/fmt/pull/2313,
+  https://github.com/fmtlib/fmt/pull/2315,
+  https://github.com/fmtlib/fmt/issues/2320,
+  https://github.com/fmtlib/fmt/pull/2321,
+  https://github.com/fmtlib/fmt/pull/2323,
+  https://github.com/fmtlib/fmt/issues/2328,
+  https://github.com/fmtlib/fmt/pull/2329,
+  https://github.com/fmtlib/fmt/pull/2333,
+  https://github.com/fmtlib/fmt/pull/2338,
+  https://github.com/fmtlib/fmt/pull/2341).
+  Thanks @darklukee, @fagg, @killerbot242, @jgopel, @yeswalrus, @Finkman,
+  @HazardyKnusperkeks, @dkavolis, @concatime, @chronoxor, @summivox, @yNeo,
+  @Apache-HB, @alexezeder, @toojays, @Brainy0207, @vadz, @imsherlock, @phprus,
+  @white238, @yafshar, @BillyDonahue, @jstaahl, @denchat, @DanielaE,
+  @ilyakurdyukov, @ilmai, @JessyDL, @sergiud, @mwinterb, @sven-herrmann,
+  @jmelas, @twoixter, @crbrz and @upsj.
+
+- Improved documentation
+  (https://github.com/fmtlib/fmt/issues/1986,
+  https://github.com/fmtlib/fmt/pull/2051,
+  https://github.com/fmtlib/fmt/issues/2057,
+  https://github.com/fmtlib/fmt/pull/2081,
+  https://github.com/fmtlib/fmt/issues/2084,
+  https://github.com/fmtlib/fmt/pull/2312).
+  Thanks @imba-tjd, @0x416c69 and @mordante.
+
+- Continuous integration and test improvements
+  (https://github.com/fmtlib/fmt/issues/1969,
+  https://github.com/fmtlib/fmt/pull/1991,
+  https://github.com/fmtlib/fmt/pull/2020,
+  https://github.com/fmtlib/fmt/pull/2110,
+  https://github.com/fmtlib/fmt/pull/2114,
+  https://github.com/fmtlib/fmt/issues/2196,
+  https://github.com/fmtlib/fmt/pull/2217,
+  https://github.com/fmtlib/fmt/pull/2247,
+  https://github.com/fmtlib/fmt/pull/2256,
+  https://github.com/fmtlib/fmt/pull/2336,
+  https://github.com/fmtlib/fmt/pull/2346).
+  Thanks @jgopel, @alexezeder and @DanielaE.
+
+The change log for versions 0.8.0 - 7.1.3 is available [here](
+doc/ChangeLog-old.md).
diff --git a/3rdparty/fmt/README.md b/3rdparty/fmt/README.md
index dcfb16ec22086..fd845db20c2c7 100644
--- a/3rdparty/fmt/README.md
+++ b/3rdparty/fmt/README.md
@@ -20,16 +20,16 @@ that help victims of the war in Ukraine: <https://www.stopputin.net/>.
 Q&A: ask questions on [StackOverflow with the tag
 fmt](https://stackoverflow.com/questions/tagged/fmt).
 
-Try {fmt} in [Compiler Explorer](https://godbolt.org/z/Eq5763).
+Try {fmt} in [Compiler Explorer](https://godbolt.org/z/8Mx1EW73v).
 
 # Features
 
-- Simple [format API](https://fmt.dev/latest/api.html) with positional
+- Simple [format API](https://fmt.dev/latest/api/) with positional
   arguments for localization
 - Implementation of [C++20
   std::format](https://en.cppreference.com/w/cpp/utility/format) and
   [C++23 std::print](https://en.cppreference.com/w/cpp/io/print)
-- [Format string syntax](https://fmt.dev/latest/syntax.html) similar
+- [Format string syntax](https://fmt.dev/latest/syntax/) similar
   to Python\'s
   [format](https://docs.python.org/3/library/stdtypes.html#str.format)
 - Fast IEEE 754 floating-point formatter with correct rounding,
@@ -37,10 +37,10 @@ Try {fmt} in [Compiler Explorer](https://godbolt.org/z/Eq5763).
   [Dragonbox](https://github.com/jk-jeon/dragonbox) algorithm
 - Portable Unicode support
 - Safe [printf
-  implementation](https://fmt.dev/latest/api.html#printf-formatting)
+  implementation](https://fmt.dev/latest/api/#printf-formatting)
   including the POSIX extension for positional arguments
 - Extensibility: [support for user-defined
-  types](https://fmt.dev/latest/api.html#formatting-user-defined-types)
+  types](https://fmt.dev/latest/api/#formatting-user-defined-types)
 - High performance: faster than common standard library
   implementations of `(s)printf`, iostreams, `to_string` and
   `to_chars`, see [Speed tests](#speed-tests) and [Converting a
@@ -58,8 +58,8 @@ Try {fmt} in [Compiler Explorer](https://godbolt.org/z/Eq5763).
   buffer overflow errors
 - Ease of use: small self-contained code base, no external
   dependencies, permissive MIT
-  [license](https://github.com/fmtlib/fmt/blob/master/LICENSE.rst)
-- [Portability](https://fmt.dev/latest/index.html#portability) with
+  [license](https://github.com/fmtlib/fmt/blob/master/LICENSE)
+- [Portability](https://fmt.dev/latest/#portability) with
   consistent output across platforms and support for older compilers
 - Clean warning-free codebase even on high warning levels such as
   `-Wall -Wextra -pedantic`
@@ -203,43 +203,38 @@ and [ryu](https://github.com/ulfjack/ryu):
 
 ## Compile time and code bloat
 
-The script
-[bloat-test.py](https://github.com/fmtlib/format-benchmark/blob/master/bloat-test.py)
-from [format-benchmark](https://github.com/fmtlib/format-benchmark)
-tests compile time and code bloat for nontrivial projects. It generates
-100 translation units and uses `printf()` or its alternative five times
-in each to simulate a medium-sized project. The resulting executable
-size and compile time (Apple LLVM version 8.1.0 (clang-802.0.42), macOS
-Sierra, best of three) is shown in the following tables.
+The script [bloat-test.py][test] from [format-benchmark][bench] tests compile
+time and code bloat for nontrivial projects. It generates 100 translation units
+and uses `printf()` or its alternative five times in each to simulate a
+medium-sized project. The resulting executable size and compile time (Apple
+clang version 15.0.0 (clang-1500.1.0.2.5), macOS Sonoma, best of three) is shown
+in the following tables.
+
+[test]: https://github.com/fmtlib/format-benchmark/blob/master/bloat-test.py
+[bench]: https://github.com/fmtlib/format-benchmark
 
 **Optimized build (-O3)**
 
 | Method        | Compile Time, s | Executable size, KiB | Stripped size, KiB |
 |---------------|-----------------|----------------------|--------------------|
-| printf        |   2.6           |   29                 |   26               |
-| printf+string |   16.4          |   29                 |   26               |
-| iostreams     |   31.1          |   59                 |   55               |
-| {fmt}         |   19.0          |   37                 |   34               |
-| Boost Format  |   91.9          |   226                |   203              |
-| Folly Format  |   115.7         |   101                |   88               |
-
-As you can see, {fmt} has 60% less overhead in terms of resulting binary
-code size compared to iostreams and comes pretty close to `printf`.
-Boost Format and Folly Format have the largest overheads.
+| printf        |             1.6 |                   54 |                 50 |
+| IOStreams     |            25.9 |                   98 |                 84 |
+| fmt 83652df   |             4.8 |                   54 |                 50 |
+| tinyformat    |            29.1 |                  161 |                136 |
+| Boost Format  |            55.0 |                  530 |                317 |
 
-`printf+string` is the same as `printf` but with an extra `<string>`
-include to measure the overhead of the latter.
+{fmt} is fast to compile and is comparable to `printf` in terms of per-call
+binary size (within a rounding error on this system).
 
 **Non-optimized build**
 
 | Method        | Compile Time, s | Executable size, KiB | Stripped size, KiB |
 |---------------|-----------------|----------------------|--------------------|
-| printf        |   2.2           |   33                 |   30               |
-| printf+string |   16.0          |   33                 |   30               |
-| iostreams     |   28.3          |   56                 |   52               |
-| {fmt}         |   18.2          |   59                 |   50               |
-| Boost Format  |   54.1          |   365                |   303              |
-| Folly Format  |   79.9          |   445                |   430              |
+| printf        |             1.4 |                   54 |                 50 |
+| IOStreams     |            23.4 |                   92 |                 68 |
+| {fmt} 83652df |             4.4 |                   89 |                 85 |
+| tinyformat    |            24.5 |                  204 |                161 |
+| Boost Format  |            36.4 |                  831 |                462 |
 
 `libc`, `lib(std)c++`, and `libfmt` are all linked as shared libraries
 to compare formatting function overhead only. Boost Format is a
@@ -248,7 +243,7 @@ header-only library so it doesn\'t provide any linkage options.
 ## Running the tests
 
 Please refer to [Building the
-library](https://fmt.dev/latest/usage.html#building-the-library) for
+library](https://fmt.dev/latest/get-started/#building-from-source) for
 instructions on how to build the library and run the unit tests.
 
 Benchmarks reside in a separate repository,
@@ -270,8 +265,7 @@ or the bloat test:
 
 # Migrating code
 
-[clang-tidy](https://clang.llvm.org/extra/clang-tidy/) v17 (not yet
-released) provides the
+[clang-tidy](https://clang.llvm.org/extra/clang-tidy/) v18 provides the
 [modernize-use-std-print](https://clang.llvm.org/extra/clang-tidy/checks/modernize/use-std-print.html)
 check that is capable of converting occurrences of `printf` and
 `fprintf` to `fmt::print` if configured to do so. (By default it
@@ -297,13 +291,14 @@ converts to `std::print`.)
 - [ccache](https://ccache.dev/): a compiler cache
 - [ClickHouse](https://github.com/ClickHouse/ClickHouse): an
   analytical database management system
+- [ContextVision](https://www.contextvision.com/): medical imaging software
 - [Contour](https://github.com/contour-terminal/contour/): a modern
   terminal emulator
 - [CUAUV](https://cuauv.org/): Cornell University\'s autonomous
   underwater vehicle
 - [Drake](https://drake.mit.edu/): a planning, control, and analysis
   toolbox for nonlinear dynamical systems (MIT)
-- [Envoy](https://lyft.github.io/envoy/): C++ L7 proxy and
+- [Envoy](https://github.com/envoyproxy/envoy): C++ L7 proxy and
   communication bus (Lyft)
 - [FiveM](https://fivem.net/): a modification framework for GTA V
 - [fmtlog](https://github.com/MengRao/fmtlog): a performant
@@ -343,7 +338,7 @@ converts to `std::print`.)
 - [Quill](https://github.com/odygrd/quill): asynchronous low-latency
   logging library
 - [QKW](https://github.com/ravijanjam/qkw): generalizing aliasing to
-  simplify navigation, and executing complex multi-line terminal
+  simplify navigation, and execute complex multi-line terminal
   command sequences
 - [redis-cerberus](https://github.com/HunanTV/redis-cerberus): a Redis
   cluster proxy
@@ -432,7 +427,7 @@ code bloat issues (see [Benchmarks](#benchmarks)).
 
 ## FastFormat
 
-This is an interesting library that is fast, safe, and has positional
+This is an interesting library that is fast, safe and has positional
 arguments. However, it has significant limitations, citing its author:
 
 > Three features that have no hope of being accommodated within the
@@ -442,8 +437,8 @@ arguments. However, it has significant limitations, citing its author:
 > - Octal/hexadecimal encoding
 > - Runtime width/alignment specification
 
-It is also quite big and has a heavy dependency, STLSoft, which might be
-too restrictive for using it in some projects.
+It is also quite big and has a heavy dependency, on STLSoft, which might be
+too restrictive for use in some projects.
 
 ## Boost Spirit.Karma
 
@@ -462,7 +457,7 @@ second](http://www.zverovich.net/2020/06/13/fast-int-to-string-revisited.html).
 
 # Documentation License
 
-The [Format String Syntax](https://fmt.dev/latest/syntax.html) section
+The [Format String Syntax](https://fmt.dev/latest/syntax/) section
 in the documentation is based on the one from Python [string module
 documentation](https://docs.python.org/3/library/string.html#module-string).
 For this reason, the documentation is distributed under the Python
@@ -486,5 +481,5 @@ To report a security issue, please disclose it at [security
 advisory](https://github.com/fmtlib/fmt/security/advisories/new).
 
 This project is maintained by a team of volunteers on a
-reasonable-effort basis. As such, please give us at least 90 days to
+reasonable-effort basis. As such, please give us at least *90* days to
 work on a fix before public exposure.
diff --git a/3rdparty/fmt/include/fmt/args.h b/3rdparty/fmt/include/fmt/args.h
index ad1654bbb6006..3ff47880748fb 100644
--- a/3rdparty/fmt/include/fmt/args.h
+++ b/3rdparty/fmt/include/fmt/args.h
@@ -8,14 +8,15 @@
 #ifndef FMT_ARGS_H_
 #define FMT_ARGS_H_
 
-#include <functional>  // std::reference_wrapper
-#include <memory>      // std::unique_ptr
-#include <vector>
+#ifndef FMT_MODULE
+#  include <functional>  // std::reference_wrapper
+#  include <memory>      // std::unique_ptr
+#  include <vector>
+#endif
 
-#include "core.h"
+#include "format.h"  // std_string_view
 
 FMT_BEGIN_NAMESPACE
-
 namespace detail {
 
 template <typename T> struct is_reference_wrapper : std::false_type {};
@@ -28,15 +29,18 @@ auto unwrap(const std::reference_wrapper<T>& v) -> const T& {
   return static_cast<const T&>(v);
 }
 
-class dynamic_arg_list {
-  // Workaround for clang's -Wweak-vtables. Unlike for regular classes, for
-  // templates it doesn't complain about inability to deduce single translation
-  // unit for placing vtable. So storage_node_base is made a fake template.
-  template <typename = void> struct node {
-    virtual ~node() = default;
-    std::unique_ptr<node<>> next;
-  };
+// node is defined outside dynamic_arg_list to workaround a C2504 bug in MSVC
+// 2022 (v17.10.0).
+//
+// Workaround for clang's -Wweak-vtables. Unlike for regular classes, for
+// templates it doesn't complain about inability to deduce single translation
+// unit for placing vtable. So node is made a fake template.
+template <typename = void> struct node {
+  virtual ~node() = default;
+  std::unique_ptr<node<>> next;
+};
 
+class dynamic_arg_list {
   template <typename T> struct typed_node : node<> {
     T value;
 
@@ -62,28 +66,18 @@ class dynamic_arg_list {
 }  // namespace detail
 
 /**
-  \rst
-  A dynamic version of `fmt::format_arg_store`.
-  It's equipped with a storage to potentially temporary objects which lifetimes
-  could be shorter than the format arguments object.
-
-  It can be implicitly converted into `~fmt::basic_format_args` for passing
-  into type-erased formatting functions such as `~fmt::vformat`.
-  \endrst
+ * A dynamic list of formatting arguments with storage.
+ *
+ * It can be implicitly converted into `fmt::basic_format_args` for passing
+ * into type-erased formatting functions such as `fmt::vformat`.
  */
-template <typename Context>
-class dynamic_format_arg_store
-#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
-    // Workaround a GCC template argument substitution bug.
-    : public basic_format_args<Context>
-#endif
-{
+template <typename Context> class dynamic_format_arg_store {
  private:
   using char_type = typename Context::char_type;
 
   template <typename T> struct need_copy {
     static constexpr detail::type mapped_type =
-        detail::mapped_type_constant<T, Context>::value;
+        detail::mapped_type_constant<T, char_type>::value;
 
     enum {
       value = !(detail::is_reference_wrapper<T>::value ||
@@ -96,7 +90,7 @@ class dynamic_format_arg_store
   };
 
   template <typename T>
-  using stored_type = conditional_t<
+  using stored_t = conditional_t<
       std::is_convertible<T, std::basic_string<char_type>>::value &&
           !detail::is_reference_wrapper<T>::value,
       std::basic_string<char_type>, T>;
@@ -111,80 +105,72 @@ class dynamic_format_arg_store
 
   friend class basic_format_args<Context>;
 
-  auto get_types() const -> unsigned long long {
-    return detail::is_unpacked_bit | data_.size() |
-           (named_info_.empty()
-                ? 0ULL
-                : static_cast<unsigned long long>(detail::has_named_args_bit));
-  }
-
   auto data() const -> const basic_format_arg<Context>* {
     return named_info_.empty() ? data_.data() : data_.data() + 1;
   }
 
   template <typename T> void emplace_arg(const T& arg) {
-    data_.emplace_back(detail::make_arg<Context>(arg));
+    data_.emplace_back(arg);
   }
 
   template <typename T>
   void emplace_arg(const detail::named_arg<char_type, T>& arg) {
-    if (named_info_.empty()) {
-      constexpr const detail::named_arg_info<char_type>* zero_ptr{nullptr};
-      data_.insert(data_.begin(), {zero_ptr, 0});
-    }
-    data_.emplace_back(detail::make_arg<Context>(detail::unwrap(arg.value)));
+    if (named_info_.empty())
+      data_.insert(data_.begin(), basic_format_arg<Context>(nullptr, 0));
+    data_.emplace_back(detail::unwrap(arg.value));
     auto pop_one = [](std::vector<basic_format_arg<Context>>* data) {
       data->pop_back();
     };
     std::unique_ptr<std::vector<basic_format_arg<Context>>, decltype(pop_one)>
         guard{&data_, pop_one};
     named_info_.push_back({arg.name, static_cast<int>(data_.size() - 2u)});
-    data_[0].value_.named_args = {named_info_.data(), named_info_.size()};
+    data_[0] = {named_info_.data(), named_info_.size()};
     guard.release();
   }
 
  public:
   constexpr dynamic_format_arg_store() = default;
 
+  operator basic_format_args<Context>() const {
+    return basic_format_args<Context>(data(), static_cast<int>(data_.size()),
+                                      !named_info_.empty());
+  }
+
   /**
-    \rst
-    Adds an argument into the dynamic store for later passing to a formatting
-    function.
-
-    Note that custom types and string types (but not string views) are copied
-    into the store dynamically allocating memory if necessary.
-
-    **Example**::
-
-      fmt::dynamic_format_arg_store<fmt::format_context> store;
-      store.push_back(42);
-      store.push_back("abc");
-      store.push_back(1.5f);
-      std::string result = fmt::vformat("{} and {} and {}", store);
-    \endrst
-  */
+   * Adds an argument into the dynamic store for later passing to a formatting
+   * function.
+   *
+   * Note that custom types and string types (but not string views) are copied
+   * into the store dynamically allocating memory if necessary.
+   *
+   * **Example**:
+   *
+   *     fmt::dynamic_format_arg_store<fmt::format_context> store;
+   *     store.push_back(42);
+   *     store.push_back("abc");
+   *     store.push_back(1.5f);
+   *     std::string result = fmt::vformat("{} and {} and {}", store);
+   */
   template <typename T> void push_back(const T& arg) {
     if (detail::const_check(need_copy<T>::value))
-      emplace_arg(dynamic_args_.push<stored_type<T>>(arg));
+      emplace_arg(dynamic_args_.push<stored_t<T>>(arg));
     else
       emplace_arg(detail::unwrap(arg));
   }
 
   /**
-    \rst
-    Adds a reference to the argument into the dynamic store for later passing to
-    a formatting function.
-
-    **Example**::
-
-      fmt::dynamic_format_arg_store<fmt::format_context> store;
-      char band[] = "Rolling Stones";
-      store.push_back(std::cref(band));
-      band[9] = 'c'; // Changing str affects the output.
-      std::string result = fmt::vformat("{}", store);
-      // result == "Rolling Scones"
-    \endrst
-  */
+   * Adds a reference to the argument into the dynamic store for later passing
+   * to a formatting function.
+   *
+   * **Example**:
+   *
+   *     fmt::dynamic_format_arg_store<fmt::format_context> store;
+   *     char band[] = "Rolling Stones";
+   *     store.push_back(std::cref(band));
+   *     band[9] = 'c'; // Changing str affects the output.
+   *     std::string result = fmt::vformat("{}", store);
+   *     // result == "Rolling Scones"
+   */
   template <typename T> void push_back(std::reference_wrapper<T> arg) {
     static_assert(
         need_copy<T>::value,
@@ -193,41 +179,40 @@ class dynamic_format_arg_store
   }
 
   /**
-    Adds named argument into the dynamic store for later passing to a formatting
-    function. ``std::reference_wrapper`` is supported to avoid copying of the
-    argument. The name is always copied into the store.
-  */
+   * Adds named argument into the dynamic store for later passing to a
+   * formatting function. `std::reference_wrapper` is supported to avoid
+   * copying of the argument. The name is always copied into the store.
+   */
   template <typename T>
   void push_back(const detail::named_arg<char_type, T>& arg) {
     const char_type* arg_name =
         dynamic_args_.push<std::basic_string<char_type>>(arg.name).c_str();
     if (detail::const_check(need_copy<T>::value)) {
       emplace_arg(
-          fmt::arg(arg_name, dynamic_args_.push<stored_type<T>>(arg.value)));
+          fmt::arg(arg_name, dynamic_args_.push<stored_t<T>>(arg.value)));
     } else {
       emplace_arg(fmt::arg(arg_name, arg.value));
     }
   }
 
-  /** Erase all elements from the store */
+  /// Erase all elements from the store.
   void clear() {
     data_.clear();
     named_info_.clear();
-    dynamic_args_ = detail::dynamic_arg_list();
+    dynamic_args_ = {};
   }
 
-  /**
-    \rst
-    Reserves space to store at least *new_cap* arguments including
-    *new_cap_named* named arguments.
-    \endrst
-  */
+  /// Reserves space to store at least `new_cap` arguments including
+  /// `new_cap_named` named arguments.
   void reserve(size_t new_cap, size_t new_cap_named) {
     FMT_ASSERT(new_cap >= new_cap_named,
-               "Set of arguments includes set of named arguments");
+               "set of arguments includes set of named arguments");
     data_.reserve(new_cap);
     named_info_.reserve(new_cap_named);
   }
+
+  /// Returns the number of elements in the store.
+  size_t size() const noexcept { return data_.size(); }
 };
 
 FMT_END_NAMESPACE
diff --git a/3rdparty/fmt/include/fmt/base.h b/3rdparty/fmt/include/fmt/base.h
new file mode 100644
index 0000000000000..c1d09c6d4712d
--- /dev/null
+++ b/3rdparty/fmt/include/fmt/base.h
@@ -0,0 +1,2958 @@
+// Formatting library for C++ - the base API for char/UTF-8
+//
+// Copyright (c) 2012 - present, Victor Zverovich
+// All rights reserved.
+//
+// For the license information refer to format.h.
+
+#ifndef FMT_BASE_H_
+#define FMT_BASE_H_
+
+#if defined(FMT_IMPORT_STD) && !defined(FMT_MODULE)
+#  define FMT_MODULE
+#endif
+
+#ifndef FMT_MODULE
+#  include <limits.h>  // CHAR_BIT
+#  include <stdio.h>   // FILE
+#  include <string.h>  // memcmp
+
+#  include <type_traits>  // std::enable_if
+#endif
+
+// The fmt library version in the form major * 10000 + minor * 100 + patch.
+#define FMT_VERSION 110102
+
+// Detect compiler versions.
+#if defined(__clang__) && !defined(__ibmxl__)
+#  define FMT_CLANG_VERSION (__clang_major__ * 100 + __clang_minor__)
+#else
+#  define FMT_CLANG_VERSION 0
+#endif
+#if defined(__GNUC__) && !defined(__clang__) && !defined(__INTEL_COMPILER)
+#  define FMT_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
+#else
+#  define FMT_GCC_VERSION 0
+#endif
+#if defined(__ICL)
+#  define FMT_ICC_VERSION __ICL
+#elif defined(__INTEL_COMPILER)
+#  define FMT_ICC_VERSION __INTEL_COMPILER
+#else
+#  define FMT_ICC_VERSION 0
+#endif
+#if defined(_MSC_VER)
+#  define FMT_MSC_VERSION _MSC_VER
+#else
+#  define FMT_MSC_VERSION 0
+#endif
+
+// Detect standard library versions.
+#ifdef _GLIBCXX_RELEASE
+#  define FMT_GLIBCXX_RELEASE _GLIBCXX_RELEASE
+#else
+#  define FMT_GLIBCXX_RELEASE 0
+#endif
+#ifdef _LIBCPP_VERSION
+#  define FMT_LIBCPP_VERSION _LIBCPP_VERSION
+#else
+#  define FMT_LIBCPP_VERSION 0
+#endif
+
+#ifdef _MSVC_LANG
+#  define FMT_CPLUSPLUS _MSVC_LANG
+#else
+#  define FMT_CPLUSPLUS __cplusplus
+#endif
+
+// Detect __has_*.
+#ifdef __has_feature
+#  define FMT_HAS_FEATURE(x) __has_feature(x)
+#else
+#  define FMT_HAS_FEATURE(x) 0
+#endif
+#ifdef __has_include
+#  define FMT_HAS_INCLUDE(x) __has_include(x)
+#else
+#  define FMT_HAS_INCLUDE(x) 0
+#endif
+#ifdef __has_builtin
+#  define FMT_HAS_BUILTIN(x) __has_builtin(x)
+#else
+#  define FMT_HAS_BUILTIN(x) 0
+#endif
+#ifdef __has_cpp_attribute
+#  define FMT_HAS_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)
+#else
+#  define FMT_HAS_CPP_ATTRIBUTE(x) 0
+#endif
+
+#define FMT_HAS_CPP14_ATTRIBUTE(attribute) \
+  (FMT_CPLUSPLUS >= 201402L && FMT_HAS_CPP_ATTRIBUTE(attribute))
+
+#define FMT_HAS_CPP17_ATTRIBUTE(attribute) \
+  (FMT_CPLUSPLUS >= 201703L && FMT_HAS_CPP_ATTRIBUTE(attribute))
+
+// Detect C++14 relaxed constexpr.
+#ifdef FMT_USE_CONSTEXPR
+// Use the provided definition.
+#elif FMT_GCC_VERSION >= 600 && FMT_CPLUSPLUS >= 201402L
+// GCC only allows throw in constexpr since version 6:
+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67371.
+#  define FMT_USE_CONSTEXPR 1
+#elif FMT_ICC_VERSION
+#  define FMT_USE_CONSTEXPR 0  // https://github.com/fmtlib/fmt/issues/1628
+#elif FMT_HAS_FEATURE(cxx_relaxed_constexpr) || FMT_MSC_VERSION >= 1912
+#  define FMT_USE_CONSTEXPR 1
+#else
+#  define FMT_USE_CONSTEXPR 0
+#endif
+#if FMT_USE_CONSTEXPR
+#  define FMT_CONSTEXPR constexpr
+#else
+#  define FMT_CONSTEXPR
+#endif
+
+// Detect consteval, C++20 constexpr extensions and std::is_constant_evaluated.
+#if !defined(__cpp_lib_is_constant_evaluated)
+#  define FMT_USE_CONSTEVAL 0
+#elif FMT_CPLUSPLUS < 201709L
+#  define FMT_USE_CONSTEVAL 0
+#elif FMT_GLIBCXX_RELEASE && FMT_GLIBCXX_RELEASE < 10
+#  define FMT_USE_CONSTEVAL 0
+#elif FMT_LIBCPP_VERSION && FMT_LIBCPP_VERSION < 10000
+#  define FMT_USE_CONSTEVAL 0
+#elif defined(__apple_build_version__) && __apple_build_version__ < 14000029L
+#  define FMT_USE_CONSTEVAL 0  // consteval is broken in Apple clang < 14.
+#elif FMT_MSC_VERSION && FMT_MSC_VERSION < 1929
+#  define FMT_USE_CONSTEVAL 0  // consteval is broken in MSVC VS2019 < 16.10.
+#elif defined(__cpp_consteval)
+#  define FMT_USE_CONSTEVAL 1
+#elif FMT_GCC_VERSION >= 1002 || FMT_CLANG_VERSION >= 1101
+#  define FMT_USE_CONSTEVAL 1
+#else
+#  define FMT_USE_CONSTEVAL 0
+#endif
+#if FMT_USE_CONSTEVAL
+#  define FMT_CONSTEVAL consteval
+#  define FMT_CONSTEXPR20 constexpr
+#else
+#  define FMT_CONSTEVAL
+#  define FMT_CONSTEXPR20
+#endif
+
+// Check if exceptions are disabled.
+#ifdef FMT_USE_EXCEPTIONS
+// Use the provided definition.
+#elif defined(__GNUC__) && !defined(__EXCEPTIONS)
+#  define FMT_USE_EXCEPTIONS 0
+#elif defined(__clang__) && !defined(__cpp_exceptions)
+#  define FMT_USE_EXCEPTIONS 0
+#elif FMT_MSC_VERSION && !_HAS_EXCEPTIONS
+#  define FMT_USE_EXCEPTIONS 0
+#else
+#  define FMT_USE_EXCEPTIONS 1
+#endif
+#if FMT_USE_EXCEPTIONS
+#  define FMT_TRY try
+#  define FMT_CATCH(x) catch (x)
+#else
+#  define FMT_TRY if (true)
+#  define FMT_CATCH(x) if (false)
+#endif
+
+#ifdef FMT_NO_UNIQUE_ADDRESS
+// Use the provided definition.
+#elif FMT_CPLUSPLUS < 202002L
+// Not supported.
+#elif FMT_HAS_CPP_ATTRIBUTE(no_unique_address)
+#  define FMT_NO_UNIQUE_ADDRESS [[no_unique_address]]
+// VS2019 v16.10 and later except clang-cl (https://reviews.llvm.org/D110485).
+#elif FMT_MSC_VERSION >= 1929 && !FMT_CLANG_VERSION
+#  define FMT_NO_UNIQUE_ADDRESS [[msvc::no_unique_address]]
+#endif
+#ifndef FMT_NO_UNIQUE_ADDRESS
+#  define FMT_NO_UNIQUE_ADDRESS
+#endif
+
+#if FMT_HAS_CPP17_ATTRIBUTE(fallthrough)
+#  define FMT_FALLTHROUGH [[fallthrough]]
+#elif defined(__clang__)
+#  define FMT_FALLTHROUGH [[clang::fallthrough]]
+#elif FMT_GCC_VERSION >= 700 && \
+    (!defined(__EDG_VERSION__) || __EDG_VERSION__ >= 520)
+#  define FMT_FALLTHROUGH [[gnu::fallthrough]]
+#else
+#  define FMT_FALLTHROUGH
+#endif
+
+// Disable [[noreturn]] on MSVC/NVCC because of bogus unreachable code warnings.
+#if FMT_HAS_CPP_ATTRIBUTE(noreturn) && !FMT_MSC_VERSION && !defined(__NVCC__)
+#  define FMT_NORETURN [[noreturn]]
+#else
+#  define FMT_NORETURN
+#endif
+
+#ifdef FMT_NODISCARD
+// Use the provided definition.
+#elif FMT_HAS_CPP17_ATTRIBUTE(nodiscard)
+#  define FMT_NODISCARD [[nodiscard]]
+#else
+#  define FMT_NODISCARD
+#endif
+
+#ifdef FMT_DEPRECATED
+// Use the provided definition.
+#elif FMT_HAS_CPP14_ATTRIBUTE(deprecated)
+#  define FMT_DEPRECATED [[deprecated]]
+#else
+#  define FMT_DEPRECATED /* deprecated */
+#endif
+
+#ifdef FMT_ALWAYS_INLINE
+// Use the provided definition.
+#elif FMT_GCC_VERSION || FMT_CLANG_VERSION
+#  define FMT_ALWAYS_INLINE inline __attribute__((always_inline))
+#else
+#  define FMT_ALWAYS_INLINE inline
+#endif
+// A version of FMT_ALWAYS_INLINE to prevent code bloat in debug mode.
+#ifdef NDEBUG
+#  define FMT_INLINE FMT_ALWAYS_INLINE
+#else
+#  define FMT_INLINE inline
+#endif
+
+#if FMT_GCC_VERSION || FMT_CLANG_VERSION
+#  define FMT_VISIBILITY(value) __attribute__((visibility(value)))
+#else
+#  define FMT_VISIBILITY(value)
+#endif
+
+// Detect pragmas.
+#define FMT_PRAGMA_IMPL(x) _Pragma(#x)
+#if FMT_GCC_VERSION >= 504 && !defined(__NVCOMPILER)
+// Workaround a _Pragma bug https://gcc.gnu.org/bugzilla/show_bug.cgi?id=59884
+// and an nvhpc warning: https://github.com/fmtlib/fmt/pull/2582.
+#  define FMT_PRAGMA_GCC(x) FMT_PRAGMA_IMPL(GCC x)
+#else
+#  define FMT_PRAGMA_GCC(x)
+#endif
+#if FMT_CLANG_VERSION
+#  define FMT_PRAGMA_CLANG(x) FMT_PRAGMA_IMPL(clang x)
+#else
+#  define FMT_PRAGMA_CLANG(x)
+#endif
+#if FMT_MSC_VERSION
+#  define FMT_MSC_WARNING(...) __pragma(warning(__VA_ARGS__))
+#else
+#  define FMT_MSC_WARNING(...)
+#endif
+
+#ifndef FMT_BEGIN_NAMESPACE
+#  define FMT_BEGIN_NAMESPACE \
+    namespace fmt {           \
+    inline namespace v11 {
+#  define FMT_END_NAMESPACE \
+    }                       \
+    }
+#endif
+
+#ifndef FMT_EXPORT
+#  define FMT_EXPORT
+#  define FMT_BEGIN_EXPORT
+#  define FMT_END_EXPORT
+#endif
+
+#ifdef _WIN32
+#  define FMT_WIN32 1
+#else
+#  define FMT_WIN32 0
+#endif
+
+#if !defined(FMT_HEADER_ONLY) && FMT_WIN32
+#  if defined(FMT_LIB_EXPORT)
+#    define FMT_API __declspec(dllexport)
+#  elif defined(FMT_SHARED)
+#    define FMT_API __declspec(dllimport)
+#  endif
+#elif defined(FMT_LIB_EXPORT) || defined(FMT_SHARED)
+#  define FMT_API FMT_VISIBILITY("default")
+#endif
+#ifndef FMT_API
+#  define FMT_API
+#endif
+
+#ifndef FMT_OPTIMIZE_SIZE
+#  define FMT_OPTIMIZE_SIZE 0
+#endif
+
+// FMT_BUILTIN_TYPE=0 may result in smaller library size at the cost of higher
+// per-call binary size by passing built-in types through the extension API.
+#ifndef FMT_BUILTIN_TYPES
+#  define FMT_BUILTIN_TYPES 1
+#endif
+
+#define FMT_APPLY_VARIADIC(expr) \
+  using ignore = int[];          \
+  (void)ignore { 0, (expr, 0)... }
+
+// Enable minimal optimizations for more compact code in debug mode.
+FMT_PRAGMA_GCC(push_options)
+#if !defined(__OPTIMIZE__) && !defined(__CUDACC__)
+FMT_PRAGMA_GCC(optimize("Og"))
+#endif
+FMT_PRAGMA_CLANG(diagnostic push)
+
+FMT_BEGIN_NAMESPACE
+
+// Implementations of enable_if_t and other metafunctions for older systems.
+template <bool B, typename T = void>
+using enable_if_t = typename std::enable_if<B, T>::type;
+template <bool B, typename T, typename F>
+using conditional_t = typename std::conditional<B, T, F>::type;
+template <bool B> using bool_constant = std::integral_constant<bool, B>;
+template <typename T>
+using remove_reference_t = typename std::remove_reference<T>::type;
+template <typename T>
+using remove_const_t = typename std::remove_const<T>::type;
+template <typename T>
+using remove_cvref_t = typename std::remove_cv<remove_reference_t<T>>::type;
+template <typename T>
+using make_unsigned_t = typename std::make_unsigned<T>::type;
+template <typename T>
+using underlying_t = typename std::underlying_type<T>::type;
+template <typename T> using decay_t = typename std::decay<T>::type;
+using nullptr_t = decltype(nullptr);
+
+#if FMT_GCC_VERSION && FMT_GCC_VERSION < 500
+// A workaround for gcc 4.9 to make void_t work in a SFINAE context.
+template <typename...> struct void_t_impl {
+  using type = void;
+};
+template <typename... T> using void_t = typename void_t_impl<T...>::type;
+#else
+template <typename...> using void_t = void;
+#endif
+
+struct monostate {
+  constexpr monostate() {}
+};
+
+// An enable_if helper to be used in template parameters which results in much
+// shorter symbols: https://godbolt.org/z/sWw4vP. Extra parentheses are needed
+// to workaround a bug in MSVC 2019 (see #1140 and #1186).
+#ifdef FMT_DOC
+#  define FMT_ENABLE_IF(...)
+#else
+#  define FMT_ENABLE_IF(...) fmt::enable_if_t<(__VA_ARGS__), int> = 0
+#endif
+
+template <typename T> constexpr auto min_of(T a, T b) -> T {
+  return a < b ? a : b;
+}
+template <typename T> constexpr auto max_of(T a, T b) -> T {
+  return a > b ? a : b;
+}
+
+namespace detail {
+// Suppresses "unused variable" warnings with the method described in
+// https://herbsutter.com/2009/10/18/mailbag-shutting-up-compiler-warnings/.
+// (void)var does not work on many Intel compilers.
+template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}
+
+constexpr auto is_constant_evaluated(bool default_value = false) noexcept
+    -> bool {
+// Workaround for incompatibility between clang 14 and libstdc++ consteval-based
+// std::is_constant_evaluated: https://github.com/fmtlib/fmt/issues/3247.
+#if FMT_CPLUSPLUS >= 202002L && FMT_GLIBCXX_RELEASE >= 12 && \
+    (FMT_CLANG_VERSION >= 1400 && FMT_CLANG_VERSION < 1500)
+  ignore_unused(default_value);
+  return __builtin_is_constant_evaluated();
+#elif defined(__cpp_lib_is_constant_evaluated)
+  ignore_unused(default_value);
+  return std::is_constant_evaluated();
+#else
+  return default_value;
+#endif
+}
+
+// Suppresses "conditional expression is constant" warnings.
+template <typename T> FMT_ALWAYS_INLINE constexpr auto const_check(T val) -> T {
+  return val;
+}
+
+FMT_NORETURN FMT_API void assert_fail(const char* file, int line,
+                                      const char* message);
+
+#if defined(FMT_ASSERT)
+// Use the provided definition.
+#elif defined(NDEBUG)
+// FMT_ASSERT is not empty to avoid -Wempty-body.
+#  define FMT_ASSERT(condition, message) \
+    fmt::detail::ignore_unused((condition), (message))
+#else
+#  define FMT_ASSERT(condition, message)                                    \
+    ((condition) /* void() fails with -Winvalid-constexpr on clang 4.0.1 */ \
+         ? (void)0                                                          \
+         : fmt::detail::assert_fail(__FILE__, __LINE__, (message)))
+#endif
+
+#ifdef FMT_USE_INT128
+// Use the provided definition.
+#elif defined(__SIZEOF_INT128__) && !defined(__NVCC__) && \
+    !(FMT_CLANG_VERSION && FMT_MSC_VERSION)
+#  define FMT_USE_INT128 1
+using int128_opt = __int128_t;  // An optional native 128-bit integer.
+using uint128_opt = __uint128_t;
+inline auto map(int128_opt x) -> int128_opt { return x; }
+inline auto map(uint128_opt x) -> uint128_opt { return x; }
+#else
+#  define FMT_USE_INT128 0
+#endif
+#if !FMT_USE_INT128
+enum class int128_opt {};
+enum class uint128_opt {};
+// Reduce template instantiations.
+inline auto map(int128_opt) -> monostate { return {}; }
+inline auto map(uint128_opt) -> monostate { return {}; }
+#endif
+
+#ifndef FMT_USE_BITINT
+#  define FMT_USE_BITINT (FMT_CLANG_VERSION >= 1500)
+#endif
+
+#if FMT_USE_BITINT
+FMT_PRAGMA_CLANG(diagnostic ignored "-Wbit-int-extension")
+template <int N> using bitint = _BitInt(N);
+template <int N> using ubitint = unsigned _BitInt(N);
+#else
+template <int N> struct bitint {};
+template <int N> struct ubitint {};
+#endif  // FMT_USE_BITINT
+
+// Casts a nonnegative integer to unsigned.
+template <typename Int>
+FMT_CONSTEXPR auto to_unsigned(Int value) -> make_unsigned_t<Int> {
+  FMT_ASSERT(std::is_unsigned<Int>::value || value >= 0, "negative value");
+  return static_cast<make_unsigned_t<Int>>(value);
+}
+
+template <typename Char>
+using unsigned_char = conditional_t<sizeof(Char) == 1, unsigned char, unsigned>;
+
+// A heuristic to detect std::string and std::[experimental::]string_view.
+// It is mainly used to avoid dependency on <[experimental/]string_view>.
+template <typename T, typename Enable = void>
+struct is_std_string_like : std::false_type {};
+template <typename T>
+struct is_std_string_like<T, void_t<decltype(std::declval<T>().find_first_of(
+                                 typename T::value_type(), 0))>>
+    : std::is_convertible<decltype(std::declval<T>().data()),
+                          const typename T::value_type*> {};
+
+// Check if the literal encoding is UTF-8.
+enum { is_utf8_enabled = "\u00A7"[1] == '\xA7' };
+enum { use_utf8 = !FMT_WIN32 || is_utf8_enabled };
+
+#ifndef FMT_UNICODE
+#  define FMT_UNICODE 1
+#endif
+
+static_assert(!FMT_UNICODE || use_utf8,
+              "Unicode support requires compiling with /utf-8");
+
+template <typename T> constexpr const char* narrow(const T*) { return nullptr; }
+constexpr FMT_ALWAYS_INLINE const char* narrow(const char* s) { return s; }
+
+template <typename Char>
+FMT_CONSTEXPR auto compare(const Char* s1, const Char* s2, std::size_t n)
+    -> int {
+  if (!is_constant_evaluated() && sizeof(Char) == 1) return memcmp(s1, s2, n);
+  for (; n != 0; ++s1, ++s2, --n) {
+    if (*s1 < *s2) return -1;
+    if (*s1 > *s2) return 1;
+  }
+  return 0;
+}
+
+namespace adl {
+using namespace std;
+
+template <typename Container>
+auto invoke_back_inserter()
+    -> decltype(back_inserter(std::declval<Container&>()));
+}  // namespace adl
+
+template <typename It, typename Enable = std::true_type>
+struct is_back_insert_iterator : std::false_type {};
+
+template <typename It>
+struct is_back_insert_iterator<
+    It, bool_constant<std::is_same<
+            decltype(adl::invoke_back_inserter<typename It::container_type>()),
+            It>::value>> : std::true_type {};
+
+// Extracts a reference to the container from *insert_iterator.
+template <typename OutputIt>
+inline FMT_CONSTEXPR20 auto get_container(OutputIt it) ->
+    typename OutputIt::container_type& {
+  struct accessor : OutputIt {
+    FMT_CONSTEXPR20 accessor(OutputIt base) : OutputIt(base) {}
+    using OutputIt::container;
+  };
+  return *accessor(it).container;
+}
+}  // namespace detail
+
+// Parsing-related public API and forward declarations.
+FMT_BEGIN_EXPORT
+
+/**
+ * An implementation of `std::basic_string_view` for pre-C++17. It provides a
+ * subset of the API. `fmt::basic_string_view` is used for format strings even
+ * if `std::basic_string_view` is available to prevent issues when a library is
+ * compiled with a different `-std` option than the client code (which is not
+ * recommended).
+ */
+template <typename Char> class basic_string_view {
+ private:
+  const Char* data_;
+  size_t size_;
+
+ public:
+  using value_type = Char;
+  using iterator = const Char*;
+
+  constexpr basic_string_view() noexcept : data_(nullptr), size_(0) {}
+
+  /// Constructs a string reference object from a C string and a size.
+  constexpr basic_string_view(const Char* s, size_t count) noexcept
+      : data_(s), size_(count) {}
+
+  constexpr basic_string_view(nullptr_t) = delete;
+
+  /// Constructs a string reference object from a C string.
+#if FMT_GCC_VERSION
+  FMT_ALWAYS_INLINE
+#endif
+  FMT_CONSTEXPR20 basic_string_view(const Char* s) : data_(s) {
+#if FMT_HAS_BUILTIN(__buitin_strlen) || FMT_GCC_VERSION || FMT_CLANG_VERSION
+    if (std::is_same<Char, char>::value) {
+      size_ = __builtin_strlen(detail::narrow(s));
+      return;
+    }
+#endif
+    size_t len = 0;
+    while (*s++) ++len;
+    size_ = len;
+  }
+
+  /// Constructs a string reference from a `std::basic_string` or a
+  /// `std::basic_string_view` object.
+  template <typename S,
+            FMT_ENABLE_IF(detail::is_std_string_like<S>::value&& std::is_same<
+                          typename S::value_type, Char>::value)>
+  FMT_CONSTEXPR basic_string_view(const S& s) noexcept
+      : data_(s.data()), size_(s.size()) {}
+
+  /// Returns a pointer to the string data.
+  constexpr auto data() const noexcept -> const Char* { return data_; }
+
+  /// Returns the string size.
+  constexpr auto size() const noexcept -> size_t { return size_; }
+
+  constexpr auto begin() const noexcept -> iterator { return data_; }
+  constexpr auto end() const noexcept -> iterator { return data_ + size_; }
+
+  constexpr auto operator[](size_t pos) const noexcept -> const Char& {
+    return data_[pos];
+  }
+
+  FMT_CONSTEXPR void remove_prefix(size_t n) noexcept {
+    data_ += n;
+    size_ -= n;
+  }
+
+  FMT_CONSTEXPR auto starts_with(basic_string_view<Char> sv) const noexcept
+      -> bool {
+    return size_ >= sv.size_ && detail::compare(data_, sv.data_, sv.size_) == 0;
+  }
+  FMT_CONSTEXPR auto starts_with(Char c) const noexcept -> bool {
+    return size_ >= 1 && *data_ == c;
+  }
+  FMT_CONSTEXPR auto starts_with(const Char* s) const -> bool {
+    return starts_with(basic_string_view<Char>(s));
+  }
+
+  // Lexicographically compare this string reference to other.
+  FMT_CONSTEXPR auto compare(basic_string_view other) const -> int {
+    int result =
+        detail::compare(data_, other.data_, min_of(size_, other.size_));
+    if (result != 0) return result;
+    return size_ == other.size_ ? 0 : (size_ < other.size_ ? -1 : 1);
+  }
+
+  FMT_CONSTEXPR friend auto operator==(basic_string_view lhs,
+                                       basic_string_view rhs) -> bool {
+    return lhs.compare(rhs) == 0;
+  }
+  friend auto operator!=(basic_string_view lhs, basic_string_view rhs) -> bool {
+    return lhs.compare(rhs) != 0;
+  }
+  friend auto operator<(basic_string_view lhs, basic_string_view rhs) -> bool {
+    return lhs.compare(rhs) < 0;
+  }
+  friend auto operator<=(basic_string_view lhs, basic_string_view rhs) -> bool {
+    return lhs.compare(rhs) <= 0;
+  }
+  friend auto operator>(basic_string_view lhs, basic_string_view rhs) -> bool {
+    return lhs.compare(rhs) > 0;
+  }
+  friend auto operator>=(basic_string_view lhs, basic_string_view rhs) -> bool {
+    return lhs.compare(rhs) >= 0;
+  }
+};
+
+using string_view = basic_string_view<char>;
+
+/// Specifies if `T` is an extended character type. Can be specialized by users.
+template <typename T> struct is_xchar : std::false_type {};
+template <> struct is_xchar<wchar_t> : std::true_type {};
+template <> struct is_xchar<char16_t> : std::true_type {};
+template <> struct is_xchar<char32_t> : std::true_type {};
+#ifdef __cpp_char8_t
+template <> struct is_xchar<char8_t> : std::true_type {};
+#endif
+
+// DEPRECATED! Will be replaced with an alias to prevent specializations.
+template <typename T> struct is_char : is_xchar<T> {};
+template <> struct is_char<char> : std::true_type {};
+
+template <typename T> class basic_appender;
+using appender = basic_appender<char>;
+
+// Checks whether T is a container with contiguous storage.
+template <typename T> struct is_contiguous : std::false_type {};
+
+class context;
+template <typename OutputIt, typename Char> class generic_context;
+template <typename Char> class parse_context;
+
+// Longer aliases for C++20 compatibility.
+template <typename Char> using basic_format_parse_context = parse_context<Char>;
+using format_parse_context = parse_context<char>;
+template <typename OutputIt, typename Char>
+using basic_format_context =
+    conditional_t<std::is_same<OutputIt, appender>::value, context,
+                  generic_context<OutputIt, Char>>;
+using format_context = context;
+
+template <typename Char>
+using buffered_context =
+    conditional_t<std::is_same<Char, char>::value, context,
+                  generic_context<basic_appender<Char>, Char>>;
+
+template <typename Context> class basic_format_arg;
+template <typename Context> class basic_format_args;
+
+// A separate type would result in shorter symbols but break ABI compatibility
+// between clang and gcc on ARM (#1919).
+using format_args = basic_format_args<context>;
+
+// A formatter for objects of type T.
+template <typename T, typename Char = char, typename Enable = void>
+struct formatter {
+  // A deleted default constructor indicates a disabled formatter.
+  formatter() = delete;
+};
+
+/// Reports a format error at compile time or, via a `format_error` exception,
+/// at runtime.
+// This function is intentionally not constexpr to give a compile-time error.
+FMT_NORETURN FMT_API void report_error(const char* message);
+
+enum class presentation_type : unsigned char {
+  // Common specifiers:
+  none = 0,
+  debug = 1,   // '?'
+  string = 2,  // 's' (string, bool)
+
+  // Integral, bool and character specifiers:
+  dec = 3,  // 'd'
+  hex,      // 'x' or 'X'
+  oct,      // 'o'
+  bin,      // 'b' or 'B'
+  chr,      // 'c'
+
+  // String and pointer specifiers:
+  pointer = 3,  // 'p'
+
+  // Floating-point specifiers:
+  exp = 1,  // 'e' or 'E' (1 since there is no FP debug presentation)
+  fixed,    // 'f' or 'F'
+  general,  // 'g' or 'G'
+  hexfloat  // 'a' or 'A'
+};
+
+enum class align { none, left, right, center, numeric };
+enum class sign { none, minus, plus, space };
+enum class arg_id_kind { none, index, name };
+
+// Basic format specifiers for built-in and string types.
+class basic_specs {
+ private:
+  // Data is arranged as follows:
+  //
+  //  0                   1                   2                   3
+  //  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+  // +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  // |type |align| w | p | s |u|#|L|  f  |          unused           |
+  // +-----+-----+---+---+---+-+-+-+-----+---------------------------+
+  //
+  //   w - dynamic width info
+  //   p - dynamic precision info
+  //   s - sign
+  //   u - uppercase (e.g. 'X' for 'x')
+  //   # - alternate form ('#')
+  //   L - localized
+  //   f - fill size
+  //
+  // Bitfields are not used because of compiler bugs such as gcc bug 61414.
+  enum : unsigned {
+    type_mask = 0x00007,
+    align_mask = 0x00038,
+    width_mask = 0x000C0,
+    precision_mask = 0x00300,
+    sign_mask = 0x00C00,
+    uppercase_mask = 0x01000,
+    alternate_mask = 0x02000,
+    localized_mask = 0x04000,
+    fill_size_mask = 0x38000,
+
+    align_shift = 3,
+    width_shift = 6,
+    precision_shift = 8,
+    sign_shift = 10,
+    fill_size_shift = 15,
+
+    max_fill_size = 4
+  };
+
+  size_t data_ = 1 << fill_size_shift;
+
+  // Character (code unit) type is erased to prevent template bloat.
+  char fill_data_[max_fill_size] = {' '};
+
+  FMT_CONSTEXPR void set_fill_size(size_t size) {
+    data_ = (data_ & ~fill_size_mask) | (size << fill_size_shift);
+  }
+
+ public:
+  constexpr auto type() const -> presentation_type {
+    return static_cast<presentation_type>(data_ & type_mask);
+  }
+  FMT_CONSTEXPR void set_type(presentation_type t) {
+    data_ = (data_ & ~type_mask) | static_cast<unsigned>(t);
+  }
+
+  constexpr auto align() const -> align {
+    return static_cast<fmt::align>((data_ & align_mask) >> align_shift);
+  }
+  FMT_CONSTEXPR void set_align(fmt::align a) {
+    data_ = (data_ & ~align_mask) | (static_cast<unsigned>(a) << align_shift);
+  }
+
+  constexpr auto dynamic_width() const -> arg_id_kind {
+    return static_cast<arg_id_kind>((data_ & width_mask) >> width_shift);
+  }
+  FMT_CONSTEXPR void set_dynamic_width(arg_id_kind w) {
+    data_ = (data_ & ~width_mask) | (static_cast<unsigned>(w) << width_shift);
+  }
+
+  FMT_CONSTEXPR auto dynamic_precision() const -> arg_id_kind {
+    return static_cast<arg_id_kind>((data_ & precision_mask) >>
+                                    precision_shift);
+  }
+  FMT_CONSTEXPR void set_dynamic_precision(arg_id_kind p) {
+    data_ = (data_ & ~precision_mask) |
+            (static_cast<unsigned>(p) << precision_shift);
+  }
+
+  constexpr bool dynamic() const {
+    return (data_ & (width_mask | precision_mask)) != 0;
+  }
+
+  constexpr auto sign() const -> sign {
+    return static_cast<fmt::sign>((data_ & sign_mask) >> sign_shift);
+  }
+  FMT_CONSTEXPR void set_sign(fmt::sign s) {
+    data_ = (data_ & ~sign_mask) | (static_cast<unsigned>(s) << sign_shift);
+  }
+
+  constexpr auto upper() const -> bool { return (data_ & uppercase_mask) != 0; }
+  FMT_CONSTEXPR void set_upper() { data_ |= uppercase_mask; }
+
+  constexpr auto alt() const -> bool { return (data_ & alternate_mask) != 0; }
+  FMT_CONSTEXPR void set_alt() { data_ |= alternate_mask; }
+  FMT_CONSTEXPR void clear_alt() { data_ &= ~alternate_mask; }
+
+  constexpr auto localized() const -> bool {
+    return (data_ & localized_mask) != 0;
+  }
+  FMT_CONSTEXPR void set_localized() { data_ |= localized_mask; }
+
+  constexpr auto fill_size() const -> size_t {
+    return (data_ & fill_size_mask) >> fill_size_shift;
+  }
+
+  template <typename Char, FMT_ENABLE_IF(std::is_same<Char, char>::value)>
+  constexpr auto fill() const -> const Char* {
+    return fill_data_;
+  }
+  template <typename Char, FMT_ENABLE_IF(!std::is_same<Char, char>::value)>
+  constexpr auto fill() const -> const Char* {
+    return nullptr;
+  }
+
+  template <typename Char> constexpr auto fill_unit() const -> Char {
+    using uchar = unsigned char;
+    return static_cast<Char>(static_cast<uchar>(fill_data_[0]) |
+                             (static_cast<uchar>(fill_data_[1]) << 8) |
+                             (static_cast<uchar>(fill_data_[2]) << 16));
+  }
+
+  FMT_CONSTEXPR void set_fill(char c) {
+    fill_data_[0] = c;
+    set_fill_size(1);
+  }
+
+  template <typename Char>
+  FMT_CONSTEXPR void set_fill(basic_string_view<Char> s) {
+    auto size = s.size();
+    set_fill_size(size);
+    if (size == 1) {
+      unsigned uchar = static_cast<detail::unsigned_char<Char>>(s[0]);
+      fill_data_[0] = static_cast<char>(uchar);
+      fill_data_[1] = static_cast<char>(uchar >> 8);
+      fill_data_[2] = static_cast<char>(uchar >> 16);
+      return;
+    }
+    FMT_ASSERT(size <= max_fill_size, "invalid fill");
+    for (size_t i = 0; i < size; ++i)
+      fill_data_[i & 3] = static_cast<char>(s[i]);
+  }
+
+  FMT_CONSTEXPR void copy_fill_from(const basic_specs& specs) {
+    set_fill_size(specs.fill_size());
+    for (size_t i = 0; i < max_fill_size; ++i)
+      fill_data_[i] = specs.fill_data_[i];
+  }
+};
+
+// Format specifiers for built-in and string types.
+struct format_specs : basic_specs {
+  int width;
+  int precision;
+
+  constexpr format_specs() : width(0), precision(-1) {}
+};
+
+/**
+ * Parsing context consisting of a format string range being parsed and an
+ * argument counter for automatic indexing.
+ */
+template <typename Char = char> class parse_context {
+ private:
+  basic_string_view<Char> fmt_;
+  int next_arg_id_;
+
+  enum { use_constexpr_cast = !FMT_GCC_VERSION || FMT_GCC_VERSION >= 1200 };
+
+  FMT_CONSTEXPR void do_check_arg_id(int arg_id);
+
+ public:
+  using char_type = Char;
+  using iterator = const Char*;
+
+  constexpr explicit parse_context(basic_string_view<Char> fmt,
+                                   int next_arg_id = 0)
+      : fmt_(fmt), next_arg_id_(next_arg_id) {}
+
+  /// Returns an iterator to the beginning of the format string range being
+  /// parsed.
+  constexpr auto begin() const noexcept -> iterator { return fmt_.begin(); }
+
+  /// Returns an iterator past the end of the format string range being parsed.
+  constexpr auto end() const noexcept -> iterator { return fmt_.end(); }
+
+  /// Advances the begin iterator to `it`.
+  FMT_CONSTEXPR void advance_to(iterator it) {
+    fmt_.remove_prefix(detail::to_unsigned(it - begin()));
+  }
+
+  /// Reports an error if using the manual argument indexing; otherwise returns
+  /// the next argument index and switches to the automatic indexing.
+  FMT_CONSTEXPR auto next_arg_id() -> int {
+    if (next_arg_id_ < 0) {
+      report_error("cannot switch from manual to automatic argument indexing");
+      return 0;
+    }
+    int id = next_arg_id_++;
+    do_check_arg_id(id);
+    return id;
+  }
+
+  /// Reports an error if using the automatic argument indexing; otherwise
+  /// switches to the manual indexing.
+  FMT_CONSTEXPR void check_arg_id(int id) {
+    if (next_arg_id_ > 0) {
+      report_error("cannot switch from automatic to manual argument indexing");
+      return;
+    }
+    next_arg_id_ = -1;
+    do_check_arg_id(id);
+  }
+  FMT_CONSTEXPR void check_arg_id(basic_string_view<Char>) {
+    next_arg_id_ = -1;
+  }
+  FMT_CONSTEXPR void check_dynamic_spec(int arg_id);
+};
+
+FMT_END_EXPORT
+
+namespace detail {
+
+// Constructs fmt::basic_string_view<Char> from types implicitly convertible
+// to it, deducing Char. Explicitly convertible types such as the ones returned
+// from FMT_STRING are intentionally excluded.
+template <typename Char, FMT_ENABLE_IF(is_char<Char>::value)>
+constexpr auto to_string_view(const Char* s) -> basic_string_view<Char> {
+  return s;
+}
+template <typename T, FMT_ENABLE_IF(is_std_string_like<T>::value)>
+constexpr auto to_string_view(const T& s)
+    -> basic_string_view<typename T::value_type> {
+  return s;
+}
+template <typename Char>
+constexpr auto to_string_view(basic_string_view<Char> s)
+    -> basic_string_view<Char> {
+  return s;
+}
+
+template <typename T, typename Enable = void>
+struct has_to_string_view : std::false_type {};
+// detail:: is intentional since to_string_view is not an extension point.
+template <typename T>
+struct has_to_string_view<
+    T, void_t<decltype(detail::to_string_view(std::declval<T>()))>>
+    : std::true_type {};
+
+/// String's character (code unit) type. detail:: is intentional to prevent ADL.
+template <typename S,
+          typename V = decltype(detail::to_string_view(std::declval<S>()))>
+using char_t = typename V::value_type;
+
+enum class type {
+  none_type,
+  // Integer types should go first,
+  int_type,
+  uint_type,
+  long_long_type,
+  ulong_long_type,
+  int128_type,
+  uint128_type,
+  bool_type,
+  char_type,
+  last_integer_type = char_type,
+  // followed by floating-point types.
+  float_type,
+  double_type,
+  long_double_type,
+  last_numeric_type = long_double_type,
+  cstring_type,
+  string_type,
+  pointer_type,
+  custom_type
+};
+
+// Maps core type T to the corresponding type enum constant.
+template <typename T, typename Char>
+struct type_constant : std::integral_constant<type, type::custom_type> {};
+
+#define FMT_TYPE_CONSTANT(Type, constant) \
+  template <typename Char>                \
+  struct type_constant<Type, Char>        \
+      : std::integral_constant<type, type::constant> {}
+
+FMT_TYPE_CONSTANT(int, int_type);
+FMT_TYPE_CONSTANT(unsigned, uint_type);
+FMT_TYPE_CONSTANT(long long, long_long_type);
+FMT_TYPE_CONSTANT(unsigned long long, ulong_long_type);
+FMT_TYPE_CONSTANT(int128_opt, int128_type);
+FMT_TYPE_CONSTANT(uint128_opt, uint128_type);
+FMT_TYPE_CONSTANT(bool, bool_type);
+FMT_TYPE_CONSTANT(Char, char_type);
+FMT_TYPE_CONSTANT(float, float_type);
+FMT_TYPE_CONSTANT(double, double_type);
+FMT_TYPE_CONSTANT(long double, long_double_type);
+FMT_TYPE_CONSTANT(const Char*, cstring_type);
+FMT_TYPE_CONSTANT(basic_string_view<Char>, string_type);
+FMT_TYPE_CONSTANT(const void*, pointer_type);
+
+constexpr auto is_integral_type(type t) -> bool {
+  return t > type::none_type && t <= type::last_integer_type;
+}
+constexpr auto is_arithmetic_type(type t) -> bool {
+  return t > type::none_type && t <= type::last_numeric_type;
+}
+
+constexpr auto set(type rhs) -> int { return 1 << static_cast<int>(rhs); }
+constexpr auto in(type t, int set) -> bool {
+  return ((set >> static_cast<int>(t)) & 1) != 0;
+}
+
+// Bitsets of types.
+enum {
+  sint_set =
+      set(type::int_type) | set(type::long_long_type) | set(type::int128_type),
+  uint_set = set(type::uint_type) | set(type::ulong_long_type) |
+             set(type::uint128_type),
+  bool_set = set(type::bool_type),
+  char_set = set(type::char_type),
+  float_set = set(type::float_type) | set(type::double_type) |
+              set(type::long_double_type),
+  string_set = set(type::string_type),
+  cstring_set = set(type::cstring_type),
+  pointer_set = set(type::pointer_type)
+};
+
+struct view {};
+
+template <typename Char, typename T> struct named_arg;
+template <typename T> struct is_named_arg : std::false_type {};
+template <typename T> struct is_static_named_arg : std::false_type {};
+
+template <typename Char, typename T>
+struct is_named_arg<named_arg<Char, T>> : std::true_type {};
+
+template <typename Char, typename T> struct named_arg : view {
+  const Char* name;
+  const T& value;
+
+  named_arg(const Char* n, const T& v) : name(n), value(v) {}
+  static_assert(!is_named_arg<T>::value, "nested named arguments");
+};
+
+template <bool B = false> constexpr auto count() -> int { return B ? 1 : 0; }
+template <bool B1, bool B2, bool... Tail> constexpr auto count() -> int {
+  return (B1 ? 1 : 0) + count<B2, Tail...>();
+}
+
+template <typename... Args> constexpr auto count_named_args() -> int {
+  return count<is_named_arg<Args>::value...>();
+}
+template <typename... Args> constexpr auto count_static_named_args() -> int {
+  return count<is_static_named_arg<Args>::value...>();
+}
+
+template <typename Char> struct named_arg_info {
+  const Char* name;
+  int id;
+};
+
+template <typename Char, typename T, FMT_ENABLE_IF(!is_named_arg<T>::value)>
+void init_named_arg(named_arg_info<Char>*, int& arg_index, int&, const T&) {
+  ++arg_index;
+}
+template <typename Char, typename T, FMT_ENABLE_IF(is_named_arg<T>::value)>
+void init_named_arg(named_arg_info<Char>* named_args, int& arg_index,
+                    int& named_arg_index, const T& arg) {
+  named_args[named_arg_index++] = {arg.name, arg_index++};
+}
+
+template <typename T, typename Char,
+          FMT_ENABLE_IF(!is_static_named_arg<T>::value)>
+FMT_CONSTEXPR void init_static_named_arg(named_arg_info<Char>*, int& arg_index,
+                                         int&) {
+  ++arg_index;
+}
+template <typename T, typename Char,
+          FMT_ENABLE_IF(is_static_named_arg<T>::value)>
+FMT_CONSTEXPR void init_static_named_arg(named_arg_info<Char>* named_args,
+                                         int& arg_index, int& named_arg_index) {
+  named_args[named_arg_index++] = {T::name, arg_index++};
+}
+
+// To minimize the number of types we need to deal with, long is translated
+// either to int or to long long depending on its size.
+enum { long_short = sizeof(long) == sizeof(int) };
+using long_type = conditional_t<long_short, int, long long>;
+using ulong_type = conditional_t<long_short, unsigned, unsigned long long>;
+
+template <typename T>
+using format_as_result =
+    remove_cvref_t<decltype(format_as(std::declval<const T&>()))>;
+template <typename T>
+using format_as_member_result =
+    remove_cvref_t<decltype(formatter<T>::format_as(std::declval<const T&>()))>;
+
+template <typename T, typename Enable = std::true_type>
+struct use_format_as : std::false_type {};
+// format_as member is only used to avoid injection into the std namespace.
+template <typename T, typename Enable = std::true_type>
+struct use_format_as_member : std::false_type {};
+
+// Only map owning types because mapping views can be unsafe.
+template <typename T>
+struct use_format_as<
+    T, bool_constant<std::is_arithmetic<format_as_result<T>>::value>>
+    : std::true_type {};
+template <typename T>
+struct use_format_as_member<
+    T, bool_constant<std::is_arithmetic<format_as_member_result<T>>::value>>
+    : std::true_type {};
+
+template <typename T, typename U = remove_const_t<T>>
+using use_formatter =
+    bool_constant<(std::is_class<T>::value || std::is_enum<T>::value ||
+                   std::is_union<T>::value || std::is_array<T>::value) &&
+                  !has_to_string_view<T>::value && !is_named_arg<T>::value &&
+                  !use_format_as<T>::value && !use_format_as_member<T>::value>;
+
+template <typename Char, typename T, typename U = remove_const_t<T>>
+auto has_formatter_impl(T* p, buffered_context<Char>* ctx = nullptr)
+    -> decltype(formatter<U, Char>().format(*p, *ctx), std::true_type());
+template <typename Char> auto has_formatter_impl(...) -> std::false_type;
+
+// T can be const-qualified to check if it is const-formattable.
+template <typename T, typename Char> constexpr auto has_formatter() -> bool {
+  return decltype(has_formatter_impl<Char>(static_cast<T*>(nullptr)))::value;
+}
+
+// Maps formatting argument types to natively supported types or user-defined
+// types with formatters. Returns void on errors to be SFINAE-friendly.
+template <typename Char> struct type_mapper {
+  static auto map(signed char) -> int;
+  static auto map(unsigned char) -> unsigned;
+  static auto map(short) -> int;
+  static auto map(unsigned short) -> unsigned;
+  static auto map(int) -> int;
+  static auto map(unsigned) -> unsigned;
+  static auto map(long) -> long_type;
+  static auto map(unsigned long) -> ulong_type;
+  static auto map(long long) -> long long;
+  static auto map(unsigned long long) -> unsigned long long;
+  static auto map(int128_opt) -> int128_opt;
+  static auto map(uint128_opt) -> uint128_opt;
+  static auto map(bool) -> bool;
+
+  template <int N>
+  static auto map(bitint<N>) -> conditional_t<N <= 64, long long, void>;
+  template <int N>
+  static auto map(ubitint<N>)
+      -> conditional_t<N <= 64, unsigned long long, void>;
+
+  template <typename T, FMT_ENABLE_IF(is_char<T>::value)>
+  static auto map(T) -> conditional_t<
+      std::is_same<T, char>::value || std::is_same<T, Char>::value, Char, void>;
+
+  static auto map(float) -> float;
+  static auto map(double) -> double;
+  static auto map(long double) -> long double;
+
+  static auto map(Char*) -> const Char*;
+  static auto map(const Char*) -> const Char*;
+  template <typename T, typename C = char_t<T>,
+            FMT_ENABLE_IF(!std::is_pointer<T>::value)>
+  static auto map(const T&) -> conditional_t<std::is_same<C, Char>::value,
+                                             basic_string_view<C>, void>;
+
+  static auto map(void*) -> const void*;
+  static auto map(const void*) -> const void*;
+  static auto map(volatile void*) -> const void*;
+  static auto map(const volatile void*) -> const void*;
+  static auto map(nullptr_t) -> const void*;
+  template <typename T, FMT_ENABLE_IF(std::is_pointer<T>::value ||
+                                      std::is_member_pointer<T>::value)>
+  static auto map(const T&) -> void;
+
+  template <typename T, FMT_ENABLE_IF(use_format_as<T>::value)>
+  static auto map(const T& x) -> decltype(map(format_as(x)));
+  template <typename T, FMT_ENABLE_IF(use_format_as_member<T>::value)>
+  static auto map(const T& x) -> decltype(map(formatter<T>::format_as(x)));
+
+  template <typename T, FMT_ENABLE_IF(use_formatter<T>::value)>
+  static auto map(T&) -> conditional_t<has_formatter<T, Char>(), T&, void>;
+
+  template <typename T, FMT_ENABLE_IF(is_named_arg<T>::value)>
+  static auto map(const T& named_arg) -> decltype(map(named_arg.value));
+};
+
+// detail:: is used to workaround a bug in MSVC 2017.
+template <typename T, typename Char>
+using mapped_t = decltype(detail::type_mapper<Char>::map(std::declval<T&>()));
+
+// A type constant after applying type_mapper.
+template <typename T, typename Char = char>
+using mapped_type_constant = type_constant<mapped_t<T, Char>, Char>;
+
+template <typename T, typename Context,
+          type TYPE =
+              mapped_type_constant<T, typename Context::char_type>::value>
+using stored_type_constant = std::integral_constant<
+    type, Context::builtin_types || TYPE == type::int_type ? TYPE
+                                                           : type::custom_type>;
+// A parse context with extra data used only in compile-time checks.
+template <typename Char>
+class compile_parse_context : public parse_context<Char> {
+ private:
+  int num_args_;
+  const type* types_;
+  using base = parse_context<Char>;
+
+ public:
+  FMT_CONSTEXPR explicit compile_parse_context(basic_string_view<Char> fmt,
+                                               int num_args, const type* types,
+                                               int next_arg_id = 0)
+      : base(fmt, next_arg_id), num_args_(num_args), types_(types) {}
+
+  constexpr auto num_args() const -> int { return num_args_; }
+  constexpr auto arg_type(int id) const -> type { return types_[id]; }
+
+  FMT_CONSTEXPR auto next_arg_id() -> int {
+    int id = base::next_arg_id();
+    if (id >= num_args_) report_error("argument not found");
+    return id;
+  }
+
+  FMT_CONSTEXPR void check_arg_id(int id) {
+    base::check_arg_id(id);
+    if (id >= num_args_) report_error("argument not found");
+  }
+  using base::check_arg_id;
+
+  FMT_CONSTEXPR void check_dynamic_spec(int arg_id) {
+    ignore_unused(arg_id);
+    if (arg_id < num_args_ && types_ && !is_integral_type(types_[arg_id]))
+      report_error("width/precision is not integer");
+  }
+};
+
+// An argument reference.
+template <typename Char> union arg_ref {
+  FMT_CONSTEXPR arg_ref(int idx = 0) : index(idx) {}
+  FMT_CONSTEXPR arg_ref(basic_string_view<Char> n) : name(n) {}
+
+  int index;
+  basic_string_view<Char> name;
+};
+
+// Format specifiers with width and precision resolved at formatting rather
+// than parsing time to allow reusing the same parsed specifiers with
+// different sets of arguments (precompilation of format strings).
+template <typename Char = char> struct dynamic_format_specs : format_specs {
+  arg_ref<Char> width_ref;
+  arg_ref<Char> precision_ref;
+};
+
+// Converts a character to ASCII. Returns '\0' on conversion failure.
+template <typename Char, FMT_ENABLE_IF(std::is_integral<Char>::value)>
+constexpr auto to_ascii(Char c) -> char {
+  return c <= 0xff ? static_cast<char>(c) : '\0';
+}
+
+// Returns the number of code units in a code point or 1 on error.
+template <typename Char>
+FMT_CONSTEXPR auto code_point_length(const Char* begin) -> int {
+  if (const_check(sizeof(Char) != 1)) return 1;
+  auto c = static_cast<unsigned char>(*begin);
+  return static_cast<int>((0x3a55000000000000ull >> (2 * (c >> 3))) & 3) + 1;
+}
+
+// Parses the range [begin, end) as an unsigned integer. This function assumes
+// that the range is non-empty and the first character is a digit.
+template <typename Char>
+FMT_CONSTEXPR auto parse_nonnegative_int(const Char*& begin, const Char* end,
+                                         int error_value) noexcept -> int {
+  FMT_ASSERT(begin != end && '0' <= *begin && *begin <= '9', "");
+  unsigned value = 0, prev = 0;
+  auto p = begin;
+  do {
+    prev = value;
+    value = value * 10 + unsigned(*p - '0');
+    ++p;
+  } while (p != end && '0' <= *p && *p <= '9');
+  auto num_digits = p - begin;
+  begin = p;
+  int digits10 = static_cast<int>(sizeof(int) * CHAR_BIT * 3 / 10);
+  if (num_digits <= digits10) return static_cast<int>(value);
+  // Check for overflow.
+  unsigned max = INT_MAX;
+  return num_digits == digits10 + 1 &&
+                 prev * 10ull + unsigned(p[-1] - '0') <= max
+             ? static_cast<int>(value)
+             : error_value;
+}
+
+FMT_CONSTEXPR inline auto parse_align(char c) -> align {
+  switch (c) {
+  case '<': return align::left;
+  case '>': return align::right;
+  case '^': return align::center;
+  }
+  return align::none;
+}
+
+template <typename Char> constexpr auto is_name_start(Char c) -> bool {
+  return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || c == '_';
+}
+
+template <typename Char, typename Handler>
+FMT_CONSTEXPR auto parse_arg_id(const Char* begin, const Char* end,
+                                Handler&& handler) -> const Char* {
+  Char c = *begin;
+  if (c >= '0' && c <= '9') {
+    int index = 0;
+    if (c != '0')
+      index = parse_nonnegative_int(begin, end, INT_MAX);
+    else
+      ++begin;
+    if (begin == end || (*begin != '}' && *begin != ':'))
+      report_error("invalid format string");
+    else
+      handler.on_index(index);
+    return begin;
+  }
+  if (FMT_OPTIMIZE_SIZE > 1 || !is_name_start(c)) {
+    report_error("invalid format string");
+    return begin;
+  }
+  auto it = begin;
+  do {
+    ++it;
+  } while (it != end && (is_name_start(*it) || ('0' <= *it && *it <= '9')));
+  handler.on_name({begin, to_unsigned(it - begin)});
+  return it;
+}
+
+template <typename Char> struct dynamic_spec_handler {
+  parse_context<Char>& ctx;
+  arg_ref<Char>& ref;
+  arg_id_kind& kind;
+
+  FMT_CONSTEXPR void on_index(int id) {
+    ref = id;
+    kind = arg_id_kind::index;
+    ctx.check_arg_id(id);
+    ctx.check_dynamic_spec(id);
+  }
+  FMT_CONSTEXPR void on_name(basic_string_view<Char> id) {
+    ref = id;
+    kind = arg_id_kind::name;
+    ctx.check_arg_id(id);
+  }
+};
+
+template <typename Char> struct parse_dynamic_spec_result {
+  const Char* end;
+  arg_id_kind kind;
+};
+
+// Parses integer | "{" [arg_id] "}".
+template <typename Char>
+FMT_CONSTEXPR auto parse_dynamic_spec(const Char* begin, const Char* end,
+                                      int& value, arg_ref<Char>& ref,
+                                      parse_context<Char>& ctx)
+    -> parse_dynamic_spec_result<Char> {
+  FMT_ASSERT(begin != end, "");
+  auto kind = arg_id_kind::none;
+  if ('0' <= *begin && *begin <= '9') {
+    int val = parse_nonnegative_int(begin, end, -1);
+    if (val == -1) report_error("number is too big");
+    value = val;
+  } else {
+    if (*begin == '{') {
+      ++begin;
+      if (begin != end) {
+        Char c = *begin;
+        if (c == '}' || c == ':') {
+          int id = ctx.next_arg_id();
+          ref = id;
+          kind = arg_id_kind::index;
+          ctx.check_dynamic_spec(id);
+        } else {
+          begin = parse_arg_id(begin, end,
+                               dynamic_spec_handler<Char>{ctx, ref, kind});
+        }
+      }
+      if (begin != end && *begin == '}') return {++begin, kind};
+    }
+    report_error("invalid format string");
+  }
+  return {begin, kind};
+}
+
+template <typename Char>
+FMT_CONSTEXPR auto parse_width(const Char* begin, const Char* end,
+                               format_specs& specs, arg_ref<Char>& width_ref,
+                               parse_context<Char>& ctx) -> const Char* {
+  auto result = parse_dynamic_spec(begin, end, specs.width, width_ref, ctx);
+  specs.set_dynamic_width(result.kind);
+  return result.end;
+}
+
+template <typename Char>
+FMT_CONSTEXPR auto parse_precision(const Char* begin, const Char* end,
+                                   format_specs& specs,
+                                   arg_ref<Char>& precision_ref,
+                                   parse_context<Char>& ctx) -> const Char* {
+  ++begin;
+  if (begin == end) {
+    report_error("invalid precision");
+    return begin;
+  }
+  auto result =
+      parse_dynamic_spec(begin, end, specs.precision, precision_ref, ctx);
+  specs.set_dynamic_precision(result.kind);
+  return result.end;
+}
+
+enum class state { start, align, sign, hash, zero, width, precision, locale };
+
+// Parses standard format specifiers.
+template <typename Char>
+FMT_CONSTEXPR auto parse_format_specs(const Char* begin, const Char* end,
+                                      dynamic_format_specs<Char>& specs,
+                                      parse_context<Char>& ctx, type arg_type)
+    -> const Char* {
+  auto c = '\0';
+  if (end - begin > 1) {
+    auto next = to_ascii(begin[1]);
+    c = parse_align(next) == align::none ? to_ascii(*begin) : '\0';
+  } else {
+    if (begin == end) return begin;
+    c = to_ascii(*begin);
+  }
+
+  struct {
+    state current_state = state::start;
+    FMT_CONSTEXPR void operator()(state s, bool valid = true) {
+      if (current_state >= s || !valid)
+        report_error("invalid format specifier");
+      current_state = s;
+    }
+  } enter_state;
+
+  using pres = presentation_type;
+  constexpr auto integral_set = sint_set | uint_set | bool_set | char_set;
+  struct {
+    const Char*& begin;
+    format_specs& specs;
+    type arg_type;
+
+    FMT_CONSTEXPR auto operator()(pres pres_type, int set) -> const Char* {
+      if (!in(arg_type, set)) report_error("invalid format specifier");
+      specs.set_type(pres_type);
+      return begin + 1;
+    }
+  } parse_presentation_type{begin, specs, arg_type};
+
+  for (;;) {
+    switch (c) {
+    case '<':
+    case '>':
+    case '^':
+      enter_state(state::align);
+      specs.set_align(parse_align(c));
+      ++begin;
+      break;
+    case '+':
+    case ' ':
+      specs.set_sign(c == ' ' ? sign::space : sign::plus);
+      FMT_FALLTHROUGH;
+    case '-':
+      enter_state(state::sign, in(arg_type, sint_set | float_set));
+      ++begin;
+      break;
+    case '#':
+      enter_state(state::hash, is_arithmetic_type(arg_type));
+      specs.set_alt();
+      ++begin;
+      break;
+    case '0':
+      enter_state(state::zero);
+      if (!is_arithmetic_type(arg_type))
+        report_error("format specifier requires numeric argument");
+      if (specs.align() == align::none) {
+        // Ignore 0 if align is specified for compatibility with std::format.
+        specs.set_align(align::numeric);
+        specs.set_fill('0');
+      }
+      ++begin;
+      break;
+      // clang-format off
+    case '1': case '2': case '3': case '4': case '5':
+    case '6': case '7': case '8': case '9': case '{':
+      // clang-format on
+      enter_state(state::width);
+      begin = parse_width(begin, end, specs, specs.width_ref, ctx);
+      break;
+    case '.':
+      enter_state(state::precision,
+                  in(arg_type, float_set | string_set | cstring_set));
+      begin = parse_precision(begin, end, specs, specs.precision_ref, ctx);
+      break;
+    case 'L':
+      enter_state(state::locale, is_arithmetic_type(arg_type));
+      specs.set_localized();
+      ++begin;
+      break;
+    case 'd': return parse_presentation_type(pres::dec, integral_set);
+    case 'X': specs.set_upper(); FMT_FALLTHROUGH;
+    case 'x': return parse_presentation_type(pres::hex, integral_set);
+    case 'o': return parse_presentation_type(pres::oct, integral_set);
+    case 'B': specs.set_upper(); FMT_FALLTHROUGH;
+    case 'b': return parse_presentation_type(pres::bin, integral_set);
+    case 'E': specs.set_upper(); FMT_FALLTHROUGH;
+    case 'e': return parse_presentation_type(pres::exp, float_set);
+    case 'F': specs.set_upper(); FMT_FALLTHROUGH;
+    case 'f': return parse_presentation_type(pres::fixed, float_set);
+    case 'G': specs.set_upper(); FMT_FALLTHROUGH;
+    case 'g': return parse_presentation_type(pres::general, float_set);
+    case 'A': specs.set_upper(); FMT_FALLTHROUGH;
+    case 'a': return parse_presentation_type(pres::hexfloat, float_set);
+    case 'c':
+      if (arg_type == type::bool_type) report_error("invalid format specifier");
+      return parse_presentation_type(pres::chr, integral_set);
+    case 's':
+      return parse_presentation_type(pres::string,
+                                     bool_set | string_set | cstring_set);
+    case 'p':
+      return parse_presentation_type(pres::pointer, pointer_set | cstring_set);
+    case '?':
+      return parse_presentation_type(pres::debug,
+                                     char_set | string_set | cstring_set);
+    case '}': return begin;
+    default:  {
+      if (*begin == '}') return begin;
+      // Parse fill and alignment.
+      auto fill_end = begin + code_point_length(begin);
+      if (end - fill_end <= 0) {
+        report_error("invalid format specifier");
+        return begin;
+      }
+      if (*begin == '{') {
+        report_error("invalid fill character '{'");
+        return begin;
+      }
+      auto alignment = parse_align(to_ascii(*fill_end));
+      enter_state(state::align, alignment != align::none);
+      specs.set_fill(
+          basic_string_view<Char>(begin, to_unsigned(fill_end - begin)));
+      specs.set_align(alignment);
+      begin = fill_end + 1;
+    }
+    }
+    if (begin == end) return begin;
+    c = to_ascii(*begin);
+  }
+}
+
+template <typename Char, typename Handler>
+FMT_CONSTEXPR FMT_INLINE auto parse_replacement_field(const Char* begin,
+                                                      const Char* end,
+                                                      Handler&& handler)
+    -> const Char* {
+  ++begin;
+  if (begin == end) {
+    handler.on_error("invalid format string");
+    return end;
+  }
+  int arg_id = 0;
+  switch (*begin) {
+  case '}':
+    handler.on_replacement_field(handler.on_arg_id(), begin);
+    return begin + 1;
+  case '{': handler.on_text(begin, begin + 1); return begin + 1;
+  case ':': arg_id = handler.on_arg_id(); break;
+  default:  {
+    struct id_adapter {
+      Handler& handler;
+      int arg_id;
+
+      FMT_CONSTEXPR void on_index(int id) { arg_id = handler.on_arg_id(id); }
+      FMT_CONSTEXPR void on_name(basic_string_view<Char> id) {
+        arg_id = handler.on_arg_id(id);
+      }
+    } adapter = {handler, 0};
+    begin = parse_arg_id(begin, end, adapter);
+    arg_id = adapter.arg_id;
+    Char c = begin != end ? *begin : Char();
+    if (c == '}') {
+      handler.on_replacement_field(arg_id, begin);
+      return begin + 1;
+    }
+    if (c != ':') {
+      handler.on_error("missing '}' in format string");
+      return end;
+    }
+    break;
+  }
+  }
+  begin = handler.on_format_specs(arg_id, begin + 1, end);
+  if (begin == end || *begin != '}')
+    return handler.on_error("unknown format specifier"), end;
+  return begin + 1;
+}
+
+template <typename Char, typename Handler>
+FMT_CONSTEXPR void parse_format_string(basic_string_view<Char> fmt,
+                                       Handler&& handler) {
+  auto begin = fmt.data(), end = begin + fmt.size();
+  auto p = begin;
+  while (p != end) {
+    auto c = *p++;
+    if (c == '{') {
+      handler.on_text(begin, p - 1);
+      begin = p = parse_replacement_field(p - 1, end, handler);
+    } else if (c == '}') {
+      if (p == end || *p != '}')
+        return handler.on_error("unmatched '}' in format string");
+      handler.on_text(begin, p);
+      begin = ++p;
+    }
+  }
+  handler.on_text(begin, end);
+}
+
+// Checks char specs and returns true iff the presentation type is char-like.
+FMT_CONSTEXPR inline auto check_char_specs(const format_specs& specs) -> bool {
+  auto type = specs.type();
+  if (type != presentation_type::none && type != presentation_type::chr &&
+      type != presentation_type::debug) {
+    return false;
+  }
+  if (specs.align() == align::numeric || specs.sign() != sign::none ||
+      specs.alt()) {
+    report_error("invalid format specifier for char");
+  }
+  return true;
+}
+
+// A base class for compile-time strings.
+struct compile_string {};
+
+template <typename T, typename Char>
+FMT_VISIBILITY("hidden")  // Suppress an ld warning on macOS (#3769).
+FMT_CONSTEXPR auto invoke_parse(parse_context<Char>& ctx) -> const Char* {
+  using mapped_type = remove_cvref_t<mapped_t<T, Char>>;
+  constexpr bool formattable =
+      std::is_constructible<formatter<mapped_type, Char>>::value;
+  if (!formattable) return ctx.begin();  // Error is reported in the value ctor.
+  using formatted_type = conditional_t<formattable, mapped_type, int>;
+  return formatter<formatted_type, Char>().parse(ctx);
+}
+
+template <typename... T> struct arg_pack {};
+
+template <typename Char, int NUM_ARGS, int NUM_NAMED_ARGS, bool DYNAMIC_NAMES>
+class format_string_checker {
+ private:
+  type types_[max_of(1, NUM_ARGS)];
+  named_arg_info<Char> named_args_[max_of(1, NUM_NAMED_ARGS)];
+  compile_parse_context<Char> context_;
+
+  using parse_func = auto (*)(parse_context<Char>&) -> const Char*;
+  parse_func parse_funcs_[max_of(1, NUM_ARGS)];
+
+ public:
+  template <typename... T>
+  FMT_CONSTEXPR explicit format_string_checker(basic_string_view<Char> fmt,
+                                               arg_pack<T...>)
+      : types_{mapped_type_constant<T, Char>::value...},
+        named_args_{},
+        context_(fmt, NUM_ARGS, types_),
+        parse_funcs_{&invoke_parse<T, Char>...} {
+    int arg_index = 0, named_arg_index = 0;
+    FMT_APPLY_VARIADIC(
+        init_static_named_arg<T>(named_args_, arg_index, named_arg_index));
+    ignore_unused(arg_index, named_arg_index);
+  }
+
+  FMT_CONSTEXPR void on_text(const Char*, const Char*) {}
+
+  FMT_CONSTEXPR auto on_arg_id() -> int { return context_.next_arg_id(); }
+  FMT_CONSTEXPR auto on_arg_id(int id) -> int {
+    context_.check_arg_id(id);
+    return id;
+  }
+  FMT_CONSTEXPR auto on_arg_id(basic_string_view<Char> id) -> int {
+    for (int i = 0; i < NUM_NAMED_ARGS; ++i) {
+      if (named_args_[i].name == id) return named_args_[i].id;
+    }
+    if (!DYNAMIC_NAMES) on_error("argument not found");
+    return -1;
+  }
+
+  FMT_CONSTEXPR void on_replacement_field(int id, const Char* begin) {
+    on_format_specs(id, begin, begin);  // Call parse() on empty specs.
+  }
+
+  FMT_CONSTEXPR auto on_format_specs(int id, const Char* begin, const Char* end)
+      -> const Char* {
+    context_.advance_to(begin);
+    if (id >= 0 && id < NUM_ARGS) return parse_funcs_[id](context_);
+    while (begin != end && *begin != '}') ++begin;
+    return begin;
+  }
+
+  FMT_NORETURN FMT_CONSTEXPR void on_error(const char* message) {
+    report_error(message);
+  }
+};
+
+/// A contiguous memory buffer with an optional growing ability. It is an
+/// internal class and shouldn't be used directly, only via `memory_buffer`.
+template <typename T> class buffer {
+ private:
+  T* ptr_;
+  size_t size_;
+  size_t capacity_;
+
+  using grow_fun = void (*)(buffer& buf, size_t capacity);
+  grow_fun grow_;
+
+ protected:
+  // Don't initialize ptr_ since it is not accessed to save a few cycles.
+  FMT_MSC_WARNING(suppress : 26495)
+  FMT_CONSTEXPR buffer(grow_fun grow, size_t sz) noexcept
+      : size_(sz), capacity_(sz), grow_(grow) {}
+
+  constexpr buffer(grow_fun grow, T* p = nullptr, size_t sz = 0,
+                   size_t cap = 0) noexcept
+      : ptr_(p), size_(sz), capacity_(cap), grow_(grow) {}
+
+  FMT_CONSTEXPR20 ~buffer() = default;
+  buffer(buffer&&) = default;
+
+  /// Sets the buffer data and capacity.
+  FMT_CONSTEXPR void set(T* buf_data, size_t buf_capacity) noexcept {
+    ptr_ = buf_data;
+    capacity_ = buf_capacity;
+  }
+
+ public:
+  using value_type = T;
+  using const_reference = const T&;
+
+  buffer(const buffer&) = delete;
+  void operator=(const buffer&) = delete;
+
+  auto begin() noexcept -> T* { return ptr_; }
+  auto end() noexcept -> T* { return ptr_ + size_; }
+
+  auto begin() const noexcept -> const T* { return ptr_; }
+  auto end() const noexcept -> const T* { return ptr_ + size_; }
+
+  /// Returns the size of this buffer.
+  constexpr auto size() const noexcept -> size_t { return size_; }
+
+  /// Returns the capacity of this buffer.
+  constexpr auto capacity() const noexcept -> size_t { return capacity_; }
+
+  /// Returns a pointer to the buffer data (not null-terminated).
+  FMT_CONSTEXPR auto data() noexcept -> T* { return ptr_; }
+  FMT_CONSTEXPR auto data() const noexcept -> const T* { return ptr_; }
+
+  /// Clears this buffer.
+  FMT_CONSTEXPR void clear() { size_ = 0; }
+
+  // Tries resizing the buffer to contain `count` elements. If T is a POD type
+  // the new elements may not be initialized.
+  FMT_CONSTEXPR void try_resize(size_t count) {
+    try_reserve(count);
+    size_ = min_of(count, capacity_);
+  }
+
+  // Tries increasing the buffer capacity to `new_capacity`. It can increase the
+  // capacity by a smaller amount than requested but guarantees there is space
+  // for at least one additional element either by increasing the capacity or by
+  // flushing the buffer if it is full.
+  FMT_CONSTEXPR void try_reserve(size_t new_capacity) {
+    if (new_capacity > capacity_) grow_(*this, new_capacity);
+  }
+
+  FMT_CONSTEXPR void push_back(const T& value) {
+    try_reserve(size_ + 1);
+    ptr_[size_++] = value;
+  }
+
+  /// Appends data to the end of the buffer.
+  template <typename U>
+// Workaround for MSVC2019 to fix error C2893: Failed to specialize function
+// template 'void fmt::v11::detail::buffer<T>::append(const U *,const U *)'.
+#if !FMT_MSC_VERSION || FMT_MSC_VERSION >= 1940
+  FMT_CONSTEXPR20
+#endif
+      void
+      append(const U* begin, const U* end) {
+    while (begin != end) {
+      auto count = to_unsigned(end - begin);
+      try_reserve(size_ + count);
+      auto free_cap = capacity_ - size_;
+      if (free_cap < count) count = free_cap;
+      // A loop is faster than memcpy on small sizes.
+      T* out = ptr_ + size_;
+      for (size_t i = 0; i < count; ++i) out[i] = begin[i];
+      size_ += count;
+      begin += count;
+    }
+  }
+
+  template <typename Idx> FMT_CONSTEXPR auto operator[](Idx index) -> T& {
+    return ptr_[index];
+  }
+  template <typename Idx>
+  FMT_CONSTEXPR auto operator[](Idx index) const -> const T& {
+    return ptr_[index];
+  }
+};
+
+struct buffer_traits {
+  constexpr explicit buffer_traits(size_t) {}
+  constexpr auto count() const -> size_t { return 0; }
+  constexpr auto limit(size_t size) const -> size_t { return size; }
+};
+
+class fixed_buffer_traits {
+ private:
+  size_t count_ = 0;
+  size_t limit_;
+
+ public:
+  constexpr explicit fixed_buffer_traits(size_t limit) : limit_(limit) {}
+  constexpr auto count() const -> size_t { return count_; }
+  FMT_CONSTEXPR auto limit(size_t size) -> size_t {
+    size_t n = limit_ > count_ ? limit_ - count_ : 0;
+    count_ += size;
+    return min_of(size, n);
+  }
+};
+
+// A buffer that writes to an output iterator when flushed.
+template <typename OutputIt, typename T, typename Traits = buffer_traits>
+class iterator_buffer : public Traits, public buffer<T> {
+ private:
+  OutputIt out_;
+  enum { buffer_size = 256 };
+  T data_[buffer_size];
+
+  static FMT_CONSTEXPR void grow(buffer<T>& buf, size_t) {
+    if (buf.size() == buffer_size) static_cast<iterator_buffer&>(buf).flush();
+  }
+
+  void flush() {
+    auto size = this->size();
+    this->clear();
+    const T* begin = data_;
+    const T* end = begin + this->limit(size);
+    while (begin != end) *out_++ = *begin++;
+  }
+
+ public:
+  explicit iterator_buffer(OutputIt out, size_t n = buffer_size)
+      : Traits(n), buffer<T>(grow, data_, 0, buffer_size), out_(out) {}
+  iterator_buffer(iterator_buffer&& other) noexcept
+      : Traits(other),
+        buffer<T>(grow, data_, 0, buffer_size),
+        out_(other.out_) {}
+  ~iterator_buffer() {
+    // Don't crash if flush fails during unwinding.
+    FMT_TRY { flush(); }
+    FMT_CATCH(...) {}
+  }
+
+  auto out() -> OutputIt {
+    flush();
+    return out_;
+  }
+  auto count() const -> size_t { return Traits::count() + this->size(); }
+};
+
+template <typename T>
+class iterator_buffer<T*, T, fixed_buffer_traits> : public fixed_buffer_traits,
+                                                    public buffer<T> {
+ private:
+  T* out_;
+  enum { buffer_size = 256 };
+  T data_[buffer_size];
+
+  static FMT_CONSTEXPR void grow(buffer<T>& buf, size_t) {
+    if (buf.size() == buf.capacity())
+      static_cast<iterator_buffer&>(buf).flush();
+  }
+
+  void flush() {
+    size_t n = this->limit(this->size());
+    if (this->data() == out_) {
+      out_ += n;
+      this->set(data_, buffer_size);
+    }
+    this->clear();
+  }
+
+ public:
+  explicit iterator_buffer(T* out, size_t n = buffer_size)
+      : fixed_buffer_traits(n), buffer<T>(grow, out, 0, n), out_(out) {}
+  iterator_buffer(iterator_buffer&& other) noexcept
+      : fixed_buffer_traits(other),
+        buffer<T>(static_cast<iterator_buffer&&>(other)),
+        out_(other.out_) {
+    if (this->data() != out_) {
+      this->set(data_, buffer_size);
+      this->clear();
+    }
+  }
+  ~iterator_buffer() { flush(); }
+
+  auto out() -> T* {
+    flush();
+    return out_;
+  }
+  auto count() const -> size_t {
+    return fixed_buffer_traits::count() + this->size();
+  }
+};
+
+template <typename T> class iterator_buffer<T*, T> : public buffer<T> {
+ public:
+  explicit iterator_buffer(T* out, size_t = 0)
+      : buffer<T>([](buffer<T>&, size_t) {}, out, 0, ~size_t()) {}
+
+  auto out() -> T* { return &*this->end(); }
+};
+
+template <typename Container>
+class container_buffer : public buffer<typename Container::value_type> {
+ private:
+  using value_type = typename Container::value_type;
+
+  static FMT_CONSTEXPR void grow(buffer<value_type>& buf, size_t capacity) {
+    auto& self = static_cast<container_buffer&>(buf);
+    self.container.resize(capacity);
+    self.set(&self.container[0], capacity);
+  }
+
+ public:
+  Container& container;
+
+  explicit container_buffer(Container& c)
+      : buffer<value_type>(grow, c.size()), container(c) {}
+};
+
+// A buffer that writes to a container with the contiguous storage.
+template <typename OutputIt>
+class iterator_buffer<
+    OutputIt,
+    enable_if_t<is_back_insert_iterator<OutputIt>::value &&
+                    is_contiguous<typename OutputIt::container_type>::value,
+                typename OutputIt::container_type::value_type>>
+    : public container_buffer<typename OutputIt::container_type> {
+ private:
+  using base = container_buffer<typename OutputIt::container_type>;
+
+ public:
+  explicit iterator_buffer(typename OutputIt::container_type& c) : base(c) {}
+  explicit iterator_buffer(OutputIt out, size_t = 0)
+      : base(get_container(out)) {}
+
+  auto out() -> OutputIt { return OutputIt(this->container); }
+};
+
+// A buffer that counts the number of code units written discarding the output.
+template <typename T = char> class counting_buffer : public buffer<T> {
+ private:
+  enum { buffer_size = 256 };
+  T data_[buffer_size];
+  size_t count_ = 0;
+
+  static FMT_CONSTEXPR void grow(buffer<T>& buf, size_t) {
+    if (buf.size() != buffer_size) return;
+    static_cast<counting_buffer&>(buf).count_ += buf.size();
+    buf.clear();
+  }
+
+ public:
+  FMT_CONSTEXPR counting_buffer() : buffer<T>(grow, data_, 0, buffer_size) {}
+
+  constexpr auto count() const noexcept -> size_t {
+    return count_ + this->size();
+  }
+};
+
+template <typename T>
+struct is_back_insert_iterator<basic_appender<T>> : std::true_type {};
+
+template <typename OutputIt, typename InputIt, typename = void>
+struct has_back_insert_iterator_container_append : std::false_type {};
+template <typename OutputIt, typename InputIt>
+struct has_back_insert_iterator_container_append<
+    OutputIt, InputIt,
+    void_t<decltype(get_container(std::declval<OutputIt>())
+                        .append(std::declval<InputIt>(),
+                                std::declval<InputIt>()))>> : std::true_type {};
+
+// An optimized version of std::copy with the output value type (T).
+template <typename T, typename InputIt, typename OutputIt,
+          FMT_ENABLE_IF(is_back_insert_iterator<OutputIt>::value&&
+                            has_back_insert_iterator_container_append<
+                                OutputIt, InputIt>::value)>
+FMT_CONSTEXPR20 auto copy(InputIt begin, InputIt end, OutputIt out)
+    -> OutputIt {
+  get_container(out).append(begin, end);
+  return out;
+}
+
+template <typename T, typename InputIt, typename OutputIt,
+          FMT_ENABLE_IF(is_back_insert_iterator<OutputIt>::value &&
+                        !has_back_insert_iterator_container_append<
+                            OutputIt, InputIt>::value)>
+FMT_CONSTEXPR20 auto copy(InputIt begin, InputIt end, OutputIt out)
+    -> OutputIt {
+  auto& c = get_container(out);
+  c.insert(c.end(), begin, end);
+  return out;
+}
+
+template <typename T, typename InputIt, typename OutputIt,
+          FMT_ENABLE_IF(!is_back_insert_iterator<OutputIt>::value)>
+FMT_CONSTEXPR auto copy(InputIt begin, InputIt end, OutputIt out) -> OutputIt {
+  while (begin != end) *out++ = static_cast<T>(*begin++);
+  return out;
+}
+
+template <typename T, typename V, typename OutputIt>
+FMT_CONSTEXPR auto copy(basic_string_view<V> s, OutputIt out) -> OutputIt {
+  return copy<T>(s.begin(), s.end(), out);
+}
+
+template <typename It, typename Enable = std::true_type>
+struct is_buffer_appender : std::false_type {};
+template <typename It>
+struct is_buffer_appender<
+    It, bool_constant<
+            is_back_insert_iterator<It>::value &&
+            std::is_base_of<buffer<typename It::container_type::value_type>,
+                            typename It::container_type>::value>>
+    : std::true_type {};
+
+// Maps an output iterator to a buffer.
+template <typename T, typename OutputIt,
+          FMT_ENABLE_IF(!is_buffer_appender<OutputIt>::value)>
+auto get_buffer(OutputIt out) -> iterator_buffer<OutputIt, T> {
+  return iterator_buffer<OutputIt, T>(out);
+}
+template <typename T, typename OutputIt,
+          FMT_ENABLE_IF(is_buffer_appender<OutputIt>::value)>
+auto get_buffer(OutputIt out) -> buffer<T>& {
+  return get_container(out);
+}
+
+template <typename Buf, typename OutputIt>
+auto get_iterator(Buf& buf, OutputIt) -> decltype(buf.out()) {
+  return buf.out();
+}
+template <typename T, typename OutputIt>
+auto get_iterator(buffer<T>&, OutputIt out) -> OutputIt {
+  return out;
+}
+
+// This type is intentionally undefined, only used for errors.
+template <typename T, typename Char> struct type_is_unformattable_for;
+
+template <typename Char> struct string_value {
+  const Char* data;
+  size_t size;
+  auto str() const -> basic_string_view<Char> { return {data, size}; }
+};
+
+template <typename Context> struct custom_value {
+  using char_type = typename Context::char_type;
+  void* value;
+  void (*format)(void* arg, parse_context<char_type>& parse_ctx, Context& ctx);
+};
+
+template <typename Char> struct named_arg_value {
+  const named_arg_info<Char>* data;
+  size_t size;
+};
+
+struct custom_tag {};
+
+#if !FMT_BUILTIN_TYPES
+#  define FMT_BUILTIN , monostate
+#else
+#  define FMT_BUILTIN
+#endif
+
+// A formatting argument value.
+template <typename Context> class value {
+ public:
+  using char_type = typename Context::char_type;
+
+  union {
+    monostate no_value;
+    int int_value;
+    unsigned uint_value;
+    long long long_long_value;
+    unsigned long long ulong_long_value;
+    int128_opt int128_value;
+    uint128_opt uint128_value;
+    bool bool_value;
+    char_type char_value;
+    float float_value;
+    double double_value;
+    long double long_double_value;
+    const void* pointer;
+    string_value<char_type> string;
+    custom_value<Context> custom;
+    named_arg_value<char_type> named_args;
+  };
+
+  constexpr FMT_INLINE value() : no_value() {}
+  constexpr FMT_INLINE value(signed char x) : int_value(x) {}
+  constexpr FMT_INLINE value(unsigned char x FMT_BUILTIN) : uint_value(x) {}
+  constexpr FMT_INLINE value(signed short x) : int_value(x) {}
+  constexpr FMT_INLINE value(unsigned short x FMT_BUILTIN) : uint_value(x) {}
+  constexpr FMT_INLINE value(int x) : int_value(x) {}
+  constexpr FMT_INLINE value(unsigned x FMT_BUILTIN) : uint_value(x) {}
+  FMT_CONSTEXPR FMT_INLINE value(long x FMT_BUILTIN) : value(long_type(x)) {}
+  FMT_CONSTEXPR FMT_INLINE value(unsigned long x FMT_BUILTIN)
+      : value(ulong_type(x)) {}
+  constexpr FMT_INLINE value(long long x FMT_BUILTIN) : long_long_value(x) {}
+  constexpr FMT_INLINE value(unsigned long long x FMT_BUILTIN)
+      : ulong_long_value(x) {}
+  FMT_INLINE value(int128_opt x FMT_BUILTIN) : int128_value(x) {}
+  FMT_INLINE value(uint128_opt x FMT_BUILTIN) : uint128_value(x) {}
+  constexpr FMT_INLINE value(bool x FMT_BUILTIN) : bool_value(x) {}
+
+  template <int N>
+  constexpr FMT_INLINE value(bitint<N> x FMT_BUILTIN) : long_long_value(x) {
+    static_assert(N <= 64, "unsupported _BitInt");
+  }
+  template <int N>
+  constexpr FMT_INLINE value(ubitint<N> x FMT_BUILTIN) : ulong_long_value(x) {
+    static_assert(N <= 64, "unsupported _BitInt");
+  }
+
+  template <typename T, FMT_ENABLE_IF(is_char<T>::value)>
+  constexpr FMT_INLINE value(T x FMT_BUILTIN) : char_value(x) {
+    static_assert(
+        std::is_same<T, char>::value || std::is_same<T, char_type>::value,
+        "mixing character types is disallowed");
+  }
+
+  constexpr FMT_INLINE value(float x FMT_BUILTIN) : float_value(x) {}
+  constexpr FMT_INLINE value(double x FMT_BUILTIN) : double_value(x) {}
+  FMT_INLINE value(long double x FMT_BUILTIN) : long_double_value(x) {}
+
+  FMT_CONSTEXPR FMT_INLINE value(char_type* x FMT_BUILTIN) {
+    string.data = x;
+    if (is_constant_evaluated()) string.size = 0;
+  }
+  FMT_CONSTEXPR FMT_INLINE value(const char_type* x FMT_BUILTIN) {
+    string.data = x;
+    if (is_constant_evaluated()) string.size = 0;
+  }
+  template <typename T, typename C = char_t<T>,
+            FMT_ENABLE_IF(!std::is_pointer<T>::value)>
+  FMT_CONSTEXPR value(const T& x FMT_BUILTIN) {
+    static_assert(std::is_same<C, char_type>::value,
+                  "mixing character types is disallowed");
+    auto sv = to_string_view(x);
+    string.data = sv.data();
+    string.size = sv.size();
+  }
+  FMT_INLINE value(void* x FMT_BUILTIN) : pointer(x) {}
+  FMT_INLINE value(const void* x FMT_BUILTIN) : pointer(x) {}
+  FMT_INLINE value(volatile void* x FMT_BUILTIN)
+      : pointer(const_cast<const void*>(x)) {}
+  FMT_INLINE value(const volatile void* x FMT_BUILTIN)
+      : pointer(const_cast<const void*>(x)) {}
+  FMT_INLINE value(nullptr_t) : pointer(nullptr) {}
+
+  template <typename T, FMT_ENABLE_IF(std::is_pointer<T>::value ||
+                                      std::is_member_pointer<T>::value)>
+  value(const T&) {
+    // Formatting of arbitrary pointers is disallowed. If you want to format a
+    // pointer cast it to `void*` or `const void*`. In particular, this forbids
+    // formatting of `[const] volatile char*` printed as bool by iostreams.
+    static_assert(sizeof(T) == 0,
+                  "formatting of non-void pointers is disallowed");
+  }
+
+  template <typename T, FMT_ENABLE_IF(use_format_as<T>::value)>
+  value(const T& x) : value(format_as(x)) {}
+  template <typename T, FMT_ENABLE_IF(use_format_as_member<T>::value)>
+  value(const T& x) : value(formatter<T>::format_as(x)) {}
+
+  template <typename T, FMT_ENABLE_IF(is_named_arg<T>::value)>
+  value(const T& named_arg) : value(named_arg.value) {}
+
+  template <typename T,
+            FMT_ENABLE_IF(use_formatter<T>::value || !FMT_BUILTIN_TYPES)>
+  FMT_CONSTEXPR20 FMT_INLINE value(T& x) : value(x, custom_tag()) {}
+
+  FMT_ALWAYS_INLINE value(const named_arg_info<char_type>* args, size_t size)
+      : named_args{args, size} {}
+
+ private:
+  template <typename T, FMT_ENABLE_IF(has_formatter<T, char_type>())>
+  FMT_CONSTEXPR value(T& x, custom_tag) {
+    using value_type = remove_const_t<T>;
+    // T may overload operator& e.g. std::vector<bool>::reference in libc++.
+    if (!is_constant_evaluated()) {
+      custom.value =
+          const_cast<char*>(&reinterpret_cast<const volatile char&>(x));
+    } else {
+      custom.value = nullptr;
+#if defined(__cpp_if_constexpr)
+      if constexpr (std::is_same<decltype(&x), remove_reference_t<T>*>::value)
+        custom.value = const_cast<value_type*>(&x);
+#endif
+    }
+    custom.format = format_custom<value_type, formatter<value_type, char_type>>;
+  }
+
+  template <typename T, FMT_ENABLE_IF(!has_formatter<T, char_type>())>
+  FMT_CONSTEXPR value(const T&, custom_tag) {
+    // Cannot format an argument; to make type T formattable provide a
+    // formatter<T> specialization: https://fmt.dev/latest/api.html#udt.
+    type_is_unformattable_for<T, char_type> _;
+  }
+
+  // Formats an argument of a custom type, such as a user-defined class.
+  template <typename T, typename Formatter>
+  static void format_custom(void* arg, parse_context<char_type>& parse_ctx,
+                            Context& ctx) {
+    auto f = Formatter();
+    parse_ctx.advance_to(f.parse(parse_ctx));
+    using qualified_type =
+        conditional_t<has_formatter<const T, char_type>(), const T, T>;
+    // format must be const for compatibility with std::format and compilation.
+    const auto& cf = f;
+    ctx.advance_to(cf.format(*static_cast<qualified_type*>(arg), ctx));
+  }
+};
+
+enum { packed_arg_bits = 4 };
+// Maximum number of arguments with packed types.
+enum { max_packed_args = 62 / packed_arg_bits };
+enum : unsigned long long { is_unpacked_bit = 1ULL << 63 };
+enum : unsigned long long { has_named_args_bit = 1ULL << 62 };
+
+template <typename It, typename T, typename Enable = void>
+struct is_output_iterator : std::false_type {};
+
+template <> struct is_output_iterator<appender, char> : std::true_type {};
+
+template <typename It, typename T>
+struct is_output_iterator<
+    It, T,
+    void_t<decltype(*std::declval<decay_t<It>&>()++ = std::declval<T>())>>
+    : std::true_type {};
+
+#ifndef FMT_USE_LOCALE
+#  define FMT_USE_LOCALE (FMT_OPTIMIZE_SIZE <= 1)
+#endif
+
+// A type-erased reference to an std::locale to avoid a heavy <locale> include.
+struct locale_ref {
+#if FMT_USE_LOCALE
+ private:
+  const void* locale_;  // A type-erased pointer to std::locale.
+
+ public:
+  constexpr locale_ref() : locale_(nullptr) {}
+  template <typename Locale> locale_ref(const Locale& loc);
+
+  inline explicit operator bool() const noexcept { return locale_ != nullptr; }
+#endif  // FMT_USE_LOCALE
+
+  template <typename Locale> auto get() const -> Locale;
+};
+
+template <typename> constexpr auto encode_types() -> unsigned long long {
+  return 0;
+}
+
+template <typename Context, typename Arg, typename... Args>
+constexpr auto encode_types() -> unsigned long long {
+  return static_cast<unsigned>(stored_type_constant<Arg, Context>::value) |
+         (encode_types<Context, Args...>() << packed_arg_bits);
+}
+
+template <typename Context, typename... T, size_t NUM_ARGS = sizeof...(T)>
+constexpr auto make_descriptor() -> unsigned long long {
+  return NUM_ARGS <= max_packed_args ? encode_types<Context, T...>()
+                                     : is_unpacked_bit | NUM_ARGS;
+}
+
+template <typename Context, int NUM_ARGS>
+using arg_t = conditional_t<NUM_ARGS <= max_packed_args, value<Context>,
+                            basic_format_arg<Context>>;
+
+template <typename Context, int NUM_ARGS, int NUM_NAMED_ARGS,
+          unsigned long long DESC>
+struct named_arg_store {
+  // args_[0].named_args points to named_args to avoid bloating format_args.
+  arg_t<Context, NUM_ARGS> args[1 + NUM_ARGS];
+  named_arg_info<typename Context::char_type> named_args[NUM_NAMED_ARGS];
+
+  template <typename... T>
+  FMT_CONSTEXPR FMT_ALWAYS_INLINE named_arg_store(T&... values)
+      : args{{named_args, NUM_NAMED_ARGS}, values...} {
+    int arg_index = 0, named_arg_index = 0;
+    FMT_APPLY_VARIADIC(
+        init_named_arg(named_args, arg_index, named_arg_index, values));
+  }
+
+  named_arg_store(named_arg_store&& rhs) {
+    args[0] = {named_args, NUM_NAMED_ARGS};
+    for (size_t i = 1; i < sizeof(args) / sizeof(*args); ++i)
+      args[i] = rhs.args[i];
+    for (size_t i = 0; i < NUM_NAMED_ARGS; ++i)
+      named_args[i] = rhs.named_args[i];
+  }
+
+  named_arg_store(const named_arg_store& rhs) = delete;
+  named_arg_store& operator=(const named_arg_store& rhs) = delete;
+  named_arg_store& operator=(named_arg_store&& rhs) = delete;
+  operator const arg_t<Context, NUM_ARGS>*() const { return args + 1; }
+};
+
+// An array of references to arguments. It can be implicitly converted to
+// `basic_format_args` for passing into type-erased formatting functions
+// such as `vformat`. It is a plain struct to reduce binary size in debug mode.
+template <typename Context, int NUM_ARGS, int NUM_NAMED_ARGS,
+          unsigned long long DESC>
+struct format_arg_store {
+  // +1 to workaround a bug in gcc 7.5 that causes duplicated-branches warning.
+  using type =
+      conditional_t<NUM_NAMED_ARGS == 0,
+                    arg_t<Context, NUM_ARGS>[max_of(1, NUM_ARGS)],
+                    named_arg_store<Context, NUM_ARGS, NUM_NAMED_ARGS, DESC>>;
+  type args;
+};
+
+// TYPE can be different from type_constant<T>, e.g. for __float128.
+template <typename T, typename Char, type TYPE> struct native_formatter {
+ private:
+  dynamic_format_specs<Char> specs_;
+
+ public:
+  using nonlocking = void;
+
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) -> const Char* {
+    if (ctx.begin() == ctx.end() || *ctx.begin() == '}') return ctx.begin();
+    auto end = parse_format_specs(ctx.begin(), ctx.end(), specs_, ctx, TYPE);
+    if (const_check(TYPE == type::char_type)) check_char_specs(specs_);
+    return end;
+  }
+
+  template <type U = TYPE,
+            FMT_ENABLE_IF(U == type::string_type || U == type::cstring_type ||
+                          U == type::char_type)>
+  FMT_CONSTEXPR void set_debug_format(bool set = true) {
+    specs_.set_type(set ? presentation_type::debug : presentation_type::none);
+  }
+
+  FMT_PRAGMA_CLANG(diagnostic ignored "-Wundefined-inline")
+  template <typename FormatContext>
+  FMT_CONSTEXPR auto format(const T& val, FormatContext& ctx) const
+      -> decltype(ctx.out());
+};
+
+template <typename T, typename Enable = void>
+struct locking
+    : bool_constant<mapped_type_constant<T>::value == type::custom_type> {};
+template <typename T>
+struct locking<T, void_t<typename formatter<remove_cvref_t<T>>::nonlocking>>
+    : std::false_type {};
+
+template <typename T = int> FMT_CONSTEXPR inline auto is_locking() -> bool {
+  return locking<T>::value;
+}
+template <typename T1, typename T2, typename... Tail>
+FMT_CONSTEXPR inline auto is_locking() -> bool {
+  return locking<T1>::value || is_locking<T2, Tail...>();
+}
+
+FMT_API void vformat_to(buffer<char>& buf, string_view fmt, format_args args,
+                        locale_ref loc = {});
+
+#if FMT_WIN32
+FMT_API void vprint_mojibake(FILE*, string_view, format_args, bool);
+#else  // format_args is passed by reference since it is defined later.
+inline void vprint_mojibake(FILE*, string_view, const format_args&, bool) {}
+#endif
+}  // namespace detail
+
+// The main public API.
+
+template <typename Char>
+FMT_CONSTEXPR void parse_context<Char>::do_check_arg_id(int arg_id) {
+  // Argument id is only checked at compile time during parsing because
+  // formatting has its own validation.
+  if (detail::is_constant_evaluated() && use_constexpr_cast) {
+    auto ctx = static_cast<detail::compile_parse_context<Char>*>(this);
+    if (arg_id >= ctx->num_args()) report_error("argument not found");
+  }
+}
+
+template <typename Char>
+FMT_CONSTEXPR void parse_context<Char>::check_dynamic_spec(int arg_id) {
+  using detail::compile_parse_context;
+  if (detail::is_constant_evaluated() && use_constexpr_cast)
+    static_cast<compile_parse_context<Char>*>(this)->check_dynamic_spec(arg_id);
+}
+
+FMT_BEGIN_EXPORT
+
+// An output iterator that appends to a buffer. It is used instead of
+// back_insert_iterator to reduce symbol sizes and avoid <iterator> dependency.
+template <typename T> class basic_appender {
+ protected:
+  detail::buffer<T>* container;
+
+ public:
+  using container_type = detail::buffer<T>;
+
+  FMT_CONSTEXPR basic_appender(detail::buffer<T>& buf) : container(&buf) {}
+
+  FMT_CONSTEXPR20 auto operator=(T c) -> basic_appender& {
+    container->push_back(c);
+    return *this;
+  }
+  FMT_CONSTEXPR20 auto operator*() -> basic_appender& { return *this; }
+  FMT_CONSTEXPR20 auto operator++() -> basic_appender& { return *this; }
+  FMT_CONSTEXPR20 auto operator++(int) -> basic_appender { return *this; }
+};
+
+// A formatting argument. Context is a template parameter for the compiled API
+// where output can be unbuffered.
+template <typename Context> class basic_format_arg {
+ private:
+  detail::value<Context> value_;
+  detail::type type_;
+
+  friend class basic_format_args<Context>;
+
+  using char_type = typename Context::char_type;
+
+ public:
+  class handle {
+   private:
+    detail::custom_value<Context> custom_;
+
+   public:
+    explicit handle(detail::custom_value<Context> custom) : custom_(custom) {}
+
+    void format(parse_context<char_type>& parse_ctx, Context& ctx) const {
+      custom_.format(custom_.value, parse_ctx, ctx);
+    }
+  };
+
+  constexpr basic_format_arg() : type_(detail::type::none_type) {}
+  basic_format_arg(const detail::named_arg_info<char_type>* args, size_t size)
+      : value_(args, size) {}
+  template <typename T>
+  basic_format_arg(T&& val)
+      : value_(val), type_(detail::stored_type_constant<T, Context>::value) {}
+
+  constexpr explicit operator bool() const noexcept {
+    return type_ != detail::type::none_type;
+  }
+  auto type() const -> detail::type { return type_; }
+
+  /**
+   * Visits an argument dispatching to the appropriate visit method based on
+   * the argument type. For example, if the argument type is `double` then
+   * `vis(value)` will be called with the value of type `double`.
+   */
+  template <typename Visitor>
+  FMT_CONSTEXPR FMT_INLINE auto visit(Visitor&& vis) const -> decltype(vis(0)) {
+    using detail::map;
+    switch (type_) {
+    case detail::type::none_type:        break;
+    case detail::type::int_type:         return vis(value_.int_value);
+    case detail::type::uint_type:        return vis(value_.uint_value);
+    case detail::type::long_long_type:   return vis(value_.long_long_value);
+    case detail::type::ulong_long_type:  return vis(value_.ulong_long_value);
+    case detail::type::int128_type:      return vis(map(value_.int128_value));
+    case detail::type::uint128_type:     return vis(map(value_.uint128_value));
+    case detail::type::bool_type:        return vis(value_.bool_value);
+    case detail::type::char_type:        return vis(value_.char_value);
+    case detail::type::float_type:       return vis(value_.float_value);
+    case detail::type::double_type:      return vis(value_.double_value);
+    case detail::type::long_double_type: return vis(value_.long_double_value);
+    case detail::type::cstring_type:     return vis(value_.string.data);
+    case detail::type::string_type:      return vis(value_.string.str());
+    case detail::type::pointer_type:     return vis(value_.pointer);
+    case detail::type::custom_type:      return vis(handle(value_.custom));
+    }
+    return vis(monostate());
+  }
+
+  auto format_custom(const char_type* parse_begin,
+                     parse_context<char_type>& parse_ctx, Context& ctx)
+      -> bool {
+    if (type_ != detail::type::custom_type) return false;
+    parse_ctx.advance_to(parse_begin);
+    value_.custom.format(value_.custom.value, parse_ctx, ctx);
+    return true;
+  }
+};
+
+/**
+ * A view of a collection of formatting arguments. To avoid lifetime issues it
+ * should only be used as a parameter type in type-erased functions such as
+ * `vformat`:
+ *
+ *     void vlog(fmt::string_view fmt, fmt::format_args args);  // OK
+ *     fmt::format_args args = fmt::make_format_args();  // Dangling reference
+ */
+template <typename Context> class basic_format_args {
+ private:
+  // A descriptor that contains information about formatting arguments.
+  // If the number of arguments is less or equal to max_packed_args then
+  // argument types are passed in the descriptor. This reduces binary code size
+  // per formatting function call.
+  unsigned long long desc_;
+  union {
+    // If is_packed() returns true then argument values are stored in values_;
+    // otherwise they are stored in args_. This is done to improve cache
+    // locality and reduce compiled code size since storing larger objects
+    // may require more code (at least on x86-64) even if the same amount of
+    // data is actually copied to stack. It saves ~10% on the bloat test.
+    const detail::value<Context>* values_;
+    const basic_format_arg<Context>* args_;
+  };
+
+  constexpr auto is_packed() const -> bool {
+    return (desc_ & detail::is_unpacked_bit) == 0;
+  }
+  constexpr auto has_named_args() const -> bool {
+    return (desc_ & detail::has_named_args_bit) != 0;
+  }
+
+  FMT_CONSTEXPR auto type(int index) const -> detail::type {
+    int shift = index * detail::packed_arg_bits;
+    unsigned mask = (1 << detail::packed_arg_bits) - 1;
+    return static_cast<detail::type>((desc_ >> shift) & mask);
+  }
+
+  template <int NUM_ARGS, int NUM_NAMED_ARGS, unsigned long long DESC>
+  using store =
+      detail::format_arg_store<Context, NUM_ARGS, NUM_NAMED_ARGS, DESC>;
+
+ public:
+  using format_arg = basic_format_arg<Context>;
+
+  constexpr basic_format_args() : desc_(0), args_(nullptr) {}
+
+  /// Constructs a `basic_format_args` object from `format_arg_store`.
+  template <int NUM_ARGS, int NUM_NAMED_ARGS, unsigned long long DESC,
+            FMT_ENABLE_IF(NUM_ARGS <= detail::max_packed_args)>
+  constexpr FMT_ALWAYS_INLINE basic_format_args(
+      const store<NUM_ARGS, NUM_NAMED_ARGS, DESC>& s)
+      : desc_(DESC | (NUM_NAMED_ARGS != 0 ? +detail::has_named_args_bit : 0)),
+        values_(s.args) {}
+
+  template <int NUM_ARGS, int NUM_NAMED_ARGS, unsigned long long DESC,
+            FMT_ENABLE_IF(NUM_ARGS > detail::max_packed_args)>
+  constexpr basic_format_args(const store<NUM_ARGS, NUM_NAMED_ARGS, DESC>& s)
+      : desc_(DESC | (NUM_NAMED_ARGS != 0 ? +detail::has_named_args_bit : 0)),
+        args_(s.args) {}
+
+  /// Constructs a `basic_format_args` object from a dynamic list of arguments.
+  constexpr basic_format_args(const format_arg* args, int count,
+                              bool has_named = false)
+      : desc_(detail::is_unpacked_bit | detail::to_unsigned(count) |
+              (has_named ? +detail::has_named_args_bit : 0)),
+        args_(args) {}
+
+  /// Returns the argument with the specified id.
+  FMT_CONSTEXPR auto get(int id) const -> format_arg {
+    auto arg = format_arg();
+    if (!is_packed()) {
+      if (id < max_size()) arg = args_[id];
+      return arg;
+    }
+    if (static_cast<unsigned>(id) >= detail::max_packed_args) return arg;
+    arg.type_ = type(id);
+    if (arg.type_ != detail::type::none_type) arg.value_ = values_[id];
+    return arg;
+  }
+
+  template <typename Char>
+  auto get(basic_string_view<Char> name) const -> format_arg {
+    int id = get_id(name);
+    return id >= 0 ? get(id) : format_arg();
+  }
+
+  template <typename Char>
+  FMT_CONSTEXPR auto get_id(basic_string_view<Char> name) const -> int {
+    if (!has_named_args()) return -1;
+    const auto& named_args =
+        (is_packed() ? values_[-1] : args_[-1].value_).named_args;
+    for (size_t i = 0; i < named_args.size; ++i) {
+      if (named_args.data[i].name == name) return named_args.data[i].id;
+    }
+    return -1;
+  }
+
+  auto max_size() const -> int {
+    unsigned long long max_packed = detail::max_packed_args;
+    return static_cast<int>(is_packed() ? max_packed
+                                        : desc_ & ~detail::is_unpacked_bit);
+  }
+};
+
+// A formatting context.
+class context {
+ private:
+  appender out_;
+  format_args args_;
+  FMT_NO_UNIQUE_ADDRESS detail::locale_ref loc_;
+
+ public:
+  /// The character type for the output.
+  using char_type = char;
+
+  using iterator = appender;
+  using format_arg = basic_format_arg<context>;
+  using parse_context_type FMT_DEPRECATED = parse_context<>;
+  template <typename T> using formatter_type FMT_DEPRECATED = formatter<T>;
+  enum { builtin_types = FMT_BUILTIN_TYPES };
+
+  /// Constructs a `context` object. References to the arguments are stored
+  /// in the object so make sure they have appropriate lifetimes.
+  FMT_CONSTEXPR context(iterator out, format_args args,
+                        detail::locale_ref loc = {})
+      : out_(out), args_(args), loc_(loc) {}
+  context(context&&) = default;
+  context(const context&) = delete;
+  void operator=(const context&) = delete;
+
+  FMT_CONSTEXPR auto arg(int id) const -> format_arg { return args_.get(id); }
+  inline auto arg(string_view name) const -> format_arg {
+    return args_.get(name);
+  }
+  FMT_CONSTEXPR auto arg_id(string_view name) const -> int {
+    return args_.get_id(name);
+  }
+
+  // Returns an iterator to the beginning of the output range.
+  FMT_CONSTEXPR auto out() const -> iterator { return out_; }
+
+  // Advances the begin iterator to `it`.
+  FMT_CONSTEXPR void advance_to(iterator) {}
+
+  FMT_CONSTEXPR auto locale() const -> detail::locale_ref { return loc_; }
+};
+
+template <typename Char = char> struct runtime_format_string {
+  basic_string_view<Char> str;
+};
+
+/**
+ * Creates a runtime format string.
+ *
+ * **Example**:
+ *
+ *     // Check format string at runtime instead of compile-time.
+ *     fmt::print(fmt::runtime("{:d}"), "I am not a number");
+ */
+inline auto runtime(string_view s) -> runtime_format_string<> { return {{s}}; }
+
+/// A compile-time format string. Use `format_string` in the public API to
+/// prevent type deduction.
+template <typename... T> struct fstring {
+ private:
+  static constexpr int num_static_named_args =
+      detail::count_static_named_args<T...>();
+
+  using checker = detail::format_string_checker<
+      char, static_cast<int>(sizeof...(T)), num_static_named_args,
+      num_static_named_args != detail::count_named_args<T...>()>;
+
+  using arg_pack = detail::arg_pack<T...>;
+
+ public:
+  string_view str;
+  using t = fstring;
+
+  // Reports a compile-time error if S is not a valid format string for T.
+  template <size_t N>
+  FMT_CONSTEVAL FMT_ALWAYS_INLINE fstring(const char (&s)[N]) : str(s, N - 1) {
+    using namespace detail;
+    static_assert(count<(std::is_base_of<view, remove_reference_t<T>>::value &&
+                         std::is_reference<T>::value)...>() == 0,
+                  "passing views as lvalues is disallowed");
+    if (FMT_USE_CONSTEVAL) parse_format_string<char>(s, checker(s, arg_pack()));
+#ifdef FMT_ENFORCE_COMPILE_STRING
+    static_assert(
+        FMT_USE_CONSTEVAL && sizeof(s) != 0,
+        "FMT_ENFORCE_COMPILE_STRING requires format strings to use FMT_STRING");
+#endif
+  }
+  template <typename S,
+            FMT_ENABLE_IF(std::is_convertible<const S&, string_view>::value)>
+  FMT_CONSTEVAL FMT_ALWAYS_INLINE fstring(const S& s) : str(s) {
+    auto sv = string_view(str);
+    if (FMT_USE_CONSTEVAL)
+      detail::parse_format_string<char>(sv, checker(sv, arg_pack()));
+#ifdef FMT_ENFORCE_COMPILE_STRING
+    static_assert(
+        FMT_USE_CONSTEVAL && sizeof(s) != 0,
+        "FMT_ENFORCE_COMPILE_STRING requires format strings to use FMT_STRING");
+#endif
+  }
+  template <typename S,
+            FMT_ENABLE_IF(std::is_base_of<detail::compile_string, S>::value&&
+                              std::is_same<typename S::char_type, char>::value)>
+  FMT_ALWAYS_INLINE fstring(const S&) : str(S()) {
+    FMT_CONSTEXPR auto sv = string_view(S());
+    FMT_CONSTEXPR int ignore =
+        (parse_format_string(sv, checker(sv, arg_pack())), 0);
+    detail::ignore_unused(ignore);
+  }
+  fstring(runtime_format_string<> fmt) : str(fmt.str) {}
+
+  // Returning by reference generates better code in debug mode.
+  FMT_ALWAYS_INLINE operator const string_view&() const { return str; }
+  auto get() const -> string_view { return str; }
+};
+
+template <typename... T> using format_string = typename fstring<T...>::t;
+
+template <typename T, typename Char = char>
+using is_formattable = bool_constant<!std::is_same<
+    detail::mapped_t<conditional_t<std::is_void<T>::value, int*, T>, Char>,
+    void>::value>;
+#ifdef __cpp_concepts
+template <typename T, typename Char = char>
+concept formattable = is_formattable<remove_reference_t<T>, Char>::value;
+#endif
+
+template <typename T, typename Char>
+using has_formatter FMT_DEPRECATED = std::is_constructible<formatter<T, Char>>;
+
+// A formatter specialization for natively supported types.
+template <typename T, typename Char>
+struct formatter<T, Char,
+                 enable_if_t<detail::type_constant<T, Char>::value !=
+                             detail::type::custom_type>>
+    : detail::native_formatter<T, Char, detail::type_constant<T, Char>::value> {
+};
+
+/**
+ * Constructs an object that stores references to arguments and can be
+ * implicitly converted to `format_args`. `Context` can be omitted in which case
+ * it defaults to `context`. See `arg` for lifetime considerations.
+ */
+// Take arguments by lvalue references to avoid some lifetime issues, e.g.
+//   auto args = make_format_args(std::string());
+template <typename Context = context, typename... T,
+          int NUM_ARGS = sizeof...(T),
+          int NUM_NAMED_ARGS = detail::count_named_args<T...>(),
+          unsigned long long DESC = detail::make_descriptor<Context, T...>()>
+constexpr FMT_ALWAYS_INLINE auto make_format_args(T&... args)
+    -> detail::format_arg_store<Context, NUM_ARGS, NUM_NAMED_ARGS, DESC> {
+  // Suppress warnings for pathological types convertible to detail::value.
+  FMT_PRAGMA_GCC(diagnostic ignored "-Wconversion")
+  return {{args...}};
+}
+
+template <typename... T>
+using vargs =
+    detail::format_arg_store<context, sizeof...(T),
+                             detail::count_named_args<T...>(),
+                             detail::make_descriptor<context, T...>()>;
+
+/**
+ * Returns a named argument to be used in a formatting function.
+ * It should only be used in a call to a formatting function.
+ *
+ * **Example**:
+ *
+ *     fmt::print("The answer is {answer}.", fmt::arg("answer", 42));
+ */
+template <typename Char, typename T>
+inline auto arg(const Char* name, const T& arg) -> detail::named_arg<Char, T> {
+  return {name, arg};
+}
+
+/// Formats a string and writes the output to `out`.
+template <typename OutputIt,
+          FMT_ENABLE_IF(detail::is_output_iterator<remove_cvref_t<OutputIt>,
+                                                   char>::value)>
+auto vformat_to(OutputIt&& out, string_view fmt, format_args args)
+    -> remove_cvref_t<OutputIt> {
+  auto&& buf = detail::get_buffer<char>(out);
+  detail::vformat_to(buf, fmt, args, {});
+  return detail::get_iterator(buf, out);
+}
+
+/**
+ * Formats `args` according to specifications in `fmt`, writes the result to
+ * the output iterator `out` and returns the iterator past the end of the output
+ * range. `format_to` does not append a terminating null character.
+ *
+ * **Example**:
+ *
+ *     auto out = std::vector<char>();
+ *     fmt::format_to(std::back_inserter(out), "{}", 42);
+ */
+template <typename OutputIt, typename... T,
+          FMT_ENABLE_IF(detail::is_output_iterator<remove_cvref_t<OutputIt>,
+                                                   char>::value)>
+FMT_INLINE auto format_to(OutputIt&& out, format_string<T...> fmt, T&&... args)
+    -> remove_cvref_t<OutputIt> {
+  return vformat_to(out, fmt.str, vargs<T...>{{args...}});
+}
+
+template <typename OutputIt> struct format_to_n_result {
+  /// Iterator past the end of the output range.
+  OutputIt out;
+  /// Total (not truncated) output size.
+  size_t size;
+};
+
+template <typename OutputIt, typename... T,
+          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
+auto vformat_to_n(OutputIt out, size_t n, string_view fmt, format_args args)
+    -> format_to_n_result<OutputIt> {
+  using traits = detail::fixed_buffer_traits;
+  auto buf = detail::iterator_buffer<OutputIt, char, traits>(out, n);
+  detail::vformat_to(buf, fmt, args, {});
+  return {buf.out(), buf.count()};
+}
+
+/**
+ * Formats `args` according to specifications in `fmt`, writes up to `n`
+ * characters of the result to the output iterator `out` and returns the total
+ * (not truncated) output size and the iterator past the end of the output
+ * range. `format_to_n` does not append a terminating null character.
+ */
+template <typename OutputIt, typename... T,
+          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
+FMT_INLINE auto format_to_n(OutputIt out, size_t n, format_string<T...> fmt,
+                            T&&... args) -> format_to_n_result<OutputIt> {
+  return vformat_to_n(out, n, fmt.str, vargs<T...>{{args...}});
+}
+
+struct format_to_result {
+  /// Pointer to just after the last successful write in the array.
+  char* out;
+  /// Specifies if the output was truncated.
+  bool truncated;
+
+  FMT_CONSTEXPR operator char*() const {
+    // Report truncation to prevent silent data loss.
+    if (truncated) report_error("output is truncated");
+    return out;
+  }
+};
+
+template <size_t N>
+auto vformat_to(char (&out)[N], string_view fmt, format_args args)
+    -> format_to_result {
+  auto result = vformat_to_n(out, N, fmt, args);
+  return {result.out, result.size > N};
+}
+
+template <size_t N, typename... T>
+FMT_INLINE auto format_to(char (&out)[N], format_string<T...> fmt, T&&... args)
+    -> format_to_result {
+  auto result = vformat_to_n(out, N, fmt.str, vargs<T...>{{args...}});
+  return {result.out, result.size > N};
+}
+
+/// Returns the number of chars in the output of `format(fmt, args...)`.
+template <typename... T>
+FMT_NODISCARD FMT_INLINE auto formatted_size(format_string<T...> fmt,
+                                             T&&... args) -> size_t {
+  auto buf = detail::counting_buffer<>();
+  detail::vformat_to(buf, fmt.str, vargs<T...>{{args...}}, {});
+  return buf.count();
+}
+
+FMT_API void vprint(string_view fmt, format_args args);
+FMT_API void vprint(FILE* f, string_view fmt, format_args args);
+FMT_API void vprintln(FILE* f, string_view fmt, format_args args);
+FMT_API void vprint_buffered(FILE* f, string_view fmt, format_args args);
+
+/**
+ * Formats `args` according to specifications in `fmt` and writes the output
+ * to `stdout`.
+ *
+ * **Example**:
+ *
+ *     fmt::print("The answer is {}.", 42);
+ */
+template <typename... T>
+FMT_INLINE void print(format_string<T...> fmt, T&&... args) {
+  vargs<T...> va = {{args...}};
+  if (detail::const_check(!detail::use_utf8))
+    return detail::vprint_mojibake(stdout, fmt.str, va, false);
+  return detail::is_locking<T...>() ? vprint_buffered(stdout, fmt.str, va)
+                                    : vprint(fmt.str, va);
+}
+
+/**
+ * Formats `args` according to specifications in `fmt` and writes the
+ * output to the file `f`.
+ *
+ * **Example**:
+ *
+ *     fmt::print(stderr, "Don't {}!", "panic");
+ */
+template <typename... T>
+FMT_INLINE void print(FILE* f, format_string<T...> fmt, T&&... args) {
+  vargs<T...> va = {{args...}};
+  if (detail::const_check(!detail::use_utf8))
+    return detail::vprint_mojibake(f, fmt.str, va, false);
+  return detail::is_locking<T...>() ? vprint_buffered(f, fmt.str, va)
+                                    : vprint(f, fmt.str, va);
+}
+
+/// Formats `args` according to specifications in `fmt` and writes the output
+/// to the file `f` followed by a newline.
+template <typename... T>
+FMT_INLINE void println(FILE* f, format_string<T...> fmt, T&&... args) {
+  vargs<T...> va = {{args...}};
+  return detail::const_check(detail::use_utf8)
+             ? vprintln(f, fmt.str, va)
+             : detail::vprint_mojibake(f, fmt.str, va, true);
+}
+
+/// Formats `args` according to specifications in `fmt` and writes the output
+/// to `stdout` followed by a newline.
+template <typename... T>
+FMT_INLINE void println(format_string<T...> fmt, T&&... args) {
+  return fmt::println(stdout, fmt, static_cast<T&&>(args)...);
+}
+
+FMT_END_EXPORT
+FMT_PRAGMA_CLANG(diagnostic pop)
+FMT_PRAGMA_GCC(pop_options)
+FMT_END_NAMESPACE
+
+#ifdef FMT_HEADER_ONLY
+#  include "format.h"
+#endif
+#endif  // FMT_BASE_H_
diff --git a/3rdparty/fmt/include/fmt/chrono.h b/3rdparty/fmt/include/fmt/chrono.h
index 9d54574e1682c..50c777c841aa7 100644
--- a/3rdparty/fmt/include/fmt/chrono.h
+++ b/3rdparty/fmt/include/fmt/chrono.h
@@ -8,51 +8,36 @@
 #ifndef FMT_CHRONO_H_
 #define FMT_CHRONO_H_
 
-#include <algorithm>
-#include <chrono>
-#include <cmath>    // std::isfinite
-#include <cstring>  // std::memcpy
-#include <ctime>
-#include <iterator>
-#include <locale>
-#include <ostream>
-#include <type_traits>
-
-#include "ostream.h"  // formatbuf
+#ifndef FMT_MODULE
+#  include <algorithm>
+#  include <chrono>
+#  include <cmath>    // std::isfinite
+#  include <cstring>  // std::memcpy
+#  include <ctime>
+#  include <iterator>
+#  include <locale>
+#  include <ostream>
+#  include <type_traits>
+#endif
 
-FMT_BEGIN_NAMESPACE
+#include "format.h"
 
-// Check if std::chrono::local_t is available.
-#ifndef FMT_USE_LOCAL_TIME
-#  ifdef __cpp_lib_chrono
-#    define FMT_USE_LOCAL_TIME (__cpp_lib_chrono >= 201907L)
-#  else
-#    define FMT_USE_LOCAL_TIME 0
-#  endif
-#endif
+namespace fmt_detail {
+struct time_zone {
+  template <typename Duration, typename T>
+  auto to_sys(T)
+      -> std::chrono::time_point<std::chrono::system_clock, Duration> {
+    return {};
+  }
+};
+template <typename... T> inline auto current_zone(T...) -> time_zone* {
+  return nullptr;
+}
 
-// Check if std::chrono::utc_timestamp is available.
-#ifndef FMT_USE_UTC_TIME
-#  ifdef __cpp_lib_chrono
-#    define FMT_USE_UTC_TIME (__cpp_lib_chrono >= 201907L)
-#  else
-#    define FMT_USE_UTC_TIME 0
-#  endif
-#endif
+template <typename... T> inline void _tzset(T...) {}
+}  // namespace fmt_detail
 
-// Enable tzset.
-#ifndef FMT_USE_TZSET
-// UWP doesn't provide _tzset.
-#  if FMT_HAS_INCLUDE("winapifamily.h")
-#    include <winapifamily.h>
-#  endif
-#  if defined(_WIN32) && (!defined(WINAPI_FAMILY) || \
-                          (WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP))
-#    define FMT_USE_TZSET 1
-#  else
-#    define FMT_USE_TZSET 0
-#  endif
-#endif
+FMT_BEGIN_NAMESPACE
 
 // Enable safe chrono durations, unless explicitly disabled.
 #ifndef FMT_SAFE_DURATION_CAST
@@ -94,10 +79,8 @@ FMT_CONSTEXPR auto lossless_integral_conversion(const From from, int& ec)
   return static_cast<To>(from);
 }
 
-/**
- * converts From to To, without loss. If the dynamic value of from
- * can't be converted to To without loss, ec is set.
- */
+/// Converts From to To, without loss. If the dynamic value of from
+/// can't be converted to To without loss, ec is set.
 template <typename To, typename From,
           FMT_ENABLE_IF(!std::is_same<From, To>::value &&
                         std::numeric_limits<From>::is_signed !=
@@ -185,61 +168,7 @@ FMT_CONSTEXPR auto safe_float_conversion(const From from, int& ec) -> To {
   return from;
 }
 
-/**
- * safe duration cast between integral durations
- */
-template <typename To, typename FromRep, typename FromPeriod,
-          FMT_ENABLE_IF(std::is_integral<FromRep>::value),
-          FMT_ENABLE_IF(std::is_integral<typename To::rep>::value)>
-auto safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from,
-                        int& ec) -> To {
-  using From = std::chrono::duration<FromRep, FromPeriod>;
-  ec = 0;
-  // the basic idea is that we need to convert from count() in the from type
-  // to count() in the To type, by multiplying it with this:
-  struct Factor
-      : std::ratio_divide<typename From::period, typename To::period> {};
-
-  static_assert(Factor::num > 0, "num must be positive");
-  static_assert(Factor::den > 0, "den must be positive");
-
-  // the conversion is like this: multiply from.count() with Factor::num
-  // /Factor::den and convert it to To::rep, all this without
-  // overflow/underflow. let's start by finding a suitable type that can hold
-  // both To, From and Factor::num
-  using IntermediateRep =
-      typename std::common_type<typename From::rep, typename To::rep,
-                                decltype(Factor::num)>::type;
-
-  // safe conversion to IntermediateRep
-  IntermediateRep count =
-      lossless_integral_conversion<IntermediateRep>(from.count(), ec);
-  if (ec) return {};
-  // multiply with Factor::num without overflow or underflow
-  if (detail::const_check(Factor::num != 1)) {
-    const auto max1 = detail::max_value<IntermediateRep>() / Factor::num;
-    if (count > max1) {
-      ec = 1;
-      return {};
-    }
-    const auto min1 =
-        (std::numeric_limits<IntermediateRep>::min)() / Factor::num;
-    if (detail::const_check(!std::is_unsigned<IntermediateRep>::value) &&
-        count < min1) {
-      ec = 1;
-      return {};
-    }
-    count *= Factor::num;
-  }
-
-  if (detail::const_check(Factor::den != 1)) count /= Factor::den;
-  auto tocount = lossless_integral_conversion<typename To::rep>(count, ec);
-  return ec ? To() : To(tocount);
-}
-
-/**
- * safe duration_cast between floating point durations
- */
+/// Safe duration_cast between floating point durations
 template <typename To, typename FromRep, typename FromPeriod,
           FMT_ENABLE_IF(std::is_floating_point<FromRep>::value),
           FMT_ENABLE_IF(std::is_floating_point<typename To::rep>::value)>
@@ -318,17 +247,94 @@ auto safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from,
 }  // namespace safe_duration_cast
 #endif
 
+namespace detail {
+
+// Check if std::chrono::utc_time is available.
+#ifdef FMT_USE_UTC_TIME
+// Use the provided definition.
+#elif defined(__cpp_lib_chrono)
+#  define FMT_USE_UTC_TIME (__cpp_lib_chrono >= 201907L)
+#else
+#  define FMT_USE_UTC_TIME 0
+#endif
+#if FMT_USE_UTC_TIME
+using utc_clock = std::chrono::utc_clock;
+#else
+struct utc_clock {
+  template <typename T> void to_sys(T);
+};
+#endif
+
+// Check if std::chrono::local_time is available.
+#ifdef FMT_USE_LOCAL_TIME
+// Use the provided definition.
+#elif defined(__cpp_lib_chrono)
+#  define FMT_USE_LOCAL_TIME (__cpp_lib_chrono >= 201907L)
+#else
+#  define FMT_USE_LOCAL_TIME 0
+#endif
+#if FMT_USE_LOCAL_TIME
+using local_t = std::chrono::local_t;
+#else
+struct local_t {};
+#endif
+
+}  // namespace detail
+
+template <typename Duration>
+using sys_time = std::chrono::time_point<std::chrono::system_clock, Duration>;
+
+template <typename Duration>
+using utc_time = std::chrono::time_point<detail::utc_clock, Duration>;
+
+template <class Duration>
+using local_time = std::chrono::time_point<detail::local_t, Duration>;
+
+namespace detail {
+
 // Prevents expansion of a preceding token as a function-style macro.
 // Usage: f FMT_NOMACRO()
 #define FMT_NOMACRO
 
-namespace detail {
 template <typename T = void> struct null {};
 inline auto localtime_r FMT_NOMACRO(...) -> null<> { return null<>(); }
 inline auto localtime_s(...) -> null<> { return null<>(); }
 inline auto gmtime_r(...) -> null<> { return null<>(); }
 inline auto gmtime_s(...) -> null<> { return null<>(); }
 
+// It is defined here and not in ostream.h because the latter has expensive
+// includes.
+template <typename StreamBuf> class formatbuf : public StreamBuf {
+ private:
+  using char_type = typename StreamBuf::char_type;
+  using streamsize = decltype(std::declval<StreamBuf>().sputn(nullptr, 0));
+  using int_type = typename StreamBuf::int_type;
+  using traits_type = typename StreamBuf::traits_type;
+
+  buffer<char_type>& buffer_;
+
+ public:
+  explicit formatbuf(buffer<char_type>& buf) : buffer_(buf) {}
+
+ protected:
+  // The put area is always empty. This makes the implementation simpler and has
+  // the advantage that the streambuf and the buffer are always in sync and
+  // sputc never writes into uninitialized memory. A disadvantage is that each
+  // call to sputc always results in a (virtual) call to overflow. There is no
+  // disadvantage here for sputn since this always results in a call to xsputn.
+
+  auto overflow(int_type ch) -> int_type override {
+    if (!traits_type::eq_int_type(ch, traits_type::eof()))
+      buffer_.push_back(static_cast<char_type>(ch));
+    return ch;
+  }
+
+  auto xsputn(const char_type* s, streamsize count) -> streamsize override {
+    buffer_.append(s, s + count);
+    return count;
+  }
+};
+
 inline auto get_classic_locale() -> const std::locale& {
   static const auto& locale = std::locale::classic();
   return locale;
@@ -341,20 +347,16 @@ template <typename CodeUnit> struct codecvt_result {
 };
 
 template <typename CodeUnit>
-void write_codecvt(codecvt_result<CodeUnit>& out, string_view in_buf,
+void write_codecvt(codecvt_result<CodeUnit>& out, string_view in,
                    const std::locale& loc) {
-#if FMT_CLANG_VERSION
-#  pragma clang diagnostic push
-#  pragma clang diagnostic ignored "-Wdeprecated"
-  auto& f = std::use_facet<std::codecvt<CodeUnit, char, std::mbstate_t>>(loc);
-#  pragma clang diagnostic pop
-#else
+  FMT_PRAGMA_CLANG(diagnostic push)
+  FMT_PRAGMA_CLANG(diagnostic ignored "-Wdeprecated")
   auto& f = std::use_facet<std::codecvt<CodeUnit, char, std::mbstate_t>>(loc);
-#endif
+  FMT_PRAGMA_CLANG(diagnostic pop)
   auto mb = std::mbstate_t();
   const char* from_next = nullptr;
-  auto result = f.in(mb, in_buf.begin(), in_buf.end(), from_next,
-                     std::begin(out.buf), std::end(out.buf), out.end);
+  auto result = f.in(mb, in.begin(), in.end(), from_next, std::begin(out.buf),
+                     std::end(out.buf), out.end);
   if (result != std::codecvt_base::ok)
     FMT_THROW(format_error("failed to format time"));
 }
@@ -362,11 +364,12 @@ void write_codecvt(codecvt_result<CodeUnit>& out, string_view in_buf,
 template <typename OutputIt>
 auto write_encoded_tm_str(OutputIt out, string_view in, const std::locale& loc)
     -> OutputIt {
-  if (detail::is_utf8() && loc != get_classic_locale()) {
+  if (const_check(detail::use_utf8) && loc != get_classic_locale()) {
     // char16_t and char32_t codecvts are broken in MSVC (linkage errors) and
     // gcc-4.
-#if FMT_MSC_VERSION != 0 || \
-    (defined(__GLIBCXX__) && !defined(_GLIBCXX_USE_DUAL_ABI))
+#if FMT_MSC_VERSION != 0 ||  \
+    (defined(__GLIBCXX__) && \
+     (!defined(_GLIBCXX_USE_DUAL_ABI) || _GLIBCXX_USE_DUAL_ABI == 0))
     // The _GLIBCXX_USE_DUAL_ABI macro is always defined in libstdc++ from gcc-5
     // and newer.
     using code_unit = wchar_t;
@@ -382,9 +385,9 @@ auto write_encoded_tm_str(OutputIt out, string_view in, const std::locale& loc)
         to_utf8<code_unit, basic_memory_buffer<char, unit_t::max_size * 4>>();
     if (!u.convert({unit.buf, to_unsigned(unit.end - unit.buf)}))
       FMT_THROW(format_error("failed to format time"));
-    return copy_str<char>(u.c_str(), u.c_str() + u.size(), out);
+    return copy<char>(u.c_str(), u.c_str() + u.size(), out);
   }
-  return copy_str<char>(in.data(), in.data() + in.size(), out);
+  return copy<char>(in.data(), in.data() + in.size(), out);
 }
 
 template <typename Char, typename OutputIt,
@@ -393,7 +396,7 @@ auto write_tm_str(OutputIt out, string_view sv, const std::locale& loc)
     -> OutputIt {
   codecvt_result<Char> unit;
   write_codecvt(unit, sv, loc);
-  return copy_str<Char>(unit.buf, unit.end, out);
+  return copy<Char>(unit.buf, unit.end, out);
 }
 
 template <typename Char, typename OutputIt,
@@ -441,16 +444,56 @@ struct is_same_arithmetic_type
                                          std::is_floating_point<Rep2>::value)> {
 };
 
-template <
-    typename To, typename FromRep, typename FromPeriod,
-    FMT_ENABLE_IF(is_same_arithmetic_type<FromRep, typename To::rep>::value)>
-auto fmt_duration_cast(std::chrono::duration<FromRep, FromPeriod> from) -> To {
+FMT_NORETURN inline void throw_duration_error() {
+  FMT_THROW(format_error("cannot format duration"));
+}
+
+// Cast one integral duration to another with an overflow check.
+template <typename To, typename FromRep, typename FromPeriod,
+          FMT_ENABLE_IF(std::is_integral<FromRep>::value&&
+                            std::is_integral<typename To::rep>::value)>
+auto duration_cast(std::chrono::duration<FromRep, FromPeriod> from) -> To {
+#if !FMT_SAFE_DURATION_CAST
+  return std::chrono::duration_cast<To>(from);
+#else
+  // The conversion factor: to.count() == factor * from.count().
+  using factor = std::ratio_divide<FromPeriod, typename To::period>;
+
+  using common_rep = typename std::common_type<FromRep, typename To::rep,
+                                               decltype(factor::num)>::type;
+
+  int ec = 0;
+  auto count = safe_duration_cast::lossless_integral_conversion<common_rep>(
+      from.count(), ec);
+  if (ec) throw_duration_error();
+
+  // Multiply from.count() by factor and check for overflow.
+  if (const_check(factor::num != 1)) {
+    if (count > max_value<common_rep>() / factor::num) throw_duration_error();
+    const auto min = (std::numeric_limits<common_rep>::min)() / factor::num;
+    if (const_check(!std::is_unsigned<common_rep>::value) && count < min)
+      throw_duration_error();
+    count *= factor::num;
+  }
+  if (const_check(factor::den != 1)) count /= factor::den;
+  auto to =
+      To(safe_duration_cast::lossless_integral_conversion<typename To::rep>(
+          count, ec));
+  if (ec) throw_duration_error();
+  return to;
+#endif
+}
+
+template <typename To, typename FromRep, typename FromPeriod,
+          FMT_ENABLE_IF(std::is_floating_point<FromRep>::value&&
+                            std::is_floating_point<typename To::rep>::value)>
+auto duration_cast(std::chrono::duration<FromRep, FromPeriod> from) -> To {
 #if FMT_SAFE_DURATION_CAST
   // Throwing version of safe_duration_cast is only available for
   // integer to integer or float to float casts.
   int ec;
   To to = safe_duration_cast::safe_duration_cast<To>(from, ec);
-  if (ec) FMT_THROW(format_error("cannot format duration"));
+  if (ec) throw_duration_error();
   return to;
 #else
   // Standard duration cast, may overflow.
@@ -461,54 +504,60 @@ auto fmt_duration_cast(std::chrono::duration<FromRep, FromPeriod> from) -> To {
 template <
     typename To, typename FromRep, typename FromPeriod,
     FMT_ENABLE_IF(!is_same_arithmetic_type<FromRep, typename To::rep>::value)>
-auto fmt_duration_cast(std::chrono::duration<FromRep, FromPeriod> from) -> To {
+auto duration_cast(std::chrono::duration<FromRep, FromPeriod> from) -> To {
   // Mixed integer <-> float cast is not supported by safe_duration_cast.
   return std::chrono::duration_cast<To>(from);
 }
 
 template <typename Duration>
-auto to_time_t(
-    std::chrono::time_point<std::chrono::system_clock, Duration> time_point)
-    -> std::time_t {
+auto to_time_t(sys_time<Duration> time_point) -> std::time_t {
   // Cannot use std::chrono::system_clock::to_time_t since this would first
   // require a cast to std::chrono::system_clock::time_point, which could
   // overflow.
-  return fmt_duration_cast<std::chrono::duration<std::time_t>>(
+  return detail::duration_cast<std::chrono::duration<std::time_t>>(
              time_point.time_since_epoch())
       .count();
 }
+
+// Workaround a bug in libstdc++ which sets __cpp_lib_chrono to 201907 without
+// providing current_zone(): https://github.com/fmtlib/fmt/issues/4160.
+template <typename T> FMT_CONSTEXPR auto has_current_zone() -> bool {
+  using namespace std::chrono;
+  using namespace fmt_detail;
+  return !std::is_same<decltype(current_zone()), fmt_detail::time_zone*>::value;
+}
 }  // namespace detail
 
 FMT_BEGIN_EXPORT
 
 /**
-  Converts given time since epoch as ``std::time_t`` value into calendar time,
-  expressed in local time. Unlike ``std::localtime``, this function is
-  thread-safe on most platforms.
+ * Converts given time since epoch as `std::time_t` value into calendar time,
+ * expressed in local time. Unlike `std::localtime`, this function is
+ * thread-safe on most platforms.
  */
 inline auto localtime(std::time_t time) -> std::tm {
   struct dispatcher {
     std::time_t time_;
     std::tm tm_;
 
-    dispatcher(std::time_t t) : time_(t) {}
+    inline dispatcher(std::time_t t) : time_(t) {}
 
-    auto run() -> bool {
+    inline auto run() -> bool {
       using namespace fmt::detail;
       return handle(localtime_r(&time_, &tm_));
     }
 
-    auto handle(std::tm* tm) -> bool { return tm != nullptr; }
+    inline auto handle(std::tm* tm) -> bool { return tm != nullptr; }
 
-    auto handle(detail::null<>) -> bool {
+    inline auto handle(detail::null<>) -> bool {
       using namespace fmt::detail;
       return fallback(localtime_s(&tm_, &time_));
     }
 
-    auto fallback(int res) -> bool { return res == 0; }
+    inline auto fallback(int res) -> bool { return res == 0; }
 
 #if !FMT_MSC_VERSION
-    auto fallback(detail::null<>) -> bool {
+    inline auto fallback(detail::null<>) -> bool {
       using namespace fmt::detail;
       std::tm* tm = std::localtime(&time_);
       if (tm) tm_ = *tm;
@@ -523,41 +572,43 @@ inline auto localtime(std::time_t time) -> std::tm {
 }
 
 #if FMT_USE_LOCAL_TIME
-template <typename Duration>
+template <typename Duration,
+          FMT_ENABLE_IF(detail::has_current_zone<Duration>())>
 inline auto localtime(std::chrono::local_time<Duration> time) -> std::tm {
-  return localtime(
-      detail::to_time_t(std::chrono::current_zone()->to_sys(time)));
+  using namespace std::chrono;
+  using namespace fmt_detail;
+  return localtime(detail::to_time_t(current_zone()->to_sys<Duration>(time)));
 }
 #endif
 
 /**
-  Converts given time since epoch as ``std::time_t`` value into calendar time,
-  expressed in Coordinated Universal Time (UTC). Unlike ``std::gmtime``, this
-  function is thread-safe on most platforms.
+ * Converts given time since epoch as `std::time_t` value into calendar time,
+ * expressed in Coordinated Universal Time (UTC). Unlike `std::gmtime`, this
+ * function is thread-safe on most platforms.
  */
 inline auto gmtime(std::time_t time) -> std::tm {
   struct dispatcher {
     std::time_t time_;
     std::tm tm_;
 
-    dispatcher(std::time_t t) : time_(t) {}
+    inline dispatcher(std::time_t t) : time_(t) {}
 
-    auto run() -> bool {
+    inline auto run() -> bool {
       using namespace fmt::detail;
       return handle(gmtime_r(&time_, &tm_));
     }
 
-    auto handle(std::tm* tm) -> bool { return tm != nullptr; }
+    inline auto handle(std::tm* tm) -> bool { return tm != nullptr; }
 
-    auto handle(detail::null<>) -> bool {
+    inline auto handle(detail::null<>) -> bool {
       using namespace fmt::detail;
       return fallback(gmtime_s(&tm_, &time_));
     }
 
-    auto fallback(int res) -> bool { return res == 0; }
+    inline auto fallback(int res) -> bool { return res == 0; }
 
 #if !FMT_MSC_VERSION
-    auto fallback(detail::null<>) -> bool {
+    inline auto fallback(detail::null<>) -> bool {
       std::tm* tm = std::gmtime(&time_);
       if (tm) tm_ = *tm;
       return tm != nullptr;
@@ -571,9 +622,7 @@ inline auto gmtime(std::time_t time) -> std::tm {
 }
 
 template <typename Duration>
-inline auto gmtime(
-    std::chrono::time_point<std::chrono::system_clock, Duration> time_point)
-    -> std::tm {
+inline auto gmtime(sys_time<Duration> time_point) -> std::tm {
   return gmtime(detail::to_time_t(time_point));
 }
 
@@ -619,7 +668,8 @@ FMT_CONSTEXPR inline auto get_units() -> const char* {
   if (std::is_same<Period, std::femto>::value) return "fs";
   if (std::is_same<Period, std::pico>::value) return "ps";
   if (std::is_same<Period, std::nano>::value) return "ns";
-  if (std::is_same<Period, std::micro>::value) return "Âµs";
+  if (std::is_same<Period, std::micro>::value)
+    return detail::use_utf8 ? "Âµs" : "us";
   if (std::is_same<Period, std::milli>::value) return "ms";
   if (std::is_same<Period, std::centi>::value) return "cs";
   if (std::is_same<Period, std::deci>::value) return "ds";
@@ -646,12 +696,10 @@ enum class numeric_system {
 
 // Glibc extensions for formatting numeric values.
 enum class pad_type {
-  unspecified,
+  // Pad a numeric result string with zeros (the default).
+  zero,
   // Do not pad a numeric result string.
   none,
-  // Pad a numeric result string with zeros even if the conversion specifier
-  // character uses space-padding by default.
-  zero,
   // Pad a numeric result string with spaces.
   space,
 };
@@ -659,7 +707,7 @@ enum class pad_type {
 template <typename OutputIt>
 auto write_padding(OutputIt out, pad_type pad, int width) -> OutputIt {
   if (pad == pad_type::none) return out;
-  return std::fill_n(out, width, pad == pad_type::space ? ' ' : '0');
+  return detail::fill_n(out, width, pad == pad_type::space ? ' ' : '0');
 }
 
 template <typename OutputIt>
@@ -675,8 +723,8 @@ FMT_CONSTEXPR auto parse_chrono_format(const Char* begin, const Char* end,
   if (begin == end || *begin == '}') return begin;
   if (*begin != '%') FMT_THROW(format_error("invalid format"));
   auto ptr = begin;
-  pad_type pad = pad_type::unspecified;
   while (ptr != end) {
+    pad_type pad = pad_type::zero;
     auto c = *ptr;
     if (c == '}') break;
     if (c != '%') {
@@ -696,17 +744,11 @@ FMT_CONSTEXPR auto parse_chrono_format(const Char* begin, const Char* end,
       pad = pad_type::none;
       ++ptr;
       break;
-    case '0':
-      pad = pad_type::zero;
-      ++ptr;
-      break;
     }
     if (ptr == end) FMT_THROW(format_error("invalid format"));
     c = *ptr++;
     switch (c) {
-    case '%':
-      handler.on_text(ptr - 1, ptr);
-      break;
+    case '%': handler.on_text(ptr - 1, ptr); break;
     case 'n': {
       const Char newline[] = {'\n'};
       handler.on_text(newline, newline + 1);
@@ -718,145 +760,66 @@ FMT_CONSTEXPR auto parse_chrono_format(const Char* begin, const Char* end,
       break;
     }
     // Year:
-    case 'Y':
-      handler.on_year(numeric_system::standard);
-      break;
-    case 'y':
-      handler.on_short_year(numeric_system::standard);
-      break;
-    case 'C':
-      handler.on_century(numeric_system::standard);
-      break;
-    case 'G':
-      handler.on_iso_week_based_year();
-      break;
-    case 'g':
-      handler.on_iso_week_based_short_year();
-      break;
+    case 'Y': handler.on_year(numeric_system::standard, pad); break;
+    case 'y': handler.on_short_year(numeric_system::standard); break;
+    case 'C': handler.on_century(numeric_system::standard); break;
+    case 'G': handler.on_iso_week_based_year(); break;
+    case 'g': handler.on_iso_week_based_short_year(); break;
     // Day of the week:
-    case 'a':
-      handler.on_abbr_weekday();
-      break;
-    case 'A':
-      handler.on_full_weekday();
-      break;
-    case 'w':
-      handler.on_dec0_weekday(numeric_system::standard);
-      break;
-    case 'u':
-      handler.on_dec1_weekday(numeric_system::standard);
-      break;
+    case 'a': handler.on_abbr_weekday(); break;
+    case 'A': handler.on_full_weekday(); break;
+    case 'w': handler.on_dec0_weekday(numeric_system::standard); break;
+    case 'u': handler.on_dec1_weekday(numeric_system::standard); break;
     // Month:
     case 'b':
-    case 'h':
-      handler.on_abbr_month();
-      break;
-    case 'B':
-      handler.on_full_month();
-      break;
-    case 'm':
-      handler.on_dec_month(numeric_system::standard);
-      break;
+    case 'h': handler.on_abbr_month(); break;
+    case 'B': handler.on_full_month(); break;
+    case 'm': handler.on_dec_month(numeric_system::standard, pad); break;
     // Day of the year/month:
     case 'U':
-      handler.on_dec0_week_of_year(numeric_system::standard);
+      handler.on_dec0_week_of_year(numeric_system::standard, pad);
       break;
     case 'W':
-      handler.on_dec1_week_of_year(numeric_system::standard);
-      break;
-    case 'V':
-      handler.on_iso_week_of_year(numeric_system::standard);
-      break;
-    case 'j':
-      handler.on_day_of_year();
-      break;
-    case 'd':
-      handler.on_day_of_month(numeric_system::standard);
+      handler.on_dec1_week_of_year(numeric_system::standard, pad);
       break;
+    case 'V': handler.on_iso_week_of_year(numeric_system::standard, pad); break;
+    case 'j': handler.on_day_of_year(pad); break;
+    case 'd': handler.on_day_of_month(numeric_system::standard, pad); break;
     case 'e':
-      handler.on_day_of_month_space(numeric_system::standard);
+      handler.on_day_of_month(numeric_system::standard, pad_type::space);
       break;
     // Hour, minute, second:
-    case 'H':
-      handler.on_24_hour(numeric_system::standard, pad);
-      break;
-    case 'I':
-      handler.on_12_hour(numeric_system::standard, pad);
-      break;
-    case 'M':
-      handler.on_minute(numeric_system::standard, pad);
-      break;
-    case 'S':
-      handler.on_second(numeric_system::standard, pad);
-      break;
+    case 'H': handler.on_24_hour(numeric_system::standard, pad); break;
+    case 'I': handler.on_12_hour(numeric_system::standard, pad); break;
+    case 'M': handler.on_minute(numeric_system::standard, pad); break;
+    case 'S': handler.on_second(numeric_system::standard, pad); break;
     // Other:
-    case 'c':
-      handler.on_datetime(numeric_system::standard);
-      break;
-    case 'x':
-      handler.on_loc_date(numeric_system::standard);
-      break;
-    case 'X':
-      handler.on_loc_time(numeric_system::standard);
-      break;
-    case 'D':
-      handler.on_us_date();
-      break;
-    case 'F':
-      handler.on_iso_date();
-      break;
-    case 'r':
-      handler.on_12_hour_time();
-      break;
-    case 'R':
-      handler.on_24_hour_time();
-      break;
-    case 'T':
-      handler.on_iso_time();
-      break;
-    case 'p':
-      handler.on_am_pm();
-      break;
-    case 'Q':
-      handler.on_duration_value();
-      break;
-    case 'q':
-      handler.on_duration_unit();
-      break;
-    case 'z':
-      handler.on_utc_offset(numeric_system::standard);
-      break;
-    case 'Z':
-      handler.on_tz_name();
-      break;
+    case 'c': handler.on_datetime(numeric_system::standard); break;
+    case 'x': handler.on_loc_date(numeric_system::standard); break;
+    case 'X': handler.on_loc_time(numeric_system::standard); break;
+    case 'D': handler.on_us_date(); break;
+    case 'F': handler.on_iso_date(); break;
+    case 'r': handler.on_12_hour_time(); break;
+    case 'R': handler.on_24_hour_time(); break;
+    case 'T': handler.on_iso_time(); break;
+    case 'p': handler.on_am_pm(); break;
+    case 'Q': handler.on_duration_value(); break;
+    case 'q': handler.on_duration_unit(); break;
+    case 'z': handler.on_utc_offset(numeric_system::standard); break;
+    case 'Z': handler.on_tz_name(); break;
     // Alternative representation:
     case 'E': {
       if (ptr == end) FMT_THROW(format_error("invalid format"));
       c = *ptr++;
       switch (c) {
-      case 'Y':
-        handler.on_year(numeric_system::alternative);
-        break;
-      case 'y':
-        handler.on_offset_year();
-        break;
-      case 'C':
-        handler.on_century(numeric_system::alternative);
-        break;
-      case 'c':
-        handler.on_datetime(numeric_system::alternative);
-        break;
-      case 'x':
-        handler.on_loc_date(numeric_system::alternative);
-        break;
-      case 'X':
-        handler.on_loc_time(numeric_system::alternative);
-        break;
-      case 'z':
-        handler.on_utc_offset(numeric_system::alternative);
-        break;
-      default:
-        FMT_THROW(format_error("invalid format"));
+      case 'Y': handler.on_year(numeric_system::alternative, pad); break;
+      case 'y': handler.on_offset_year(); break;
+      case 'C': handler.on_century(numeric_system::alternative); break;
+      case 'c': handler.on_datetime(numeric_system::alternative); break;
+      case 'x': handler.on_loc_date(numeric_system::alternative); break;
+      case 'X': handler.on_loc_time(numeric_system::alternative); break;
+      case 'z': handler.on_utc_offset(numeric_system::alternative); break;
+      default:  FMT_THROW(format_error("invalid format"));
       }
       break;
     }
@@ -864,54 +827,34 @@ FMT_CONSTEXPR auto parse_chrono_format(const Char* begin, const Char* end,
       if (ptr == end) FMT_THROW(format_error("invalid format"));
       c = *ptr++;
       switch (c) {
-      case 'y':
-        handler.on_short_year(numeric_system::alternative);
-        break;
-      case 'm':
-        handler.on_dec_month(numeric_system::alternative);
-        break;
+      case 'y': handler.on_short_year(numeric_system::alternative); break;
+      case 'm': handler.on_dec_month(numeric_system::alternative, pad); break;
       case 'U':
-        handler.on_dec0_week_of_year(numeric_system::alternative);
+        handler.on_dec0_week_of_year(numeric_system::alternative, pad);
         break;
       case 'W':
-        handler.on_dec1_week_of_year(numeric_system::alternative);
+        handler.on_dec1_week_of_year(numeric_system::alternative, pad);
         break;
       case 'V':
-        handler.on_iso_week_of_year(numeric_system::alternative);
+        handler.on_iso_week_of_year(numeric_system::alternative, pad);
         break;
       case 'd':
-        handler.on_day_of_month(numeric_system::alternative);
+        handler.on_day_of_month(numeric_system::alternative, pad);
         break;
       case 'e':
-        handler.on_day_of_month_space(numeric_system::alternative);
-        break;
-      case 'w':
-        handler.on_dec0_weekday(numeric_system::alternative);
-        break;
-      case 'u':
-        handler.on_dec1_weekday(numeric_system::alternative);
-        break;
-      case 'H':
-        handler.on_24_hour(numeric_system::alternative, pad);
-        break;
-      case 'I':
-        handler.on_12_hour(numeric_system::alternative, pad);
-        break;
-      case 'M':
-        handler.on_minute(numeric_system::alternative, pad);
+        handler.on_day_of_month(numeric_system::alternative, pad_type::space);
         break;
-      case 'S':
-        handler.on_second(numeric_system::alternative, pad);
-        break;
-      case 'z':
-        handler.on_utc_offset(numeric_system::alternative);
-        break;
-      default:
-        FMT_THROW(format_error("invalid format"));
+      case 'w': handler.on_dec0_weekday(numeric_system::alternative); break;
+      case 'u': handler.on_dec1_weekday(numeric_system::alternative); break;
+      case 'H': handler.on_24_hour(numeric_system::alternative, pad); break;
+      case 'I': handler.on_12_hour(numeric_system::alternative, pad); break;
+      case 'M': handler.on_minute(numeric_system::alternative, pad); break;
+      case 'S': handler.on_second(numeric_system::alternative, pad); break;
+      case 'z': handler.on_utc_offset(numeric_system::alternative); break;
+      default:  FMT_THROW(format_error("invalid format"));
       }
       break;
-    default:
-      FMT_THROW(format_error("invalid format"));
+    default: FMT_THROW(format_error("invalid format"));
     }
     begin = ptr;
   }
@@ -923,7 +866,7 @@ template <typename Derived> struct null_chrono_spec_handler {
   FMT_CONSTEXPR void unsupported() {
     static_cast<Derived*>(this)->unsupported();
   }
-  FMT_CONSTEXPR void on_year(numeric_system) { unsupported(); }
+  FMT_CONSTEXPR void on_year(numeric_system, pad_type) { unsupported(); }
   FMT_CONSTEXPR void on_short_year(numeric_system) { unsupported(); }
   FMT_CONSTEXPR void on_offset_year() { unsupported(); }
   FMT_CONSTEXPR void on_century(numeric_system) { unsupported(); }
@@ -935,13 +878,20 @@ template <typename Derived> struct null_chrono_spec_handler {
   FMT_CONSTEXPR void on_dec1_weekday(numeric_system) { unsupported(); }
   FMT_CONSTEXPR void on_abbr_month() { unsupported(); }
   FMT_CONSTEXPR void on_full_month() { unsupported(); }
-  FMT_CONSTEXPR void on_dec_month(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_dec0_week_of_year(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_dec1_week_of_year(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_iso_week_of_year(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_day_of_year() { unsupported(); }
-  FMT_CONSTEXPR void on_day_of_month(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_day_of_month_space(numeric_system) { unsupported(); }
+  FMT_CONSTEXPR void on_dec_month(numeric_system, pad_type) { unsupported(); }
+  FMT_CONSTEXPR void on_dec0_week_of_year(numeric_system, pad_type) {
+    unsupported();
+  }
+  FMT_CONSTEXPR void on_dec1_week_of_year(numeric_system, pad_type) {
+    unsupported();
+  }
+  FMT_CONSTEXPR void on_iso_week_of_year(numeric_system, pad_type) {
+    unsupported();
+  }
+  FMT_CONSTEXPR void on_day_of_year(pad_type) { unsupported(); }
+  FMT_CONSTEXPR void on_day_of_month(numeric_system, pad_type) {
+    unsupported();
+  }
   FMT_CONSTEXPR void on_24_hour(numeric_system) { unsupported(); }
   FMT_CONSTEXPR void on_12_hour(numeric_system) { unsupported(); }
   FMT_CONSTEXPR void on_minute(numeric_system) { unsupported(); }
@@ -962,11 +912,13 @@ template <typename Derived> struct null_chrono_spec_handler {
 };
 
 struct tm_format_checker : null_chrono_spec_handler<tm_format_checker> {
-  FMT_NORETURN void unsupported() { FMT_THROW(format_error("no format")); }
+  FMT_NORETURN inline void unsupported() {
+    FMT_THROW(format_error("no format"));
+  }
 
   template <typename Char>
   FMT_CONSTEXPR void on_text(const Char*, const Char*) {}
-  FMT_CONSTEXPR void on_year(numeric_system) {}
+  FMT_CONSTEXPR void on_year(numeric_system, pad_type) {}
   FMT_CONSTEXPR void on_short_year(numeric_system) {}
   FMT_CONSTEXPR void on_offset_year() {}
   FMT_CONSTEXPR void on_century(numeric_system) {}
@@ -978,13 +930,12 @@ struct tm_format_checker : null_chrono_spec_handler<tm_format_checker> {
   FMT_CONSTEXPR void on_dec1_weekday(numeric_system) {}
   FMT_CONSTEXPR void on_abbr_month() {}
   FMT_CONSTEXPR void on_full_month() {}
-  FMT_CONSTEXPR void on_dec_month(numeric_system) {}
-  FMT_CONSTEXPR void on_dec0_week_of_year(numeric_system) {}
-  FMT_CONSTEXPR void on_dec1_week_of_year(numeric_system) {}
-  FMT_CONSTEXPR void on_iso_week_of_year(numeric_system) {}
-  FMT_CONSTEXPR void on_day_of_year() {}
-  FMT_CONSTEXPR void on_day_of_month(numeric_system) {}
-  FMT_CONSTEXPR void on_day_of_month_space(numeric_system) {}
+  FMT_CONSTEXPR void on_dec_month(numeric_system, pad_type) {}
+  FMT_CONSTEXPR void on_dec0_week_of_year(numeric_system, pad_type) {}
+  FMT_CONSTEXPR void on_dec1_week_of_year(numeric_system, pad_type) {}
+  FMT_CONSTEXPR void on_iso_week_of_year(numeric_system, pad_type) {}
+  FMT_CONSTEXPR void on_day_of_year(pad_type) {}
+  FMT_CONSTEXPR void on_day_of_month(numeric_system, pad_type) {}
   FMT_CONSTEXPR void on_24_hour(numeric_system, pad_type) {}
   FMT_CONSTEXPR void on_12_hour(numeric_system, pad_type) {}
   FMT_CONSTEXPR void on_minute(numeric_system, pad_type) {}
@@ -1040,15 +991,14 @@ template <typename T>
 struct has_member_data_tm_zone<T, void_t<decltype(T::tm_zone)>>
     : std::true_type {};
 
-#if FMT_USE_TZSET
 inline void tzset_once() {
-  static bool init = []() -> bool {
+  static bool init = []() {
+    using namespace fmt_detail;
     _tzset();
-    return true;
+    return false;
   }();
   ignore_unused(init);
 }
-#endif
 
 // Converts value to Int and checks that it's in the range [0, upper).
 template <typename T, typename Int, FMT_ENABLE_IF(std::is_integral<T>::value)>
@@ -1061,9 +1011,10 @@ inline auto to_nonnegative_int(T value, Int upper) -> Int {
 }
 template <typename T, typename Int, FMT_ENABLE_IF(!std::is_integral<T>::value)>
 inline auto to_nonnegative_int(T value, Int upper) -> Int {
-  if (value < 0 || value > static_cast<T>(upper))
+  auto int_value = static_cast<Int>(value);
+  if (int_value < 0 || value > static_cast<T>(upper))
     FMT_THROW(format_error("invalid value"));
-  return static_cast<Int>(value);
+  return int_value;
 }
 
 constexpr auto pow10(std::uint32_t n) -> long long {
@@ -1098,16 +1049,16 @@ void write_fractional_seconds(OutputIt& out, Duration d, int precision = -1) {
   using subsecond_precision = std::chrono::duration<
       typename std::common_type<typename Duration::rep,
                                 std::chrono::seconds::rep>::type,
-      std::ratio<1, detail::pow10(num_fractional_digits)>>;
+      std::ratio<1, pow10(num_fractional_digits)>>;
 
-  const auto fractional = d - fmt_duration_cast<std::chrono::seconds>(d);
+  const auto fractional = d - detail::duration_cast<std::chrono::seconds>(d);
   const auto subseconds =
       std::chrono::treat_as_floating_point<
           typename subsecond_precision::rep>::value
           ? fractional.count()
-          : fmt_duration_cast<subsecond_precision>(fractional).count();
+          : detail::duration_cast<subsecond_precision>(fractional).count();
   auto n = static_cast<uint32_or_64_or_128_t<long long>>(subseconds);
-  const int num_digits = detail::count_digits(n);
+  const int num_digits = count_digits(n);
 
   int leading_zeroes = (std::max)(0, num_fractional_digits - num_digits);
   if (precision < 0) {
@@ -1115,22 +1066,25 @@ void write_fractional_seconds(OutputIt& out, Duration d, int precision = -1) {
     if (std::ratio_less<typename subsecond_precision::period,
                         std::chrono::seconds::period>::value) {
       *out++ = '.';
-      out = std::fill_n(out, leading_zeroes, '0');
-      out = format_decimal<Char>(out, n, num_digits).end;
+      out = detail::fill_n(out, leading_zeroes, '0');
+      out = format_decimal<Char>(out, n, num_digits);
     }
-  } else {
+  } else if (precision > 0) {
     *out++ = '.';
-    leading_zeroes = (std::min)(leading_zeroes, precision);
-    out = std::fill_n(out, leading_zeroes, '0');
+    leading_zeroes = min_of(leading_zeroes, precision);
     int remaining = precision - leading_zeroes;
-    if (remaining != 0 && remaining < num_digits) {
-      n /= to_unsigned(detail::pow10(to_unsigned(num_digits - remaining)));
-      out = format_decimal<Char>(out, n, remaining).end;
+    out = detail::fill_n(out, leading_zeroes, '0');
+    if (remaining < num_digits) {
+      int num_truncated_digits = num_digits - remaining;
+      n /= to_unsigned(pow10(to_unsigned(num_truncated_digits)));
+      if (n != 0) out = format_decimal<Char>(out, n, remaining);
       return;
     }
-    out = format_decimal<Char>(out, n, num_digits).end;
-    remaining -= num_digits;
-    out = std::fill_n(out, remaining, '0');
+    if (n != 0) {
+      out = format_decimal<Char>(out, n, num_digits);
+      remaining -= num_digits;
+    }
+    out = detail::fill_n(out, remaining, '0');
   }
 }
 
@@ -1271,29 +1225,28 @@ class tm_writer {
     }
   }
 
-  void write_year_extended(long long year) {
+  void write_year_extended(long long year, pad_type pad) {
     // At least 4 characters.
     int width = 4;
-    if (year < 0) {
-      *out_++ = '-';
+    bool negative = year < 0;
+    if (negative) {
       year = 0 - year;
       --width;
     }
     uint32_or_64_or_128_t<long long> n = to_unsigned(year);
     const int num_digits = count_digits(n);
-    if (width > num_digits) out_ = std::fill_n(out_, width - num_digits, '0');
-    out_ = format_decimal<Char>(out_, n, num_digits).end;
-  }
-  void write_year(long long year) {
-    if (year >= 0 && year < 10000) {
-      write2(static_cast<int>(year / 100));
-      write2(static_cast<int>(year % 100));
-    } else {
-      write_year_extended(year);
+    if (negative && pad == pad_type::zero) *out_++ = '-';
+    if (width > num_digits) {
+      out_ = detail::write_padding(out_, pad, width - num_digits);
     }
+    if (negative && pad != pad_type::zero) *out_++ = '-';
+    out_ = format_decimal<Char>(out_, n, num_digits);
+  }
+  void write_year(long long year, pad_type pad) {
+    write_year_extended(year, pad);
   }
 
-  void write_utc_offset(long offset, numeric_system ns) {
+  void write_utc_offset(long long offset, numeric_system ns) {
     if (offset < 0) {
       *out_++ = '-';
       offset = -offset;
@@ -1305,6 +1258,7 @@ class tm_writer {
     if (ns != numeric_system::standard) *out_++ = ':';
     write2(static_cast<int>(offset % 60));
   }
+
   template <typename T, FMT_ENABLE_IF(has_member_data_tm_gmtoff<T>::value)>
   void format_utc_offset_impl(const T& tm, numeric_system ns) {
     write_utc_offset(tm.tm_gmtoff, ns);
@@ -1312,9 +1266,7 @@ class tm_writer {
   template <typename T, FMT_ENABLE_IF(!has_member_data_tm_gmtoff<T>::value)>
   void format_utc_offset_impl(const T& tm, numeric_system ns) {
 #if defined(_WIN32) && defined(_UCRT)
-#  if FMT_USE_TZSET
     tzset_once();
-#  endif
     long offset = 0;
     _get_timezone(&offset);
     if (tm.tm_isdst) {
@@ -1331,7 +1283,7 @@ class tm_writer {
     std::time_t gt = std::mktime(&gtm);
     std::tm ltm = gmtime(gt);
     std::time_t lt = std::mktime(&ltm);
-    long offset = gt - lt;
+    long long offset = gt - lt;
     write_utc_offset(offset, ns);
 #endif
   }
@@ -1364,7 +1316,7 @@ class tm_writer {
   auto out() const -> OutputIt { return out_; }
 
   FMT_CONSTEXPR void on_text(const Char* begin, const Char* end) {
-    out_ = copy_str<Char>(begin, end, out_);
+    out_ = copy<Char>(begin, end, out_);
   }
 
   void on_abbr_weekday() {
@@ -1411,11 +1363,11 @@ class tm_writer {
       *out_++ = ' ';
       on_abbr_month();
       *out_++ = ' ';
-      on_day_of_month_space(numeric_system::standard);
+      on_day_of_month(numeric_system::standard, pad_type::space);
       *out_++ = ' ';
       on_iso_time();
       *out_++ = ' ';
-      on_year(numeric_system::standard);
+      on_year(numeric_system::standard, pad_type::space);
     } else {
       format_localized('c', ns == numeric_system::standard ? '\0' : 'E');
     }
@@ -1437,31 +1389,31 @@ class tm_writer {
     write_digit2_separated(buf, to_unsigned(tm_mon() + 1),
                            to_unsigned(tm_mday()),
                            to_unsigned(split_year_lower(tm_year())), '/');
-    out_ = copy_str<Char>(std::begin(buf), std::end(buf), out_);
+    out_ = copy<Char>(std::begin(buf), std::end(buf), out_);
   }
   void on_iso_date() {
     auto year = tm_year();
     char buf[10];
     size_t offset = 0;
     if (year >= 0 && year < 10000) {
-      copy2(buf, digits2(static_cast<size_t>(year / 100)));
+      write2digits(buf, static_cast<size_t>(year / 100));
     } else {
       offset = 4;
-      write_year_extended(year);
+      write_year_extended(year, pad_type::zero);
       year = 0;
     }
     write_digit2_separated(buf + 2, static_cast<unsigned>(year % 100),
                            to_unsigned(tm_mon() + 1), to_unsigned(tm_mday()),
                            '-');
-    out_ = copy_str<Char>(std::begin(buf) + offset, std::end(buf), out_);
+    out_ = copy<Char>(std::begin(buf) + offset, std::end(buf), out_);
   }
 
   void on_utc_offset(numeric_system ns) { format_utc_offset_impl(tm_, ns); }
   void on_tz_name() { format_tz_name_impl(tm_); }
 
-  void on_year(numeric_system ns) {
+  void on_year(numeric_system ns, pad_type pad) {
     if (is_classic_ || ns == numeric_system::standard)
-      return write_year(tm_year());
+      return write_year(tm_year(), pad);
     format_localized('Y', 'E');
   }
   void on_short_year(numeric_system ns) {
@@ -1492,56 +1444,57 @@ class tm_writer {
     }
   }
 
-  void on_dec_month(numeric_system ns) {
+  void on_dec_month(numeric_system ns, pad_type pad) {
     if (is_classic_ || ns == numeric_system::standard)
-      return write2(tm_mon() + 1);
+      return write2(tm_mon() + 1, pad);
     format_localized('m', 'O');
   }
 
-  void on_dec0_week_of_year(numeric_system ns) {
+  void on_dec0_week_of_year(numeric_system ns, pad_type pad) {
     if (is_classic_ || ns == numeric_system::standard)
-      return write2((tm_yday() + days_per_week - tm_wday()) / days_per_week);
+      return write2((tm_yday() + days_per_week - tm_wday()) / days_per_week,
+                    pad);
     format_localized('U', 'O');
   }
-  void on_dec1_week_of_year(numeric_system ns) {
+  void on_dec1_week_of_year(numeric_system ns, pad_type pad) {
     if (is_classic_ || ns == numeric_system::standard) {
       auto wday = tm_wday();
       write2((tm_yday() + days_per_week -
               (wday == 0 ? (days_per_week - 1) : (wday - 1))) /
-             days_per_week);
+                 days_per_week,
+             pad);
     } else {
       format_localized('W', 'O');
     }
   }
-  void on_iso_week_of_year(numeric_system ns) {
+  void on_iso_week_of_year(numeric_system ns, pad_type pad) {
     if (is_classic_ || ns == numeric_system::standard)
-      return write2(tm_iso_week_of_year());
+      return write2(tm_iso_week_of_year(), pad);
     format_localized('V', 'O');
   }
 
-  void on_iso_week_based_year() { write_year(tm_iso_week_year()); }
+  void on_iso_week_based_year() {
+    write_year(tm_iso_week_year(), pad_type::zero);
+  }
   void on_iso_week_based_short_year() {
     write2(split_year_lower(tm_iso_week_year()));
   }
 
-  void on_day_of_year() {
+  void on_day_of_year(pad_type pad) {
     auto yday = tm_yday() + 1;
-    write1(yday / 100);
-    write2(yday % 100);
-  }
-  void on_day_of_month(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard) return write2(tm_mday());
-    format_localized('d', 'O');
-  }
-  void on_day_of_month_space(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard) {
-      auto mday = to_unsigned(tm_mday()) % 100;
-      const char* d2 = digits2(mday);
-      *out_++ = mday < 10 ? ' ' : d2[0];
-      *out_++ = d2[1];
+    auto digit1 = yday / 100;
+    if (digit1 != 0) {
+      write1(digit1);
     } else {
-      format_localized('e', 'O');
+      out_ = detail::write_padding(out_, pad);
     }
+    write2(yday % 100, pad);
+  }
+
+  void on_day_of_month(numeric_system ns, pad_type pad) {
+    if (is_classic_ || ns == numeric_system::standard)
+      return write2(tm_mday(), pad);
+    format_localized('d', 'O');
   }
 
   void on_24_hour(numeric_system ns, pad_type pad) {
@@ -1569,7 +1522,7 @@ class tm_writer {
           write_floating_seconds(buf, *subsecs_);
           if (buf.size() > 1) {
             // Remove the leading "0", write something like ".123".
-            out_ = std::copy(buf.begin() + 1, buf.end(), out_);
+            out_ = copy<Char>(buf.begin() + 1, buf.end(), out_);
           }
         } else {
           write_fractional_seconds<Char>(out_, *subsecs_);
@@ -1586,7 +1539,7 @@ class tm_writer {
       char buf[8];
       write_digit2_separated(buf, to_unsigned(tm_hour12()),
                              to_unsigned(tm_min()), to_unsigned(tm_sec()), ':');
-      out_ = copy_str<Char>(std::begin(buf), std::end(buf), out_);
+      out_ = copy<Char>(std::begin(buf), std::end(buf), out_);
       *out_++ = ' ';
       on_am_pm();
     } else {
@@ -1601,7 +1554,7 @@ class tm_writer {
   void on_iso_time() {
     on_24_hour_time();
     *out_++ = ':';
-    on_second(numeric_system::standard, pad_type::unspecified);
+    on_second(numeric_system::standard, pad_type::zero);
   }
 
   void on_am_pm() {
@@ -1621,11 +1574,11 @@ class tm_writer {
 struct chrono_format_checker : null_chrono_spec_handler<chrono_format_checker> {
   bool has_precision_integral = false;
 
-  FMT_NORETURN void unsupported() { FMT_THROW(format_error("no date")); }
+  FMT_NORETURN inline void unsupported() { FMT_THROW(format_error("no date")); }
 
   template <typename Char>
   FMT_CONSTEXPR void on_text(const Char*, const Char*) {}
-  FMT_CONSTEXPR void on_day_of_year() {}
+  FMT_CONSTEXPR void on_day_of_year(pad_type) {}
   FMT_CONSTEXPR void on_24_hour(numeric_system, pad_type) {}
   FMT_CONSTEXPR void on_12_hour(numeric_system, pad_type) {}
   FMT_CONSTEXPR void on_minute(numeric_system, pad_type) {}
@@ -1635,9 +1588,8 @@ struct chrono_format_checker : null_chrono_spec_handler<chrono_format_checker> {
   FMT_CONSTEXPR void on_iso_time() {}
   FMT_CONSTEXPR void on_am_pm() {}
   FMT_CONSTEXPR void on_duration_value() const {
-    if (has_precision_integral) {
+    if (has_precision_integral)
       FMT_THROW(format_error("precision not allowed for this argument type"));
-    }
   }
   FMT_CONSTEXPR void on_duration_unit() {}
 };
@@ -1677,17 +1629,17 @@ inline auto get_milliseconds(std::chrono::duration<Rep, Period> d)
 #if FMT_SAFE_DURATION_CAST
   using CommonSecondsType =
       typename std::common_type<decltype(d), std::chrono::seconds>::type;
-  const auto d_as_common = fmt_duration_cast<CommonSecondsType>(d);
+  const auto d_as_common = detail::duration_cast<CommonSecondsType>(d);
   const auto d_as_whole_seconds =
-      fmt_duration_cast<std::chrono::seconds>(d_as_common);
+      detail::duration_cast<std::chrono::seconds>(d_as_common);
   // this conversion should be nonproblematic
   const auto diff = d_as_common - d_as_whole_seconds;
   const auto ms =
-      fmt_duration_cast<std::chrono::duration<Rep, std::milli>>(diff);
+      detail::duration_cast<std::chrono::duration<Rep, std::milli>>(diff);
   return ms;
 #else
-  auto s = fmt_duration_cast<std::chrono::seconds>(d);
-  return fmt_duration_cast<std::chrono::milliseconds>(d - s);
+  auto s = detail::duration_cast<std::chrono::seconds>(d);
+  return detail::duration_cast<std::chrono::milliseconds>(d - s);
 #endif
 }
 
@@ -1700,16 +1652,16 @@ auto format_duration_value(OutputIt out, Rep val, int) -> OutputIt {
 template <typename Char, typename Rep, typename OutputIt,
           FMT_ENABLE_IF(std::is_floating_point<Rep>::value)>
 auto format_duration_value(OutputIt out, Rep val, int precision) -> OutputIt {
-  auto specs = format_specs<Char>();
+  auto specs = format_specs();
   specs.precision = precision;
-  specs.type = precision >= 0 ? presentation_type::fixed_lower
-                              : presentation_type::general_lower;
+  specs.set_type(precision >= 0 ? presentation_type::fixed
+                                : presentation_type::general);
   return write<Char>(out, val, specs);
 }
 
 template <typename Char, typename OutputIt>
 auto copy_unit(string_view unit, OutputIt out, Char) -> OutputIt {
-  return std::copy(unit.begin(), unit.end(), out);
+  return copy<Char>(unit.begin(), unit.end(), out);
 }
 
 template <typename OutputIt>
@@ -1717,7 +1669,7 @@ auto copy_unit(string_view unit, OutputIt out, wchar_t) -> OutputIt {
   // This works when wchar_t is UTF-32 because units only contain characters
   // that have the same representation in UTF-16 and UTF-32.
   utf8_to_utf16 u(unit);
-  return std::copy(u.c_str(), u.c_str() + u.size(), out);
+  return copy<wchar_t>(u.c_str(), u.c_str() + u.size(), out);
 }
 
 template <typename Char, typename Period, typename OutputIt>
@@ -1743,14 +1695,14 @@ class get_locale {
   bool has_locale_ = false;
 
  public:
-  get_locale(bool localized, locale_ref loc) : has_locale_(localized) {
+  inline get_locale(bool localized, locale_ref loc) : has_locale_(localized) {
     if (localized)
       ::new (&locale_) std::locale(loc.template get<std::locale>());
   }
-  ~get_locale() {
+  inline ~get_locale() {
     if (has_locale_) locale_.~locale();
   }
-  operator const std::locale&() const {
+  inline operator const std::locale&() const {
     return has_locale_ ? locale_ : get_classic_locale();
   }
 };
@@ -1789,7 +1741,7 @@ struct chrono_formatter {
     // this may overflow and/or the result may not fit in the
     // target type.
     // might need checked conversion (rep!=Rep)
-    s = fmt_duration_cast<seconds>(std::chrono::duration<rep, Period>(val));
+    s = detail::duration_cast<seconds>(std::chrono::duration<rep, Period>(val));
   }
 
   // returns true if nan or inf, writes to out.
@@ -1840,7 +1792,7 @@ struct chrono_formatter {
     }
   }
 
-  void write(Rep value, int width, pad_type pad = pad_type::unspecified) {
+  void write(Rep value, int width, pad_type pad = pad_type::zero) {
     write_sign();
     if (isnan(value)) return write_nan();
     uint32_or_64_or_128_t<int> n =
@@ -1849,7 +1801,7 @@ struct chrono_formatter {
     if (width > num_digits) {
       out = detail::write_padding(out, pad, width - num_digits);
     }
-    out = format_decimal<char_type>(out, n, num_digits).end;
+    out = format_decimal<char_type>(out, n, num_digits);
   }
 
   void write_nan() { std::copy_n("nan", 3, out); }
@@ -1866,7 +1818,7 @@ struct chrono_formatter {
   }
 
   void on_text(const char_type* begin, const char_type* end) {
-    std::copy(begin, end, out);
+    copy<char_type>(begin, end, out);
   }
 
   // These are not implemented because durations don't have date information.
@@ -1883,20 +1835,19 @@ struct chrono_formatter {
   void on_iso_date() {}
   void on_utc_offset(numeric_system) {}
   void on_tz_name() {}
-  void on_year(numeric_system) {}
+  void on_year(numeric_system, pad_type) {}
   void on_short_year(numeric_system) {}
   void on_offset_year() {}
   void on_century(numeric_system) {}
   void on_iso_week_based_year() {}
   void on_iso_week_based_short_year() {}
-  void on_dec_month(numeric_system) {}
-  void on_dec0_week_of_year(numeric_system) {}
-  void on_dec1_week_of_year(numeric_system) {}
-  void on_iso_week_of_year(numeric_system) {}
-  void on_day_of_month(numeric_system) {}
-  void on_day_of_month_space(numeric_system) {}
-
-  void on_day_of_year() {
+  void on_dec_month(numeric_system, pad_type) {}
+  void on_dec0_week_of_year(numeric_system, pad_type) {}
+  void on_dec1_week_of_year(numeric_system, pad_type) {}
+  void on_iso_week_of_year(numeric_system, pad_type) {}
+  void on_day_of_month(numeric_system, pad_type) {}
+
+  void on_day_of_year(pad_type) {
     if (handle_nan_inf()) return;
     write(days(), 0);
   }
@@ -1940,7 +1891,7 @@ struct chrono_formatter {
         if (buf.size() < 2 || buf[1] == '.') {
           out = detail::write_padding(out, pad);
         }
-        out = std::copy(buf.begin(), buf.end(), out);
+        out = copy<char_type>(buf.begin(), buf.end(), out);
       } else {
         write(second(), 2, pad);
         write_fractional_seconds<char_type>(
@@ -1974,7 +1925,7 @@ struct chrono_formatter {
     on_24_hour_time();
     *out++ = ':';
     if (handle_nan_inf()) return;
-    on_second(numeric_system::standard, pad_type::unspecified);
+    on_second(numeric_system::standard, pad_type::zero);
   }
 
   void on_am_pm() {
@@ -1997,82 +1948,240 @@ struct chrono_formatter {
 
 #if defined(__cpp_lib_chrono) && __cpp_lib_chrono >= 201907
 using weekday = std::chrono::weekday;
+using day = std::chrono::day;
+using month = std::chrono::month;
+using year = std::chrono::year;
+using year_month_day = std::chrono::year_month_day;
 #else
 // A fallback version of weekday.
 class weekday {
  private:
-  unsigned char value;
+  unsigned char value_;
 
  public:
   weekday() = default;
-  explicit constexpr weekday(unsigned wd) noexcept
-      : value(static_cast<unsigned char>(wd != 7 ? wd : 0)) {}
-  constexpr auto c_encoding() const noexcept -> unsigned { return value; }
+  constexpr explicit weekday(unsigned wd) noexcept
+      : value_(static_cast<unsigned char>(wd != 7 ? wd : 0)) {}
+  constexpr auto c_encoding() const noexcept -> unsigned { return value_; }
+};
+
+class day {
+ private:
+  unsigned char value_;
+
+ public:
+  day() = default;
+  constexpr explicit day(unsigned d) noexcept
+      : value_(static_cast<unsigned char>(d)) {}
+  constexpr explicit operator unsigned() const noexcept { return value_; }
 };
 
-class year_month_day {};
+class month {
+ private:
+  unsigned char value_;
+
+ public:
+  month() = default;
+  constexpr explicit month(unsigned m) noexcept
+      : value_(static_cast<unsigned char>(m)) {}
+  constexpr explicit operator unsigned() const noexcept { return value_; }
+};
+
+class year {
+ private:
+  int value_;
+
+ public:
+  year() = default;
+  constexpr explicit year(int y) noexcept : value_(y) {}
+  constexpr explicit operator int() const noexcept { return value_; }
+};
+
+class year_month_day {
+ private:
+  fmt::year year_;
+  fmt::month month_;
+  fmt::day day_;
+
+ public:
+  year_month_day() = default;
+  constexpr year_month_day(const year& y, const month& m, const day& d) noexcept
+      : year_(y), month_(m), day_(d) {}
+  constexpr auto year() const noexcept -> fmt::year { return year_; }
+  constexpr auto month() const noexcept -> fmt::month { return month_; }
+  constexpr auto day() const noexcept -> fmt::day { return day_; }
+};
 #endif
 
-// A rudimentary weekday formatter.
-template <typename Char> struct formatter<weekday, Char> {
+template <typename Char>
+struct formatter<weekday, Char> : private formatter<std::tm, Char> {
  private:
-  bool localized = false;
+  bool localized_ = false;
+  bool use_tm_formatter_ = false;
 
  public:
-  FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)
-      -> decltype(ctx.begin()) {
-    auto begin = ctx.begin(), end = ctx.end();
-    if (begin != end && *begin == 'L') {
-      ++begin;
-      localized = true;
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) -> const Char* {
+    auto it = ctx.begin(), end = ctx.end();
+    if (it != end && *it == 'L') {
+      ++it;
+      localized_ = true;
+      return it;
     }
-    return begin;
+    use_tm_formatter_ = it != end && *it != '}';
+    return use_tm_formatter_ ? formatter<std::tm, Char>::parse(ctx) : it;
   }
 
   template <typename FormatContext>
   auto format(weekday wd, FormatContext& ctx) const -> decltype(ctx.out()) {
     auto time = std::tm();
     time.tm_wday = static_cast<int>(wd.c_encoding());
-    detail::get_locale loc(localized, ctx.locale());
+    if (use_tm_formatter_) return formatter<std::tm, Char>::format(time, ctx);
+    detail::get_locale loc(localized_, ctx.locale());
     auto w = detail::tm_writer<decltype(ctx.out()), Char>(loc, ctx.out(), time);
     w.on_abbr_weekday();
     return w.out();
   }
 };
 
+template <typename Char>
+struct formatter<day, Char> : private formatter<std::tm, Char> {
+ private:
+  bool use_tm_formatter_ = false;
+
+ public:
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) -> const Char* {
+    auto it = ctx.begin(), end = ctx.end();
+    use_tm_formatter_ = it != end && *it != '}';
+    return use_tm_formatter_ ? formatter<std::tm, Char>::parse(ctx) : it;
+  }
+
+  template <typename FormatContext>
+  auto format(day d, FormatContext& ctx) const -> decltype(ctx.out()) {
+    auto time = std::tm();
+    time.tm_mday = static_cast<int>(static_cast<unsigned>(d));
+    if (use_tm_formatter_) return formatter<std::tm, Char>::format(time, ctx);
+    detail::get_locale loc(false, ctx.locale());
+    auto w = detail::tm_writer<decltype(ctx.out()), Char>(loc, ctx.out(), time);
+    w.on_day_of_month(detail::numeric_system::standard, detail::pad_type::zero);
+    return w.out();
+  }
+};
+
+template <typename Char>
+struct formatter<month, Char> : private formatter<std::tm, Char> {
+ private:
+  bool localized_ = false;
+  bool use_tm_formatter_ = false;
+
+ public:
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) -> const Char* {
+    auto it = ctx.begin(), end = ctx.end();
+    if (it != end && *it == 'L') {
+      ++it;
+      localized_ = true;
+      return it;
+    }
+    use_tm_formatter_ = it != end && *it != '}';
+    return use_tm_formatter_ ? formatter<std::tm, Char>::parse(ctx) : it;
+  }
+
+  template <typename FormatContext>
+  auto format(month m, FormatContext& ctx) const -> decltype(ctx.out()) {
+    auto time = std::tm();
+    time.tm_mon = static_cast<int>(static_cast<unsigned>(m)) - 1;
+    if (use_tm_formatter_) return formatter<std::tm, Char>::format(time, ctx);
+    detail::get_locale loc(localized_, ctx.locale());
+    auto w = detail::tm_writer<decltype(ctx.out()), Char>(loc, ctx.out(), time);
+    w.on_abbr_month();
+    return w.out();
+  }
+};
+
+template <typename Char>
+struct formatter<year, Char> : private formatter<std::tm, Char> {
+ private:
+  bool use_tm_formatter_ = false;
+
+ public:
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) -> const Char* {
+    auto it = ctx.begin(), end = ctx.end();
+    use_tm_formatter_ = it != end && *it != '}';
+    return use_tm_formatter_ ? formatter<std::tm, Char>::parse(ctx) : it;
+  }
+
+  template <typename FormatContext>
+  auto format(year y, FormatContext& ctx) const -> decltype(ctx.out()) {
+    auto time = std::tm();
+    time.tm_year = static_cast<int>(y) - 1900;
+    if (use_tm_formatter_) return formatter<std::tm, Char>::format(time, ctx);
+    detail::get_locale loc(false, ctx.locale());
+    auto w = detail::tm_writer<decltype(ctx.out()), Char>(loc, ctx.out(), time);
+    w.on_year(detail::numeric_system::standard, detail::pad_type::zero);
+    return w.out();
+  }
+};
+
+template <typename Char>
+struct formatter<year_month_day, Char> : private formatter<std::tm, Char> {
+ private:
+  bool use_tm_formatter_ = false;
+
+ public:
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) -> const Char* {
+    auto it = ctx.begin(), end = ctx.end();
+    use_tm_formatter_ = it != end && *it != '}';
+    return use_tm_formatter_ ? formatter<std::tm, Char>::parse(ctx) : it;
+  }
+
+  template <typename FormatContext>
+  auto format(year_month_day val, FormatContext& ctx) const
+      -> decltype(ctx.out()) {
+    auto time = std::tm();
+    time.tm_year = static_cast<int>(val.year()) - 1900;
+    time.tm_mon = static_cast<int>(static_cast<unsigned>(val.month())) - 1;
+    time.tm_mday = static_cast<int>(static_cast<unsigned>(val.day()));
+    if (use_tm_formatter_) return formatter<std::tm, Char>::format(time, ctx);
+    detail::get_locale loc(true, ctx.locale());
+    auto w = detail::tm_writer<decltype(ctx.out()), Char>(loc, ctx.out(), time);
+    w.on_iso_date();
+    return w.out();
+  }
+};
+
 template <typename Rep, typename Period, typename Char>
 struct formatter<std::chrono::duration<Rep, Period>, Char> {
  private:
-  format_specs<Char> specs_;
+  format_specs specs_;
   detail::arg_ref<Char> width_ref_;
   detail::arg_ref<Char> precision_ref_;
   bool localized_ = false;
-  basic_string_view<Char> format_str_;
+  basic_string_view<Char> fmt_;
 
  public:
-  FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)
-      -> decltype(ctx.begin()) {
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) -> const Char* {
     auto it = ctx.begin(), end = ctx.end();
     if (it == end || *it == '}') return it;
 
     it = detail::parse_align(it, end, specs_);
     if (it == end) return it;
 
-    it = detail::parse_dynamic_spec(it, end, specs_.width, width_ref_, ctx);
-    if (it == end) return it;
+    Char c = *it;
+    if ((c >= '0' && c <= '9') || c == '{') {
+      it = detail::parse_width(it, end, specs_, width_ref_, ctx);
+      if (it == end) return it;
+    }
 
     auto checker = detail::chrono_format_checker();
     if (*it == '.') {
       checker.has_precision_integral = !std::is_floating_point<Rep>::value;
-      it = detail::parse_precision(it, end, specs_.precision, precision_ref_,
-                                   ctx);
+      it = detail::parse_precision(it, end, specs_, precision_ref_, ctx);
     }
     if (it != end && *it == 'L') {
       localized_ = true;
       ++it;
     }
     end = detail::parse_chrono_format(it, end, checker);
-    format_str_ = {it, detail::to_unsigned(end - it)};
+    fmt_ = {it, detail::to_unsigned(end - it)};
     return end;
   }
 
@@ -2082,15 +2191,15 @@ struct formatter<std::chrono::duration<Rep, Period>, Char> {
     auto specs = specs_;
     auto precision = specs.precision;
     specs.precision = -1;
-    auto begin = format_str_.begin(), end = format_str_.end();
+    auto begin = fmt_.begin(), end = fmt_.end();
     // As a possible future optimization, we could avoid extra copying if width
     // is not specified.
     auto buf = basic_memory_buffer<Char>();
-    auto out = std::back_inserter(buf);
-    detail::handle_dynamic_spec<detail::width_checker>(specs.width, width_ref_,
-                                                       ctx);
-    detail::handle_dynamic_spec<detail::precision_checker>(precision,
-                                                           precision_ref_, ctx);
+    auto out = basic_appender<Char>(buf);
+    detail::handle_dynamic_spec(specs.dynamic_width(), specs.width, width_ref_,
+                                ctx);
+    detail::handle_dynamic_spec(specs.dynamic_precision(), precision,
+                                precision_ref_, ctx);
     if (begin == end || *begin == '}') {
       out = detail::format_duration_value<Char>(out, d.count(), precision);
       detail::format_duration_unit<Char, Period>(out);
@@ -2107,130 +2216,119 @@ struct formatter<std::chrono::duration<Rep, Period>, Char> {
   }
 };
 
-template <typename Char, typename Duration>
-struct formatter<std::chrono::time_point<std::chrono::system_clock, Duration>,
-                 Char> : formatter<std::tm, Char> {
-  FMT_CONSTEXPR formatter() {
-    this->format_str_ = detail::string_literal<Char, '%', 'F', ' ', '%', 'T'>{};
-  }
-
-  template <typename FormatContext>
-  auto format(std::chrono::time_point<std::chrono::system_clock, Duration> val,
-              FormatContext& ctx) const -> decltype(ctx.out()) {
-    using period = typename Duration::period;
-    if (detail::const_check(
-            period::num != 1 || period::den != 1 ||
-            std::is_floating_point<typename Duration::rep>::value)) {
-      const auto epoch = val.time_since_epoch();
-      auto subsecs = detail::fmt_duration_cast<Duration>(
-          epoch - detail::fmt_duration_cast<std::chrono::seconds>(epoch));
-
-      if (subsecs.count() < 0) {
-        auto second =
-            detail::fmt_duration_cast<Duration>(std::chrono::seconds(1));
-        if (epoch.count() < ((Duration::min)() + second).count())
-          FMT_THROW(format_error("duration is too small"));
-        subsecs += second;
-        val -= second;
-      }
-
-      return formatter<std::tm, Char>::do_format(gmtime(val), ctx, &subsecs);
-    }
-
-    return formatter<std::tm, Char>::format(gmtime(val), ctx);
-  }
-};
-
-#if FMT_USE_LOCAL_TIME
-template <typename Char, typename Duration>
-struct formatter<std::chrono::local_time<Duration>, Char>
-    : formatter<std::tm, Char> {
-  FMT_CONSTEXPR formatter() {
-    this->format_str_ = detail::string_literal<Char, '%', 'F', ' ', '%', 'T'>{};
-  }
-
-  template <typename FormatContext>
-  auto format(std::chrono::local_time<Duration> val, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    using period = typename Duration::period;
-    if (period::num != 1 || period::den != 1 ||
-        std::is_floating_point<typename Duration::rep>::value) {
-      const auto epoch = val.time_since_epoch();
-      const auto subsecs = detail::fmt_duration_cast<Duration>(
-          epoch - detail::fmt_duration_cast<std::chrono::seconds>(epoch));
-
-      return formatter<std::tm, Char>::do_format(localtime(val), ctx, &subsecs);
-    }
-
-    return formatter<std::tm, Char>::format(localtime(val), ctx);
-  }
-};
-#endif
-
-#if FMT_USE_UTC_TIME
-template <typename Char, typename Duration>
-struct formatter<std::chrono::time_point<std::chrono::utc_clock, Duration>,
-                 Char>
-    : formatter<std::chrono::time_point<std::chrono::system_clock, Duration>,
-                Char> {
-  template <typename FormatContext>
-  auto format(std::chrono::time_point<std::chrono::utc_clock, Duration> val,
-              FormatContext& ctx) const -> decltype(ctx.out()) {
-    return formatter<
-        std::chrono::time_point<std::chrono::system_clock, Duration>,
-        Char>::format(std::chrono::utc_clock::to_sys(val), ctx);
-  }
-};
-#endif
-
 template <typename Char> struct formatter<std::tm, Char> {
  private:
-  format_specs<Char> specs_;
+  format_specs specs_;
   detail::arg_ref<Char> width_ref_;
 
  protected:
-  basic_string_view<Char> format_str_;
+  basic_string_view<Char> fmt_;
 
-  template <typename FormatContext, typename Duration>
+  template <typename Duration, typename FormatContext>
   auto do_format(const std::tm& tm, FormatContext& ctx,
                  const Duration* subsecs) const -> decltype(ctx.out()) {
     auto specs = specs_;
     auto buf = basic_memory_buffer<Char>();
-    auto out = std::back_inserter(buf);
-    detail::handle_dynamic_spec<detail::width_checker>(specs.width, width_ref_,
-                                                       ctx);
+    auto out = basic_appender<Char>(buf);
+    detail::handle_dynamic_spec(specs.dynamic_width(), specs.width, width_ref_,
+                                ctx);
 
     auto loc_ref = ctx.locale();
     detail::get_locale loc(static_cast<bool>(loc_ref), loc_ref);
     auto w =
         detail::tm_writer<decltype(out), Char, Duration>(loc, out, tm, subsecs);
-    detail::parse_chrono_format(format_str_.begin(), format_str_.end(), w);
+    detail::parse_chrono_format(fmt_.begin(), fmt_.end(), w);
     return detail::write(
         ctx.out(), basic_string_view<Char>(buf.data(), buf.size()), specs);
   }
 
  public:
-  FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)
-      -> decltype(ctx.begin()) {
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) -> const Char* {
     auto it = ctx.begin(), end = ctx.end();
     if (it == end || *it == '}') return it;
 
     it = detail::parse_align(it, end, specs_);
     if (it == end) return it;
 
-    it = detail::parse_dynamic_spec(it, end, specs_.width, width_ref_, ctx);
-    if (it == end) return it;
+    Char c = *it;
+    if ((c >= '0' && c <= '9') || c == '{') {
+      it = detail::parse_width(it, end, specs_, width_ref_, ctx);
+      if (it == end) return it;
+    }
 
     end = detail::parse_chrono_format(it, end, detail::tm_format_checker());
-    // Replace the default format_str only if the new spec is not empty.
-    if (end != it) format_str_ = {it, detail::to_unsigned(end - it)};
+    // Replace the default format string only if the new spec is not empty.
+    if (end != it) fmt_ = {it, detail::to_unsigned(end - it)};
     return end;
   }
 
   template <typename FormatContext>
   auto format(const std::tm& tm, FormatContext& ctx) const
       -> decltype(ctx.out()) {
-    return do_format<FormatContext, std::chrono::seconds>(tm, ctx, nullptr);
+    return do_format<std::chrono::seconds>(tm, ctx, nullptr);
+  }
+};
+
+template <typename Char, typename Duration>
+struct formatter<sys_time<Duration>, Char> : formatter<std::tm, Char> {
+  FMT_CONSTEXPR formatter() {
+    this->fmt_ = detail::string_literal<Char, '%', 'F', ' ', '%', 'T'>();
+  }
+
+  template <typename FormatContext>
+  auto format(sys_time<Duration> val, FormatContext& ctx) const
+      -> decltype(ctx.out()) {
+    std::tm tm = gmtime(val);
+    using period = typename Duration::period;
+    if (detail::const_check(
+            period::num == 1 && period::den == 1 &&
+            !std::is_floating_point<typename Duration::rep>::value)) {
+      return formatter<std::tm, Char>::format(tm, ctx);
+    }
+    Duration epoch = val.time_since_epoch();
+    Duration subsecs = detail::duration_cast<Duration>(
+        epoch - detail::duration_cast<std::chrono::seconds>(epoch));
+    if (subsecs.count() < 0) {
+      auto second = detail::duration_cast<Duration>(std::chrono::seconds(1));
+      if (tm.tm_sec != 0)
+        --tm.tm_sec;
+      else
+        tm = gmtime(val - second);
+      subsecs += detail::duration_cast<Duration>(std::chrono::seconds(1));
+    }
+    return formatter<std::tm, Char>::do_format(tm, ctx, &subsecs);
+  }
+};
+
+template <typename Duration, typename Char>
+struct formatter<utc_time<Duration>, Char>
+    : formatter<sys_time<Duration>, Char> {
+  template <typename FormatContext>
+  auto format(utc_time<Duration> val, FormatContext& ctx) const
+      -> decltype(ctx.out()) {
+    return formatter<sys_time<Duration>, Char>::format(
+        detail::utc_clock::to_sys(val), ctx);
+  }
+};
+
+template <typename Duration, typename Char>
+struct formatter<local_time<Duration>, Char> : formatter<std::tm, Char> {
+  FMT_CONSTEXPR formatter() {
+    this->fmt_ = detail::string_literal<Char, '%', 'F', ' ', '%', 'T'>();
+  }
+
+  template <typename FormatContext>
+  auto format(local_time<Duration> val, FormatContext& ctx) const
+      -> decltype(ctx.out()) {
+    using period = typename Duration::period;
+    if (period::num == 1 && period::den == 1 &&
+        !std::is_floating_point<typename Duration::rep>::value) {
+      return formatter<std::tm, Char>::format(localtime(val), ctx);
+    }
+    auto epoch = val.time_since_epoch();
+    auto subsecs = detail::duration_cast<Duration>(
+        epoch - detail::duration_cast<std::chrono::seconds>(epoch));
+    return formatter<std::tm, Char>::do_format(localtime(val), ctx, &subsecs);
   }
 };
 
diff --git a/3rdparty/fmt/include/fmt/color.h b/3rdparty/fmt/include/fmt/color.h
index 367849a86a7c0..2faaf3a067a64 100644
--- a/3rdparty/fmt/include/fmt/color.h
+++ b/3rdparty/fmt/include/fmt/color.h
@@ -227,7 +227,7 @@ struct color_type {
 };
 }  // namespace detail
 
-/** A text style consisting of foreground and background colors and emphasis. */
+/// A text style consisting of foreground and background colors and emphasis.
 class text_style {
  public:
   FMT_CONSTEXPR text_style(emphasis em = emphasis()) noexcept
@@ -239,7 +239,7 @@ class text_style {
       foreground_color = rhs.foreground_color;
     } else if (rhs.set_foreground_color) {
       if (!foreground_color.is_rgb || !rhs.foreground_color.is_rgb)
-        FMT_THROW(format_error("can't OR a terminal color"));
+        report_error("can't OR a terminal color");
       foreground_color.value.rgb_color |= rhs.foreground_color.value.rgb_color;
     }
 
@@ -248,7 +248,7 @@ class text_style {
       background_color = rhs.background_color;
     } else if (rhs.set_background_color) {
       if (!background_color.is_rgb || !rhs.background_color.is_rgb)
-        FMT_THROW(format_error("can't OR a terminal color"));
+        report_error("can't OR a terminal color");
       background_color.value.rgb_color |= rhs.background_color.value.rgb_color;
     }
 
@@ -310,13 +310,13 @@ class text_style {
   emphasis ems;
 };
 
-/** Creates a text style from the foreground (text) color. */
+/// Creates a text style from the foreground (text) color.
 FMT_CONSTEXPR inline auto fg(detail::color_type foreground) noexcept
     -> text_style {
   return text_style(true, foreground);
 }
 
-/** Creates a text style from the background color. */
+/// Creates a text style from the background color.
 FMT_CONSTEXPR inline auto bg(detail::color_type background) noexcept
     -> text_style {
   return text_style(false, background);
@@ -330,7 +330,7 @@ FMT_CONSTEXPR inline auto operator|(emphasis lhs, emphasis rhs) noexcept
 namespace detail {
 
 template <typename Char> struct ansi_color_escape {
-  FMT_CONSTEXPR ansi_color_escape(detail::color_type text_color,
+  FMT_CONSTEXPR ansi_color_escape(color_type text_color,
                                   const char* esc) noexcept {
     // If we have a terminal color, we need to output another escape code
     // sequence.
@@ -390,8 +390,8 @@ template <typename Char> struct ansi_color_escape {
   FMT_CONSTEXPR operator const Char*() const noexcept { return buffer; }
 
   FMT_CONSTEXPR auto begin() const noexcept -> const Char* { return buffer; }
-  FMT_CONSTEXPR_CHAR_TRAITS auto end() const noexcept -> const Char* {
-    return buffer + std::char_traits<Char>::length(buffer);
+  FMT_CONSTEXPR20 auto end() const noexcept -> const Char* {
+    return buffer + basic_string_view<Char>(buffer).size();
   }
 
  private:
@@ -412,13 +412,13 @@ template <typename Char> struct ansi_color_escape {
 };
 
 template <typename Char>
-FMT_CONSTEXPR auto make_foreground_color(detail::color_type foreground) noexcept
+FMT_CONSTEXPR auto make_foreground_color(color_type foreground) noexcept
     -> ansi_color_escape<Char> {
   return ansi_color_escape<Char>(foreground, "\x1b[38;2;");
 }
 
 template <typename Char>
-FMT_CONSTEXPR auto make_background_color(detail::color_type background) noexcept
+FMT_CONSTEXPR auto make_background_color(color_type background) noexcept
     -> ansi_color_escape<Char> {
   return ansi_color_escape<Char>(background, "\x1b[48;2;");
 }
@@ -434,7 +434,7 @@ template <typename Char> inline void reset_color(buffer<Char>& buffer) {
   buffer.append(reset_color.begin(), reset_color.end());
 }
 
-template <typename T> struct styled_arg : detail::view {
+template <typename T> struct styled_arg : view {
   const T& value;
   text_style style;
   styled_arg(const T& v, text_style s) : value(v), style(s) {}
@@ -442,145 +442,115 @@ template <typename T> struct styled_arg : detail::view {
 
 template <typename Char>
 void vformat_to(buffer<Char>& buf, const text_style& ts,
-                basic_string_view<Char> format_str,
-                basic_format_args<buffer_context<type_identity_t<Char>>> args) {
+                basic_string_view<Char> fmt,
+                basic_format_args<buffered_context<Char>> args) {
   bool has_style = false;
   if (ts.has_emphasis()) {
     has_style = true;
-    auto emphasis = detail::make_emphasis<Char>(ts.get_emphasis());
+    auto emphasis = make_emphasis<Char>(ts.get_emphasis());
     buf.append(emphasis.begin(), emphasis.end());
   }
   if (ts.has_foreground()) {
     has_style = true;
-    auto foreground = detail::make_foreground_color<Char>(ts.get_foreground());
+    auto foreground = make_foreground_color<Char>(ts.get_foreground());
     buf.append(foreground.begin(), foreground.end());
   }
   if (ts.has_background()) {
     has_style = true;
-    auto background = detail::make_background_color<Char>(ts.get_background());
+    auto background = make_background_color<Char>(ts.get_background());
     buf.append(background.begin(), background.end());
   }
-  detail::vformat_to(buf, format_str, args, {});
-  if (has_style) detail::reset_color<Char>(buf);
+  vformat_to(buf, fmt, args);
+  if (has_style) reset_color<Char>(buf);
 }
-
 }  // namespace detail
 
-inline void vprint(std::FILE* f, const text_style& ts, string_view fmt,
+inline void vprint(FILE* f, const text_style& ts, string_view fmt,
                    format_args args) {
-  // Legacy wide streams are not supported.
   auto buf = memory_buffer();
   detail::vformat_to(buf, ts, fmt, args);
-  if (detail::is_utf8()) {
-    detail::print(f, string_view(buf.begin(), buf.size()));
-    return;
-  }
-  buf.push_back('\0');
-  int result = std::fputs(buf.data(), f);
-  if (result < 0)
-    FMT_THROW(system_error(errno, FMT_STRING("cannot write to file")));
+  print(f, FMT_STRING("{}"), string_view(buf.begin(), buf.size()));
 }
 
 /**
-  \rst
-  Formats a string and prints it to the specified file stream using ANSI
-  escape sequences to specify text formatting.
-
-  **Example**::
-
-    fmt::print(fmt::emphasis::bold | fg(fmt::color::red),
-               "Elapsed time: {0:.2f} seconds", 1.23);
-  \endrst
+ * Formats a string and prints it to the specified file stream using ANSI
+ * escape sequences to specify text formatting.
+ *
+ * **Example**:
+ *
+ *     fmt::print(fmt::emphasis::bold | fg(fmt::color::red),
+ *                "Elapsed time: {0:.2f} seconds", 1.23);
  */
-template <typename S, typename... Args,
-          FMT_ENABLE_IF(detail::is_string<S>::value)>
-void print(std::FILE* f, const text_style& ts, const S& format_str,
-           const Args&... args) {
-  vprint(f, ts, format_str,
-         fmt::make_format_args<buffer_context<char_t<S>>>(args...));
+template <typename... T>
+void print(FILE* f, const text_style& ts, format_string<T...> fmt,
+           T&&... args) {
+  vprint(f, ts, fmt.str, vargs<T...>{{args...}});
 }
 
 /**
-  \rst
-  Formats a string and prints it to stdout using ANSI escape sequences to
-  specify text formatting.
-
-  **Example**::
-
-    fmt::print(fmt::emphasis::bold | fg(fmt::color::red),
-               "Elapsed time: {0:.2f} seconds", 1.23);
-  \endrst
+ * Formats a string and prints it to stdout using ANSI escape sequences to
+ * specify text formatting.
+ *
+ * **Example**:
+ *
+ *     fmt::print(fmt::emphasis::bold | fg(fmt::color::red),
+ *                "Elapsed time: {0:.2f} seconds", 1.23);
  */
-template <typename S, typename... Args,
-          FMT_ENABLE_IF(detail::is_string<S>::value)>
-void print(const text_style& ts, const S& format_str, const Args&... args) {
-  return print(stdout, ts, format_str, args...);
+template <typename... T>
+void print(const text_style& ts, format_string<T...> fmt, T&&... args) {
+  return print(stdout, ts, fmt, std::forward<T>(args)...);
 }
 
-template <typename S, typename Char = char_t<S>>
-inline auto vformat(
-    const text_style& ts, const S& format_str,
-    basic_format_args<buffer_context<type_identity_t<Char>>> args)
-    -> std::basic_string<Char> {
-  basic_memory_buffer<Char> buf;
-  detail::vformat_to(buf, ts, detail::to_string_view(format_str), args);
+inline auto vformat(const text_style& ts, string_view fmt, format_args args)
+    -> std::string {
+  auto buf = memory_buffer();
+  detail::vformat_to(buf, ts, fmt, args);
   return fmt::to_string(buf);
 }
 
 /**
-  \rst
-  Formats arguments and returns the result as a string using ANSI
-  escape sequences to specify text formatting.
-
-  **Example**::
-
-    #include <fmt/color.h>
-    std::string message = fmt::format(fmt::emphasis::bold | fg(fmt::color::red),
-                                      "The answer is {}", 42);
-  \endrst
-*/
-template <typename S, typename... Args, typename Char = char_t<S>>
-inline auto format(const text_style& ts, const S& format_str,
-                   const Args&... args) -> std::basic_string<Char> {
-  return fmt::vformat(ts, detail::to_string_view(format_str),
-                      fmt::make_format_args<buffer_context<Char>>(args...));
+ * Formats arguments and returns the result as a string using ANSI escape
+ * sequences to specify text formatting.
+ *
+ * **Example**:
+ *
+ * ```
+ * #include <fmt/color.h>
+ * std::string message = fmt::format(fmt::emphasis::bold | fg(fmt::color::red),
+ *                                   "The answer is {}", 42);
+ * ```
+ */
+template <typename... T>
+inline auto format(const text_style& ts, format_string<T...> fmt, T&&... args)
+    -> std::string {
+  return fmt::vformat(ts, fmt.str, vargs<T...>{{args...}});
 }
 
-/**
-  Formats a string with the given text_style and writes the output to ``out``.
- */
-template <typename OutputIt, typename Char,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value)>
-auto vformat_to(OutputIt out, const text_style& ts,
-                basic_string_view<Char> format_str,
-                basic_format_args<buffer_context<type_identity_t<Char>>> args)
-    -> OutputIt {
-  auto&& buf = detail::get_buffer<Char>(out);
-  detail::vformat_to(buf, ts, format_str, args);
+/// Formats a string with the given text_style and writes the output to `out`.
+template <typename OutputIt,
+          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
+auto vformat_to(OutputIt out, const text_style& ts, string_view fmt,
+                format_args args) -> OutputIt {
+  auto&& buf = detail::get_buffer<char>(out);
+  detail::vformat_to(buf, ts, fmt, args);
   return detail::get_iterator(buf, out);
 }
 
 /**
-  \rst
-  Formats arguments with the given text_style, writes the result to the output
-  iterator ``out`` and returns the iterator past the end of the output range.
-
-  **Example**::
-
-    std::vector<char> out;
-    fmt::format_to(std::back_inserter(out),
-                   fmt::emphasis::bold | fg(fmt::color::red), "{}", 42);
-  \endrst
-*/
-template <
-    typename OutputIt, typename S, typename... Args,
-    bool enable = detail::is_output_iterator<OutputIt, char_t<S>>::value &&
-                  detail::is_string<S>::value>
-inline auto format_to(OutputIt out, const text_style& ts, const S& format_str,
-                      Args&&... args) ->
-    typename std::enable_if<enable, OutputIt>::type {
-  return vformat_to(out, ts, detail::to_string_view(format_str),
-                    fmt::make_format_args<buffer_context<char_t<S>>>(args...));
+ * Formats arguments with the given text style, writes the result to the output
+ * iterator `out` and returns the iterator past the end of the output range.
+ *
+ * **Example**:
+ *
+ *     std::vector<char> out;
+ *     fmt::format_to(std::back_inserter(out),
+ *                    fmt::emphasis::bold | fg(fmt::color::red), "{}", 42);
+ */
+template <typename OutputIt, typename... T,
+          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
+inline auto format_to(OutputIt out, const text_style& ts,
+                      format_string<T...> fmt, T&&... args) -> OutputIt {
+  return vformat_to(out, ts, fmt.str, vargs<T...>{{args...}});
 }
 
 template <typename T, typename Char>
@@ -589,47 +559,44 @@ struct formatter<detail::styled_arg<T>, Char> : formatter<T, Char> {
   auto format(const detail::styled_arg<T>& arg, FormatContext& ctx) const
       -> decltype(ctx.out()) {
     const auto& ts = arg.style;
-    const auto& value = arg.value;
     auto out = ctx.out();
 
     bool has_style = false;
     if (ts.has_emphasis()) {
       has_style = true;
       auto emphasis = detail::make_emphasis<Char>(ts.get_emphasis());
-      out = std::copy(emphasis.begin(), emphasis.end(), out);
+      out = detail::copy<Char>(emphasis.begin(), emphasis.end(), out);
     }
     if (ts.has_foreground()) {
       has_style = true;
       auto foreground =
           detail::make_foreground_color<Char>(ts.get_foreground());
-      out = std::copy(foreground.begin(), foreground.end(), out);
+      out = detail::copy<Char>(foreground.begin(), foreground.end(), out);
     }
     if (ts.has_background()) {
       has_style = true;
       auto background =
           detail::make_background_color<Char>(ts.get_background());
-      out = std::copy(background.begin(), background.end(), out);
+      out = detail::copy<Char>(background.begin(), background.end(), out);
     }
-    out = formatter<T, Char>::format(value, ctx);
+    out = formatter<T, Char>::format(arg.value, ctx);
     if (has_style) {
       auto reset_color = string_view("\x1b[0m");
-      out = std::copy(reset_color.begin(), reset_color.end(), out);
+      out = detail::copy<Char>(reset_color.begin(), reset_color.end(), out);
     }
     return out;
   }
 };
 
 /**
-  \rst
-  Returns an argument that will be formatted using ANSI escape sequences,
-  to be used in a formatting function.
-
-  **Example**::
-
-    fmt::print("Elapsed time: {0:.2f} seconds",
-               fmt::styled(1.23, fmt::fg(fmt::color::green) |
-                                 fmt::bg(fmt::color::blue)));
-  \endrst
+ * Returns an argument that will be formatted using ANSI escape sequences,
+ * to be used in a formatting function.
+ *
+ * **Example**:
+ *
+ *     fmt::print("Elapsed time: {0:.2f} seconds",
+ *                fmt::styled(1.23, fmt::fg(fmt::color::green) |
+ *                                  fmt::bg(fmt::color::blue)));
  */
 template <typename T>
 FMT_CONSTEXPR auto styled(const T& value, text_style ts)
diff --git a/3rdparty/fmt/include/fmt/compile.h b/3rdparty/fmt/include/fmt/compile.h
index 3b3f166e0cd0c..68b451c71d9c0 100644
--- a/3rdparty/fmt/include/fmt/compile.h
+++ b/3rdparty/fmt/include/fmt/compile.h
@@ -8,49 +8,44 @@
 #ifndef FMT_COMPILE_H_
 #define FMT_COMPILE_H_
 
+#ifndef FMT_MODULE
+#  include <iterator>  // std::back_inserter
+#endif
+
 #include "format.h"
 
 FMT_BEGIN_NAMESPACE
-namespace detail {
-
-template <typename Char, typename InputIt>
-FMT_CONSTEXPR inline auto copy_str(InputIt begin, InputIt end,
-                                   counting_iterator it) -> counting_iterator {
-  return it + (end - begin);
-}
 
 // A compile-time string which is compiled into fast formatting code.
-class compiled_string {};
+FMT_EXPORT class compiled_string {};
+
+namespace detail {
 
 template <typename S>
 struct is_compiled_string : std::is_base_of<compiled_string, S> {};
 
 /**
-  \rst
-  Converts a string literal *s* into a format string that will be parsed at
-  compile time and converted into efficient formatting code. Requires C++17
-  ``constexpr if`` compiler support.
-
-  **Example**::
-
-    // Converts 42 into std::string using the most efficient method and no
-    // runtime format string processing.
-    std::string s = fmt::format(FMT_COMPILE("{}"), 42);
-  \endrst
+ * Converts a string literal `s` into a format string that will be parsed at
+ * compile time and converted into efficient formatting code. Requires C++17
+ * `constexpr if` compiler support.
+ *
+ * **Example**:
+ *
+ *     // Converts 42 into std::string using the most efficient method and no
+ *     // runtime format string processing.
+ *     std::string s = fmt::format(FMT_COMPILE("{}"), 42);
  */
 #if defined(__cpp_if_constexpr) && defined(__cpp_return_type_deduction)
-#  define FMT_COMPILE(s) \
-    FMT_STRING_IMPL(s, fmt::detail::compiled_string, explicit)
+#  define FMT_COMPILE(s) FMT_STRING_IMPL(s, fmt::compiled_string)
 #else
 #  define FMT_COMPILE(s) FMT_STRING(s)
 #endif
 
 #if FMT_USE_NONTYPE_TEMPLATE_ARGS
-template <typename Char, size_t N,
-          fmt::detail_exported::fixed_string<Char, N> Str>
+template <typename Char, size_t N, fmt::detail::fixed_string<Char, N> Str>
 struct udl_compiled_string : compiled_string {
   using char_type = Char;
-  explicit constexpr operator basic_string_view<char_type>() const {
+  constexpr explicit operator basic_string_view<char_type>() const {
     return {Str.data, N - 1};
   }
 };
@@ -75,6 +70,29 @@ constexpr const auto& get([[maybe_unused]] const T& first,
     return detail::get<N - 1>(rest...);
 }
 
+#  if FMT_USE_NONTYPE_TEMPLATE_ARGS
+template <int N, typename T, typename... Args, typename Char>
+constexpr auto get_arg_index_by_name(basic_string_view<Char> name) -> int {
+  if constexpr (is_static_named_arg<T>()) {
+    if (name == T::name) return N;
+  }
+  if constexpr (sizeof...(Args) > 0)
+    return get_arg_index_by_name<N + 1, Args...>(name);
+  (void)name;  // Workaround an MSVC bug about "unused" parameter.
+  return -1;
+}
+#  endif
+
+template <typename... Args, typename Char>
+FMT_CONSTEXPR auto get_arg_index_by_name(basic_string_view<Char> name) -> int {
+#  if FMT_USE_NONTYPE_TEMPLATE_ARGS
+  if constexpr (sizeof...(Args) > 0)
+    return get_arg_index_by_name<0, Args...>(name);
+#  endif
+  (void)name;
+  return -1;
+}
+
 template <typename Char, typename... Args>
 constexpr int get_arg_index_by_name(basic_string_view<Char> name,
                                     type_list<Args...>) {
@@ -144,11 +162,12 @@ template <typename Char, typename T, int N> struct field {
   template <typename OutputIt, typename... Args>
   constexpr OutputIt format(OutputIt out, const Args&... args) const {
     const T& arg = get_arg_checked<T, N>(args...);
-    if constexpr (std::is_convertible_v<T, basic_string_view<Char>>) {
+    if constexpr (std::is_convertible<T, basic_string_view<Char>>::value) {
       auto s = basic_string_view<Char>(arg);
-      return copy_str<Char>(s.begin(), s.end(), out);
+      return copy<Char>(s.begin(), s.end(), out);
+    } else {
+      return write<Char>(out, arg);
     }
-    return write<Char>(out, arg);
   }
 };
 
@@ -236,13 +255,12 @@ constexpr size_t parse_text(basic_string_view<Char> str, size_t pos) {
 }
 
 template <typename Args, size_t POS, int ID, typename S>
-constexpr auto compile_format_string(S format_str);
+constexpr auto compile_format_string(S fmt);
 
 template <typename Args, size_t POS, int ID, typename T, typename S>
-constexpr auto parse_tail(T head, S format_str) {
-  if constexpr (POS !=
-                basic_string_view<typename S::char_type>(format_str).size()) {
-    constexpr auto tail = compile_format_string<Args, POS, ID>(format_str);
+constexpr auto parse_tail(T head, S fmt) {
+  if constexpr (POS != basic_string_view<typename S::char_type>(fmt).size()) {
+    constexpr auto tail = compile_format_string<Args, POS, ID>(fmt);
     if constexpr (std::is_same<remove_cvref_t<decltype(tail)>,
                                unknown_format>())
       return tail;
@@ -274,6 +292,7 @@ constexpr parse_specs_result<T, Char> parse_specs(basic_string_view<Char> str,
 }
 
 template <typename Char> struct arg_id_handler {
+  arg_id_kind kind;
   arg_ref<Char> arg_id;
 
   constexpr int on_auto() {
@@ -281,25 +300,28 @@ template <typename Char> struct arg_id_handler {
     return 0;
   }
   constexpr int on_index(int id) {
+    kind = arg_id_kind::index;
     arg_id = arg_ref<Char>(id);
     return 0;
   }
   constexpr int on_name(basic_string_view<Char> id) {
+    kind = arg_id_kind::name;
     arg_id = arg_ref<Char>(id);
     return 0;
   }
 };
 
 template <typename Char> struct parse_arg_id_result {
+  arg_id_kind kind;
   arg_ref<Char> arg_id;
   const Char* arg_id_end;
 };
 
 template <int ID, typename Char>
 constexpr auto parse_arg_id(const Char* begin, const Char* end) {
-  auto handler = arg_id_handler<Char>{arg_ref<Char>{}};
+  auto handler = arg_id_handler<Char>{arg_id_kind::none, arg_ref<Char>{}};
   auto arg_id_end = parse_arg_id(begin, end, handler);
-  return parse_arg_id_result<Char>{handler.arg_id, arg_id_end};
+  return parse_arg_id_result<Char>{handler.kind, handler.arg_id, arg_id_end};
 }
 
 template <typename T, typename Enable = void> struct field_type {
@@ -313,14 +335,13 @@ struct field_type<T, enable_if_t<detail::is_named_arg<T>::value>> {
 
 template <typename T, typename Args, size_t END_POS, int ARG_INDEX, int NEXT_ID,
           typename S>
-constexpr auto parse_replacement_field_then_tail(S format_str) {
+constexpr auto parse_replacement_field_then_tail(S fmt) {
   using char_type = typename S::char_type;
-  constexpr auto str = basic_string_view<char_type>(format_str);
+  constexpr auto str = basic_string_view<char_type>(fmt);
   constexpr char_type c = END_POS != str.size() ? str[END_POS] : char_type();
   if constexpr (c == '}') {
     return parse_tail<Args, END_POS + 1, NEXT_ID>(
-        field<char_type, typename field_type<T>::type, ARG_INDEX>(),
-        format_str);
+        field<char_type, typename field_type<T>::type, ARG_INDEX>(), fmt);
   } else if constexpr (c != ':') {
     FMT_THROW(format_error("expected ':'"));
   } else {
@@ -333,7 +354,7 @@ constexpr auto parse_replacement_field_then_tail(S format_str) {
       return parse_tail<Args, result.end + 1, result.next_arg_id>(
           spec_field<char_type, typename field_type<T>::type, ARG_INDEX>{
               result.fmt},
-          format_str);
+          fmt);
     }
   }
 }
@@ -341,22 +362,21 @@ constexpr auto parse_replacement_field_then_tail(S format_str) {
 // Compiles a non-empty format string and returns the compiled representation
 // or unknown_format() on unrecognized input.
 template <typename Args, size_t POS, int ID, typename S>
-constexpr auto compile_format_string(S format_str) {
+constexpr auto compile_format_string(S fmt) {
   using char_type = typename S::char_type;
-  constexpr auto str = basic_string_view<char_type>(format_str);
+  constexpr auto str = basic_string_view<char_type>(fmt);
   if constexpr (str[POS] == '{') {
     if constexpr (POS + 1 == str.size())
       FMT_THROW(format_error("unmatched '{' in format string"));
     if constexpr (str[POS + 1] == '{') {
-      return parse_tail<Args, POS + 2, ID>(make_text(str, POS, 1), format_str);
+      return parse_tail<Args, POS + 2, ID>(make_text(str, POS, 1), fmt);
     } else if constexpr (str[POS + 1] == '}' || str[POS + 1] == ':') {
       static_assert(ID != manual_indexing_id,
                     "cannot switch from manual to automatic argument indexing");
       constexpr auto next_id =
           ID != manual_indexing_id ? ID + 1 : manual_indexing_id;
       return parse_replacement_field_then_tail<get_type<ID, Args>, Args,
-                                               POS + 1, ID, next_id>(
-          format_str);
+                                               POS + 1, ID, next_id>(fmt);
     } else {
       constexpr auto arg_id_result =
           parse_arg_id<ID>(str.data() + POS + 1, str.data() + str.size());
@@ -364,28 +384,27 @@ constexpr auto compile_format_string(S format_str) {
       constexpr char_type c =
           arg_id_end_pos != str.size() ? str[arg_id_end_pos] : char_type();
       static_assert(c == '}' || c == ':', "missing '}' in format string");
-      if constexpr (arg_id_result.arg_id.kind == arg_id_kind::index) {
+      if constexpr (arg_id_result.kind == arg_id_kind::index) {
         static_assert(
             ID == manual_indexing_id || ID == 0,
             "cannot switch from automatic to manual argument indexing");
-        constexpr auto arg_index = arg_id_result.arg_id.val.index;
+        constexpr auto arg_index = arg_id_result.arg_id.index;
         return parse_replacement_field_then_tail<get_type<arg_index, Args>,
                                                  Args, arg_id_end_pos,
                                                  arg_index, manual_indexing_id>(
-            format_str);
-      } else if constexpr (arg_id_result.arg_id.kind == arg_id_kind::name) {
+            fmt);
+      } else if constexpr (arg_id_result.kind == arg_id_kind::name) {
         constexpr auto arg_index =
-            get_arg_index_by_name(arg_id_result.arg_id.val.name, Args{});
+            get_arg_index_by_name(arg_id_result.arg_id.name, Args{});
         if constexpr (arg_index >= 0) {
           constexpr auto next_id =
               ID != manual_indexing_id ? ID + 1 : manual_indexing_id;
           return parse_replacement_field_then_tail<
               decltype(get_type<arg_index, Args>::value), Args, arg_id_end_pos,
-              arg_index, next_id>(format_str);
+              arg_index, next_id>(fmt);
         } else if constexpr (c == '}') {
           return parse_tail<Args, arg_id_end_pos + 1, ID>(
-              runtime_named_field<char_type>{arg_id_result.arg_id.val.name},
-              format_str);
+              runtime_named_field<char_type>{arg_id_result.arg_id.name}, fmt);
         } else if constexpr (c == ':') {
           return unknown_format();  // no type info for specs parsing
         }
@@ -394,29 +413,26 @@ constexpr auto compile_format_string(S format_str) {
   } else if constexpr (str[POS] == '}') {
     if constexpr (POS + 1 == str.size())
       FMT_THROW(format_error("unmatched '}' in format string"));
-    return parse_tail<Args, POS + 2, ID>(make_text(str, POS, 1), format_str);
+    return parse_tail<Args, POS + 2, ID>(make_text(str, POS, 1), fmt);
   } else {
     constexpr auto end = parse_text(str, POS + 1);
     if constexpr (end - POS > 1) {
-      return parse_tail<Args, end, ID>(make_text(str, POS, end - POS),
-                                       format_str);
+      return parse_tail<Args, end, ID>(make_text(str, POS, end - POS), fmt);
     } else {
-      return parse_tail<Args, end, ID>(code_unit<char_type>{str[POS]},
-                                       format_str);
+      return parse_tail<Args, end, ID>(code_unit<char_type>{str[POS]}, fmt);
     }
   }
 }
 
 template <typename... Args, typename S,
           FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
-constexpr auto compile(S format_str) {
-  constexpr auto str = basic_string_view<typename S::char_type>(format_str);
+constexpr auto compile(S fmt) {
+  constexpr auto str = basic_string_view<typename S::char_type>(fmt);
   if constexpr (str.size() == 0) {
     return detail::make_text(str, 0, 0);
   } else {
     constexpr auto result =
-        detail::compile_format_string<detail::type_list<Args...>, 0, 0>(
-            format_str);
+        detail::compile_format_string<detail::type_list<Args...>, 0, 0>(fmt);
     return result;
   }
 }
@@ -488,40 +504,40 @@ FMT_CONSTEXPR OutputIt format_to(OutputIt out, const S&, Args&&... args) {
 
 template <typename OutputIt, typename S, typename... Args,
           FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
-auto format_to_n(OutputIt out, size_t n, const S& format_str, Args&&... args)
+auto format_to_n(OutputIt out, size_t n, const S& fmt, Args&&... args)
     -> format_to_n_result<OutputIt> {
   using traits = detail::fixed_buffer_traits;
   auto buf = detail::iterator_buffer<OutputIt, char, traits>(out, n);
-  fmt::format_to(std::back_inserter(buf), format_str,
-                 std::forward<Args>(args)...);
+  fmt::format_to(std::back_inserter(buf), fmt, std::forward<Args>(args)...);
   return {buf.out(), buf.count()};
 }
 
 template <typename S, typename... Args,
           FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
-FMT_CONSTEXPR20 auto formatted_size(const S& format_str, const Args&... args)
+FMT_CONSTEXPR20 auto formatted_size(const S& fmt, const Args&... args)
     -> size_t {
-  return fmt::format_to(detail::counting_iterator(), format_str, args...)
-      .count();
+  auto buf = detail::counting_buffer<>();
+  fmt::format_to(appender(buf), fmt, args...);
+  return buf.count();
 }
 
 template <typename S, typename... Args,
           FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
-void print(std::FILE* f, const S& format_str, const Args&... args) {
-  memory_buffer buffer;
-  fmt::format_to(std::back_inserter(buffer), format_str, args...);
-  detail::print(f, {buffer.data(), buffer.size()});
+void print(std::FILE* f, const S& fmt, const Args&... args) {
+  auto buf = memory_buffer();
+  fmt::format_to(appender(buf), fmt, args...);
+  detail::print(f, {buf.data(), buf.size()});
 }
 
 template <typename S, typename... Args,
           FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
-void print(const S& format_str, const Args&... args) {
-  print(stdout, format_str, args...);
+void print(const S& fmt, const Args&... args) {
+  print(stdout, fmt, args...);
 }
 
 #if FMT_USE_NONTYPE_TEMPLATE_ARGS
 inline namespace literals {
-template <detail_exported::fixed_string Str> constexpr auto operator""_cf() {
+template <detail::fixed_string Str> constexpr auto operator""_cf() {
   using char_t = remove_cvref_t<decltype(Str.data[0])>;
   return detail::udl_compiled_string<char_t, sizeof(Str.data) / sizeof(char_t),
                                      Str>();
diff --git a/3rdparty/fmt/include/fmt/core.h b/3rdparty/fmt/include/fmt/core.h
index b51c1406a9907..8ca735f0c0049 100644
--- a/3rdparty/fmt/include/fmt/core.h
+++ b/3rdparty/fmt/include/fmt/core.h
@@ -1,2969 +1,5 @@
-// Formatting library for C++ - the core API for char/UTF-8
-//
-// Copyright (c) 2012 - present, Victor Zverovich
-// All rights reserved.
-//
-// For the license information refer to format.h.
+// This file is only provided for compatibility and may be removed in future
+// versions. Use fmt/base.h if you don't need fmt::format and fmt/format.h
+// otherwise.
 
-#ifndef FMT_CORE_H_
-#define FMT_CORE_H_
-
-#include <cstddef>  // std::byte
-#include <cstdio>   // std::FILE
-#include <cstring>  // std::strlen
-#include <iterator>
-#include <limits>
-#include <memory>  // std::addressof
-#include <string>
-#include <type_traits>
-
-// The fmt library version in the form major * 10000 + minor * 100 + patch.
-#define FMT_VERSION 100201
-
-#if defined(__clang__) && !defined(__ibmxl__)
-#  define FMT_CLANG_VERSION (__clang_major__ * 100 + __clang_minor__)
-#else
-#  define FMT_CLANG_VERSION 0
-#endif
-
-#if defined(__GNUC__) && !defined(__clang__) && !defined(__INTEL_COMPILER) && \
-    !defined(__NVCOMPILER)
-#  define FMT_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
-#else
-#  define FMT_GCC_VERSION 0
-#endif
-
-#ifndef FMT_GCC_PRAGMA
-// Workaround _Pragma bug https://gcc.gnu.org/bugzilla/show_bug.cgi?id=59884.
-#  if FMT_GCC_VERSION >= 504
-#    define FMT_GCC_PRAGMA(arg) _Pragma(arg)
-#  else
-#    define FMT_GCC_PRAGMA(arg)
-#  endif
-#endif
-
-#ifdef __ICL
-#  define FMT_ICC_VERSION __ICL
-#elif defined(__INTEL_COMPILER)
-#  define FMT_ICC_VERSION __INTEL_COMPILER
-#else
-#  define FMT_ICC_VERSION 0
-#endif
-
-#ifdef _MSC_VER
-#  define FMT_MSC_VERSION _MSC_VER
-#  define FMT_MSC_WARNING(...) __pragma(warning(__VA_ARGS__))
-#else
-#  define FMT_MSC_VERSION 0
-#  define FMT_MSC_WARNING(...)
-#endif
-
-#ifdef _MSVC_LANG
-#  define FMT_CPLUSPLUS _MSVC_LANG
-#else
-#  define FMT_CPLUSPLUS __cplusplus
-#endif
-
-#ifdef __has_feature
-#  define FMT_HAS_FEATURE(x) __has_feature(x)
-#else
-#  define FMT_HAS_FEATURE(x) 0
-#endif
-
-#if defined(__has_include) || FMT_ICC_VERSION >= 1600 || FMT_MSC_VERSION > 1900
-#  define FMT_HAS_INCLUDE(x) __has_include(x)
-#else
-#  define FMT_HAS_INCLUDE(x) 0
-#endif
-
-#ifdef __has_cpp_attribute
-#  define FMT_HAS_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)
-#else
-#  define FMT_HAS_CPP_ATTRIBUTE(x) 0
-#endif
-
-#define FMT_HAS_CPP14_ATTRIBUTE(attribute) \
-  (FMT_CPLUSPLUS >= 201402L && FMT_HAS_CPP_ATTRIBUTE(attribute))
-
-#define FMT_HAS_CPP17_ATTRIBUTE(attribute) \
-  (FMT_CPLUSPLUS >= 201703L && FMT_HAS_CPP_ATTRIBUTE(attribute))
-
-// Check if relaxed C++14 constexpr is supported.
-// GCC doesn't allow throw in constexpr until version 6 (bug 67371).
-#ifndef FMT_USE_CONSTEXPR
-#  if (FMT_HAS_FEATURE(cxx_relaxed_constexpr) || FMT_MSC_VERSION >= 1912 || \
-       (FMT_GCC_VERSION >= 600 && FMT_CPLUSPLUS >= 201402L)) &&             \
-      !FMT_ICC_VERSION && (!defined(__NVCC__) || FMT_CPLUSPLUS >= 202002L)
-#    define FMT_USE_CONSTEXPR 1
-#  else
-#    define FMT_USE_CONSTEXPR 0
-#  endif
-#endif
-#if FMT_USE_CONSTEXPR
-#  define FMT_CONSTEXPR constexpr
-#else
-#  define FMT_CONSTEXPR
-#endif
-
-#if (FMT_CPLUSPLUS >= 202002L ||                                \
-     (FMT_CPLUSPLUS >= 201709L && FMT_GCC_VERSION >= 1002)) &&  \
-    ((!defined(_GLIBCXX_RELEASE) || _GLIBCXX_RELEASE >= 10) &&  \
-     (!defined(_LIBCPP_VERSION) || _LIBCPP_VERSION >= 10000) && \
-     (!FMT_MSC_VERSION || FMT_MSC_VERSION >= 1928)) &&          \
-    defined(__cpp_lib_is_constant_evaluated)
-#  define FMT_CONSTEXPR20 constexpr
-#else
-#  define FMT_CONSTEXPR20
-#endif
-
-// Check if constexpr std::char_traits<>::{compare,length} are supported.
-#if defined(__GLIBCXX__)
-#  if FMT_CPLUSPLUS >= 201703L && defined(_GLIBCXX_RELEASE) && \
-      _GLIBCXX_RELEASE >= 7  // GCC 7+ libstdc++ has _GLIBCXX_RELEASE.
-#    define FMT_CONSTEXPR_CHAR_TRAITS constexpr
-#  endif
-#elif defined(_LIBCPP_VERSION) && FMT_CPLUSPLUS >= 201703L && \
-    _LIBCPP_VERSION >= 4000
-#  define FMT_CONSTEXPR_CHAR_TRAITS constexpr
-#elif FMT_MSC_VERSION >= 1914 && FMT_CPLUSPLUS >= 201703L
-#  define FMT_CONSTEXPR_CHAR_TRAITS constexpr
-#endif
-#ifndef FMT_CONSTEXPR_CHAR_TRAITS
-#  define FMT_CONSTEXPR_CHAR_TRAITS
-#endif
-
-// Check if exceptions are disabled.
-#ifndef FMT_EXCEPTIONS
-#  if (defined(__GNUC__) && !defined(__EXCEPTIONS)) || \
-      (FMT_MSC_VERSION && !_HAS_EXCEPTIONS)
-#    define FMT_EXCEPTIONS 0
-#  else
-#    define FMT_EXCEPTIONS 1
-#  endif
-#endif
-
-// Disable [[noreturn]] on MSVC/NVCC because of bogus unreachable code warnings.
-#if FMT_EXCEPTIONS && FMT_HAS_CPP_ATTRIBUTE(noreturn) && !FMT_MSC_VERSION && \
-    !defined(__NVCC__)
-#  define FMT_NORETURN [[noreturn]]
-#else
-#  define FMT_NORETURN
-#endif
-
-#ifndef FMT_NODISCARD
-#  if FMT_HAS_CPP17_ATTRIBUTE(nodiscard)
-#    define FMT_NODISCARD [[nodiscard]]
-#  else
-#    define FMT_NODISCARD
-#  endif
-#endif
-
-#ifndef FMT_INLINE
-#  if FMT_GCC_VERSION || FMT_CLANG_VERSION
-#    define FMT_INLINE inline __attribute__((always_inline))
-#  else
-#    define FMT_INLINE inline
-#  endif
-#endif
-
-#ifdef _MSC_VER
-#  define FMT_UNCHECKED_ITERATOR(It) \
-    using _Unchecked_type = It  // Mark iterator as checked.
-#else
-#  define FMT_UNCHECKED_ITERATOR(It) using unchecked_type = It
-#endif
-
-#ifndef FMT_BEGIN_NAMESPACE
-#  define FMT_BEGIN_NAMESPACE \
-    namespace fmt {           \
-    inline namespace v10 {
-#  define FMT_END_NAMESPACE \
-    }                       \
-    }
-#endif
-
-#ifndef FMT_EXPORT
-#  define FMT_EXPORT
-#  define FMT_BEGIN_EXPORT
-#  define FMT_END_EXPORT
-#endif
-
-#if FMT_GCC_VERSION || FMT_CLANG_VERSION
-#  define FMT_VISIBILITY(value) __attribute__((visibility(value)))
-#else
-#  define FMT_VISIBILITY(value)
-#endif
-
-#if !defined(FMT_HEADER_ONLY) && defined(_WIN32)
-#  if defined(FMT_LIB_EXPORT)
-#    define FMT_API __declspec(dllexport)
-#  elif defined(FMT_SHARED)
-#    define FMT_API __declspec(dllimport)
-#  endif
-#elif defined(FMT_LIB_EXPORT) || defined(FMT_SHARED)
-#  define FMT_API FMT_VISIBILITY("default")
-#endif
-#ifndef FMT_API
-#  define FMT_API
-#endif
-
-// libc++ supports string_view in pre-c++17.
-#if FMT_HAS_INCLUDE(<string_view>) && \
-    (FMT_CPLUSPLUS >= 201703L || defined(_LIBCPP_VERSION))
-#  include <string_view>
-#  define FMT_USE_STRING_VIEW
-#elif FMT_HAS_INCLUDE("experimental/string_view") && FMT_CPLUSPLUS >= 201402L
-#  include <experimental/string_view>
-#  define FMT_USE_EXPERIMENTAL_STRING_VIEW
-#endif
-
-#ifndef FMT_UNICODE
-#  define FMT_UNICODE !FMT_MSC_VERSION
-#endif
-
-#ifndef FMT_CONSTEVAL
-#  if ((FMT_GCC_VERSION >= 1000 || FMT_CLANG_VERSION >= 1101) && \
-       (!defined(__apple_build_version__) ||                     \
-        __apple_build_version__ >= 14000029L) &&                 \
-       FMT_CPLUSPLUS >= 202002L) ||                              \
-      (defined(__cpp_consteval) &&                               \
-       (!FMT_MSC_VERSION || FMT_MSC_VERSION >= 1929))
-// consteval is broken in MSVC before VS2019 version 16.10 and Apple clang
-// before 14.
-#    define FMT_CONSTEVAL consteval
-#    define FMT_HAS_CONSTEVAL
-#  else
-#    define FMT_CONSTEVAL
-#  endif
-#endif
-
-#ifndef FMT_USE_NONTYPE_TEMPLATE_ARGS
-#  if defined(__cpp_nontype_template_args) &&                  \
-      ((FMT_GCC_VERSION >= 903 && FMT_CPLUSPLUS >= 201709L) || \
-       __cpp_nontype_template_args >= 201911L) &&              \
-      !defined(__NVCOMPILER) && !defined(__LCC__)
-#    define FMT_USE_NONTYPE_TEMPLATE_ARGS 1
-#  else
-#    define FMT_USE_NONTYPE_TEMPLATE_ARGS 0
-#  endif
-#endif
-
-// GCC < 5 requires this-> in decltype
-#ifndef FMT_DECLTYPE_THIS
-#  if FMT_GCC_VERSION && FMT_GCC_VERSION < 500
-#    define FMT_DECLTYPE_THIS this->
-#  else
-#    define FMT_DECLTYPE_THIS
-#  endif
-#endif
-
-// Enable minimal optimizations for more compact code in debug mode.
-FMT_GCC_PRAGMA("GCC push_options")
-#if !defined(__OPTIMIZE__) && !defined(__NVCOMPILER) && !defined(__LCC__) && \
-    !defined(__CUDACC__)
-FMT_GCC_PRAGMA("GCC optimize(\"Og\")")
-#endif
-
-FMT_BEGIN_NAMESPACE
-
-// Implementations of enable_if_t and other metafunctions for older systems.
-template <bool B, typename T = void>
-using enable_if_t = typename std::enable_if<B, T>::type;
-template <bool B, typename T, typename F>
-using conditional_t = typename std::conditional<B, T, F>::type;
-template <bool B> using bool_constant = std::integral_constant<bool, B>;
-template <typename T>
-using remove_reference_t = typename std::remove_reference<T>::type;
-template <typename T>
-using remove_const_t = typename std::remove_const<T>::type;
-template <typename T>
-using remove_cvref_t = typename std::remove_cv<remove_reference_t<T>>::type;
-template <typename T> struct type_identity {
-  using type = T;
-};
-template <typename T> using type_identity_t = typename type_identity<T>::type;
-template <typename T>
-using underlying_t = typename std::underlying_type<T>::type;
-
-// Checks whether T is a container with contiguous storage.
-template <typename T> struct is_contiguous : std::false_type {};
-template <typename Char>
-struct is_contiguous<std::basic_string<Char>> : std::true_type {};
-
-struct monostate {
-  constexpr monostate() {}
-};
-
-// An enable_if helper to be used in template parameters which results in much
-// shorter symbols: https://godbolt.org/z/sWw4vP. Extra parentheses are needed
-// to workaround a bug in MSVC 2019 (see #1140 and #1186).
-#ifdef FMT_DOC
-#  define FMT_ENABLE_IF(...)
-#else
-#  define FMT_ENABLE_IF(...) fmt::enable_if_t<(__VA_ARGS__), int> = 0
-#endif
-
-// This is defined in core.h instead of format.h to avoid injecting in std.
-// It is a template to avoid undesirable implicit conversions to std::byte.
-#ifdef __cpp_lib_byte
-template <typename T, FMT_ENABLE_IF(std::is_same<T, std::byte>::value)>
-inline auto format_as(T b) -> unsigned char {
-  return static_cast<unsigned char>(b);
-}
-#endif
-
-namespace detail {
-// Suppresses "unused variable" warnings with the method described in
-// https://herbsutter.com/2009/10/18/mailbag-shutting-up-compiler-warnings/.
-// (void)var does not work on many Intel compilers.
-template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}
-
-constexpr FMT_INLINE auto is_constant_evaluated(
-    bool default_value = false) noexcept -> bool {
-// Workaround for incompatibility between libstdc++ consteval-based
-// std::is_constant_evaluated() implementation and clang-14.
-// https://github.com/fmtlib/fmt/issues/3247
-#if FMT_CPLUSPLUS >= 202002L && defined(_GLIBCXX_RELEASE) && \
-    _GLIBCXX_RELEASE >= 12 &&                                \
-    (FMT_CLANG_VERSION >= 1400 && FMT_CLANG_VERSION < 1500)
-  ignore_unused(default_value);
-  return __builtin_is_constant_evaluated();
-#elif defined(__cpp_lib_is_constant_evaluated)
-  ignore_unused(default_value);
-  return std::is_constant_evaluated();
-#else
-  return default_value;
-#endif
-}
-
-// Suppresses "conditional expression is constant" warnings.
-template <typename T> constexpr FMT_INLINE auto const_check(T value) -> T {
-  return value;
-}
-
-FMT_NORETURN FMT_API void assert_fail(const char* file, int line,
-                                      const char* message);
-
-#ifndef FMT_ASSERT
-#  ifdef NDEBUG
-// FMT_ASSERT is not empty to avoid -Wempty-body.
-#    define FMT_ASSERT(condition, message) \
-      fmt::detail::ignore_unused((condition), (message))
-#  else
-#    define FMT_ASSERT(condition, message)                                    \
-      ((condition) /* void() fails with -Winvalid-constexpr on clang 4.0.1 */ \
-           ? (void)0                                                          \
-           : fmt::detail::assert_fail(__FILE__, __LINE__, (message)))
-#  endif
-#endif
-
-#if defined(FMT_USE_STRING_VIEW)
-template <typename Char> using std_string_view = std::basic_string_view<Char>;
-#elif defined(FMT_USE_EXPERIMENTAL_STRING_VIEW)
-template <typename Char>
-using std_string_view = std::experimental::basic_string_view<Char>;
-#else
-template <typename T> struct std_string_view {};
-#endif
-
-#ifdef FMT_USE_INT128
-// Do nothing.
-#elif defined(__SIZEOF_INT128__) && !defined(__NVCC__) && \
-    !(FMT_CLANG_VERSION && FMT_MSC_VERSION)
-#  define FMT_USE_INT128 1
-using int128_opt = __int128_t;  // An optional native 128-bit integer.
-using uint128_opt = __uint128_t;
-template <typename T> inline auto convert_for_visit(T value) -> T {
-  return value;
-}
-#else
-#  define FMT_USE_INT128 0
-#endif
-#if !FMT_USE_INT128
-enum class int128_opt {};
-enum class uint128_opt {};
-// Reduce template instantiations.
-template <typename T> auto convert_for_visit(T) -> monostate { return {}; }
-#endif
-
-// Casts a nonnegative integer to unsigned.
-template <typename Int>
-FMT_CONSTEXPR auto to_unsigned(Int value) ->
-    typename std::make_unsigned<Int>::type {
-  FMT_ASSERT(std::is_unsigned<Int>::value || value >= 0, "negative value");
-  return static_cast<typename std::make_unsigned<Int>::type>(value);
-}
-
-FMT_CONSTEXPR inline auto is_utf8() -> bool {
-  FMT_MSC_WARNING(suppress : 4566) constexpr unsigned char section[] = "\u00A7";
-
-  // Avoid buggy sign extensions in MSVC's constant evaluation mode (#2297).
-  using uchar = unsigned char;
-  return FMT_UNICODE || (sizeof(section) == 3 && uchar(section[0]) == 0xC2 &&
-                         uchar(section[1]) == 0xA7);
-}
-}  // namespace detail
-
-/**
-  An implementation of ``std::basic_string_view`` for pre-C++17. It provides a
-  subset of the API. ``fmt::basic_string_view`` is used for format strings even
-  if ``std::string_view`` is available to prevent issues when a library is
-  compiled with a different ``-std`` option than the client code (which is not
-  recommended).
- */
-FMT_EXPORT
-template <typename Char> class basic_string_view {
- private:
-  const Char* data_;
-  size_t size_;
-
- public:
-  using value_type = Char;
-  using iterator = const Char*;
-
-  constexpr basic_string_view() noexcept : data_(nullptr), size_(0) {}
-
-  /** Constructs a string reference object from a C string and a size. */
-  constexpr basic_string_view(const Char* s, size_t count) noexcept
-      : data_(s), size_(count) {}
-
-  /**
-    \rst
-    Constructs a string reference object from a C string computing
-    the size with ``std::char_traits<Char>::length``.
-    \endrst
-   */
-  FMT_CONSTEXPR_CHAR_TRAITS
-  FMT_INLINE
-  basic_string_view(const Char* s)
-      : data_(s),
-        size_(detail::const_check(std::is_same<Char, char>::value &&
-                                  !detail::is_constant_evaluated(true))
-                  ? std::strlen(reinterpret_cast<const char*>(s))
-                  : std::char_traits<Char>::length(s)) {}
-
-  /** Constructs a string reference from a ``std::basic_string`` object. */
-  template <typename Traits, typename Alloc>
-  FMT_CONSTEXPR basic_string_view(
-      const std::basic_string<Char, Traits, Alloc>& s) noexcept
-      : data_(s.data()), size_(s.size()) {}
-
-  template <typename S, FMT_ENABLE_IF(std::is_same<
-                                      S, detail::std_string_view<Char>>::value)>
-  FMT_CONSTEXPR basic_string_view(S s) noexcept
-      : data_(s.data()), size_(s.size()) {}
-
-  /** Returns a pointer to the string data. */
-  constexpr auto data() const noexcept -> const Char* { return data_; }
-
-  /** Returns the string size. */
-  constexpr auto size() const noexcept -> size_t { return size_; }
-
-  constexpr auto begin() const noexcept -> iterator { return data_; }
-  constexpr auto end() const noexcept -> iterator { return data_ + size_; }
-
-  constexpr auto operator[](size_t pos) const noexcept -> const Char& {
-    return data_[pos];
-  }
-
-  FMT_CONSTEXPR void remove_prefix(size_t n) noexcept {
-    data_ += n;
-    size_ -= n;
-  }
-
-  FMT_CONSTEXPR_CHAR_TRAITS auto starts_with(
-      basic_string_view<Char> sv) const noexcept -> bool {
-    return size_ >= sv.size_ &&
-           std::char_traits<Char>::compare(data_, sv.data_, sv.size_) == 0;
-  }
-  FMT_CONSTEXPR_CHAR_TRAITS auto starts_with(Char c) const noexcept -> bool {
-    return size_ >= 1 && std::char_traits<Char>::eq(*data_, c);
-  }
-  FMT_CONSTEXPR_CHAR_TRAITS auto starts_with(const Char* s) const -> bool {
-    return starts_with(basic_string_view<Char>(s));
-  }
-
-  // Lexicographically compare this string reference to other.
-  FMT_CONSTEXPR_CHAR_TRAITS auto compare(basic_string_view other) const -> int {
-    size_t str_size = size_ < other.size_ ? size_ : other.size_;
-    int result = std::char_traits<Char>::compare(data_, other.data_, str_size);
-    if (result == 0)
-      result = size_ == other.size_ ? 0 : (size_ < other.size_ ? -1 : 1);
-    return result;
-  }
-
-  FMT_CONSTEXPR_CHAR_TRAITS friend auto operator==(basic_string_view lhs,
-                                                   basic_string_view rhs)
-      -> bool {
-    return lhs.compare(rhs) == 0;
-  }
-  friend auto operator!=(basic_string_view lhs, basic_string_view rhs) -> bool {
-    return lhs.compare(rhs) != 0;
-  }
-  friend auto operator<(basic_string_view lhs, basic_string_view rhs) -> bool {
-    return lhs.compare(rhs) < 0;
-  }
-  friend auto operator<=(basic_string_view lhs, basic_string_view rhs) -> bool {
-    return lhs.compare(rhs) <= 0;
-  }
-  friend auto operator>(basic_string_view lhs, basic_string_view rhs) -> bool {
-    return lhs.compare(rhs) > 0;
-  }
-  friend auto operator>=(basic_string_view lhs, basic_string_view rhs) -> bool {
-    return lhs.compare(rhs) >= 0;
-  }
-};
-
-FMT_EXPORT
-using string_view = basic_string_view<char>;
-
-/** Specifies if ``T`` is a character type. Can be specialized by users. */
-FMT_EXPORT
-template <typename T> struct is_char : std::false_type {};
-template <> struct is_char<char> : std::true_type {};
-
-namespace detail {
-
-// A base class for compile-time strings.
-struct compile_string {};
-
-template <typename S>
-struct is_compile_string : std::is_base_of<compile_string, S> {};
-
-template <typename Char, FMT_ENABLE_IF(is_char<Char>::value)>
-FMT_INLINE auto to_string_view(const Char* s) -> basic_string_view<Char> {
-  return s;
-}
-template <typename Char, typename Traits, typename Alloc>
-inline auto to_string_view(const std::basic_string<Char, Traits, Alloc>& s)
-    -> basic_string_view<Char> {
-  return s;
-}
-template <typename Char>
-constexpr auto to_string_view(basic_string_view<Char> s)
-    -> basic_string_view<Char> {
-  return s;
-}
-template <typename Char,
-          FMT_ENABLE_IF(!std::is_empty<std_string_view<Char>>::value)>
-inline auto to_string_view(std_string_view<Char> s) -> basic_string_view<Char> {
-  return s;
-}
-template <typename S, FMT_ENABLE_IF(is_compile_string<S>::value)>
-constexpr auto to_string_view(const S& s)
-    -> basic_string_view<typename S::char_type> {
-  return basic_string_view<typename S::char_type>(s);
-}
-void to_string_view(...);
-
-// Specifies whether S is a string type convertible to fmt::basic_string_view.
-// It should be a constexpr function but MSVC 2017 fails to compile it in
-// enable_if and MSVC 2015 fails to compile it as an alias template.
-// ADL is intentionally disabled as to_string_view is not an extension point.
-template <typename S>
-struct is_string
-    : std::is_class<decltype(detail::to_string_view(std::declval<S>()))> {};
-
-template <typename S, typename = void> struct char_t_impl {};
-template <typename S> struct char_t_impl<S, enable_if_t<is_string<S>::value>> {
-  using result = decltype(to_string_view(std::declval<S>()));
-  using type = typename result::value_type;
-};
-
-enum class type {
-  none_type,
-  // Integer types should go first,
-  int_type,
-  uint_type,
-  long_long_type,
-  ulong_long_type,
-  int128_type,
-  uint128_type,
-  bool_type,
-  char_type,
-  last_integer_type = char_type,
-  // followed by floating-point types.
-  float_type,
-  double_type,
-  long_double_type,
-  last_numeric_type = long_double_type,
-  cstring_type,
-  string_type,
-  pointer_type,
-  custom_type
-};
-
-// Maps core type T to the corresponding type enum constant.
-template <typename T, typename Char>
-struct type_constant : std::integral_constant<type, type::custom_type> {};
-
-#define FMT_TYPE_CONSTANT(Type, constant) \
-  template <typename Char>                \
-  struct type_constant<Type, Char>        \
-      : std::integral_constant<type, type::constant> {}
-
-FMT_TYPE_CONSTANT(int, int_type);
-FMT_TYPE_CONSTANT(unsigned, uint_type);
-FMT_TYPE_CONSTANT(long long, long_long_type);
-FMT_TYPE_CONSTANT(unsigned long long, ulong_long_type);
-FMT_TYPE_CONSTANT(int128_opt, int128_type);
-FMT_TYPE_CONSTANT(uint128_opt, uint128_type);
-FMT_TYPE_CONSTANT(bool, bool_type);
-FMT_TYPE_CONSTANT(Char, char_type);
-FMT_TYPE_CONSTANT(float, float_type);
-FMT_TYPE_CONSTANT(double, double_type);
-FMT_TYPE_CONSTANT(long double, long_double_type);
-FMT_TYPE_CONSTANT(const Char*, cstring_type);
-FMT_TYPE_CONSTANT(basic_string_view<Char>, string_type);
-FMT_TYPE_CONSTANT(const void*, pointer_type);
-
-constexpr auto is_integral_type(type t) -> bool {
-  return t > type::none_type && t <= type::last_integer_type;
-}
-constexpr auto is_arithmetic_type(type t) -> bool {
-  return t > type::none_type && t <= type::last_numeric_type;
-}
-
-constexpr auto set(type rhs) -> int { return 1 << static_cast<int>(rhs); }
-constexpr auto in(type t, int set) -> bool {
-  return ((set >> static_cast<int>(t)) & 1) != 0;
-}
-
-// Bitsets of types.
-enum {
-  sint_set =
-      set(type::int_type) | set(type::long_long_type) | set(type::int128_type),
-  uint_set = set(type::uint_type) | set(type::ulong_long_type) |
-             set(type::uint128_type),
-  bool_set = set(type::bool_type),
-  char_set = set(type::char_type),
-  float_set = set(type::float_type) | set(type::double_type) |
-              set(type::long_double_type),
-  string_set = set(type::string_type),
-  cstring_set = set(type::cstring_type),
-  pointer_set = set(type::pointer_type)
-};
-
-// DEPRECATED!
-FMT_NORETURN FMT_API void throw_format_error(const char* message);
-
-struct error_handler {
-  constexpr error_handler() = default;
-
-  // This function is intentionally not constexpr to give a compile-time error.
-  FMT_NORETURN void on_error(const char* message) {
-    throw_format_error(message);
-  }
-};
-}  // namespace detail
-
-/** Throws ``format_error`` with a given message. */
-using detail::throw_format_error;
-
-/** String's character type. */
-template <typename S> using char_t = typename detail::char_t_impl<S>::type;
-
-/**
-  \rst
-  Parsing context consisting of a format string range being parsed and an
-  argument counter for automatic indexing.
-  You can use the ``format_parse_context`` type alias for ``char`` instead.
-  \endrst
- */
-FMT_EXPORT
-template <typename Char> class basic_format_parse_context {
- private:
-  basic_string_view<Char> format_str_;
-  int next_arg_id_;
-
-  FMT_CONSTEXPR void do_check_arg_id(int id);
-
- public:
-  using char_type = Char;
-  using iterator = const Char*;
-
-  explicit constexpr basic_format_parse_context(
-      basic_string_view<Char> format_str, int next_arg_id = 0)
-      : format_str_(format_str), next_arg_id_(next_arg_id) {}
-
-  /**
-    Returns an iterator to the beginning of the format string range being
-    parsed.
-   */
-  constexpr auto begin() const noexcept -> iterator {
-    return format_str_.begin();
-  }
-
-  /**
-    Returns an iterator past the end of the format string range being parsed.
-   */
-  constexpr auto end() const noexcept -> iterator { return format_str_.end(); }
-
-  /** Advances the begin iterator to ``it``. */
-  FMT_CONSTEXPR void advance_to(iterator it) {
-    format_str_.remove_prefix(detail::to_unsigned(it - begin()));
-  }
-
-  /**
-    Reports an error if using the manual argument indexing; otherwise returns
-    the next argument index and switches to the automatic indexing.
-   */
-  FMT_CONSTEXPR auto next_arg_id() -> int {
-    if (next_arg_id_ < 0) {
-      detail::throw_format_error(
-          "cannot switch from manual to automatic argument indexing");
-      return 0;
-    }
-    int id = next_arg_id_++;
-    do_check_arg_id(id);
-    return id;
-  }
-
-  /**
-    Reports an error if using the automatic argument indexing; otherwise
-    switches to the manual indexing.
-   */
-  FMT_CONSTEXPR void check_arg_id(int id) {
-    if (next_arg_id_ > 0) {
-      detail::throw_format_error(
-          "cannot switch from automatic to manual argument indexing");
-      return;
-    }
-    next_arg_id_ = -1;
-    do_check_arg_id(id);
-  }
-  FMT_CONSTEXPR void check_arg_id(basic_string_view<Char>) {}
-  FMT_CONSTEXPR void check_dynamic_spec(int arg_id);
-};
-
-FMT_EXPORT
-using format_parse_context = basic_format_parse_context<char>;
-
-namespace detail {
-// A parse context with extra data used only in compile-time checks.
-template <typename Char>
-class compile_parse_context : public basic_format_parse_context<Char> {
- private:
-  int num_args_;
-  const type* types_;
-  using base = basic_format_parse_context<Char>;
-
- public:
-  explicit FMT_CONSTEXPR compile_parse_context(
-      basic_string_view<Char> format_str, int num_args, const type* types,
-      int next_arg_id = 0)
-      : base(format_str, next_arg_id), num_args_(num_args), types_(types) {}
-
-  constexpr auto num_args() const -> int { return num_args_; }
-  constexpr auto arg_type(int id) const -> type { return types_[id]; }
-
-  FMT_CONSTEXPR auto next_arg_id() -> int {
-    int id = base::next_arg_id();
-    if (id >= num_args_) throw_format_error("argument not found");
-    return id;
-  }
-
-  FMT_CONSTEXPR void check_arg_id(int id) {
-    base::check_arg_id(id);
-    if (id >= num_args_) throw_format_error("argument not found");
-  }
-  using base::check_arg_id;
-
-  FMT_CONSTEXPR void check_dynamic_spec(int arg_id) {
-    detail::ignore_unused(arg_id);
-#if !defined(__LCC__)
-    if (arg_id < num_args_ && types_ && !is_integral_type(types_[arg_id]))
-      throw_format_error("width/precision is not integer");
-#endif
-  }
-};
-
-// Extracts a reference to the container from back_insert_iterator.
-template <typename Container>
-inline auto get_container(std::back_insert_iterator<Container> it)
-    -> Container& {
-  using base = std::back_insert_iterator<Container>;
-  struct accessor : base {
-    accessor(base b) : base(b) {}
-    using base::container;
-  };
-  return *accessor(it).container;
-}
-
-template <typename Char, typename InputIt, typename OutputIt>
-FMT_CONSTEXPR auto copy_str(InputIt begin, InputIt end, OutputIt out)
-    -> OutputIt {
-  while (begin != end) *out++ = static_cast<Char>(*begin++);
-  return out;
-}
-
-template <typename Char, typename T, typename U,
-          FMT_ENABLE_IF(
-              std::is_same<remove_const_t<T>, U>::value&& is_char<U>::value)>
-FMT_CONSTEXPR auto copy_str(T* begin, T* end, U* out) -> U* {
-  if (is_constant_evaluated()) return copy_str<Char, T*, U*>(begin, end, out);
-  auto size = to_unsigned(end - begin);
-  if (size > 0) memcpy(out, begin, size * sizeof(U));
-  return out + size;
-}
-
-/**
-  \rst
-  A contiguous memory buffer with an optional growing ability. It is an internal
-  class and shouldn't be used directly, only via `~fmt::basic_memory_buffer`.
-  \endrst
- */
-template <typename T> class buffer {
- private:
-  T* ptr_;
-  size_t size_;
-  size_t capacity_;
-
- protected:
-  // Don't initialize ptr_ since it is not accessed to save a few cycles.
-  FMT_MSC_WARNING(suppress : 26495)
-  FMT_CONSTEXPR buffer(size_t sz) noexcept : size_(sz), capacity_(sz) {}
-
-  FMT_CONSTEXPR20 buffer(T* p = nullptr, size_t sz = 0, size_t cap = 0) noexcept
-      : ptr_(p), size_(sz), capacity_(cap) {}
-
-  FMT_CONSTEXPR20 ~buffer() = default;
-  buffer(buffer&&) = default;
-
-  /** Sets the buffer data and capacity. */
-  FMT_CONSTEXPR void set(T* buf_data, size_t buf_capacity) noexcept {
-    ptr_ = buf_data;
-    capacity_ = buf_capacity;
-  }
-
-  /** Increases the buffer capacity to hold at least *capacity* elements. */
-  // DEPRECATED!
-  virtual FMT_CONSTEXPR20 void grow(size_t capacity) = 0;
-
- public:
-  using value_type = T;
-  using const_reference = const T&;
-
-  buffer(const buffer&) = delete;
-  void operator=(const buffer&) = delete;
-
-  FMT_INLINE auto begin() noexcept -> T* { return ptr_; }
-  FMT_INLINE auto end() noexcept -> T* { return ptr_ + size_; }
-
-  FMT_INLINE auto begin() const noexcept -> const T* { return ptr_; }
-  FMT_INLINE auto end() const noexcept -> const T* { return ptr_ + size_; }
-
-  /** Returns the size of this buffer. */
-  constexpr auto size() const noexcept -> size_t { return size_; }
-
-  /** Returns the capacity of this buffer. */
-  constexpr auto capacity() const noexcept -> size_t { return capacity_; }
-
-  /** Returns a pointer to the buffer data (not null-terminated). */
-  FMT_CONSTEXPR auto data() noexcept -> T* { return ptr_; }
-  FMT_CONSTEXPR auto data() const noexcept -> const T* { return ptr_; }
-
-  /** Clears this buffer. */
-  void clear() { size_ = 0; }
-
-  // Tries resizing the buffer to contain *count* elements. If T is a POD type
-  // the new elements may not be initialized.
-  FMT_CONSTEXPR20 void try_resize(size_t count) {
-    try_reserve(count);
-    size_ = count <= capacity_ ? count : capacity_;
-  }
-
-  // Tries increasing the buffer capacity to *new_capacity*. It can increase the
-  // capacity by a smaller amount than requested but guarantees there is space
-  // for at least one additional element either by increasing the capacity or by
-  // flushing the buffer if it is full.
-  FMT_CONSTEXPR20 void try_reserve(size_t new_capacity) {
-    if (new_capacity > capacity_) grow(new_capacity);
-  }
-
-  FMT_CONSTEXPR20 void push_back(const T& value) {
-    try_reserve(size_ + 1);
-    ptr_[size_++] = value;
-  }
-
-  /** Appends data to the end of the buffer. */
-  template <typename U> void append(const U* begin, const U* end);
-
-  template <typename Idx> FMT_CONSTEXPR auto operator[](Idx index) -> T& {
-    return ptr_[index];
-  }
-  template <typename Idx>
-  FMT_CONSTEXPR auto operator[](Idx index) const -> const T& {
-    return ptr_[index];
-  }
-};
-
-struct buffer_traits {
-  explicit buffer_traits(size_t) {}
-  auto count() const -> size_t { return 0; }
-  auto limit(size_t size) -> size_t { return size; }
-};
-
-class fixed_buffer_traits {
- private:
-  size_t count_ = 0;
-  size_t limit_;
-
- public:
-  explicit fixed_buffer_traits(size_t limit) : limit_(limit) {}
-  auto count() const -> size_t { return count_; }
-  auto limit(size_t size) -> size_t {
-    size_t n = limit_ > count_ ? limit_ - count_ : 0;
-    count_ += size;
-    return size < n ? size : n;
-  }
-};
-
-// A buffer that writes to an output iterator when flushed.
-template <typename OutputIt, typename T, typename Traits = buffer_traits>
-class iterator_buffer final : public Traits, public buffer<T> {
- private:
-  OutputIt out_;
-  enum { buffer_size = 256 };
-  T data_[buffer_size];
-
- protected:
-  FMT_CONSTEXPR20 void grow(size_t) override {
-    if (this->size() == buffer_size) flush();
-  }
-
-  void flush() {
-    auto size = this->size();
-    this->clear();
-    out_ = copy_str<T>(data_, data_ + this->limit(size), out_);
-  }
-
- public:
-  explicit iterator_buffer(OutputIt out, size_t n = buffer_size)
-      : Traits(n), buffer<T>(data_, 0, buffer_size), out_(out) {}
-  iterator_buffer(iterator_buffer&& other)
-      : Traits(other), buffer<T>(data_, 0, buffer_size), out_(other.out_) {}
-  ~iterator_buffer() { flush(); }
-
-  auto out() -> OutputIt {
-    flush();
-    return out_;
-  }
-  auto count() const -> size_t { return Traits::count() + this->size(); }
-};
-
-template <typename T>
-class iterator_buffer<T*, T, fixed_buffer_traits> final
-    : public fixed_buffer_traits,
-      public buffer<T> {
- private:
-  T* out_;
-  enum { buffer_size = 256 };
-  T data_[buffer_size];
-
- protected:
-  FMT_CONSTEXPR20 void grow(size_t) override {
-    if (this->size() == this->capacity()) flush();
-  }
-
-  void flush() {
-    size_t n = this->limit(this->size());
-    if (this->data() == out_) {
-      out_ += n;
-      this->set(data_, buffer_size);
-    }
-    this->clear();
-  }
-
- public:
-  explicit iterator_buffer(T* out, size_t n = buffer_size)
-      : fixed_buffer_traits(n), buffer<T>(out, 0, n), out_(out) {}
-  iterator_buffer(iterator_buffer&& other)
-      : fixed_buffer_traits(other),
-        buffer<T>(std::move(other)),
-        out_(other.out_) {
-    if (this->data() != out_) {
-      this->set(data_, buffer_size);
-      this->clear();
-    }
-  }
-  ~iterator_buffer() { flush(); }
-
-  auto out() -> T* {
-    flush();
-    return out_;
-  }
-  auto count() const -> size_t {
-    return fixed_buffer_traits::count() + this->size();
-  }
-};
-
-template <typename T> class iterator_buffer<T*, T> final : public buffer<T> {
- protected:
-  FMT_CONSTEXPR20 void grow(size_t) override {}
-
- public:
-  explicit iterator_buffer(T* out, size_t = 0) : buffer<T>(out, 0, ~size_t()) {}
-
-  auto out() -> T* { return &*this->end(); }
-};
-
-// A buffer that writes to a container with the contiguous storage.
-template <typename Container>
-class iterator_buffer<std::back_insert_iterator<Container>,
-                      enable_if_t<is_contiguous<Container>::value,
-                                  typename Container::value_type>>
-    final : public buffer<typename Container::value_type> {
- private:
-  Container& container_;
-
- protected:
-  FMT_CONSTEXPR20 void grow(size_t capacity) override {
-    container_.resize(capacity);
-    this->set(&container_[0], capacity);
-  }
-
- public:
-  explicit iterator_buffer(Container& c)
-      : buffer<typename Container::value_type>(c.size()), container_(c) {}
-  explicit iterator_buffer(std::back_insert_iterator<Container> out, size_t = 0)
-      : iterator_buffer(get_container(out)) {}
-
-  auto out() -> std::back_insert_iterator<Container> {
-    return std::back_inserter(container_);
-  }
-};
-
-// A buffer that counts the number of code units written discarding the output.
-template <typename T = char> class counting_buffer final : public buffer<T> {
- private:
-  enum { buffer_size = 256 };
-  T data_[buffer_size];
-  size_t count_ = 0;
-
- protected:
-  FMT_CONSTEXPR20 void grow(size_t) override {
-    if (this->size() != buffer_size) return;
-    count_ += this->size();
-    this->clear();
-  }
-
- public:
-  counting_buffer() : buffer<T>(data_, 0, buffer_size) {}
-
-  auto count() -> size_t { return count_ + this->size(); }
-};
-}  // namespace detail
-
-template <typename Char>
-FMT_CONSTEXPR void basic_format_parse_context<Char>::do_check_arg_id(int id) {
-  // Argument id is only checked at compile-time during parsing because
-  // formatting has its own validation.
-  if (detail::is_constant_evaluated() &&
-      (!FMT_GCC_VERSION || FMT_GCC_VERSION >= 1200)) {
-    using context = detail::compile_parse_context<Char>;
-    if (id >= static_cast<context*>(this)->num_args())
-      detail::throw_format_error("argument not found");
-  }
-}
-
-template <typename Char>
-FMT_CONSTEXPR void basic_format_parse_context<Char>::check_dynamic_spec(
-    int arg_id) {
-  if (detail::is_constant_evaluated() &&
-      (!FMT_GCC_VERSION || FMT_GCC_VERSION >= 1200)) {
-    using context = detail::compile_parse_context<Char>;
-    static_cast<context*>(this)->check_dynamic_spec(arg_id);
-  }
-}
-
-FMT_EXPORT template <typename Context> class basic_format_arg;
-FMT_EXPORT template <typename Context> class basic_format_args;
-FMT_EXPORT template <typename Context> class dynamic_format_arg_store;
-
-// A formatter for objects of type T.
-FMT_EXPORT
-template <typename T, typename Char = char, typename Enable = void>
-struct formatter {
-  // A deleted default constructor indicates a disabled formatter.
-  formatter() = delete;
-};
-
-// Specifies if T has an enabled formatter specialization. A type can be
-// formattable even if it doesn't have a formatter e.g. via a conversion.
-template <typename T, typename Context>
-using has_formatter =
-    std::is_constructible<typename Context::template formatter_type<T>>;
-
-// An output iterator that appends to a buffer.
-// It is used to reduce symbol sizes for the common case.
-class appender : public std::back_insert_iterator<detail::buffer<char>> {
-  using base = std::back_insert_iterator<detail::buffer<char>>;
-
- public:
-  using std::back_insert_iterator<detail::buffer<char>>::back_insert_iterator;
-  appender(base it) noexcept : base(it) {}
-  FMT_UNCHECKED_ITERATOR(appender);
-
-  auto operator++() noexcept -> appender& { return *this; }
-  auto operator++(int) noexcept -> appender { return *this; }
-};
-
-namespace detail {
-
-template <typename Context, typename T>
-constexpr auto has_const_formatter_impl(T*)
-    -> decltype(typename Context::template formatter_type<T>().format(
-                    std::declval<const T&>(), std::declval<Context&>()),
-                true) {
-  return true;
-}
-template <typename Context>
-constexpr auto has_const_formatter_impl(...) -> bool {
-  return false;
-}
-template <typename T, typename Context>
-constexpr auto has_const_formatter() -> bool {
-  return has_const_formatter_impl<Context>(static_cast<T*>(nullptr));
-}
-
-template <typename T>
-using buffer_appender = conditional_t<std::is_same<T, char>::value, appender,
-                                      std::back_insert_iterator<buffer<T>>>;
-
-// Maps an output iterator to a buffer.
-template <typename T, typename OutputIt>
-auto get_buffer(OutputIt out) -> iterator_buffer<OutputIt, T> {
-  return iterator_buffer<OutputIt, T>(out);
-}
-template <typename T, typename Buf,
-          FMT_ENABLE_IF(std::is_base_of<buffer<char>, Buf>::value)>
-auto get_buffer(std::back_insert_iterator<Buf> out) -> buffer<char>& {
-  return get_container(out);
-}
-
-template <typename Buf, typename OutputIt>
-FMT_INLINE auto get_iterator(Buf& buf, OutputIt) -> decltype(buf.out()) {
-  return buf.out();
-}
-template <typename T, typename OutputIt>
-auto get_iterator(buffer<T>&, OutputIt out) -> OutputIt {
-  return out;
-}
-
-struct view {};
-
-template <typename Char, typename T> struct named_arg : view {
-  const Char* name;
-  const T& value;
-  named_arg(const Char* n, const T& v) : name(n), value(v) {}
-};
-
-template <typename Char> struct named_arg_info {
-  const Char* name;
-  int id;
-};
-
-template <typename T, typename Char, size_t NUM_ARGS, size_t NUM_NAMED_ARGS>
-struct arg_data {
-  // args_[0].named_args points to named_args_ to avoid bloating format_args.
-  // +1 to workaround a bug in gcc 7.5 that causes duplicated-branches warning.
-  T args_[1 + (NUM_ARGS != 0 ? NUM_ARGS : +1)];
-  named_arg_info<Char> named_args_[NUM_NAMED_ARGS];
-
-  template <typename... U>
-  arg_data(const U&... init) : args_{T(named_args_, NUM_NAMED_ARGS), init...} {}
-  arg_data(const arg_data& other) = delete;
-  auto args() const -> const T* { return args_ + 1; }
-  auto named_args() -> named_arg_info<Char>* { return named_args_; }
-};
-
-template <typename T, typename Char, size_t NUM_ARGS>
-struct arg_data<T, Char, NUM_ARGS, 0> {
-  // +1 to workaround a bug in gcc 7.5 that causes duplicated-branches warning.
-  T args_[NUM_ARGS != 0 ? NUM_ARGS : +1];
-
-  template <typename... U>
-  FMT_CONSTEXPR FMT_INLINE arg_data(const U&... init) : args_{init...} {}
-  FMT_CONSTEXPR FMT_INLINE auto args() const -> const T* { return args_; }
-  FMT_CONSTEXPR FMT_INLINE auto named_args() -> std::nullptr_t {
-    return nullptr;
-  }
-};
-
-template <typename Char>
-inline void init_named_args(named_arg_info<Char>*, int, int) {}
-
-template <typename T> struct is_named_arg : std::false_type {};
-template <typename T> struct is_statically_named_arg : std::false_type {};
-
-template <typename T, typename Char>
-struct is_named_arg<named_arg<Char, T>> : std::true_type {};
-
-template <typename Char, typename T, typename... Tail,
-          FMT_ENABLE_IF(!is_named_arg<T>::value)>
-void init_named_args(named_arg_info<Char>* named_args, int arg_count,
-                     int named_arg_count, const T&, const Tail&... args) {
-  init_named_args(named_args, arg_count + 1, named_arg_count, args...);
-}
-
-template <typename Char, typename T, typename... Tail,
-          FMT_ENABLE_IF(is_named_arg<T>::value)>
-void init_named_args(named_arg_info<Char>* named_args, int arg_count,
-                     int named_arg_count, const T& arg, const Tail&... args) {
-  named_args[named_arg_count++] = {arg.name, arg_count};
-  init_named_args(named_args, arg_count + 1, named_arg_count, args...);
-}
-
-template <typename... Args>
-FMT_CONSTEXPR FMT_INLINE void init_named_args(std::nullptr_t, int, int,
-                                              const Args&...) {}
-
-template <bool B = false> constexpr auto count() -> size_t { return B ? 1 : 0; }
-template <bool B1, bool B2, bool... Tail> constexpr auto count() -> size_t {
-  return (B1 ? 1 : 0) + count<B2, Tail...>();
-}
-
-template <typename... Args> constexpr auto count_named_args() -> size_t {
-  return count<is_named_arg<Args>::value...>();
-}
-
-template <typename... Args>
-constexpr auto count_statically_named_args() -> size_t {
-  return count<is_statically_named_arg<Args>::value...>();
-}
-
-struct unformattable {};
-struct unformattable_char : unformattable {};
-struct unformattable_pointer : unformattable {};
-
-template <typename Char> struct string_value {
-  const Char* data;
-  size_t size;
-};
-
-template <typename Char> struct named_arg_value {
-  const named_arg_info<Char>* data;
-  size_t size;
-};
-
-template <typename Context> struct custom_value {
-  using parse_context = typename Context::parse_context_type;
-  void* value;
-  void (*format)(void* arg, parse_context& parse_ctx, Context& ctx);
-};
-
-// A formatting argument value.
-template <typename Context> class value {
- public:
-  using char_type = typename Context::char_type;
-
-  union {
-    monostate no_value;
-    int int_value;
-    unsigned uint_value;
-    long long long_long_value;
-    unsigned long long ulong_long_value;
-    int128_opt int128_value;
-    uint128_opt uint128_value;
-    bool bool_value;
-    char_type char_value;
-    float float_value;
-    double double_value;
-    long double long_double_value;
-    const void* pointer;
-    string_value<char_type> string;
-    custom_value<Context> custom;
-    named_arg_value<char_type> named_args;
-  };
-
-  constexpr FMT_INLINE value() : no_value() {}
-  constexpr FMT_INLINE value(int val) : int_value(val) {}
-  constexpr FMT_INLINE value(unsigned val) : uint_value(val) {}
-  constexpr FMT_INLINE value(long long val) : long_long_value(val) {}
-  constexpr FMT_INLINE value(unsigned long long val) : ulong_long_value(val) {}
-  FMT_INLINE value(int128_opt val) : int128_value(val) {}
-  FMT_INLINE value(uint128_opt val) : uint128_value(val) {}
-  constexpr FMT_INLINE value(float val) : float_value(val) {}
-  constexpr FMT_INLINE value(double val) : double_value(val) {}
-  FMT_INLINE value(long double val) : long_double_value(val) {}
-  constexpr FMT_INLINE value(bool val) : bool_value(val) {}
-  constexpr FMT_INLINE value(char_type val) : char_value(val) {}
-  FMT_CONSTEXPR FMT_INLINE value(const char_type* val) {
-    string.data = val;
-    if (is_constant_evaluated()) string.size = {};
-  }
-  FMT_CONSTEXPR FMT_INLINE value(basic_string_view<char_type> val) {
-    string.data = val.data();
-    string.size = val.size();
-  }
-  FMT_INLINE value(const void* val) : pointer(val) {}
-  FMT_INLINE value(const named_arg_info<char_type>* args, size_t size)
-      : named_args{args, size} {}
-
-  template <typename T> FMT_CONSTEXPR20 FMT_INLINE value(T& val) {
-    using value_type = remove_const_t<T>;
-    custom.value = const_cast<value_type*>(std::addressof(val));
-    // Get the formatter type through the context to allow different contexts
-    // have different extension points, e.g. `formatter<T>` for `format` and
-    // `printf_formatter<T>` for `printf`.
-    custom.format = format_custom_arg<
-        value_type, typename Context::template formatter_type<value_type>>;
-  }
-  value(unformattable);
-  value(unformattable_char);
-  value(unformattable_pointer);
-
- private:
-  // Formats an argument of a custom type, such as a user-defined class.
-  template <typename T, typename Formatter>
-  static void format_custom_arg(void* arg,
-                                typename Context::parse_context_type& parse_ctx,
-                                Context& ctx) {
-    auto f = Formatter();
-    parse_ctx.advance_to(f.parse(parse_ctx));
-    using qualified_type =
-        conditional_t<has_const_formatter<T, Context>(), const T, T>;
-    // Calling format through a mutable reference is deprecated.
-    ctx.advance_to(f.format(*static_cast<qualified_type*>(arg), ctx));
-  }
-};
-
-// To minimize the number of types we need to deal with, long is translated
-// either to int or to long long depending on its size.
-enum { long_short = sizeof(long) == sizeof(int) };
-using long_type = conditional_t<long_short, int, long long>;
-using ulong_type = conditional_t<long_short, unsigned, unsigned long long>;
-
-template <typename T> struct format_as_result {
-  template <typename U,
-            FMT_ENABLE_IF(std::is_enum<U>::value || std::is_class<U>::value)>
-  static auto map(U*) -> remove_cvref_t<decltype(format_as(std::declval<U>()))>;
-  static auto map(...) -> void;
-
-  using type = decltype(map(static_cast<T*>(nullptr)));
-};
-template <typename T> using format_as_t = typename format_as_result<T>::type;
-
-template <typename T>
-struct has_format_as
-    : bool_constant<!std::is_same<format_as_t<T>, void>::value> {};
-
-// Maps formatting arguments to core types.
-// arg_mapper reports errors by returning unformattable instead of using
-// static_assert because it's used in the is_formattable trait.
-template <typename Context> struct arg_mapper {
-  using char_type = typename Context::char_type;
-
-  FMT_CONSTEXPR FMT_INLINE auto map(signed char val) -> int { return val; }
-  FMT_CONSTEXPR FMT_INLINE auto map(unsigned char val) -> unsigned {
-    return val;
-  }
-  FMT_CONSTEXPR FMT_INLINE auto map(short val) -> int { return val; }
-  FMT_CONSTEXPR FMT_INLINE auto map(unsigned short val) -> unsigned {
-    return val;
-  }
-  FMT_CONSTEXPR FMT_INLINE auto map(int val) -> int { return val; }
-  FMT_CONSTEXPR FMT_INLINE auto map(unsigned val) -> unsigned { return val; }
-  FMT_CONSTEXPR FMT_INLINE auto map(long val) -> long_type { return val; }
-  FMT_CONSTEXPR FMT_INLINE auto map(unsigned long val) -> ulong_type {
-    return val;
-  }
-  FMT_CONSTEXPR FMT_INLINE auto map(long long val) -> long long { return val; }
-  FMT_CONSTEXPR FMT_INLINE auto map(unsigned long long val)
-      -> unsigned long long {
-    return val;
-  }
-  FMT_CONSTEXPR FMT_INLINE auto map(int128_opt val) -> int128_opt {
-    return val;
-  }
-  FMT_CONSTEXPR FMT_INLINE auto map(uint128_opt val) -> uint128_opt {
-    return val;
-  }
-  FMT_CONSTEXPR FMT_INLINE auto map(bool val) -> bool { return val; }
-
-  template <typename T, FMT_ENABLE_IF(std::is_same<T, char>::value ||
-                                      std::is_same<T, char_type>::value)>
-  FMT_CONSTEXPR FMT_INLINE auto map(T val) -> char_type {
-    return val;
-  }
-  template <typename T, enable_if_t<(std::is_same<T, wchar_t>::value ||
-#ifdef __cpp_char8_t
-                                     std::is_same<T, char8_t>::value ||
-#endif
-                                     std::is_same<T, char16_t>::value ||
-                                     std::is_same<T, char32_t>::value) &&
-                                        !std::is_same<T, char_type>::value,
-                                    int> = 0>
-  FMT_CONSTEXPR FMT_INLINE auto map(T) -> unformattable_char {
-    return {};
-  }
-
-  FMT_CONSTEXPR FMT_INLINE auto map(float val) -> float { return val; }
-  FMT_CONSTEXPR FMT_INLINE auto map(double val) -> double { return val; }
-  FMT_CONSTEXPR FMT_INLINE auto map(long double val) -> long double {
-    return val;
-  }
-
-  FMT_CONSTEXPR FMT_INLINE auto map(char_type* val) -> const char_type* {
-    return val;
-  }
-  FMT_CONSTEXPR FMT_INLINE auto map(const char_type* val) -> const char_type* {
-    return val;
-  }
-  template <typename T,
-            FMT_ENABLE_IF(is_string<T>::value && !std::is_pointer<T>::value &&
-                          std::is_same<char_type, char_t<T>>::value)>
-  FMT_CONSTEXPR FMT_INLINE auto map(const T& val)
-      -> basic_string_view<char_type> {
-    return to_string_view(val);
-  }
-  template <typename T,
-            FMT_ENABLE_IF(is_string<T>::value && !std::is_pointer<T>::value &&
-                          !std::is_same<char_type, char_t<T>>::value)>
-  FMT_CONSTEXPR FMT_INLINE auto map(const T&) -> unformattable_char {
-    return {};
-  }
-
-  FMT_CONSTEXPR FMT_INLINE auto map(void* val) -> const void* { return val; }
-  FMT_CONSTEXPR FMT_INLINE auto map(const void* val) -> const void* {
-    return val;
-  }
-  FMT_CONSTEXPR FMT_INLINE auto map(std::nullptr_t val) -> const void* {
-    return val;
-  }
-
-  // Use SFINAE instead of a const T* parameter to avoid a conflict with the
-  // array overload.
-  template <
-      typename T,
-      FMT_ENABLE_IF(
-          std::is_pointer<T>::value || std::is_member_pointer<T>::value ||
-          std::is_function<typename std::remove_pointer<T>::type>::value ||
-          (std::is_array<T>::value &&
-           !std::is_convertible<T, const char_type*>::value))>
-  FMT_CONSTEXPR auto map(const T&) -> unformattable_pointer {
-    return {};
-  }
-
-  template <typename T, std::size_t N,
-            FMT_ENABLE_IF(!std::is_same<T, wchar_t>::value)>
-  FMT_CONSTEXPR FMT_INLINE auto map(const T (&values)[N]) -> const T (&)[N] {
-    return values;
-  }
-
-  // Only map owning types because mapping views can be unsafe.
-  template <typename T, typename U = format_as_t<T>,
-            FMT_ENABLE_IF(std::is_arithmetic<U>::value)>
-  FMT_CONSTEXPR FMT_INLINE auto map(const T& val)
-      -> decltype(FMT_DECLTYPE_THIS map(U())) {
-    return map(format_as(val));
-  }
-
-  template <typename T, typename U = remove_const_t<T>>
-  struct formattable : bool_constant<has_const_formatter<U, Context>() ||
-                                     (has_formatter<U, Context>::value &&
-                                      !std::is_const<T>::value)> {};
-
-  template <typename T, FMT_ENABLE_IF(formattable<T>::value)>
-  FMT_CONSTEXPR FMT_INLINE auto do_map(T& val) -> T& {
-    return val;
-  }
-  template <typename T, FMT_ENABLE_IF(!formattable<T>::value)>
-  FMT_CONSTEXPR FMT_INLINE auto do_map(T&) -> unformattable {
-    return {};
-  }
-
-  template <typename T, typename U = remove_const_t<T>,
-            FMT_ENABLE_IF((std::is_class<U>::value || std::is_enum<U>::value ||
-                           std::is_union<U>::value) &&
-                          !is_string<U>::value && !is_char<U>::value &&
-                          !is_named_arg<U>::value &&
-                          !std::is_arithmetic<format_as_t<U>>::value)>
-  FMT_CONSTEXPR FMT_INLINE auto map(T& val)
-      -> decltype(FMT_DECLTYPE_THIS do_map(val)) {
-    return do_map(val);
-  }
-
-  template <typename T, FMT_ENABLE_IF(is_named_arg<T>::value)>
-  FMT_CONSTEXPR FMT_INLINE auto map(const T& named_arg)
-      -> decltype(FMT_DECLTYPE_THIS map(named_arg.value)) {
-    return map(named_arg.value);
-  }
-
-  auto map(...) -> unformattable { return {}; }
-};
-
-// A type constant after applying arg_mapper<Context>.
-template <typename T, typename Context>
-using mapped_type_constant =
-    type_constant<decltype(arg_mapper<Context>().map(std::declval<const T&>())),
-                  typename Context::char_type>;
-
-enum { packed_arg_bits = 4 };
-// Maximum number of arguments with packed types.
-enum { max_packed_args = 62 / packed_arg_bits };
-enum : unsigned long long { is_unpacked_bit = 1ULL << 63 };
-enum : unsigned long long { has_named_args_bit = 1ULL << 62 };
-
-template <typename Char, typename InputIt>
-auto copy_str(InputIt begin, InputIt end, appender out) -> appender {
-  get_container(out).append(begin, end);
-  return out;
-}
-template <typename Char, typename InputIt>
-auto copy_str(InputIt begin, InputIt end,
-              std::back_insert_iterator<std::string> out)
-    -> std::back_insert_iterator<std::string> {
-  get_container(out).append(begin, end);
-  return out;
-}
-
-template <typename Char, typename R, typename OutputIt>
-FMT_CONSTEXPR auto copy_str(R&& rng, OutputIt out) -> OutputIt {
-  return detail::copy_str<Char>(rng.begin(), rng.end(), out);
-}
-
-#if FMT_GCC_VERSION && FMT_GCC_VERSION < 500
-// A workaround for gcc 4.8 to make void_t work in a SFINAE context.
-template <typename...> struct void_t_impl {
-  using type = void;
-};
-template <typename... T> using void_t = typename void_t_impl<T...>::type;
-#else
-template <typename...> using void_t = void;
-#endif
-
-template <typename It, typename T, typename Enable = void>
-struct is_output_iterator : std::false_type {};
-
-template <typename It, typename T>
-struct is_output_iterator<
-    It, T,
-    void_t<typename std::iterator_traits<It>::iterator_category,
-           decltype(*std::declval<It>() = std::declval<T>())>>
-    : std::true_type {};
-
-template <typename It> struct is_back_insert_iterator : std::false_type {};
-template <typename Container>
-struct is_back_insert_iterator<std::back_insert_iterator<Container>>
-    : std::true_type {};
-
-// A type-erased reference to an std::locale to avoid a heavy <locale> include.
-class locale_ref {
- private:
-  const void* locale_;  // A type-erased pointer to std::locale.
-
- public:
-  constexpr FMT_INLINE locale_ref() : locale_(nullptr) {}
-  template <typename Locale> explicit locale_ref(const Locale& loc);
-
-  explicit operator bool() const noexcept { return locale_ != nullptr; }
-
-  template <typename Locale> auto get() const -> Locale;
-};
-
-template <typename> constexpr auto encode_types() -> unsigned long long {
-  return 0;
-}
-
-template <typename Context, typename Arg, typename... Args>
-constexpr auto encode_types() -> unsigned long long {
-  return static_cast<unsigned>(mapped_type_constant<Arg, Context>::value) |
-         (encode_types<Context, Args...>() << packed_arg_bits);
-}
-
-#if defined(__cpp_if_constexpr)
-// This type is intentionally undefined, only used for errors
-template <typename T, typename Char> struct type_is_unformattable_for;
-#endif
-
-template <bool PACKED, typename Context, typename T, FMT_ENABLE_IF(PACKED)>
-FMT_CONSTEXPR FMT_INLINE auto make_arg(T& val) -> value<Context> {
-  using arg_type = remove_cvref_t<decltype(arg_mapper<Context>().map(val))>;
-
-  constexpr bool formattable_char =
-      !std::is_same<arg_type, unformattable_char>::value;
-  static_assert(formattable_char, "Mixing character types is disallowed.");
-
-  // Formatting of arbitrary pointers is disallowed. If you want to format a
-  // pointer cast it to `void*` or `const void*`. In particular, this forbids
-  // formatting of `[const] volatile char*` printed as bool by iostreams.
-  constexpr bool formattable_pointer =
-      !std::is_same<arg_type, unformattable_pointer>::value;
-  static_assert(formattable_pointer,
-                "Formatting of non-void pointers is disallowed.");
-
-  constexpr bool formattable = !std::is_same<arg_type, unformattable>::value;
-#if defined(__cpp_if_constexpr)
-  if constexpr (!formattable) {
-    type_is_unformattable_for<T, typename Context::char_type> _;
-  }
-#endif
-  static_assert(
-      formattable,
-      "Cannot format an argument. To make type T formattable provide a "
-      "formatter<T> specialization: https://fmt.dev/latest/api.html#udt");
-  return {arg_mapper<Context>().map(val)};
-}
-
-template <typename Context, typename T>
-FMT_CONSTEXPR auto make_arg(T& val) -> basic_format_arg<Context> {
-  auto arg = basic_format_arg<Context>();
-  arg.type_ = mapped_type_constant<T, Context>::value;
-  arg.value_ = make_arg<true, Context>(val);
-  return arg;
-}
-
-template <bool PACKED, typename Context, typename T, FMT_ENABLE_IF(!PACKED)>
-FMT_CONSTEXPR inline auto make_arg(T& val) -> basic_format_arg<Context> {
-  return make_arg<Context>(val);
-}
-}  // namespace detail
-FMT_BEGIN_EXPORT
-
-// A formatting argument. Context is a template parameter for the compiled API
-// where output can be unbuffered.
-template <typename Context> class basic_format_arg {
- private:
-  detail::value<Context> value_;
-  detail::type type_;
-
-  template <typename ContextType, typename T>
-  friend FMT_CONSTEXPR auto detail::make_arg(T& value)
-      -> basic_format_arg<ContextType>;
-
-  template <typename Visitor, typename Ctx>
-  friend FMT_CONSTEXPR auto visit_format_arg(Visitor&& vis,
-                                             const basic_format_arg<Ctx>& arg)
-      -> decltype(vis(0));
-
-  friend class basic_format_args<Context>;
-  friend class dynamic_format_arg_store<Context>;
-
-  using char_type = typename Context::char_type;
-
-  template <typename T, typename Char, size_t NUM_ARGS, size_t NUM_NAMED_ARGS>
-  friend struct detail::arg_data;
-
-  basic_format_arg(const detail::named_arg_info<char_type>* args, size_t size)
-      : value_(args, size) {}
-
- public:
-  class handle {
-   public:
-    explicit handle(detail::custom_value<Context> custom) : custom_(custom) {}
-
-    void format(typename Context::parse_context_type& parse_ctx,
-                Context& ctx) const {
-      custom_.format(custom_.value, parse_ctx, ctx);
-    }
-
-   private:
-    detail::custom_value<Context> custom_;
-  };
-
-  constexpr basic_format_arg() : type_(detail::type::none_type) {}
-
-  constexpr explicit operator bool() const noexcept {
-    return type_ != detail::type::none_type;
-  }
-
-  auto type() const -> detail::type { return type_; }
-
-  auto is_integral() const -> bool { return detail::is_integral_type(type_); }
-  auto is_arithmetic() const -> bool {
-    return detail::is_arithmetic_type(type_);
-  }
-
-  FMT_INLINE auto format_custom(const char_type* parse_begin,
-                                typename Context::parse_context_type& parse_ctx,
-                                Context& ctx) -> bool {
-    if (type_ != detail::type::custom_type) return false;
-    parse_ctx.advance_to(parse_begin);
-    value_.custom.format(value_.custom.value, parse_ctx, ctx);
-    return true;
-  }
-};
-
-/**
-  \rst
-  Visits an argument dispatching to the appropriate visit method based on
-  the argument type. For example, if the argument type is ``double`` then
-  ``vis(value)`` will be called with the value of type ``double``.
-  \endrst
- */
-// DEPRECATED!
-template <typename Visitor, typename Context>
-FMT_CONSTEXPR FMT_INLINE auto visit_format_arg(
-    Visitor&& vis, const basic_format_arg<Context>& arg) -> decltype(vis(0)) {
-  switch (arg.type_) {
-  case detail::type::none_type:
-    break;
-  case detail::type::int_type:
-    return vis(arg.value_.int_value);
-  case detail::type::uint_type:
-    return vis(arg.value_.uint_value);
-  case detail::type::long_long_type:
-    return vis(arg.value_.long_long_value);
-  case detail::type::ulong_long_type:
-    return vis(arg.value_.ulong_long_value);
-  case detail::type::int128_type:
-    return vis(detail::convert_for_visit(arg.value_.int128_value));
-  case detail::type::uint128_type:
-    return vis(detail::convert_for_visit(arg.value_.uint128_value));
-  case detail::type::bool_type:
-    return vis(arg.value_.bool_value);
-  case detail::type::char_type:
-    return vis(arg.value_.char_value);
-  case detail::type::float_type:
-    return vis(arg.value_.float_value);
-  case detail::type::double_type:
-    return vis(arg.value_.double_value);
-  case detail::type::long_double_type:
-    return vis(arg.value_.long_double_value);
-  case detail::type::cstring_type:
-    return vis(arg.value_.string.data);
-  case detail::type::string_type:
-    using sv = basic_string_view<typename Context::char_type>;
-    return vis(sv(arg.value_.string.data, arg.value_.string.size));
-  case detail::type::pointer_type:
-    return vis(arg.value_.pointer);
-  case detail::type::custom_type:
-    return vis(typename basic_format_arg<Context>::handle(arg.value_.custom));
-  }
-  return vis(monostate());
-}
-
-// Formatting context.
-template <typename OutputIt, typename Char> class basic_format_context {
- private:
-  OutputIt out_;
-  basic_format_args<basic_format_context> args_;
-  detail::locale_ref loc_;
-
- public:
-  using iterator = OutputIt;
-  using format_arg = basic_format_arg<basic_format_context>;
-  using format_args = basic_format_args<basic_format_context>;
-  using parse_context_type = basic_format_parse_context<Char>;
-  template <typename T> using formatter_type = formatter<T, Char>;
-
-  /** The character type for the output. */
-  using char_type = Char;
-
-  basic_format_context(basic_format_context&&) = default;
-  basic_format_context(const basic_format_context&) = delete;
-  void operator=(const basic_format_context&) = delete;
-  /**
-    Constructs a ``basic_format_context`` object. References to the arguments
-    are stored in the object so make sure they have appropriate lifetimes.
-   */
-  constexpr basic_format_context(OutputIt out, format_args ctx_args,
-                                 detail::locale_ref loc = {})
-      : out_(out), args_(ctx_args), loc_(loc) {}
-
-  constexpr auto arg(int id) const -> format_arg { return args_.get(id); }
-  FMT_CONSTEXPR auto arg(basic_string_view<Char> name) -> format_arg {
-    return args_.get(name);
-  }
-  FMT_CONSTEXPR auto arg_id(basic_string_view<Char> name) -> int {
-    return args_.get_id(name);
-  }
-  auto args() const -> const format_args& { return args_; }
-
-  // DEPRECATED!
-  FMT_CONSTEXPR auto error_handler() -> detail::error_handler { return {}; }
-  void on_error(const char* message) { error_handler().on_error(message); }
-
-  // Returns an iterator to the beginning of the output range.
-  FMT_CONSTEXPR auto out() -> iterator { return out_; }
-
-  // Advances the begin iterator to ``it``.
-  void advance_to(iterator it) {
-    if (!detail::is_back_insert_iterator<iterator>()) out_ = it;
-  }
-
-  FMT_CONSTEXPR auto locale() -> detail::locale_ref { return loc_; }
-};
-
-template <typename Char>
-using buffer_context =
-    basic_format_context<detail::buffer_appender<Char>, Char>;
-using format_context = buffer_context<char>;
-
-template <typename T, typename Char = char>
-using is_formattable = bool_constant<!std::is_base_of<
-    detail::unformattable, decltype(detail::arg_mapper<buffer_context<Char>>()
-                                        .map(std::declval<T&>()))>::value>;
-
-/**
-  \rst
-  An array of references to arguments. It can be implicitly converted into
-  `~fmt::basic_format_args` for passing into type-erased formatting functions
-  such as `~fmt::vformat`.
-  \endrst
- */
-template <typename Context, typename... Args>
-class format_arg_store
-#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
-    // Workaround a GCC template argument substitution bug.
-    : public basic_format_args<Context>
-#endif
-{
- private:
-  static const size_t num_args = sizeof...(Args);
-  static constexpr size_t num_named_args = detail::count_named_args<Args...>();
-  static const bool is_packed = num_args <= detail::max_packed_args;
-
-  using value_type = conditional_t<is_packed, detail::value<Context>,
-                                   basic_format_arg<Context>>;
-
-  detail::arg_data<value_type, typename Context::char_type, num_args,
-                   num_named_args>
-      data_;
-
-  friend class basic_format_args<Context>;
-
-  static constexpr unsigned long long desc =
-      (is_packed ? detail::encode_types<Context, Args...>()
-                 : detail::is_unpacked_bit | num_args) |
-      (num_named_args != 0
-           ? static_cast<unsigned long long>(detail::has_named_args_bit)
-           : 0);
-
- public:
-  template <typename... T>
-  FMT_CONSTEXPR FMT_INLINE format_arg_store(T&... args)
-      :
-#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
-        basic_format_args<Context>(*this),
-#endif
-        data_{detail::make_arg<is_packed, Context>(args)...} {
-    if (detail::const_check(num_named_args != 0))
-      detail::init_named_args(data_.named_args(), 0, 0, args...);
-  }
-};
-
-/**
-  \rst
-  Constructs a `~fmt::format_arg_store` object that contains references to
-  arguments and can be implicitly converted to `~fmt::format_args`. `Context`
-  can be omitted in which case it defaults to `~fmt::format_context`.
-  See `~fmt::arg` for lifetime considerations.
-  \endrst
- */
-// Arguments are taken by lvalue references to avoid some lifetime issues.
-template <typename Context = format_context, typename... T>
-constexpr auto make_format_args(T&... args)
-    -> format_arg_store<Context, remove_cvref_t<T>...> {
-  return {args...};
-}
-
-/**
-  \rst
-  Returns a named argument to be used in a formatting function.
-  It should only be used in a call to a formatting function or
-  `dynamic_format_arg_store::push_back`.
-
-  **Example**::
-
-    fmt::print("Elapsed time: {s:.2f} seconds", fmt::arg("s", 1.23));
-  \endrst
- */
-template <typename Char, typename T>
-inline auto arg(const Char* name, const T& arg) -> detail::named_arg<Char, T> {
-  static_assert(!detail::is_named_arg<T>(), "nested named arguments");
-  return {name, arg};
-}
-FMT_END_EXPORT
-
-/**
-  \rst
-  A view of a collection of formatting arguments. To avoid lifetime issues it
-  should only be used as a parameter type in type-erased functions such as
-  ``vformat``::
-
-    void vlog(string_view format_str, format_args args);  // OK
-    format_args args = make_format_args();  // Error: dangling reference
-  \endrst
- */
-template <typename Context> class basic_format_args {
- public:
-  using size_type = int;
-  using format_arg = basic_format_arg<Context>;
-
- private:
-  // A descriptor that contains information about formatting arguments.
-  // If the number of arguments is less or equal to max_packed_args then
-  // argument types are passed in the descriptor. This reduces binary code size
-  // per formatting function call.
-  unsigned long long desc_;
-  union {
-    // If is_packed() returns true then argument values are stored in values_;
-    // otherwise they are stored in args_. This is done to improve cache
-    // locality and reduce compiled code size since storing larger objects
-    // may require more code (at least on x86-64) even if the same amount of
-    // data is actually copied to stack. It saves ~10% on the bloat test.
-    const detail::value<Context>* values_;
-    const format_arg* args_;
-  };
-
-  constexpr auto is_packed() const -> bool {
-    return (desc_ & detail::is_unpacked_bit) == 0;
-  }
-  auto has_named_args() const -> bool {
-    return (desc_ & detail::has_named_args_bit) != 0;
-  }
-
-  FMT_CONSTEXPR auto type(int index) const -> detail::type {
-    int shift = index * detail::packed_arg_bits;
-    unsigned int mask = (1 << detail::packed_arg_bits) - 1;
-    return static_cast<detail::type>((desc_ >> shift) & mask);
-  }
-
-  constexpr FMT_INLINE basic_format_args(unsigned long long desc,
-                                         const detail::value<Context>* values)
-      : desc_(desc), values_(values) {}
-  constexpr basic_format_args(unsigned long long desc, const format_arg* args)
-      : desc_(desc), args_(args) {}
-
- public:
-  constexpr basic_format_args() : desc_(0), args_(nullptr) {}
-
-  /**
-   \rst
-   Constructs a `basic_format_args` object from `~fmt::format_arg_store`.
-   \endrst
-   */
-  template <typename... Args>
-  constexpr FMT_INLINE basic_format_args(
-      const format_arg_store<Context, Args...>& store)
-      : basic_format_args(format_arg_store<Context, Args...>::desc,
-                          store.data_.args()) {}
-
-  /**
-   \rst
-   Constructs a `basic_format_args` object from
-   `~fmt::dynamic_format_arg_store`.
-   \endrst
-   */
-  constexpr FMT_INLINE basic_format_args(
-      const dynamic_format_arg_store<Context>& store)
-      : basic_format_args(store.get_types(), store.data()) {}
-
-  /**
-   \rst
-   Constructs a `basic_format_args` object from a dynamic set of arguments.
-   \endrst
-   */
-  constexpr basic_format_args(const format_arg* args, int count)
-      : basic_format_args(detail::is_unpacked_bit | detail::to_unsigned(count),
-                          args) {}
-
-  /** Returns the argument with the specified id. */
-  FMT_CONSTEXPR auto get(int id) const -> format_arg {
-    format_arg arg;
-    if (!is_packed()) {
-      if (id < max_size()) arg = args_[id];
-      return arg;
-    }
-    if (id >= detail::max_packed_args) return arg;
-    arg.type_ = type(id);
-    if (arg.type_ == detail::type::none_type) return arg;
-    arg.value_ = values_[id];
-    return arg;
-  }
-
-  template <typename Char>
-  auto get(basic_string_view<Char> name) const -> format_arg {
-    int id = get_id(name);
-    return id >= 0 ? get(id) : format_arg();
-  }
-
-  template <typename Char>
-  auto get_id(basic_string_view<Char> name) const -> int {
-    if (!has_named_args()) return -1;
-    const auto& named_args =
-        (is_packed() ? values_[-1] : args_[-1].value_).named_args;
-    for (size_t i = 0; i < named_args.size; ++i) {
-      if (named_args.data[i].name == name) return named_args.data[i].id;
-    }
-    return -1;
-  }
-
-  auto max_size() const -> int {
-    unsigned long long max_packed = detail::max_packed_args;
-    return static_cast<int>(is_packed() ? max_packed
-                                        : desc_ & ~detail::is_unpacked_bit);
-  }
-};
-
-/** An alias to ``basic_format_args<format_context>``. */
-// A separate type would result in shorter symbols but break ABI compatibility
-// between clang and gcc on ARM (#1919).
-FMT_EXPORT using format_args = basic_format_args<format_context>;
-
-// We cannot use enum classes as bit fields because of a gcc bug, so we put them
-// in namespaces instead (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61414).
-// Additionally, if an underlying type is specified, older gcc incorrectly warns
-// that the type is too small. Both bugs are fixed in gcc 9.3.
-#if FMT_GCC_VERSION && FMT_GCC_VERSION < 903
-#  define FMT_ENUM_UNDERLYING_TYPE(type)
-#else
-#  define FMT_ENUM_UNDERLYING_TYPE(type) : type
-#endif
-namespace align {
-enum type FMT_ENUM_UNDERLYING_TYPE(unsigned char){none, left, right, center,
-                                                  numeric};
-}
-using align_t = align::type;
-namespace sign {
-enum type FMT_ENUM_UNDERLYING_TYPE(unsigned char){none, minus, plus, space};
-}
-using sign_t = sign::type;
-
-namespace detail {
-
-// Workaround an array initialization issue in gcc 4.8.
-template <typename Char> struct fill_t {
- private:
-  enum { max_size = 4 };
-  Char data_[max_size] = {Char(' '), Char(0), Char(0), Char(0)};
-  unsigned char size_ = 1;
-
- public:
-  FMT_CONSTEXPR void operator=(basic_string_view<Char> s) {
-    auto size = s.size();
-    FMT_ASSERT(size <= max_size, "invalid fill");
-    for (size_t i = 0; i < size; ++i) data_[i] = s[i];
-    size_ = static_cast<unsigned char>(size);
-  }
-
-  constexpr auto size() const -> size_t { return size_; }
-  constexpr auto data() const -> const Char* { return data_; }
-
-  FMT_CONSTEXPR auto operator[](size_t index) -> Char& { return data_[index]; }
-  FMT_CONSTEXPR auto operator[](size_t index) const -> const Char& {
-    return data_[index];
-  }
-};
-}  // namespace detail
-
-enum class presentation_type : unsigned char {
-  none,
-  dec,             // 'd'
-  oct,             // 'o'
-  hex_lower,       // 'x'
-  hex_upper,       // 'X'
-  bin_lower,       // 'b'
-  bin_upper,       // 'B'
-  hexfloat_lower,  // 'a'
-  hexfloat_upper,  // 'A'
-  exp_lower,       // 'e'
-  exp_upper,       // 'E'
-  fixed_lower,     // 'f'
-  fixed_upper,     // 'F'
-  general_lower,   // 'g'
-  general_upper,   // 'G'
-  chr,             // 'c'
-  string,          // 's'
-  pointer,         // 'p'
-  debug            // '?'
-};
-
-// Format specifiers for built-in and string types.
-template <typename Char = char> struct format_specs {
-  int width;
-  int precision;
-  presentation_type type;
-  align_t align : 4;
-  sign_t sign : 3;
-  bool alt : 1;  // Alternate form ('#').
-  bool localized : 1;
-  detail::fill_t<Char> fill;
-
-  constexpr format_specs()
-      : width(0),
-        precision(-1),
-        type(presentation_type::none),
-        align(align::none),
-        sign(sign::none),
-        alt(false),
-        localized(false) {}
-};
-
-namespace detail {
-
-enum class arg_id_kind { none, index, name };
-
-// An argument reference.
-template <typename Char> struct arg_ref {
-  FMT_CONSTEXPR arg_ref() : kind(arg_id_kind::none), val() {}
-
-  FMT_CONSTEXPR explicit arg_ref(int index)
-      : kind(arg_id_kind::index), val(index) {}
-  FMT_CONSTEXPR explicit arg_ref(basic_string_view<Char> name)
-      : kind(arg_id_kind::name), val(name) {}
-
-  FMT_CONSTEXPR auto operator=(int idx) -> arg_ref& {
-    kind = arg_id_kind::index;
-    val.index = idx;
-    return *this;
-  }
-
-  arg_id_kind kind;
-  union value {
-    FMT_CONSTEXPR value(int idx = 0) : index(idx) {}
-    FMT_CONSTEXPR value(basic_string_view<Char> n) : name(n) {}
-
-    int index;
-    basic_string_view<Char> name;
-  } val;
-};
-
-// Format specifiers with width and precision resolved at formatting rather
-// than parsing time to allow reusing the same parsed specifiers with
-// different sets of arguments (precompilation of format strings).
-template <typename Char = char>
-struct dynamic_format_specs : format_specs<Char> {
-  arg_ref<Char> width_ref;
-  arg_ref<Char> precision_ref;
-};
-
-// Converts a character to ASCII. Returns '\0' on conversion failure.
-template <typename Char, FMT_ENABLE_IF(std::is_integral<Char>::value)>
-constexpr auto to_ascii(Char c) -> char {
-  return c <= 0xff ? static_cast<char>(c) : '\0';
-}
-template <typename Char, FMT_ENABLE_IF(std::is_enum<Char>::value)>
-constexpr auto to_ascii(Char c) -> char {
-  return c <= 0xff ? static_cast<char>(c) : '\0';
-}
-
-// Returns the number of code units in a code point or 1 on error.
-template <typename Char>
-FMT_CONSTEXPR auto code_point_length(const Char* begin) -> int {
-  if (const_check(sizeof(Char) != 1)) return 1;
-  auto c = static_cast<unsigned char>(*begin);
-  return static_cast<int>((0x3a55000000000000ull >> (2 * (c >> 3))) & 0x3) + 1;
-}
-
-// Return the result via the out param to workaround gcc bug 77539.
-template <bool IS_CONSTEXPR, typename T, typename Ptr = const T*>
-FMT_CONSTEXPR auto find(Ptr first, Ptr last, T value, Ptr& out) -> bool {
-  for (out = first; out != last; ++out) {
-    if (*out == value) return true;
-  }
-  return false;
-}
-
-template <>
-inline auto find<false, char>(const char* first, const char* last, char value,
-                              const char*& out) -> bool {
-  out = static_cast<const char*>(
-      std::memchr(first, value, to_unsigned(last - first)));
-  return out != nullptr;
-}
-
-// Parses the range [begin, end) as an unsigned integer. This function assumes
-// that the range is non-empty and the first character is a digit.
-template <typename Char>
-FMT_CONSTEXPR auto parse_nonnegative_int(const Char*& begin, const Char* end,
-                                         int error_value) noexcept -> int {
-  FMT_ASSERT(begin != end && '0' <= *begin && *begin <= '9', "");
-  unsigned value = 0, prev = 0;
-  auto p = begin;
-  do {
-    prev = value;
-    value = value * 10 + unsigned(*p - '0');
-    ++p;
-  } while (p != end && '0' <= *p && *p <= '9');
-  auto num_digits = p - begin;
-  begin = p;
-  if (num_digits <= std::numeric_limits<int>::digits10)
-    return static_cast<int>(value);
-  // Check for overflow.
-  const unsigned max = to_unsigned((std::numeric_limits<int>::max)());
-  return num_digits == std::numeric_limits<int>::digits10 + 1 &&
-                 prev * 10ull + unsigned(p[-1] - '0') <= max
-             ? static_cast<int>(value)
-             : error_value;
-}
-
-FMT_CONSTEXPR inline auto parse_align(char c) -> align_t {
-  switch (c) {
-  case '<':
-    return align::left;
-  case '>':
-    return align::right;
-  case '^':
-    return align::center;
-  }
-  return align::none;
-}
-
-template <typename Char> constexpr auto is_name_start(Char c) -> bool {
-  return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || c == '_';
-}
-
-template <typename Char, typename Handler>
-FMT_CONSTEXPR auto do_parse_arg_id(const Char* begin, const Char* end,
-                                   Handler&& handler) -> const Char* {
-  Char c = *begin;
-  if (c >= '0' && c <= '9') {
-    int index = 0;
-    constexpr int max = (std::numeric_limits<int>::max)();
-    if (c != '0')
-      index = parse_nonnegative_int(begin, end, max);
-    else
-      ++begin;
-    if (begin == end || (*begin != '}' && *begin != ':'))
-      throw_format_error("invalid format string");
-    else
-      handler.on_index(index);
-    return begin;
-  }
-  if (!is_name_start(c)) {
-    throw_format_error("invalid format string");
-    return begin;
-  }
-  auto it = begin;
-  do {
-    ++it;
-  } while (it != end && (is_name_start(*it) || ('0' <= *it && *it <= '9')));
-  handler.on_name({begin, to_unsigned(it - begin)});
-  return it;
-}
-
-template <typename Char, typename Handler>
-FMT_CONSTEXPR FMT_INLINE auto parse_arg_id(const Char* begin, const Char* end,
-                                           Handler&& handler) -> const Char* {
-  FMT_ASSERT(begin != end, "");
-  Char c = *begin;
-  if (c != '}' && c != ':') return do_parse_arg_id(begin, end, handler);
-  handler.on_auto();
-  return begin;
-}
-
-template <typename Char> struct dynamic_spec_id_handler {
-  basic_format_parse_context<Char>& ctx;
-  arg_ref<Char>& ref;
-
-  FMT_CONSTEXPR void on_auto() {
-    int id = ctx.next_arg_id();
-    ref = arg_ref<Char>(id);
-    ctx.check_dynamic_spec(id);
-  }
-  FMT_CONSTEXPR void on_index(int id) {
-    ref = arg_ref<Char>(id);
-    ctx.check_arg_id(id);
-    ctx.check_dynamic_spec(id);
-  }
-  FMT_CONSTEXPR void on_name(basic_string_view<Char> id) {
-    ref = arg_ref<Char>(id);
-    ctx.check_arg_id(id);
-  }
-};
-
-// Parses [integer | "{" [arg_id] "}"].
-template <typename Char>
-FMT_CONSTEXPR auto parse_dynamic_spec(const Char* begin, const Char* end,
-                                      int& value, arg_ref<Char>& ref,
-                                      basic_format_parse_context<Char>& ctx)
-    -> const Char* {
-  FMT_ASSERT(begin != end, "");
-  if ('0' <= *begin && *begin <= '9') {
-    int val = parse_nonnegative_int(begin, end, -1);
-    if (val != -1)
-      value = val;
-    else
-      throw_format_error("number is too big");
-  } else if (*begin == '{') {
-    ++begin;
-    auto handler = dynamic_spec_id_handler<Char>{ctx, ref};
-    if (begin != end) begin = parse_arg_id(begin, end, handler);
-    if (begin != end && *begin == '}') return ++begin;
-    throw_format_error("invalid format string");
-  }
-  return begin;
-}
-
-template <typename Char>
-FMT_CONSTEXPR auto parse_precision(const Char* begin, const Char* end,
-                                   int& value, arg_ref<Char>& ref,
-                                   basic_format_parse_context<Char>& ctx)
-    -> const Char* {
-  ++begin;
-  if (begin == end || *begin == '}') {
-    throw_format_error("invalid precision");
-    return begin;
-  }
-  return parse_dynamic_spec(begin, end, value, ref, ctx);
-}
-
-enum class state { start, align, sign, hash, zero, width, precision, locale };
-
-// Parses standard format specifiers.
-template <typename Char>
-FMT_CONSTEXPR FMT_INLINE auto parse_format_specs(
-    const Char* begin, const Char* end, dynamic_format_specs<Char>& specs,
-    basic_format_parse_context<Char>& ctx, type arg_type) -> const Char* {
-  auto c = '\0';
-  if (end - begin > 1) {
-    auto next = to_ascii(begin[1]);
-    c = parse_align(next) == align::none ? to_ascii(*begin) : '\0';
-  } else {
-    if (begin == end) return begin;
-    c = to_ascii(*begin);
-  }
-
-  struct {
-    state current_state = state::start;
-    FMT_CONSTEXPR void operator()(state s, bool valid = true) {
-      if (current_state >= s || !valid)
-        throw_format_error("invalid format specifier");
-      current_state = s;
-    }
-  } enter_state;
-
-  using pres = presentation_type;
-  constexpr auto integral_set = sint_set | uint_set | bool_set | char_set;
-  struct {
-    const Char*& begin;
-    dynamic_format_specs<Char>& specs;
-    type arg_type;
-
-    FMT_CONSTEXPR auto operator()(pres pres_type, int set) -> const Char* {
-      if (!in(arg_type, set)) {
-        if (arg_type == type::none_type) return begin;
-        throw_format_error("invalid format specifier");
-      }
-      specs.type = pres_type;
-      return begin + 1;
-    }
-  } parse_presentation_type{begin, specs, arg_type};
-
-  for (;;) {
-    switch (c) {
-    case '<':
-    case '>':
-    case '^':
-      enter_state(state::align);
-      specs.align = parse_align(c);
-      ++begin;
-      break;
-    case '+':
-    case '-':
-    case ' ':
-      if (arg_type == type::none_type) return begin;
-      enter_state(state::sign, in(arg_type, sint_set | float_set));
-      switch (c) {
-      case '+':
-        specs.sign = sign::plus;
-        break;
-      case '-':
-        specs.sign = sign::minus;
-        break;
-      case ' ':
-        specs.sign = sign::space;
-        break;
-      }
-      ++begin;
-      break;
-    case '#':
-      if (arg_type == type::none_type) return begin;
-      enter_state(state::hash, is_arithmetic_type(arg_type));
-      specs.alt = true;
-      ++begin;
-      break;
-    case '0':
-      enter_state(state::zero);
-      if (!is_arithmetic_type(arg_type)) {
-        if (arg_type == type::none_type) return begin;
-        throw_format_error("format specifier requires numeric argument");
-      }
-      if (specs.align == align::none) {
-        // Ignore 0 if align is specified for compatibility with std::format.
-        specs.align = align::numeric;
-        specs.fill[0] = Char('0');
-      }
-      ++begin;
-      break;
-    case '1':
-    case '2':
-    case '3':
-    case '4':
-    case '5':
-    case '6':
-    case '7':
-    case '8':
-    case '9':
-    case '{':
-      enter_state(state::width);
-      begin = parse_dynamic_spec(begin, end, specs.width, specs.width_ref, ctx);
-      break;
-    case '.':
-      if (arg_type == type::none_type) return begin;
-      enter_state(state::precision,
-                  in(arg_type, float_set | string_set | cstring_set));
-      begin = parse_precision(begin, end, specs.precision, specs.precision_ref,
-                              ctx);
-      break;
-    case 'L':
-      if (arg_type == type::none_type) return begin;
-      enter_state(state::locale, is_arithmetic_type(arg_type));
-      specs.localized = true;
-      ++begin;
-      break;
-    case 'd':
-      return parse_presentation_type(pres::dec, integral_set);
-    case 'o':
-      return parse_presentation_type(pres::oct, integral_set);
-    case 'x':
-      return parse_presentation_type(pres::hex_lower, integral_set);
-    case 'X':
-      return parse_presentation_type(pres::hex_upper, integral_set);
-    case 'b':
-      return parse_presentation_type(pres::bin_lower, integral_set);
-    case 'B':
-      return parse_presentation_type(pres::bin_upper, integral_set);
-    case 'a':
-      return parse_presentation_type(pres::hexfloat_lower, float_set);
-    case 'A':
-      return parse_presentation_type(pres::hexfloat_upper, float_set);
-    case 'e':
-      return parse_presentation_type(pres::exp_lower, float_set);
-    case 'E':
-      return parse_presentation_type(pres::exp_upper, float_set);
-    case 'f':
-      return parse_presentation_type(pres::fixed_lower, float_set);
-    case 'F':
-      return parse_presentation_type(pres::fixed_upper, float_set);
-    case 'g':
-      return parse_presentation_type(pres::general_lower, float_set);
-    case 'G':
-      return parse_presentation_type(pres::general_upper, float_set);
-    case 'c':
-      if (arg_type == type::bool_type)
-        throw_format_error("invalid format specifier");
-      return parse_presentation_type(pres::chr, integral_set);
-    case 's':
-      return parse_presentation_type(pres::string,
-                                     bool_set | string_set | cstring_set);
-    case 'p':
-      return parse_presentation_type(pres::pointer, pointer_set | cstring_set);
-    case '?':
-      return parse_presentation_type(pres::debug,
-                                     char_set | string_set | cstring_set);
-    case '}':
-      return begin;
-    default: {
-      if (*begin == '}') return begin;
-      // Parse fill and alignment.
-      auto fill_end = begin + code_point_length(begin);
-      if (end - fill_end <= 0) {
-        throw_format_error("invalid format specifier");
-        return begin;
-      }
-      if (*begin == '{') {
-        throw_format_error("invalid fill character '{'");
-        return begin;
-      }
-      auto align = parse_align(to_ascii(*fill_end));
-      enter_state(state::align, align != align::none);
-      specs.fill = {begin, to_unsigned(fill_end - begin)};
-      specs.align = align;
-      begin = fill_end + 1;
-    }
-    }
-    if (begin == end) return begin;
-    c = to_ascii(*begin);
-  }
-}
-
-template <typename Char, typename Handler>
-FMT_CONSTEXPR auto parse_replacement_field(const Char* begin, const Char* end,
-                                           Handler&& handler) -> const Char* {
-  struct id_adapter {
-    Handler& handler;
-    int arg_id;
-
-    FMT_CONSTEXPR void on_auto() { arg_id = handler.on_arg_id(); }
-    FMT_CONSTEXPR void on_index(int id) { arg_id = handler.on_arg_id(id); }
-    FMT_CONSTEXPR void on_name(basic_string_view<Char> id) {
-      arg_id = handler.on_arg_id(id);
-    }
-  };
-
-  ++begin;
-  if (begin == end) return handler.on_error("invalid format string"), end;
-  if (*begin == '}') {
-    handler.on_replacement_field(handler.on_arg_id(), begin);
-  } else if (*begin == '{') {
-    handler.on_text(begin, begin + 1);
-  } else {
-    auto adapter = id_adapter{handler, 0};
-    begin = parse_arg_id(begin, end, adapter);
-    Char c = begin != end ? *begin : Char();
-    if (c == '}') {
-      handler.on_replacement_field(adapter.arg_id, begin);
-    } else if (c == ':') {
-      begin = handler.on_format_specs(adapter.arg_id, begin + 1, end);
-      if (begin == end || *begin != '}')
-        return handler.on_error("unknown format specifier"), end;
-    } else {
-      return handler.on_error("missing '}' in format string"), end;
-    }
-  }
-  return begin + 1;
-}
-
-template <bool IS_CONSTEXPR, typename Char, typename Handler>
-FMT_CONSTEXPR FMT_INLINE void parse_format_string(
-    basic_string_view<Char> format_str, Handler&& handler) {
-  auto begin = format_str.data();
-  auto end = begin + format_str.size();
-  if (end - begin < 32) {
-    // Use a simple loop instead of memchr for small strings.
-    const Char* p = begin;
-    while (p != end) {
-      auto c = *p++;
-      if (c == '{') {
-        handler.on_text(begin, p - 1);
-        begin = p = parse_replacement_field(p - 1, end, handler);
-      } else if (c == '}') {
-        if (p == end || *p != '}')
-          return handler.on_error("unmatched '}' in format string");
-        handler.on_text(begin, p);
-        begin = ++p;
-      }
-    }
-    handler.on_text(begin, end);
-    return;
-  }
-  struct writer {
-    FMT_CONSTEXPR void operator()(const Char* from, const Char* to) {
-      if (from == to) return;
-      for (;;) {
-        const Char* p = nullptr;
-        if (!find<IS_CONSTEXPR>(from, to, Char('}'), p))
-          return handler_.on_text(from, to);
-        ++p;
-        if (p == to || *p != '}')
-          return handler_.on_error("unmatched '}' in format string");
-        handler_.on_text(from, p);
-        from = p + 1;
-      }
-    }
-    Handler& handler_;
-  } write = {handler};
-  while (begin != end) {
-    // Doing two passes with memchr (one for '{' and another for '}') is up to
-    // 2.5x faster than the naive one-pass implementation on big format strings.
-    const Char* p = begin;
-    if (*begin != '{' && !find<IS_CONSTEXPR>(begin + 1, end, Char('{'), p))
-      return write(begin, end);
-    write(begin, p);
-    begin = parse_replacement_field(p, end, handler);
-  }
-}
-
-template <typename T, bool = is_named_arg<T>::value> struct strip_named_arg {
-  using type = T;
-};
-template <typename T> struct strip_named_arg<T, true> {
-  using type = remove_cvref_t<decltype(T::value)>;
-};
-
-template <typename T, typename ParseContext>
-FMT_CONSTEXPR auto parse_format_specs(ParseContext& ctx)
-    -> decltype(ctx.begin()) {
-  using char_type = typename ParseContext::char_type;
-  using context = buffer_context<char_type>;
-  using mapped_type = conditional_t<
-      mapped_type_constant<T, context>::value != type::custom_type,
-      decltype(arg_mapper<context>().map(std::declval<const T&>())),
-      typename strip_named_arg<T>::type>;
-#if defined(__cpp_if_constexpr)
-  if constexpr (std::is_default_constructible<
-                    formatter<mapped_type, char_type>>::value) {
-    return formatter<mapped_type, char_type>().parse(ctx);
-  } else {
-    type_is_unformattable_for<T, char_type> _;
-    return ctx.begin();
-  }
-#else
-  return formatter<mapped_type, char_type>().parse(ctx);
-#endif
-}
-
-// Checks char specs and returns true iff the presentation type is char-like.
-template <typename Char>
-FMT_CONSTEXPR auto check_char_specs(const format_specs<Char>& specs) -> bool {
-  if (specs.type != presentation_type::none &&
-      specs.type != presentation_type::chr &&
-      specs.type != presentation_type::debug) {
-    return false;
-  }
-  if (specs.align == align::numeric || specs.sign != sign::none || specs.alt)
-    throw_format_error("invalid format specifier for char");
-  return true;
-}
-
-#if FMT_USE_NONTYPE_TEMPLATE_ARGS
-template <int N, typename T, typename... Args, typename Char>
-constexpr auto get_arg_index_by_name(basic_string_view<Char> name) -> int {
-  if constexpr (is_statically_named_arg<T>()) {
-    if (name == T::name) return N;
-  }
-  if constexpr (sizeof...(Args) > 0)
-    return get_arg_index_by_name<N + 1, Args...>(name);
-  (void)name;  // Workaround an MSVC bug about "unused" parameter.
-  return -1;
-}
-#endif
-
-template <typename... Args, typename Char>
-FMT_CONSTEXPR auto get_arg_index_by_name(basic_string_view<Char> name) -> int {
-#if FMT_USE_NONTYPE_TEMPLATE_ARGS
-  if constexpr (sizeof...(Args) > 0)
-    return get_arg_index_by_name<0, Args...>(name);
-#endif
-  (void)name;
-  return -1;
-}
-
-template <typename Char, typename... Args> class format_string_checker {
- private:
-  using parse_context_type = compile_parse_context<Char>;
-  static constexpr int num_args = sizeof...(Args);
-
-  // Format specifier parsing function.
-  // In the future basic_format_parse_context will replace compile_parse_context
-  // here and will use is_constant_evaluated and downcasting to access the data
-  // needed for compile-time checks: https://godbolt.org/z/GvWzcTjh1.
-  using parse_func = const Char* (*)(parse_context_type&);
-
-  type types_[num_args > 0 ? static_cast<size_t>(num_args) : 1];
-  parse_context_type context_;
-  parse_func parse_funcs_[num_args > 0 ? static_cast<size_t>(num_args) : 1];
-
- public:
-  explicit FMT_CONSTEXPR format_string_checker(basic_string_view<Char> fmt)
-      : types_{mapped_type_constant<Args, buffer_context<Char>>::value...},
-        context_(fmt, num_args, types_),
-        parse_funcs_{&parse_format_specs<Args, parse_context_type>...} {}
-
-  FMT_CONSTEXPR void on_text(const Char*, const Char*) {}
-
-  FMT_CONSTEXPR auto on_arg_id() -> int { return context_.next_arg_id(); }
-  FMT_CONSTEXPR auto on_arg_id(int id) -> int {
-    return context_.check_arg_id(id), id;
-  }
-  FMT_CONSTEXPR auto on_arg_id(basic_string_view<Char> id) -> int {
-#if FMT_USE_NONTYPE_TEMPLATE_ARGS
-    auto index = get_arg_index_by_name<Args...>(id);
-    if (index < 0) on_error("named argument is not found");
-    return index;
-#else
-    (void)id;
-    on_error("compile-time checks for named arguments require C++20 support");
-    return 0;
-#endif
-  }
-
-  FMT_CONSTEXPR void on_replacement_field(int id, const Char* begin) {
-    on_format_specs(id, begin, begin);  // Call parse() on empty specs.
-  }
-
-  FMT_CONSTEXPR auto on_format_specs(int id, const Char* begin, const Char*)
-      -> const Char* {
-    context_.advance_to(begin);
-    // id >= 0 check is a workaround for gcc 10 bug (#2065).
-    return id >= 0 && id < num_args ? parse_funcs_[id](context_) : begin;
-  }
-
-  FMT_CONSTEXPR void on_error(const char* message) {
-    throw_format_error(message);
-  }
-};
-
-// Reports a compile-time error if S is not a valid format string.
-template <typename..., typename S, FMT_ENABLE_IF(!is_compile_string<S>::value)>
-FMT_INLINE void check_format_string(const S&) {
-#ifdef FMT_ENFORCE_COMPILE_STRING
-  static_assert(is_compile_string<S>::value,
-                "FMT_ENFORCE_COMPILE_STRING requires all format strings to use "
-                "FMT_STRING.");
-#endif
-}
-template <typename... Args, typename S,
-          FMT_ENABLE_IF(is_compile_string<S>::value)>
-void check_format_string(S format_str) {
-  using char_t = typename S::char_type;
-  FMT_CONSTEXPR auto s = basic_string_view<char_t>(format_str);
-  using checker = format_string_checker<char_t, remove_cvref_t<Args>...>;
-  FMT_CONSTEXPR bool error = (parse_format_string<true>(s, checker(s)), true);
-  ignore_unused(error);
-}
-
-template <typename Char = char> struct vformat_args {
-  using type = basic_format_args<
-      basic_format_context<std::back_insert_iterator<buffer<Char>>, Char>>;
-};
-template <> struct vformat_args<char> {
-  using type = format_args;
-};
-
-// Use vformat_args and avoid type_identity to keep symbols short.
-template <typename Char>
-void vformat_to(buffer<Char>& buf, basic_string_view<Char> fmt,
-                typename vformat_args<Char>::type args, locale_ref loc = {});
-
-FMT_API void vprint_mojibake(std::FILE*, string_view, format_args);
-#ifndef _WIN32
-inline void vprint_mojibake(std::FILE*, string_view, format_args) {}
-#endif
-}  // namespace detail
-
-FMT_BEGIN_EXPORT
-
-// A formatter specialization for natively supported types.
-template <typename T, typename Char>
-struct formatter<T, Char,
-                 enable_if_t<detail::type_constant<T, Char>::value !=
-                             detail::type::custom_type>> {
- private:
-  detail::dynamic_format_specs<Char> specs_;
-
- public:
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> const Char* {
-    auto type = detail::type_constant<T, Char>::value;
-    auto end =
-        detail::parse_format_specs(ctx.begin(), ctx.end(), specs_, ctx, type);
-    if (type == detail::type::char_type) detail::check_char_specs(specs_);
-    return end;
-  }
-
-  template <detail::type U = detail::type_constant<T, Char>::value,
-            FMT_ENABLE_IF(U == detail::type::string_type ||
-                          U == detail::type::cstring_type ||
-                          U == detail::type::char_type)>
-  FMT_CONSTEXPR void set_debug_format(bool set = true) {
-    specs_.type = set ? presentation_type::debug : presentation_type::none;
-  }
-
-  template <typename FormatContext>
-  FMT_CONSTEXPR auto format(const T& val, FormatContext& ctx) const
-      -> decltype(ctx.out());
-};
-
-template <typename Char = char> struct runtime_format_string {
-  basic_string_view<Char> str;
-};
-
-/** A compile-time format string. */
-template <typename Char, typename... Args> class basic_format_string {
- private:
-  basic_string_view<Char> str_;
-
- public:
-  template <typename S,
-            FMT_ENABLE_IF(
-                std::is_convertible<const S&, basic_string_view<Char>>::value)>
-  FMT_CONSTEVAL FMT_INLINE basic_format_string(const S& s) : str_(s) {
-    static_assert(
-        detail::count<
-            (std::is_base_of<detail::view, remove_reference_t<Args>>::value &&
-             std::is_reference<Args>::value)...>() == 0,
-        "passing views as lvalues is disallowed");
-#ifdef FMT_HAS_CONSTEVAL
-    if constexpr (detail::count_named_args<Args...>() ==
-                  detail::count_statically_named_args<Args...>()) {
-      using checker =
-          detail::format_string_checker<Char, remove_cvref_t<Args>...>;
-      detail::parse_format_string<true>(str_, checker(s));
-    }
-#else
-    detail::check_format_string<Args...>(s);
-#endif
-  }
-  basic_format_string(runtime_format_string<Char> fmt) : str_(fmt.str) {}
-
-  FMT_INLINE operator basic_string_view<Char>() const { return str_; }
-  FMT_INLINE auto get() const -> basic_string_view<Char> { return str_; }
-};
-
-#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
-// Workaround broken conversion on older gcc.
-template <typename...> using format_string = string_view;
-inline auto runtime(string_view s) -> string_view { return s; }
-#else
-template <typename... Args>
-using format_string = basic_format_string<char, type_identity_t<Args>...>;
-/**
-  \rst
-  Creates a runtime format string.
-
-  **Example**::
-
-    // Check format string at runtime instead of compile-time.
-    fmt::print(fmt::runtime("{:d}"), "I am not a number");
-  \endrst
- */
-inline auto runtime(string_view s) -> runtime_format_string<> { return {{s}}; }
-#endif
-
-FMT_API auto vformat(string_view fmt, format_args args) -> std::string;
-
-/**
-  \rst
-  Formats ``args`` according to specifications in ``fmt`` and returns the result
-  as a string.
-
-  **Example**::
-
-    #include <fmt/core.h>
-    std::string message = fmt::format("The answer is {}.", 42);
-  \endrst
-*/
-template <typename... T>
-FMT_NODISCARD FMT_INLINE auto format(format_string<T...> fmt, T&&... args)
-    -> std::string {
-  return vformat(fmt, fmt::make_format_args(args...));
-}
-
-/** Formats a string and writes the output to ``out``. */
-template <typename OutputIt,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
-auto vformat_to(OutputIt out, string_view fmt, format_args args) -> OutputIt {
-  auto&& buf = detail::get_buffer<char>(out);
-  detail::vformat_to(buf, fmt, args, {});
-  return detail::get_iterator(buf, out);
-}
-
-/**
- \rst
- Formats ``args`` according to specifications in ``fmt``, writes the result to
- the output iterator ``out`` and returns the iterator past the end of the output
- range. `format_to` does not append a terminating null character.
-
- **Example**::
-
-   auto out = std::vector<char>();
-   fmt::format_to(std::back_inserter(out), "{}", 42);
- \endrst
- */
-template <typename OutputIt, typename... T,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
-FMT_INLINE auto format_to(OutputIt out, format_string<T...> fmt, T&&... args)
-    -> OutputIt {
-  return vformat_to(out, fmt, fmt::make_format_args(args...));
-}
-
-template <typename OutputIt> struct format_to_n_result {
-  /** Iterator past the end of the output range. */
-  OutputIt out;
-  /** Total (not truncated) output size. */
-  size_t size;
-};
-
-template <typename OutputIt, typename... T,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
-auto vformat_to_n(OutputIt out, size_t n, string_view fmt, format_args args)
-    -> format_to_n_result<OutputIt> {
-  using traits = detail::fixed_buffer_traits;
-  auto buf = detail::iterator_buffer<OutputIt, char, traits>(out, n);
-  detail::vformat_to(buf, fmt, args, {});
-  return {buf.out(), buf.count()};
-}
-
-/**
-  \rst
-  Formats ``args`` according to specifications in ``fmt``, writes up to ``n``
-  characters of the result to the output iterator ``out`` and returns the total
-  (not truncated) output size and the iterator past the end of the output range.
-  `format_to_n` does not append a terminating null character.
-  \endrst
- */
-template <typename OutputIt, typename... T,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
-FMT_INLINE auto format_to_n(OutputIt out, size_t n, format_string<T...> fmt,
-                            T&&... args) -> format_to_n_result<OutputIt> {
-  return vformat_to_n(out, n, fmt, fmt::make_format_args(args...));
-}
-
-/** Returns the number of chars in the output of ``format(fmt, args...)``. */
-template <typename... T>
-FMT_NODISCARD FMT_INLINE auto formatted_size(format_string<T...> fmt,
-                                             T&&... args) -> size_t {
-  auto buf = detail::counting_buffer<>();
-  detail::vformat_to<char>(buf, fmt, fmt::make_format_args(args...), {});
-  return buf.count();
-}
-
-FMT_API void vprint(string_view fmt, format_args args);
-FMT_API void vprint(std::FILE* f, string_view fmt, format_args args);
-
-/**
-  \rst
-  Formats ``args`` according to specifications in ``fmt`` and writes the output
-  to ``stdout``.
-
-  **Example**::
-
-    fmt::print("Elapsed time: {0:.2f} seconds", 1.23);
-  \endrst
- */
-template <typename... T>
-FMT_INLINE void print(format_string<T...> fmt, T&&... args) {
-  const auto& vargs = fmt::make_format_args(args...);
-  return detail::is_utf8() ? vprint(fmt, vargs)
-                           : detail::vprint_mojibake(stdout, fmt, vargs);
-}
-
-/**
-  \rst
-  Formats ``args`` according to specifications in ``fmt`` and writes the
-  output to the file ``f``.
-
-  **Example**::
-
-    fmt::print(stderr, "Don't {}!", "panic");
-  \endrst
- */
-template <typename... T>
-FMT_INLINE void print(std::FILE* f, format_string<T...> fmt, T&&... args) {
-  const auto& vargs = fmt::make_format_args(args...);
-  return detail::is_utf8() ? vprint(f, fmt, vargs)
-                           : detail::vprint_mojibake(f, fmt, vargs);
-}
-
-/**
-  Formats ``args`` according to specifications in ``fmt`` and writes the
-  output to the file ``f`` followed by a newline.
- */
-template <typename... T>
-FMT_INLINE void println(std::FILE* f, format_string<T...> fmt, T&&... args) {
-  return fmt::print(f, "{}\n", fmt::format(fmt, std::forward<T>(args)...));
-}
-
-/**
-  Formats ``args`` according to specifications in ``fmt`` and writes the output
-  to ``stdout`` followed by a newline.
- */
-template <typename... T>
-FMT_INLINE void println(format_string<T...> fmt, T&&... args) {
-  return fmt::println(stdout, fmt, std::forward<T>(args)...);
-}
-
-FMT_END_EXPORT
-FMT_GCC_PRAGMA("GCC pop_options")
-FMT_END_NAMESPACE
-
-#ifdef FMT_HEADER_ONLY
-#  include "format.h"
-#endif
-#endif  // FMT_CORE_H_
+#include "format.h"
diff --git a/3rdparty/fmt/include/fmt/format-inl.h b/3rdparty/fmt/include/fmt/format-inl.h
index efac5d1f88fef..a5b79dbe49b5e 100644
--- a/3rdparty/fmt/include/fmt/format-inl.h
+++ b/3rdparty/fmt/include/fmt/format-inl.h
@@ -8,36 +8,36 @@
 #ifndef FMT_FORMAT_INL_H_
 #define FMT_FORMAT_INL_H_
 
-#include <algorithm>
-#include <cerrno>  // errno
-#include <climits>
-#include <cmath>
-#include <exception>
-
-#ifndef FMT_STATIC_THOUSANDS_SEPARATOR
-#  include <locale>
+#ifndef FMT_MODULE
+#  include <algorithm>
+#  include <cerrno>  // errno
+#  include <climits>
+#  include <cmath>
+#  include <exception>
 #endif
 
-#if defined(_WIN32) && !defined(FMT_WINDOWS_NO_WCHAR)
+#if defined(_WIN32) && !defined(FMT_USE_WRITE_CONSOLE)
 #  include <io.h>  // _isatty
 #endif
 
 #include "format.h"
 
+#if FMT_USE_LOCALE
+#  include <locale>
+#endif
+
+#ifndef FMT_FUNC
+#  define FMT_FUNC
+#endif
+
 FMT_BEGIN_NAMESPACE
 namespace detail {
 
 FMT_FUNC void assert_fail(const char* file, int line, const char* message) {
   // Use unchecked std::fprintf to avoid triggering another assertion when
-  // writing to stderr fails
-  std::fprintf(stderr, "%s:%d: assertion failed: %s", file, line, message);
-  // Chosen instead of std::abort to satisfy Clang in CUDA mode during device
-  // code pass.
-  std::terminate();
-}
-
-FMT_FUNC void throw_format_error(const char* message) {
-  FMT_THROW(format_error(message));
+  // writing to stderr fails.
+  fprintf(stderr, "%s:%d: assertion failed: %s", file, line, message);
+  abort();
 }
 
 FMT_FUNC void format_error_code(detail::buffer<char>& out, int error_code,
@@ -56,89 +56,105 @@ FMT_FUNC void format_error_code(detail::buffer<char>& out, int error_code,
     ++error_code_size;
   }
   error_code_size += detail::to_unsigned(detail::count_digits(abs_value));
-  auto it = buffer_appender<char>(out);
+  auto it = appender(out);
   if (message.size() <= inline_buffer_size - error_code_size)
     fmt::format_to(it, FMT_STRING("{}{}"), message, SEP);
   fmt::format_to(it, FMT_STRING("{}{}"), ERROR_STR, error_code);
   FMT_ASSERT(out.size() <= inline_buffer_size, "");
 }
 
-FMT_FUNC void report_error(format_func func, int error_code,
-                           const char* message) noexcept {
+FMT_FUNC void do_report_error(format_func func, int error_code,
+                              const char* message) noexcept {
   memory_buffer full_message;
   func(full_message, error_code, message);
-  // Don't use fwrite_fully because the latter may throw.
+  // Don't use fwrite_all because the latter may throw.
   if (std::fwrite(full_message.data(), full_message.size(), 1, stderr) > 0)
     std::fputc('\n', stderr);
 }
 
 // A wrapper around fwrite that throws on error.
-inline void fwrite_fully(const void* ptr, size_t count, FILE* stream) {
+inline void fwrite_all(const void* ptr, size_t count, FILE* stream) {
   size_t written = std::fwrite(ptr, 1, count, stream);
   if (written < count)
     FMT_THROW(system_error(errno, FMT_STRING("cannot write to file")));
 }
 
-#ifndef FMT_STATIC_THOUSANDS_SEPARATOR
+#if FMT_USE_LOCALE
+using std::locale;
+using std::numpunct;
+using std::use_facet;
+
 template <typename Locale>
 locale_ref::locale_ref(const Locale& loc) : locale_(&loc) {
-  static_assert(std::is_same<Locale, std::locale>::value, "");
+  static_assert(std::is_same<Locale, locale>::value, "");
 }
+#else
+struct locale {};
+template <typename Char> struct numpunct {
+  auto grouping() const -> std::string { return "\03"; }
+  auto thousands_sep() const -> Char { return ','; }
+  auto decimal_point() const -> Char { return '.'; }
+};
+template <typename Facet> Facet use_facet(locale) { return {}; }
+#endif  // FMT_USE_LOCALE
 
 template <typename Locale> auto locale_ref::get() const -> Locale {
-  static_assert(std::is_same<Locale, std::locale>::value, "");
-  return locale_ ? *static_cast<const std::locale*>(locale_) : std::locale();
+  static_assert(std::is_same<Locale, locale>::value, "");
+#if FMT_USE_LOCALE
+  if (locale_) return *static_cast<const locale*>(locale_);
+#endif
+  return locale();
 }
 
 template <typename Char>
 FMT_FUNC auto thousands_sep_impl(locale_ref loc) -> thousands_sep_result<Char> {
-  auto& facet = std::use_facet<std::numpunct<Char>>(loc.get<std::locale>());
+  auto&& facet = use_facet<numpunct<Char>>(loc.get<locale>());
   auto grouping = facet.grouping();
   auto thousands_sep = grouping.empty() ? Char() : facet.thousands_sep();
   return {std::move(grouping), thousands_sep};
 }
 template <typename Char>
 FMT_FUNC auto decimal_point_impl(locale_ref loc) -> Char {
-  return std::use_facet<std::numpunct<Char>>(loc.get<std::locale>())
-      .decimal_point();
+  return use_facet<numpunct<Char>>(loc.get<locale>()).decimal_point();
 }
-#else
-template <typename Char>
-FMT_FUNC auto thousands_sep_impl(locale_ref) -> thousands_sep_result<Char> {
-  return {"\03", FMT_STATIC_THOUSANDS_SEPARATOR};
-}
-template <typename Char> FMT_FUNC Char decimal_point_impl(locale_ref) {
-  return '.';
-}
-#endif
 
+#if FMT_USE_LOCALE
 FMT_FUNC auto write_loc(appender out, loc_value value,
-                        const format_specs<>& specs, locale_ref loc) -> bool {
-#ifndef FMT_STATIC_THOUSANDS_SEPARATOR
+                        const format_specs& specs, locale_ref loc) -> bool {
   auto locale = loc.get<std::locale>();
   // We cannot use the num_put<char> facet because it may produce output in
   // a wrong encoding.
   using facet = format_facet<std::locale>;
   if (std::has_facet<facet>(locale))
-    return std::use_facet<facet>(locale).put(out, value, specs);
+    return use_facet<facet>(locale).put(out, value, specs);
   return facet(locale).put(out, value, specs);
-#endif
-  return false;
 }
+#endif
 }  // namespace detail
 
+FMT_FUNC void report_error(const char* message) {
+#if FMT_USE_EXCEPTIONS
+  // Use FMT_THROW instead of throw to avoid bogus unreachable code warnings
+  // from MSVC.
+  FMT_THROW(format_error(message));
+#else
+  fputs(message, stderr);
+  abort();
+#endif
+}
+
 template <typename Locale> typename Locale::id format_facet<Locale>::id;
 
-#ifndef FMT_STATIC_THOUSANDS_SEPARATOR
 template <typename Locale> format_facet<Locale>::format_facet(Locale& loc) {
-  auto& numpunct = std::use_facet<std::numpunct<char>>(loc);
-  grouping_ = numpunct.grouping();
-  if (!grouping_.empty()) separator_ = std::string(1, numpunct.thousands_sep());
+  auto& np = detail::use_facet<detail::numpunct<char>>(loc);
+  grouping_ = np.grouping();
+  if (!grouping_.empty()) separator_ = std::string(1, np.thousands_sep());
 }
 
+#if FMT_USE_LOCALE
 template <>
 FMT_API FMT_FUNC auto format_facet<std::locale>::do_put(
-    appender out, loc_value val, const format_specs<>& specs) const -> bool {
+    appender out, loc_value val, const format_specs& specs) const -> bool {
   return val.visit(
       detail::loc_writer<>{out, specs, separator_, grouping_, decimal_point_});
 }
@@ -1411,7 +1427,7 @@ FMT_FUNC void format_system_error(detail::buffer<char>& out, int error_code,
                                   const char* message) noexcept {
   FMT_TRY {
     auto ec = std::error_code(error_code, std::generic_category());
-    write(std::back_inserter(out), std::system_error(ec, message).what());
+    detail::write(appender(out), std::system_error(ec, message).what());
     return;
   }
   FMT_CATCH(...) {}
@@ -1420,7 +1436,7 @@ FMT_FUNC void format_system_error(detail::buffer<char>& out, int error_code,
 
 FMT_FUNC void report_system_error(int error_code,
                                   const char* message) noexcept {
-  report_error(format_system_error, error_code, message);
+  do_report_error(format_system_error, error_code, message);
 }
 
 FMT_FUNC auto vformat(string_view fmt, format_args args) -> std::string {
@@ -1432,9 +1448,252 @@ FMT_FUNC auto vformat(string_view fmt, format_args args) -> std::string {
 }
 
 namespace detail {
-#if !defined(_WIN32) || defined(FMT_WINDOWS_NO_WCHAR)
+
+FMT_FUNC void vformat_to(buffer<char>& buf, string_view fmt, format_args args,
+                         locale_ref loc) {
+  auto out = appender(buf);
+  if (fmt.size() == 2 && equal2(fmt.data(), "{}"))
+    return args.get(0).visit(default_arg_formatter<char>{out});
+  parse_format_string(
+      fmt, format_handler<char>{parse_context<char>(fmt), {out, args, loc}});
+}
+
+template <typename T> struct span {
+  T* data;
+  size_t size;
+};
+
+template <typename F> auto flockfile(F* f) -> decltype(_lock_file(f)) {
+  _lock_file(f);
+}
+template <typename F> auto funlockfile(F* f) -> decltype(_unlock_file(f)) {
+  _unlock_file(f);
+}
+
+#ifndef getc_unlocked
+template <typename F> auto getc_unlocked(F* f) -> decltype(_fgetc_nolock(f)) {
+  return _fgetc_nolock(f);
+}
+#endif
+
+template <typename F = FILE, typename Enable = void>
+struct has_flockfile : std::false_type {};
+
+template <typename F>
+struct has_flockfile<F, void_t<decltype(flockfile(&std::declval<F&>()))>>
+    : std::true_type {};
+
+// A FILE wrapper. F is FILE defined as a template parameter to make system API
+// detection work.
+template <typename F> class file_base {
+ public:
+  F* file_;
+
+ public:
+  file_base(F* file) : file_(file) {}
+  operator F*() const { return file_; }
+
+  // Reads a code unit from the stream.
+  auto get() -> int {
+    int result = getc_unlocked(file_);
+    if (result == EOF && ferror(file_) != 0)
+      FMT_THROW(system_error(errno, FMT_STRING("getc failed")));
+    return result;
+  }
+
+  // Puts the code unit back into the stream buffer.
+  void unget(char c) {
+    if (ungetc(c, file_) == EOF)
+      FMT_THROW(system_error(errno, FMT_STRING("ungetc failed")));
+  }
+
+  void flush() { fflush(this->file_); }
+};
+
+// A FILE wrapper for glibc.
+template <typename F> class glibc_file : public file_base<F> {
+ private:
+  enum {
+    line_buffered = 0x200,  // _IO_LINE_BUF
+    unbuffered = 2          // _IO_UNBUFFERED
+  };
+
+ public:
+  using file_base<F>::file_base;
+
+  auto is_buffered() const -> bool {
+    return (this->file_->_flags & unbuffered) == 0;
+  }
+
+  void init_buffer() {
+    if (this->file_->_IO_write_ptr) return;
+    // Force buffer initialization by placing and removing a char in a buffer.
+    assume(this->file_->_IO_write_ptr >= this->file_->_IO_write_end);
+    putc_unlocked(0, this->file_);
+    --this->file_->_IO_write_ptr;
+  }
+
+  // Returns the file's read buffer.
+  auto get_read_buffer() const -> span<const char> {
+    auto ptr = this->file_->_IO_read_ptr;
+    return {ptr, to_unsigned(this->file_->_IO_read_end - ptr)};
+  }
+
+  // Returns the file's write buffer.
+  auto get_write_buffer() const -> span<char> {
+    auto ptr = this->file_->_IO_write_ptr;
+    return {ptr, to_unsigned(this->file_->_IO_buf_end - ptr)};
+  }
+
+  void advance_write_buffer(size_t size) { this->file_->_IO_write_ptr += size; }
+
+  bool needs_flush() const {
+    if ((this->file_->_flags & line_buffered) == 0) return false;
+    char* end = this->file_->_IO_write_end;
+    return memchr(end, '\n', to_unsigned(this->file_->_IO_write_ptr - end));
+  }
+
+  void flush() { fflush_unlocked(this->file_); }
+};
+
+// A FILE wrapper for Apple's libc.
+template <typename F> class apple_file : public file_base<F> {
+ private:
+  enum {
+    line_buffered = 1,  // __SNBF
+    unbuffered = 2      // __SLBF
+  };
+
+ public:
+  using file_base<F>::file_base;
+
+  auto is_buffered() const -> bool {
+    return (this->file_->_flags & unbuffered) == 0;
+  }
+
+  void init_buffer() {
+    if (this->file_->_p) return;
+    // Force buffer initialization by placing and removing a char in a buffer.
+    putc_unlocked(0, this->file_);
+    --this->file_->_p;
+    ++this->file_->_w;
+  }
+
+  auto get_read_buffer() const -> span<const char> {
+    return {reinterpret_cast<char*>(this->file_->_p),
+            to_unsigned(this->file_->_r)};
+  }
+
+  auto get_write_buffer() const -> span<char> {
+    return {reinterpret_cast<char*>(this->file_->_p),
+            to_unsigned(this->file_->_bf._base + this->file_->_bf._size -
+                        this->file_->_p)};
+  }
+
+  void advance_write_buffer(size_t size) {
+    this->file_->_p += size;
+    this->file_->_w -= size;
+  }
+
+  bool needs_flush() const {
+    if ((this->file_->_flags & line_buffered) == 0) return false;
+    return memchr(this->file_->_p + this->file_->_w, '\n',
+                  to_unsigned(-this->file_->_w));
+  }
+};
+
+// A fallback FILE wrapper.
+template <typename F> class fallback_file : public file_base<F> {
+ private:
+  char next_;  // The next unconsumed character in the buffer.
+  bool has_next_ = false;
+
+ public:
+  using file_base<F>::file_base;
+
+  auto is_buffered() const -> bool { return false; }
+  auto needs_flush() const -> bool { return false; }
+  void init_buffer() {}
+
+  auto get_read_buffer() const -> span<const char> {
+    return {&next_, has_next_ ? 1u : 0u};
+  }
+
+  auto get_write_buffer() const -> span<char> { return {nullptr, 0}; }
+
+  void advance_write_buffer(size_t) {}
+
+  auto get() -> int {
+    has_next_ = false;
+    return file_base<F>::get();
+  }
+
+  void unget(char c) {
+    file_base<F>::unget(c);
+    next_ = c;
+    has_next_ = true;
+  }
+};
+
+#ifndef FMT_USE_FALLBACK_FILE
+#  define FMT_USE_FALLBACK_FILE 0
+#endif
+
+template <typename F,
+          FMT_ENABLE_IF(sizeof(F::_p) != 0 && !FMT_USE_FALLBACK_FILE)>
+auto get_file(F* f, int) -> apple_file<F> {
+  return f;
+}
+template <typename F,
+          FMT_ENABLE_IF(sizeof(F::_IO_read_ptr) != 0 && !FMT_USE_FALLBACK_FILE)>
+inline auto get_file(F* f, int) -> glibc_file<F> {
+  return f;
+}
+
+inline auto get_file(FILE* f, ...) -> fallback_file<FILE> { return f; }
+
+using file_ref = decltype(get_file(static_cast<FILE*>(nullptr), 0));
+
+template <typename F = FILE, typename Enable = void>
+class file_print_buffer : public buffer<char> {
+ public:
+  explicit file_print_buffer(F*) : buffer(nullptr, size_t()) {}
+};
+
+template <typename F>
+class file_print_buffer<F, enable_if_t<has_flockfile<F>::value>>
+    : public buffer<char> {
+ private:
+  file_ref file_;
+
+  static void grow(buffer<char>& base, size_t) {
+    auto& self = static_cast<file_print_buffer&>(base);
+    self.file_.advance_write_buffer(self.size());
+    if (self.file_.get_write_buffer().size == 0) self.file_.flush();
+    auto buf = self.file_.get_write_buffer();
+    FMT_ASSERT(buf.size > 0, "");
+    self.set(buf.data, buf.size);
+    self.clear();
+  }
+
+ public:
+  explicit file_print_buffer(F* f) : buffer(grow, size_t()), file_(f) {
+    flockfile(f);
+    file_.init_buffer();
+    auto buf = file_.get_write_buffer();
+    set(buf.data, buf.size);
+  }
+  ~file_print_buffer() {
+    file_.advance_write_buffer(size());
+    bool flush = file_.needs_flush();
+    F* f = file_;    // Make funlockfile depend on the template parameter F
+    funlockfile(f);  // for the system API detection to work.
+    if (flush) fflush(file_);
+  }
+};
+
+#if !defined(_WIN32) || defined(FMT_USE_WRITE_CONSOLE)
 FMT_FUNC auto write_console(int, string_view) -> bool { return false; }
-FMT_FUNC auto write_console(std::FILE*, string_view) -> bool { return false; }
 #else
 using dword = conditional_t<sizeof(long) == 4, unsigned long, unsigned>;
 extern "C" __declspec(dllimport) int __stdcall WriteConsoleW(  //
@@ -1445,36 +1704,48 @@ FMT_FUNC bool write_console(int fd, string_view text) {
   return WriteConsoleW(reinterpret_cast<void*>(_get_osfhandle(fd)), u16.c_str(),
                        static_cast<dword>(u16.size()), nullptr, nullptr) != 0;
 }
-
-FMT_FUNC auto write_console(std::FILE* f, string_view text) -> bool {
-  return write_console(_fileno(f), text);
-}
 #endif
 
 #ifdef _WIN32
 // Print assuming legacy (non-Unicode) encoding.
-FMT_FUNC void vprint_mojibake(std::FILE* f, string_view fmt, format_args args) {
+FMT_FUNC void vprint_mojibake(std::FILE* f, string_view fmt, format_args args,
+                              bool newline) {
   auto buffer = memory_buffer();
   detail::vformat_to(buffer, fmt, args);
-  fwrite_fully(buffer.data(), buffer.size(), f);
+  if (newline) buffer.push_back('\n');
+  fwrite_all(buffer.data(), buffer.size(), f);
 }
 #endif
 
 FMT_FUNC void print(std::FILE* f, string_view text) {
-#ifdef _WIN32
+#if defined(_WIN32) && !defined(FMT_USE_WRITE_CONSOLE)
   int fd = _fileno(f);
   if (_isatty(fd)) {
     std::fflush(f);
     if (write_console(fd, text)) return;
   }
 #endif
-  fwrite_fully(text.data(), text.size(), f);
+  fwrite_all(text.data(), text.size(), f);
 }
 }  // namespace detail
 
+FMT_FUNC void vprint_buffered(std::FILE* f, string_view fmt, format_args args) {
+  auto buffer = memory_buffer();
+  detail::vformat_to(buffer, fmt, args);
+  detail::print(f, {buffer.data(), buffer.size()});
+}
+
 FMT_FUNC void vprint(std::FILE* f, string_view fmt, format_args args) {
+  if (!detail::file_ref(f).is_buffered() || !detail::has_flockfile<>())
+    return vprint_buffered(f, fmt, args);
+  auto&& buffer = detail::file_print_buffer<>(f);
+  return detail::vformat_to(buffer, fmt, args);
+}
+
+FMT_FUNC void vprintln(std::FILE* f, string_view fmt, format_args args) {
   auto buffer = memory_buffer();
   detail::vformat_to(buffer, fmt, args);
+  buffer.push_back('\n');
   detail::print(f, {buffer.data(), buffer.size()});
 }
 
diff --git a/3rdparty/fmt/include/fmt/format.h b/3rdparty/fmt/include/fmt/format.h
index 7637c8a0d0687..92a1d5b7a04d5 100644
--- a/3rdparty/fmt/include/fmt/format.h
+++ b/3rdparty/fmt/include/fmt/format.h
@@ -33,20 +33,59 @@
 #ifndef FMT_FORMAT_H_
 #define FMT_FORMAT_H_
 
-#include <cmath>             // std::signbit
-#include <cstdint>           // uint32_t
-#include <cstring>           // std::memcpy
-#include <initializer_list>  // std::initializer_list
-#include <limits>            // std::numeric_limits
-#include <memory>            // std::uninitialized_copy
-#include <stdexcept>         // std::runtime_error
-#include <system_error>      // std::system_error
-
-#ifdef __cpp_lib_bit_cast
-#  include <bit>  // std::bit_cast
+#ifndef _LIBCPP_REMOVE_TRANSITIVE_INCLUDES
+#  define _LIBCPP_REMOVE_TRANSITIVE_INCLUDES
+#  define FMT_REMOVE_TRANSITIVE_INCLUDES
 #endif
 
-#include "core.h"
+#include "base.h"
+
+#ifndef FMT_MODULE
+#  include <cmath>    // std::signbit
+#  include <cstddef>  // std::byte
+#  include <cstdint>  // uint32_t
+#  include <cstring>  // std::memcpy
+#  include <limits>   // std::numeric_limits
+#  include <new>      // std::bad_alloc
+#  if defined(__GLIBCXX__) && !defined(_GLIBCXX_USE_DUAL_ABI)
+// Workaround for pre gcc 5 libstdc++.
+#    include <memory>  // std::allocator_traits
+#  endif
+#  include <stdexcept>     // std::runtime_error
+#  include <string>        // std::string
+#  include <system_error>  // std::system_error
+
+// Check FMT_CPLUSPLUS to avoid a warning in MSVC.
+#  if FMT_HAS_INCLUDE(<bit>) && FMT_CPLUSPLUS > 201703L
+#    include <bit>  // std::bit_cast
+#  endif
+
+// libc++ supports string_view in pre-c++17.
+#  if FMT_HAS_INCLUDE(<string_view>) && \
+      (FMT_CPLUSPLUS >= 201703L || defined(_LIBCPP_VERSION))
+#    include <string_view>
+#    define FMT_USE_STRING_VIEW
+#  endif
+
+#  if FMT_MSC_VERSION
+#    include <intrin.h>  // _BitScanReverse[64], _umul128
+#  endif
+#endif  // FMT_MODULE
+
+#if defined(FMT_USE_NONTYPE_TEMPLATE_ARGS)
+// Use the provided definition.
+#elif defined(__NVCOMPILER)
+#  define FMT_USE_NONTYPE_TEMPLATE_ARGS 0
+#elif FMT_GCC_VERSION >= 903 && FMT_CPLUSPLUS >= 201709L
+#  define FMT_USE_NONTYPE_TEMPLATE_ARGS 1
+#elif defined(__cpp_nontype_template_args) && \
+    __cpp_nontype_template_args >= 201911L
+#  define FMT_USE_NONTYPE_TEMPLATE_ARGS 1
+#elif FMT_CLANG_VERSION >= 1200 && FMT_CPLUSPLUS >= 202002L
+#  define FMT_USE_NONTYPE_TEMPLATE_ARGS 1
+#else
+#  define FMT_USE_NONTYPE_TEMPLATE_ARGS 0
+#endif
 
 #if defined __cpp_inline_variables && __cpp_inline_variables >= 201606L
 #  define FMT_INLINE_VARIABLE inline
@@ -54,43 +93,15 @@
 #  define FMT_INLINE_VARIABLE
 #endif
 
-#if FMT_HAS_CPP17_ATTRIBUTE(fallthrough)
-#  define FMT_FALLTHROUGH [[fallthrough]]
-#elif defined(__clang__)
-#  define FMT_FALLTHROUGH [[clang::fallthrough]]
-#elif FMT_GCC_VERSION >= 700 && \
-    (!defined(__EDG_VERSION__) || __EDG_VERSION__ >= 520)
-#  define FMT_FALLTHROUGH [[gnu::fallthrough]]
+// Check if RTTI is disabled.
+#ifdef FMT_USE_RTTI
+// Use the provided definition.
+#elif defined(__GXX_RTTI) || FMT_HAS_FEATURE(cxx_rtti) || defined(_CPPRTTI) || \
+    defined(__INTEL_RTTI__) || defined(__RTTI)
+// __RTTI is for EDG compilers. _CPPRTTI is for MSVC.
+#  define FMT_USE_RTTI 1
 #else
-#  define FMT_FALLTHROUGH
-#endif
-
-#ifndef FMT_DEPRECATED
-#  if FMT_HAS_CPP14_ATTRIBUTE(deprecated) || FMT_MSC_VERSION >= 1900
-#    define FMT_DEPRECATED [[deprecated]]
-#  else
-#    if (defined(__GNUC__) && !defined(__LCC__)) || defined(__clang__)
-#      define FMT_DEPRECATED __attribute__((deprecated))
-#    elif FMT_MSC_VERSION
-#      define FMT_DEPRECATED __declspec(deprecated)
-#    else
-#      define FMT_DEPRECATED /* deprecated */
-#    endif
-#  endif
-#endif
-
-#ifndef FMT_NO_UNIQUE_ADDRESS
-#  if FMT_CPLUSPLUS >= 202002L
-#    if FMT_HAS_CPP_ATTRIBUTE(no_unique_address)
-#      define FMT_NO_UNIQUE_ADDRESS [[no_unique_address]]
-// VS2019 v16.10 and later except clang-cl (https://reviews.llvm.org/D110485)
-#    elif (FMT_MSC_VERSION >= 1929) && !FMT_CLANG_VERSION
-#      define FMT_NO_UNIQUE_ADDRESS [[msvc::no_unique_address]]
-#    endif
-#  endif
-#endif
-#ifndef FMT_NO_UNIQUE_ADDRESS
-#  define FMT_NO_UNIQUE_ADDRESS
+#  define FMT_USE_RTTI 0
 #endif
 
 // Visibility when compiled as a shared library/object.
@@ -100,20 +111,25 @@
 #  define FMT_SO_VISIBILITY(value)
 #endif
 
-#ifdef __has_builtin
-#  define FMT_HAS_BUILTIN(x) __has_builtin(x)
-#else
-#  define FMT_HAS_BUILTIN(x) 0
-#endif
-
 #if FMT_GCC_VERSION || FMT_CLANG_VERSION
 #  define FMT_NOINLINE __attribute__((noinline))
 #else
 #  define FMT_NOINLINE
 #endif
 
+namespace std {
+template <typename T> struct iterator_traits<fmt::basic_appender<T>> {
+  using iterator_category = output_iterator_tag;
+  using value_type = T;
+  using difference_type =
+      decltype(static_cast<int*>(nullptr) - static_cast<int*>(nullptr));
+  using pointer = void;
+  using reference = void;
+};
+}  // namespace std
+
 #ifndef FMT_THROW
-#  if FMT_EXCEPTIONS
+#  if FMT_USE_EXCEPTIONS
 #    if FMT_MSC_VERSION || defined(__NVCC__)
 FMT_BEGIN_NAMESPACE
 namespace detail {
@@ -132,38 +148,8 @@ FMT_END_NAMESPACE
 #  else
 #    define FMT_THROW(x) \
       ::fmt::detail::assert_fail(__FILE__, __LINE__, (x).what())
-#  endif
-#endif
-
-#if FMT_EXCEPTIONS
-#  define FMT_TRY try
-#  define FMT_CATCH(x) catch (x)
-#else
-#  define FMT_TRY if (true)
-#  define FMT_CATCH(x) if (false)
-#endif
-
-#ifndef FMT_MAYBE_UNUSED
-#  if FMT_HAS_CPP17_ATTRIBUTE(maybe_unused)
-#    define FMT_MAYBE_UNUSED [[maybe_unused]]
-#  else
-#    define FMT_MAYBE_UNUSED
-#  endif
-#endif
-
-#ifndef FMT_USE_USER_DEFINED_LITERALS
-// EDG based compilers (Intel, NVIDIA, Elbrus, etc), GCC and MSVC support UDLs.
-//
-// GCC before 4.9 requires a space in `operator"" _a` which is invalid in later
-// compiler versions.
-#  if (FMT_HAS_FEATURE(cxx_user_literals) || FMT_GCC_VERSION >= 409 || \
-       FMT_MSC_VERSION >= 1900) &&                                     \
-      (!defined(__EDG_VERSION__) || __EDG_VERSION__ >= /* UDL feature */ 480)
-#    define FMT_USE_USER_DEFINED_LITERALS 1
-#  else
-#    define FMT_USE_USER_DEFINED_LITERALS 0
-#  endif
-#endif
+#  endif  // FMT_USE_EXCEPTIONS
+#endif    // FMT_THROW
 
 // Defining FMT_REDUCE_INT_INSTANTIATIONS to 1, will reduce the number of
 // integer formatter template instantiations to just one by only using the
@@ -173,7 +159,15 @@ FMT_END_NAMESPACE
 #  define FMT_REDUCE_INT_INSTANTIATIONS 0
 #endif
 
-// __builtin_clz is broken in clang with Microsoft CodeGen:
+FMT_BEGIN_NAMESPACE
+
+template <typename Char, typename Traits, typename Allocator>
+struct is_contiguous<std::basic_string<Char, Traits, Allocator>>
+    : std::true_type {};
+
+namespace detail {
+
+// __builtin_clz is broken in clang with Microsoft codegen:
 // https://github.com/fmtlib/fmt/issues/519.
 #if !FMT_MSC_VERSION
 #  if FMT_HAS_BUILTIN(__builtin_clz) || FMT_GCC_VERSION || FMT_ICC_VERSION
@@ -184,53 +178,30 @@ FMT_END_NAMESPACE
 #  endif
 #endif
 
-// __builtin_ctz is broken in Intel Compiler Classic on Windows:
-// https://github.com/fmtlib/fmt/issues/2510.
-#ifndef __ICL
-#  if FMT_HAS_BUILTIN(__builtin_ctz) || FMT_GCC_VERSION || FMT_ICC_VERSION || \
-      defined(__NVCOMPILER)
-#    define FMT_BUILTIN_CTZ(n) __builtin_ctz(n)
-#  endif
-#  if FMT_HAS_BUILTIN(__builtin_ctzll) || FMT_GCC_VERSION || \
-      FMT_ICC_VERSION || defined(__NVCOMPILER)
-#    define FMT_BUILTIN_CTZLL(n) __builtin_ctzll(n)
-#  endif
-#endif
-
-#if FMT_MSC_VERSION
-#  include <intrin.h>  // _BitScanReverse[64], _BitScanForward[64], _umul128
-#endif
-
-// Some compilers masquerade as both MSVC and GCC-likes or otherwise support
+// Some compilers masquerade as both MSVC and GCC but otherwise support
 // __builtin_clz and __builtin_clzll, so only define FMT_BUILTIN_CLZ using the
 // MSVC intrinsics if the clz and clzll builtins are not available.
-#if FMT_MSC_VERSION && !defined(FMT_BUILTIN_CLZLL) && \
-    !defined(FMT_BUILTIN_CTZLL)
-FMT_BEGIN_NAMESPACE
-namespace detail {
+#if FMT_MSC_VERSION && !defined(FMT_BUILTIN_CLZLL)
 // Avoid Clang with Microsoft CodeGen's -Wunknown-pragmas warning.
-#  if !defined(__clang__)
-#    pragma intrinsic(_BitScanForward)
+#  ifndef __clang__
 #    pragma intrinsic(_BitScanReverse)
-#    if defined(_WIN64)
-#      pragma intrinsic(_BitScanForward64)
+#    ifdef _WIN64
 #      pragma intrinsic(_BitScanReverse64)
 #    endif
 #  endif
 
 inline auto clz(uint32_t x) -> int {
+  FMT_ASSERT(x != 0, "");
+  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
   unsigned long r = 0;
   _BitScanReverse(&r, x);
-  FMT_ASSERT(x != 0, "");
-  // Static analysis complains about using uninitialized data
-  // "r", but the only way that can happen is if "x" is 0,
-  // which the callers guarantee to not happen.
-  FMT_MSC_WARNING(suppress : 6102)
   return 31 ^ static_cast<int>(r);
 }
 #  define FMT_BUILTIN_CLZ(n) detail::clz(n)
 
 inline auto clzll(uint64_t x) -> int {
+  FMT_ASSERT(x != 0, "");
+  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
   unsigned long r = 0;
 #  ifdef _WIN64
   _BitScanReverse64(&r, x);
@@ -241,43 +212,10 @@ inline auto clzll(uint64_t x) -> int {
   // Scan the low 32 bits.
   _BitScanReverse(&r, static_cast<uint32_t>(x));
 #  endif
-  FMT_ASSERT(x != 0, "");
-  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
   return 63 ^ static_cast<int>(r);
 }
 #  define FMT_BUILTIN_CLZLL(n) detail::clzll(n)
-
-inline auto ctz(uint32_t x) -> int {
-  unsigned long r = 0;
-  _BitScanForward(&r, x);
-  FMT_ASSERT(x != 0, "");
-  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
-  return static_cast<int>(r);
-}
-#  define FMT_BUILTIN_CTZ(n) detail::ctz(n)
-
-inline auto ctzll(uint64_t x) -> int {
-  unsigned long r = 0;
-  FMT_ASSERT(x != 0, "");
-  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
-#  ifdef _WIN64
-  _BitScanForward64(&r, x);
-#  else
-  // Scan the low 32 bits.
-  if (_BitScanForward(&r, static_cast<uint32_t>(x))) return static_cast<int>(r);
-  // Scan the high 32 bits.
-  _BitScanForward(&r, static_cast<uint32_t>(x >> 32));
-  r += 32;
-#  endif
-  return static_cast<int>(r);
-}
-#  define FMT_BUILTIN_CTZLL(n) detail::ctzll(n)
-}  // namespace detail
-FMT_END_NAMESPACE
-#endif
-
-FMT_BEGIN_NAMESPACE
-namespace detail {
+#endif  // FMT_MSC_VERSION && !defined(FMT_BUILTIN_CLZLL)
 
 FMT_CONSTEXPR inline void abort_fuzzing_if(bool condition) {
   ignore_unused(condition);
@@ -286,16 +224,21 @@ FMT_CONSTEXPR inline void abort_fuzzing_if(bool condition) {
 #endif
 }
 
-template <typename CharT, CharT... C> struct string_literal {
-  static constexpr CharT value[sizeof...(C)] = {C...};
-  constexpr operator basic_string_view<CharT>() const {
+#if defined(FMT_USE_STRING_VIEW)
+template <typename Char> using std_string_view = std::basic_string_view<Char>;
+#else
+template <typename T> struct std_string_view {};
+#endif
+
+template <typename Char, Char... C> struct string_literal {
+  static constexpr Char value[sizeof...(C)] = {C...};
+  constexpr operator basic_string_view<Char>() const {
     return {value, sizeof...(C)};
   }
 };
-
 #if FMT_CPLUSPLUS < 201703L
-template <typename CharT, CharT... C>
-constexpr CharT string_literal<CharT, C...>::value[sizeof...(C)];
+template <typename Char, Char... C>
+constexpr Char string_literal<Char, C...>::value[sizeof...(C)];
 #endif
 
 // Implementation of std::bit_cast for pre-C++20.
@@ -367,13 +310,14 @@ class uint128_fallback {
       -> uint128_fallback {
     return {~n.hi_, ~n.lo_};
   }
-  friend auto operator+(const uint128_fallback& lhs,
-                        const uint128_fallback& rhs) -> uint128_fallback {
+  friend FMT_CONSTEXPR auto operator+(const uint128_fallback& lhs,
+                                      const uint128_fallback& rhs)
+      -> uint128_fallback {
     auto result = uint128_fallback(lhs);
     result += rhs;
     return result;
   }
-  friend auto operator*(const uint128_fallback& lhs, uint32_t rhs)
+  friend FMT_CONSTEXPR auto operator*(const uint128_fallback& lhs, uint32_t rhs)
       -> uint128_fallback {
     FMT_ASSERT(lhs.hi_ == 0, "");
     uint64_t hi = (lhs.lo_ >> 32) * rhs;
@@ -381,7 +325,7 @@ class uint128_fallback {
     uint64_t new_lo = (hi << 32) + lo;
     return {(hi >> 32) + (new_lo < lo ? 1 : 0), new_lo};
   }
-  friend auto operator-(const uint128_fallback& lhs, uint64_t rhs)
+  friend constexpr auto operator-(const uint128_fallback& lhs, uint64_t rhs)
       -> uint128_fallback {
     return {lhs.hi_ - (lhs.lo_ < rhs ? 1 : 0), lhs.lo_ - rhs};
   }
@@ -454,23 +398,24 @@ template <typename T> constexpr auto num_bits() -> int {
 }
 // std::numeric_limits<T>::digits may return 0 for 128-bit ints.
 template <> constexpr auto num_bits<int128_opt>() -> int { return 128; }
-template <> constexpr auto num_bits<uint128_t>() -> int { return 128; }
+template <> constexpr auto num_bits<uint128_opt>() -> int { return 128; }
+template <> constexpr auto num_bits<uint128_fallback>() -> int { return 128; }
 
 // A heterogeneous bit_cast used for converting 96-bit long double to uint128_t
 // and 128-bit pointers to uint128_fallback.
 template <typename To, typename From, FMT_ENABLE_IF(sizeof(To) > sizeof(From))>
 inline auto bit_cast(const From& from) -> To {
-  constexpr auto size = static_cast<int>(sizeof(From) / sizeof(unsigned));
+  constexpr auto size = static_cast<int>(sizeof(From) / sizeof(unsigned short));
   struct data_t {
-    unsigned value[static_cast<unsigned>(size)];
+    unsigned short value[static_cast<unsigned>(size)];
   } data = bit_cast<data_t>(from);
   auto result = To();
   if (const_check(is_big_endian())) {
     for (int i = 0; i < size; ++i)
-      result = (result << num_bits<unsigned>()) | data.value[i];
+      result = (result << num_bits<unsigned short>()) | data.value[i];
   } else {
     for (int i = size - 1; i >= 0; --i)
-      result = (result << num_bits<unsigned>()) | data.value[i];
+      result = (result << num_bits<unsigned short>()) | data.value[i];
   }
   return result;
 }
@@ -506,38 +451,25 @@ FMT_INLINE void assume(bool condition) {
 #endif
 }
 
-// An approximation of iterator_t for pre-C++20 systems.
-template <typename T>
-using iterator_t = decltype(std::begin(std::declval<T&>()));
-template <typename T> using sentinel_t = decltype(std::end(std::declval<T&>()));
-
-// A workaround for std::string not having mutable data() until C++17.
-template <typename Char>
-inline auto get_data(std::basic_string<Char>& s) -> Char* {
-  return &s[0];
-}
-template <typename Container>
-inline auto get_data(Container& c) -> typename Container::value_type* {
-  return c.data();
-}
-
 // Attempts to reserve space for n extra characters in the output range.
 // Returns a pointer to the reserved range or a reference to it.
-template <typename Container, FMT_ENABLE_IF(is_contiguous<Container>::value)>
+template <typename OutputIt,
+          FMT_ENABLE_IF(is_back_insert_iterator<OutputIt>::value&&
+                            is_contiguous<typename OutputIt::container>::value)>
 #if FMT_CLANG_VERSION >= 307 && !FMT_ICC_VERSION
 __attribute__((no_sanitize("undefined")))
 #endif
-inline auto
-reserve(std::back_insert_iterator<Container> it, size_t n) ->
-    typename Container::value_type* {
-  Container& c = get_container(it);
+FMT_CONSTEXPR20 inline auto
+reserve(OutputIt it, size_t n) -> typename OutputIt::value_type* {
+  auto& c = get_container(it);
   size_t size = c.size();
   c.resize(size + n);
-  return get_data(c) + size;
+  return &c[size];
 }
 
 template <typename T>
-inline auto reserve(buffer_appender<T> it, size_t n) -> buffer_appender<T> {
+FMT_CONSTEXPR20 inline auto reserve(basic_appender<T> it, size_t n)
+    -> basic_appender<T> {
   buffer<T>& buf = get_container(it);
   buf.try_reserve(buf.size() + n);
   return it;
@@ -556,18 +488,22 @@ template <typename T, typename OutputIt>
 constexpr auto to_pointer(OutputIt, size_t) -> T* {
   return nullptr;
 }
-template <typename T> auto to_pointer(buffer_appender<T> it, size_t n) -> T* {
+template <typename T>
+FMT_CONSTEXPR20 auto to_pointer(basic_appender<T> it, size_t n) -> T* {
   buffer<T>& buf = get_container(it);
+  buf.try_reserve(buf.size() + n);
   auto size = buf.size();
   if (buf.capacity() < size + n) return nullptr;
   buf.try_resize(size + n);
   return buf.data() + size;
 }
 
-template <typename Container, FMT_ENABLE_IF(is_contiguous<Container>::value)>
-inline auto base_iterator(std::back_insert_iterator<Container> it,
-                          typename Container::value_type*)
-    -> std::back_insert_iterator<Container> {
+template <typename OutputIt,
+          FMT_ENABLE_IF(is_back_insert_iterator<OutputIt>::value&&
+                            is_contiguous<typename OutputIt::container>::value)>
+inline auto base_iterator(OutputIt it,
+                          typename OutputIt::container_type::value_type*)
+    -> OutputIt {
   return it;
 }
 
@@ -586,23 +522,15 @@ FMT_CONSTEXPR auto fill_n(OutputIt out, Size count, const T& value)
 }
 template <typename T, typename Size>
 FMT_CONSTEXPR20 auto fill_n(T* out, Size count, char value) -> T* {
-  if (is_constant_evaluated()) {
-    return fill_n<T*, Size, T>(out, count, value);
-  }
+  if (is_constant_evaluated()) return fill_n<T*, Size, T>(out, count, value);
   std::memset(out, value, to_unsigned(count));
   return out + count;
 }
 
-#ifdef __cpp_char8_t
-using char8_type = char8_t;
-#else
-enum char8_type : unsigned char {};
-#endif
-
 template <typename OutChar, typename InputIt, typename OutputIt>
-FMT_CONSTEXPR FMT_NOINLINE auto copy_str_noinline(InputIt begin, InputIt end,
-                                                  OutputIt out) -> OutputIt {
-  return copy_str<OutChar>(begin, end, out);
+FMT_CONSTEXPR FMT_NOINLINE auto copy_noinline(InputIt begin, InputIt end,
+                                              OutputIt out) -> OutputIt {
+  return copy<OutChar>(begin, end, out);
 }
 
 // A public domain branchless UTF-8 decoder by Christopher Wellons:
@@ -673,6 +601,7 @@ FMT_CONSTEXPR void for_each_codepoint(string_view s, F f) {
                     string_view(ptr, error ? 1 : to_unsigned(end - buf_ptr)));
     return result ? (error ? buf_ptr + 1 : end) : nullptr;
   };
+
   auto p = s.data();
   const size_t block_size = 4;  // utf8_decode always reads blocks of 4 chars.
   if (s.size() >= block_size) {
@@ -681,17 +610,20 @@ FMT_CONSTEXPR void for_each_codepoint(string_view s, F f) {
       if (!p) return;
     }
   }
-  if (auto num_chars_left = s.data() + s.size() - p) {
-    char buf[2 * block_size - 1] = {};
-    copy_str<char>(p, p + num_chars_left, buf);
-    const char* buf_ptr = buf;
-    do {
-      auto end = decode(buf_ptr, p);
-      if (!end) return;
-      p += end - buf_ptr;
-      buf_ptr = end;
-    } while (buf_ptr - buf < num_chars_left);
-  }
+  auto num_chars_left = to_unsigned(s.data() + s.size() - p);
+  if (num_chars_left == 0) return;
+
+  // Suppress bogus -Wstringop-overflow.
+  if (FMT_GCC_VERSION) num_chars_left &= 3;
+  char buf[2 * block_size - 1] = {};
+  copy<char>(p, p + num_chars_left, buf);
+  const char* buf_ptr = buf;
+  do {
+    auto end = decode(buf_ptr, p);
+    if (!end) return;
+    p += end - buf_ptr;
+    buf_ptr = end;
+  } while (buf_ptr < buf + num_chars_left);
 }
 
 template <typename Char>
@@ -706,7 +638,7 @@ FMT_CONSTEXPR inline auto compute_width(string_view s) -> size_t {
   struct count_code_points {
     size_t* count;
     FMT_CONSTEXPR auto operator()(uint32_t cp, string_view) const -> bool {
-      *count += detail::to_unsigned(
+      *count += to_unsigned(
           1 +
           (cp >= 0x1100 &&
            (cp <= 0x115f ||  // Hangul Jamo init. consonants
@@ -734,15 +666,9 @@ FMT_CONSTEXPR inline auto compute_width(string_view s) -> size_t {
   return num_code_points;
 }
 
-inline auto compute_width(basic_string_view<char8_type> s) -> size_t {
-  return compute_width(
-      string_view(reinterpret_cast<const char*>(s.data()), s.size()));
-}
-
 template <typename Char>
 inline auto code_point_index(basic_string_view<Char> s, size_t n) -> size_t {
-  size_t size = s.size();
-  return n < size ? n : size;
+  return min_of(n, s.size());
 }
 
 // Calculates the index of the nth code point in a UTF-8 string.
@@ -760,12 +686,6 @@ inline auto code_point_index(string_view s, size_t n) -> size_t {
   return result;
 }
 
-inline auto code_point_index(basic_string_view<char8_type> s, size_t n)
-    -> size_t {
-  return code_point_index(
-      string_view(reinterpret_cast<const char*>(s.data()), s.size()), n);
-}
-
 template <typename T> struct is_integral : std::is_integral<T> {};
 template <> struct is_integral<int128_opt> : std::true_type {};
 template <> struct is_integral<uint128_t> : std::true_type {};
@@ -781,38 +701,22 @@ using is_integer =
                   !std::is_same<T, char>::value &&
                   !std::is_same<T, wchar_t>::value>;
 
-#ifndef FMT_USE_FLOAT
-#  define FMT_USE_FLOAT 1
-#endif
-#ifndef FMT_USE_DOUBLE
-#  define FMT_USE_DOUBLE 1
-#endif
-#ifndef FMT_USE_LONG_DOUBLE
-#  define FMT_USE_LONG_DOUBLE 1
-#endif
-
-#ifndef FMT_USE_FLOAT128
-#  ifdef __clang__
-// Clang emulates GCC, so it has to appear early.
-#    if FMT_HAS_INCLUDE(<quadmath.h>)
-#      define FMT_USE_FLOAT128 1
-#    endif
-#  elif defined(__GNUC__)
-// GNU C++:
-#    if defined(_GLIBCXX_USE_FLOAT128) && !defined(__STRICT_ANSI__)
-#      define FMT_USE_FLOAT128 1
-#    endif
-#  endif
-#  ifndef FMT_USE_FLOAT128
-#    define FMT_USE_FLOAT128 0
-#  endif
+#if defined(FMT_USE_FLOAT128)
+// Use the provided definition.
+#elif FMT_CLANG_VERSION && FMT_HAS_INCLUDE(<quadmath.h>)
+#  define FMT_USE_FLOAT128 1
+#elif FMT_GCC_VERSION && defined(_GLIBCXX_USE_FLOAT128) && \
+    !defined(__STRICT_ANSI__)
+#  define FMT_USE_FLOAT128 1
+#else
+#  define FMT_USE_FLOAT128 0
 #endif
-
 #if FMT_USE_FLOAT128
 using float128 = __float128;
 #else
-using float128 = void;
+struct float128 {};
 #endif
+
 template <typename T> using is_float128 = std::is_same<T, float128>;
 
 template <typename T>
@@ -831,24 +735,21 @@ using is_double_double = bool_constant<std::numeric_limits<T>::digits == 106>;
 #  define FMT_USE_FULL_CACHE_DRAGONBOX 0
 #endif
 
-template <typename T>
-template <typename U>
-void buffer<T>::append(const U* begin, const U* end) {
-  while (begin != end) {
-    auto count = to_unsigned(end - begin);
-    try_reserve(size_ + count);
-    auto free_cap = capacity_ - size_;
-    if (free_cap < count) count = free_cap;
-    std::uninitialized_copy_n(begin, count, ptr_ + size_);
-    size_ += count;
-    begin += count;
+// An allocator that uses malloc/free to allow removing dependency on the C++
+// standard libary runtime.
+template <typename T> struct allocator {
+  using value_type = T;
+
+  T* allocate(size_t n) {
+    FMT_ASSERT(n <= max_value<size_t>() / sizeof(T), "");
+    T* p = static_cast<T*>(malloc(n * sizeof(T)));
+    if (!p) FMT_THROW(std::bad_alloc());
+    return p;
   }
-}
 
-template <typename T, typename Enable = void>
-struct is_locale : std::false_type {};
-template <typename T>
-struct is_locale<T, void_t<decltype(T::classic())>> : std::true_type {};
+  void deallocate(T* p, size_t) { free(p); }
+};
+
 }  // namespace detail
 
 FMT_BEGIN_EXPORT
@@ -858,29 +759,21 @@ FMT_BEGIN_EXPORT
 enum { inline_buffer_size = 500 };
 
 /**
-  \rst
-  A dynamically growing memory buffer for trivially copyable/constructible types
-  with the first ``SIZE`` elements stored in the object itself.
-
-  You can use the ``memory_buffer`` type alias for ``char`` instead.
-
-  **Example**::
-
-     auto out = fmt::memory_buffer();
-     fmt::format_to(std::back_inserter(out), "The answer is {}.", 42);
-
-  This will append the following output to the ``out`` object:
-
-  .. code-block:: none
-
-     The answer is 42.
-
-  The output can be converted to an ``std::string`` with ``to_string(out)``.
-  \endrst
+ * A dynamically growing memory buffer for trivially copyable/constructible
+ * types with the first `SIZE` elements stored in the object itself. Most
+ * commonly used via the `memory_buffer` alias for `char`.
+ *
+ * **Example**:
+ *
+ *     auto out = fmt::memory_buffer();
+ *     fmt::format_to(std::back_inserter(out), "The answer is {}.", 42);
+ *
+ * This will append "The answer is 42." to `out`. The buffer content can be
+ * converted to `std::string` with `to_string(out)`.
  */
 template <typename T, size_t SIZE = inline_buffer_size,
-          typename Allocator = std::allocator<T>>
-class basic_memory_buffer final : public detail::buffer<T> {
+          typename Allocator = detail::allocator<T>>
+class basic_memory_buffer : public detail::buffer<T> {
  private:
   T store_[SIZE];
 
@@ -893,37 +786,37 @@ class basic_memory_buffer final : public detail::buffer<T> {
     if (data != store_) alloc_.deallocate(data, this->capacity());
   }
 
- protected:
-  FMT_CONSTEXPR20 void grow(size_t size) override {
+  static FMT_CONSTEXPR20 void grow(detail::buffer<T>& buf, size_t size) {
     detail::abort_fuzzing_if(size > 5000);
-    const size_t max_size = std::allocator_traits<Allocator>::max_size(alloc_);
-    size_t old_capacity = this->capacity();
+    auto& self = static_cast<basic_memory_buffer&>(buf);
+    const size_t max_size =
+        std::allocator_traits<Allocator>::max_size(self.alloc_);
+    size_t old_capacity = buf.capacity();
     size_t new_capacity = old_capacity + old_capacity / 2;
     if (size > new_capacity)
       new_capacity = size;
     else if (new_capacity > max_size)
-      new_capacity = size > max_size ? size : max_size;
-    T* old_data = this->data();
-    T* new_data =
-        std::allocator_traits<Allocator>::allocate(alloc_, new_capacity);
+      new_capacity = max_of(size, max_size);
+    T* old_data = buf.data();
+    T* new_data = self.alloc_.allocate(new_capacity);
     // Suppress a bogus -Wstringop-overflow in gcc 13.1 (#3481).
-    detail::assume(this->size() <= new_capacity);
+    detail::assume(buf.size() <= new_capacity);
     // The following code doesn't throw, so the raw pointer above doesn't leak.
-    std::uninitialized_copy_n(old_data, this->size(), new_data);
-    this->set(new_data, new_capacity);
+    memcpy(new_data, old_data, buf.size() * sizeof(T));
+    self.set(new_data, new_capacity);
     // deallocate must not throw according to the standard, but even if it does,
     // the buffer already uses the new storage and will deallocate it in
     // destructor.
-    if (old_data != store_) alloc_.deallocate(old_data, old_capacity);
+    if (old_data != self.store_) self.alloc_.deallocate(old_data, old_capacity);
   }
 
  public:
   using value_type = T;
   using const_reference = const T&;
 
-  FMT_CONSTEXPR20 explicit basic_memory_buffer(
+  FMT_CONSTEXPR explicit basic_memory_buffer(
       const Allocator& alloc = Allocator())
-      : alloc_(alloc) {
+      : detail::buffer<T>(grow), alloc_(alloc) {
     this->set(store_, SIZE);
     if (detail::is_constant_evaluated()) detail::fill_n(store_, SIZE, T());
   }
@@ -937,7 +830,7 @@ class basic_memory_buffer final : public detail::buffer<T> {
     size_t size = other.size(), capacity = other.capacity();
     if (data == other.store_) {
       this->set(store_, capacity);
-      detail::copy_str<T>(other.store_, other.store_ + size, store_);
+      detail::copy<T>(other.store_, other.store_ + size, store_);
     } else {
       this->set(data, capacity);
       // Set pointer to the inline array so that delete is not called
@@ -949,21 +842,14 @@ class basic_memory_buffer final : public detail::buffer<T> {
   }
 
  public:
-  /**
-    \rst
-    Constructs a :class:`fmt::basic_memory_buffer` object moving the content
-    of the other object to it.
-    \endrst
-   */
-  FMT_CONSTEXPR20 basic_memory_buffer(basic_memory_buffer&& other) noexcept {
+  /// Constructs a `basic_memory_buffer` object moving the content of the other
+  /// object to it.
+  FMT_CONSTEXPR20 basic_memory_buffer(basic_memory_buffer&& other) noexcept
+      : detail::buffer<T>(grow) {
     move(other);
   }
 
-  /**
-    \rst
-    Moves the content of the other ``basic_memory_buffer`` object to this one.
-    \endrst
-   */
+  /// Moves the content of the other `basic_memory_buffer` object to this one.
   auto operator=(basic_memory_buffer&& other) noexcept -> basic_memory_buffer& {
     FMT_ASSERT(this != &other, "");
     deallocate();
@@ -974,120 +860,108 @@ class basic_memory_buffer final : public detail::buffer<T> {
   // Returns a copy of the allocator associated with this buffer.
   auto get_allocator() const -> Allocator { return alloc_; }
 
-  /**
-    Resizes the buffer to contain *count* elements. If T is a POD type new
-    elements may not be initialized.
-   */
-  FMT_CONSTEXPR20 void resize(size_t count) { this->try_resize(count); }
+  /// Resizes the buffer to contain `count` elements. If T is a POD type new
+  /// elements may not be initialized.
+  FMT_CONSTEXPR void resize(size_t count) { this->try_resize(count); }
 
-  /** Increases the buffer capacity to *new_capacity*. */
+  /// Increases the buffer capacity to `new_capacity`.
   void reserve(size_t new_capacity) { this->try_reserve(new_capacity); }
 
   using detail::buffer<T>::append;
   template <typename ContiguousRange>
-  void append(const ContiguousRange& range) {
+  FMT_CONSTEXPR20 void append(const ContiguousRange& range) {
     append(range.data(), range.data() + range.size());
   }
 };
 
 using memory_buffer = basic_memory_buffer<char>;
 
-template <typename T, size_t SIZE, typename Allocator>
-struct is_contiguous<basic_memory_buffer<T, SIZE, Allocator>> : std::true_type {
+template <size_t SIZE>
+FMT_NODISCARD auto to_string(const basic_memory_buffer<char, SIZE>& buf)
+    -> std::string {
+  auto size = buf.size();
+  detail::assume(size < std::string().max_size());
+  return {buf.data(), size};
+}
+
+// A writer to a buffered stream. It doesn't own the underlying stream.
+class writer {
+ private:
+  detail::buffer<char>* buf_;
+
+  // We cannot create a file buffer in advance because any write to a FILE may
+  // invalidate it.
+  FILE* file_;
+
+ public:
+  inline writer(FILE* f) : buf_(nullptr), file_(f) {}
+  inline writer(detail::buffer<char>& buf) : buf_(&buf) {}
+
+  /// Formats `args` according to specifications in `fmt` and writes the
+  /// output to the file.
+  template <typename... T> void print(format_string<T...> fmt, T&&... args) {
+    if (buf_)
+      fmt::format_to(appender(*buf_), fmt, std::forward<T>(args)...);
+    else
+      fmt::print(file_, fmt, std::forward<T>(args)...);
+  }
 };
 
-FMT_END_EXPORT
-namespace detail {
-FMT_API auto write_console(int fd, string_view text) -> bool;
-FMT_API auto write_console(std::FILE* f, string_view text) -> bool;
-FMT_API void print(std::FILE*, string_view);
-}  // namespace detail
+class string_buffer {
+ private:
+  std::string str_;
+  detail::container_buffer<std::string> buf_;
 
-FMT_BEGIN_EXPORT
+ public:
+  inline string_buffer() : buf_(str_) {}
+
+  inline operator writer() { return buf_; }
+  inline std::string& str() { return str_; }
+};
+
+template <typename T, size_t SIZE, typename Allocator>
+struct is_contiguous<basic_memory_buffer<T, SIZE, Allocator>> : std::true_type {
+};
 
 // Suppress a misleading warning in older versions of clang.
-#if FMT_CLANG_VERSION
-#  pragma clang diagnostic ignored "-Wweak-vtables"
-#endif
+FMT_PRAGMA_CLANG(diagnostic ignored "-Wweak-vtables")
 
-/** An error reported from a formatting function. */
+/// An error reported from a formatting function.
 class FMT_SO_VISIBILITY("default") format_error : public std::runtime_error {
  public:
   using std::runtime_error::runtime_error;
 };
 
-namespace detail_exported {
-#if FMT_USE_NONTYPE_TEMPLATE_ARGS
+class loc_value;
+
+FMT_END_EXPORT
+namespace detail {
+FMT_API auto write_console(int fd, string_view text) -> bool;
+FMT_API void print(FILE*, string_view);
+}  // namespace detail
+
+namespace detail {
 template <typename Char, size_t N> struct fixed_string {
-  constexpr fixed_string(const Char (&str)[N]) {
-    detail::copy_str<Char, const Char*, Char*>(static_cast<const Char*>(str),
-                                               str + N, data);
+  FMT_CONSTEXPR20 fixed_string(const Char (&s)[N]) {
+    detail::copy<Char, const Char*, Char*>(static_cast<const Char*>(s), s + N,
+                                           data);
   }
   Char data[N] = {};
 };
-#endif
 
 // Converts a compile-time string to basic_string_view.
-template <typename Char, size_t N>
+FMT_EXPORT template <typename Char, size_t N>
 constexpr auto compile_string_to_view(const Char (&s)[N])
     -> basic_string_view<Char> {
   // Remove trailing NUL character if needed. Won't be present if this is used
   // with a raw character array (i.e. not defined as a string).
   return {s, N - (std::char_traits<Char>::to_int_type(s[N - 1]) == 0 ? 1 : 0)};
 }
-template <typename Char>
-constexpr auto compile_string_to_view(detail::std_string_view<Char> s)
+FMT_EXPORT template <typename Char>
+constexpr auto compile_string_to_view(basic_string_view<Char> s)
     -> basic_string_view<Char> {
-  return {s.data(), s.size()};
+  return s;
 }
-}  // namespace detail_exported
-
-class loc_value {
- private:
-  basic_format_arg<format_context> value_;
-
- public:
-  template <typename T, FMT_ENABLE_IF(!detail::is_float128<T>::value)>
-  loc_value(T value) : value_(detail::make_arg<format_context>(value)) {}
-
-  template <typename T, FMT_ENABLE_IF(detail::is_float128<T>::value)>
-  loc_value(T) {}
-
-  template <typename Visitor> auto visit(Visitor&& vis) -> decltype(vis(0)) {
-    return visit_format_arg(vis, value_);
-  }
-};
-
-// A locale facet that formats values in UTF-8.
-// It is parameterized on the locale to avoid the heavy <locale> include.
-template <typename Locale> class format_facet : public Locale::facet {
- private:
-  std::string separator_;
-  std::string grouping_;
-  std::string decimal_point_;
-
- protected:
-  virtual auto do_put(appender out, loc_value val,
-                      const format_specs<>& specs) const -> bool;
-
- public:
-  static FMT_API typename Locale::id id;
-
-  explicit format_facet(Locale& loc);
-  explicit format_facet(string_view sep = "",
-                        std::initializer_list<unsigned char> g = {3},
-                        std::string decimal_point = ".")
-      : separator_(sep.data(), sep.size()),
-        grouping_(g.begin(), g.end()),
-        decimal_point_(decimal_point) {}
-
-  auto put(appender out, loc_value val, const format_specs<>& specs) const
-      -> bool {
-    return do_put(out, val, specs);
-  }
-};
-
-namespace detail {
 
 // Returns true if value is negative, false otherwise.
 // Same as `value < 0` but doesn't produce warnings if T is an unsigned type.
@@ -1100,14 +974,6 @@ constexpr auto is_negative(T) -> bool {
   return false;
 }
 
-template <typename T>
-FMT_CONSTEXPR auto is_supported_floating_point(T) -> bool {
-  if (std::is_same<T, float>()) return FMT_USE_FLOAT;
-  if (std::is_same<T, double>()) return FMT_USE_DOUBLE;
-  if (std::is_same<T, long double>()) return FMT_USE_LONG_DOUBLE;
-  return true;
-}
-
 // Smallest of uint32_t, uint64_t, uint128_t that is large enough to
 // represent all values of an integral type T.
 template <typename T>
@@ -1124,21 +990,22 @@ using uint64_or_128_t = conditional_t<num_bits<T>() <= 64, uint64_t, uint128_t>;
       (factor) * 100000000, (factor) * 1000000000
 
 // Converts value in the range [0, 100) to a string.
-constexpr auto digits2(size_t value) -> const char* {
-  // GCC generates slightly better code when value is pointer-size.
-  return &"0001020304050607080910111213141516171819"
-         "2021222324252627282930313233343536373839"
-         "4041424344454647484950515253545556575859"
-         "6061626364656667686970717273747576777879"
-         "8081828384858687888990919293949596979899"[value * 2];
-}
-
-// Sign is a template parameter to workaround a bug in gcc 4.8.
-template <typename Char, typename Sign> constexpr auto sign(Sign s) -> Char {
-#if !FMT_GCC_VERSION || FMT_GCC_VERSION >= 604
-  static_assert(std::is_same<Sign, sign_t>::value, "");
-#endif
-  return static_cast<Char>("\0-+ "[s]);
+// GCC generates slightly better code when value is pointer-size.
+inline auto digits2(size_t value) -> const char* {
+  // Align data since unaligned access may be slower when crossing a
+  // hardware-specific boundary.
+  alignas(2) static const char data[] =
+      "0001020304050607080910111213141516171819"
+      "2021222324252627282930313233343536373839"
+      "4041424344454647484950515253545556575859"
+      "6061626364656667686970717273747576777879"
+      "8081828384858687888990919293949596979899";
+  return &data[value * 2];
+}
+
+template <typename Char> constexpr auto getsign(sign s) -> Char {
+  return static_cast<char>(((' ' << 24) | ('+' << 16) | ('-' << 8)) >>
+                           (static_cast<int>(s) * 8));
 }
 
 template <typename T> FMT_CONSTEXPR auto count_digits_fallback(T n) -> int {
@@ -1186,9 +1053,7 @@ inline auto do_count_digits(uint64_t n) -> int {
 // except for n == 0 in which case count_digits returns 1.
 FMT_CONSTEXPR20 inline auto count_digits(uint64_t n) -> int {
 #ifdef FMT_BUILTIN_CLZLL
-  if (!is_constant_evaluated()) {
-    return do_count_digits(n);
-  }
+  if (!is_constant_evaluated() && !FMT_OPTIMIZE_SIZE) return do_count_digits(n);
 #endif
   return count_digits_fallback(n);
 }
@@ -1238,9 +1103,7 @@ FMT_INLINE auto do_count_digits(uint32_t n) -> int {
 // Optional version of count_digits for better performance on 32-bit platforms.
 FMT_CONSTEXPR20 inline auto count_digits(uint32_t n) -> int {
 #ifdef FMT_BUILTIN_CLZ
-  if (!is_constant_evaluated()) {
-    return do_count_digits(n);
-  }
+  if (!is_constant_evaluated() && !FMT_OPTIMIZE_SIZE) return do_count_digits(n);
 #endif
   return count_digits_fallback(n);
 }
@@ -1277,6 +1140,17 @@ template <> inline auto decimal_point(locale_ref loc) -> wchar_t {
   return decimal_point_impl<wchar_t>(loc);
 }
 
+#ifndef FMT_HEADER_ONLY
+FMT_BEGIN_EXPORT
+extern template FMT_API auto thousands_sep_impl<char>(locale_ref)
+    -> thousands_sep_result<char>;
+extern template FMT_API auto thousands_sep_impl<wchar_t>(locale_ref)
+    -> thousands_sep_result<wchar_t>;
+extern template FMT_API auto decimal_point_impl(locale_ref) -> char;
+extern template FMT_API auto decimal_point_impl(locale_ref) -> wchar_t;
+FMT_END_EXPORT
+#endif  // FMT_HEADER_ONLY
+
 // Compares two characters for equality.
 template <typename Char> auto equal2(const Char* lhs, const char* rhs) -> bool {
   return lhs[0] == Char(rhs[0]) && lhs[1] == Char(rhs[1]);
@@ -1285,83 +1159,99 @@ inline auto equal2(const char* lhs, const char* rhs) -> bool {
   return memcmp(lhs, rhs, 2) == 0;
 }
 
-// Copies two characters from src to dst.
+// Writes a two-digit value to out.
 template <typename Char>
-FMT_CONSTEXPR20 FMT_INLINE void copy2(Char* dst, const char* src) {
-  if (!is_constant_evaluated() && sizeof(Char) == sizeof(char)) {
-    memcpy(dst, src, 2);
+FMT_CONSTEXPR20 FMT_INLINE void write2digits(Char* out, size_t value) {
+  if (!is_constant_evaluated() && std::is_same<Char, char>::value &&
+      !FMT_OPTIMIZE_SIZE) {
+    memcpy(out, digits2(value), 2);
     return;
   }
-  *dst++ = static_cast<Char>(*src++);
-  *dst = static_cast<Char>(*src);
+  *out++ = static_cast<Char>('0' + value / 10);
+  *out = static_cast<Char>('0' + value % 10);
 }
 
-template <typename Iterator> struct format_decimal_result {
-  Iterator begin;
-  Iterator end;
-};
-
-// Formats a decimal unsigned integer value writing into out pointing to a
-// buffer of specified size. The caller must ensure that the buffer is large
-// enough.
+// Formats a decimal unsigned integer value writing to out pointing to a buffer
+// of specified size. The caller must ensure that the buffer is large enough.
 template <typename Char, typename UInt>
-FMT_CONSTEXPR20 auto format_decimal(Char* out, UInt value, int size)
-    -> format_decimal_result<Char*> {
+FMT_CONSTEXPR20 auto do_format_decimal(Char* out, UInt value, int size)
+    -> Char* {
   FMT_ASSERT(size >= count_digits(value), "invalid digit count");
-  out += size;
-  Char* end = out;
+  unsigned n = to_unsigned(size);
   while (value >= 100) {
     // Integer division is slow so do it for a group of two digits instead
     // of for every digit. The idea comes from the talk by Alexandrescu
     // "Three Optimization Tips for C++". See speed-test for a comparison.
-    out -= 2;
-    copy2(out, digits2(static_cast<size_t>(value % 100)));
+    n -= 2;
+    write2digits(out + n, static_cast<unsigned>(value % 100));
     value /= 100;
   }
-  if (value < 10) {
-    *--out = static_cast<Char>('0' + value);
-    return {out, end};
+  if (value >= 10) {
+    n -= 2;
+    write2digits(out + n, static_cast<unsigned>(value));
+  } else {
+    out[--n] = static_cast<Char>('0' + value);
   }
-  out -= 2;
-  copy2(out, digits2(static_cast<size_t>(value)));
-  return {out, end};
-}
-
-template <typename Char, typename UInt, typename Iterator,
-          FMT_ENABLE_IF(!std::is_pointer<remove_cvref_t<Iterator>>::value)>
-FMT_CONSTEXPR inline auto format_decimal(Iterator out, UInt value, int size)
-    -> format_decimal_result<Iterator> {
-  // Buffer is large enough to hold all digits (digits10 + 1).
-  Char buffer[digits10<UInt>() + 1] = {};
-  auto end = format_decimal(buffer, value, size).end;
-  return {out, detail::copy_str_noinline<Char>(buffer, end, out)};
+  return out + n;
 }
 
-template <unsigned BASE_BITS, typename Char, typename UInt>
-FMT_CONSTEXPR auto format_uint(Char* buffer, UInt value, int num_digits,
-                               bool upper = false) -> Char* {
-  buffer += num_digits;
-  Char* end = buffer;
-  do {
-    const char* digits = upper ? "0123456789ABCDEF" : "0123456789abcdef";
-    unsigned digit = static_cast<unsigned>(value & ((1 << BASE_BITS) - 1));
-    *--buffer = static_cast<Char>(BASE_BITS < 4 ? static_cast<char>('0' + digit)
-                                                : digits[digit]);
-  } while ((value >>= BASE_BITS) != 0);
-  return end;
+template <typename Char, typename UInt>
+FMT_CONSTEXPR FMT_INLINE auto format_decimal(Char* out, UInt value,
+                                             int num_digits) -> Char* {
+  do_format_decimal(out, value, num_digits);
+  return out + num_digits;
 }
 
-template <unsigned BASE_BITS, typename Char, typename It, typename UInt>
-FMT_CONSTEXPR inline auto format_uint(It out, UInt value, int num_digits,
-                                      bool upper = false) -> It {
+template <typename Char, typename UInt, typename OutputIt,
+          FMT_ENABLE_IF(is_back_insert_iterator<OutputIt>::value)>
+FMT_CONSTEXPR auto format_decimal(OutputIt out, UInt value, int num_digits)
+    -> OutputIt {
   if (auto ptr = to_pointer<Char>(out, to_unsigned(num_digits))) {
-    format_uint<BASE_BITS>(ptr, value, num_digits, upper);
+    do_format_decimal(ptr, value, num_digits);
     return out;
   }
-  // Buffer should be large enough to hold all digits (digits / BASE_BITS + 1).
-  char buffer[num_bits<UInt>() / BASE_BITS + 1] = {};
-  format_uint<BASE_BITS>(buffer, value, num_digits, upper);
-  return detail::copy_str_noinline<Char>(buffer, buffer + num_digits, out);
+  // Buffer is large enough to hold all digits (digits10 + 1).
+  char buffer[digits10<UInt>() + 1];
+  if (is_constant_evaluated()) fill_n(buffer, sizeof(buffer), '\0');
+  do_format_decimal(buffer, value, num_digits);
+  return copy_noinline<Char>(buffer, buffer + num_digits, out);
+}
+
+template <typename Char, typename UInt>
+FMT_CONSTEXPR auto do_format_base2e(int base_bits, Char* out, UInt value,
+                                    int size, bool upper = false) -> Char* {
+  out += size;
+  do {
+    const char* digits = upper ? "0123456789ABCDEF" : "0123456789abcdef";
+    unsigned digit = static_cast<unsigned>(value & ((1 << base_bits) - 1));
+    *--out = static_cast<Char>(base_bits < 4 ? static_cast<char>('0' + digit)
+                                             : digits[digit]);
+  } while ((value >>= base_bits) != 0);
+  return out;
+}
+
+// Formats an unsigned integer in the power of two base (binary, octal, hex).
+template <typename Char, typename UInt>
+FMT_CONSTEXPR auto format_base2e(int base_bits, Char* out, UInt value,
+                                 int num_digits, bool upper = false) -> Char* {
+  do_format_base2e(base_bits, out, value, num_digits, upper);
+  return out + num_digits;
+}
+
+template <typename Char, typename OutputIt, typename UInt,
+          FMT_ENABLE_IF(is_back_insert_iterator<OutputIt>::value)>
+FMT_CONSTEXPR inline auto format_base2e(int base_bits, OutputIt out, UInt value,
+                                        int num_digits, bool upper = false)
+    -> OutputIt {
+  if (auto ptr = to_pointer<Char>(out, to_unsigned(num_digits))) {
+    format_base2e(base_bits, ptr, value, num_digits, upper);
+    return out;
+  }
+  // Make buffer large enough for any base.
+  char buffer[num_bits<UInt>()];
+  if (is_constant_evaluated()) fill_n(buffer, sizeof(buffer), '\0');
+  format_base2e(base_bits, buffer, value, num_digits, upper);
+  return detail::copy_noinline<Char>(buffer, buffer + num_digits, out);
 }
 
 // A converter from UTF-8 to UTF-16.
@@ -1371,10 +1261,12 @@ class utf8_to_utf16 {
 
  public:
   FMT_API explicit utf8_to_utf16(string_view s);
-  operator basic_string_view<wchar_t>() const { return {&buffer_[0], size()}; }
-  auto size() const -> size_t { return buffer_.size() - 1; }
-  auto c_str() const -> const wchar_t* { return &buffer_[0]; }
-  auto str() const -> std::wstring { return {&buffer_[0], size()}; }
+  inline operator basic_string_view<wchar_t>() const {
+    return {&buffer_[0], size()};
+  }
+  inline auto size() const -> size_t { return buffer_.size() - 1; }
+  inline auto c_str() const -> const wchar_t* { return &buffer_[0]; }
+  inline auto str() const -> std::wstring { return {&buffer_[0], size()}; }
 };
 
 enum class to_utf8_error_policy { abort, replace };
@@ -1421,10 +1313,12 @@ template <typename WChar, typename Buffer = memory_buffer> class to_utf8 {
           if (policy == to_utf8_error_policy::abort) return false;
           buf.append(string_view("\xEF\xBF\xBD"));
           --p;
+          continue;
         } else {
           c = (c << 10) + static_cast<uint32_t>(*p) - 0x35fdc00;
         }
-      } else if (c < 0x80) {
+      }
+      if (c < 0x80) {
         buf.push_back(static_cast<char>(c));
       } else if (c < 0x800) {
         buf.push_back(static_cast<char>(0xc0 | (c >> 6)));
@@ -1592,25 +1486,30 @@ template <typename Float> constexpr auto exponent_bias() -> int {
 }
 
 // Writes the exponent exp in the form "[+-]d{2,3}" to buffer.
-template <typename Char, typename It>
-FMT_CONSTEXPR auto write_exponent(int exp, It it) -> It {
+template <typename Char, typename OutputIt>
+FMT_CONSTEXPR auto write_exponent(int exp, OutputIt out) -> OutputIt {
   FMT_ASSERT(-10000 < exp && exp < 10000, "exponent out of range");
   if (exp < 0) {
-    *it++ = static_cast<Char>('-');
+    *out++ = static_cast<Char>('-');
     exp = -exp;
   } else {
-    *it++ = static_cast<Char>('+');
+    *out++ = static_cast<Char>('+');
   }
-  if (exp >= 100) {
-    const char* top = digits2(to_unsigned(exp / 100));
-    if (exp >= 1000) *it++ = static_cast<Char>(top[0]);
-    *it++ = static_cast<Char>(top[1]);
-    exp %= 100;
-  }
-  const char* d = digits2(to_unsigned(exp));
-  *it++ = static_cast<Char>(d[0]);
-  *it++ = static_cast<Char>(d[1]);
-  return it;
+  auto uexp = static_cast<uint32_t>(exp);
+  if (is_constant_evaluated()) {
+    if (uexp < 10) *out++ = '0';
+    return format_decimal<Char>(out, uexp, count_digits(uexp));
+  }
+  if (uexp >= 100u) {
+    const char* top = digits2(uexp / 100);
+    if (uexp >= 1000u) *out++ = static_cast<Char>(top[0]);
+    *out++ = static_cast<Char>(top[1]);
+    uexp %= 100;
+  }
+  const char* d = digits2(uexp);
+  *out++ = static_cast<Char>(d[0]);
+  *out++ = static_cast<Char>(d[1]);
+  return out;
 }
 
 // A floating-point number f * pow(2, e) where F is an unsigned type.
@@ -1711,67 +1610,69 @@ constexpr auto convert_float(T value) -> convert_float_result<T> {
   return static_cast<convert_float_result<T>>(value);
 }
 
-template <typename OutputIt, typename Char>
+template <typename Char, typename OutputIt>
 FMT_NOINLINE FMT_CONSTEXPR auto fill(OutputIt it, size_t n,
-                                     const fill_t<Char>& fill) -> OutputIt {
-  auto fill_size = fill.size();
-  if (fill_size == 1) return detail::fill_n(it, n, fill[0]);
-  auto data = fill.data();
-  for (size_t i = 0; i < n; ++i)
-    it = copy_str<Char>(data, data + fill_size, it);
+                                     const basic_specs& specs) -> OutputIt {
+  auto fill_size = specs.fill_size();
+  if (fill_size == 1) return detail::fill_n(it, n, specs.fill_unit<Char>());
+  if (const Char* data = specs.fill<Char>()) {
+    for (size_t i = 0; i < n; ++i) it = copy<Char>(data, data + fill_size, it);
+  }
   return it;
 }
 
 // Writes the output of f, padded according to format specifications in specs.
 // size: output size in code units.
 // width: output display width in (terminal) column positions.
-template <align::type align = align::left, typename OutputIt, typename Char,
+template <typename Char, align default_align = align::left, typename OutputIt,
           typename F>
-FMT_CONSTEXPR auto write_padded(OutputIt out, const format_specs<Char>& specs,
+FMT_CONSTEXPR auto write_padded(OutputIt out, const format_specs& specs,
                                 size_t size, size_t width, F&& f) -> OutputIt {
-  static_assert(align == align::left || align == align::right, "");
+  static_assert(default_align == align::left || default_align == align::right,
+                "");
   unsigned spec_width = to_unsigned(specs.width);
   size_t padding = spec_width > width ? spec_width - width : 0;
   // Shifts are encoded as string literals because static constexpr is not
   // supported in constexpr functions.
-  auto* shifts = align == align::left ? "\x1f\x1f\x00\x01" : "\x00\x1f\x00\x01";
-  size_t left_padding = padding >> shifts[specs.align];
+  auto* shifts =
+      default_align == align::left ? "\x1f\x1f\x00\x01" : "\x00\x1f\x00\x01";
+  size_t left_padding = padding >> shifts[static_cast<int>(specs.align())];
   size_t right_padding = padding - left_padding;
-  auto it = reserve(out, size + padding * specs.fill.size());
-  if (left_padding != 0) it = fill(it, left_padding, specs.fill);
+  auto it = reserve(out, size + padding * specs.fill_size());
+  if (left_padding != 0) it = fill<Char>(it, left_padding, specs);
   it = f(it);
-  if (right_padding != 0) it = fill(it, right_padding, specs.fill);
+  if (right_padding != 0) it = fill<Char>(it, right_padding, specs);
   return base_iterator(out, it);
 }
 
-template <align::type align = align::left, typename OutputIt, typename Char,
+template <typename Char, align default_align = align::left, typename OutputIt,
           typename F>
-constexpr auto write_padded(OutputIt out, const format_specs<Char>& specs,
+constexpr auto write_padded(OutputIt out, const format_specs& specs,
                             size_t size, F&& f) -> OutputIt {
-  return write_padded<align>(out, specs, size, size, f);
+  return write_padded<Char, default_align>(out, specs, size, size, f);
 }
 
-template <align::type align = align::left, typename Char, typename OutputIt>
+template <typename Char, align default_align = align::left, typename OutputIt>
 FMT_CONSTEXPR auto write_bytes(OutputIt out, string_view bytes,
-                               const format_specs<Char>& specs) -> OutputIt {
-  return write_padded<align>(
+                               const format_specs& specs = {}) -> OutputIt {
+  return write_padded<Char, default_align>(
       out, specs, bytes.size(), [bytes](reserve_iterator<OutputIt> it) {
         const char* data = bytes.data();
-        return copy_str<Char>(data, data + bytes.size(), it);
+        return copy<Char>(data, data + bytes.size(), it);
       });
 }
 
 template <typename Char, typename OutputIt, typename UIntPtr>
-auto write_ptr(OutputIt out, UIntPtr value, const format_specs<Char>* specs)
+auto write_ptr(OutputIt out, UIntPtr value, const format_specs* specs)
     -> OutputIt {
   int num_digits = count_digits<4>(value);
   auto size = to_unsigned(num_digits) + size_t(2);
   auto write = [=](reserve_iterator<OutputIt> it) {
     *it++ = static_cast<Char>('0');
     *it++ = static_cast<Char>('x');
-    return format_uint<4, Char>(it, value, num_digits);
+    return format_base2e<Char>(4, it, value, num_digits);
   };
-  return specs ? write_padded<align::right>(out, *specs, size, write)
+  return specs ? write_padded<Char, align::right>(out, *specs, size, write)
                : base_iterator(out, write(reserve(out, size)));
 }
 
@@ -1779,8 +1680,9 @@ auto write_ptr(OutputIt out, UIntPtr value, const format_specs<Char>* specs)
 FMT_API auto is_printable(uint32_t cp) -> bool;
 
 inline auto needs_escape(uint32_t cp) -> bool {
-  return cp < 0x20 || cp == 0x7f || cp == '"' || cp == '\\' ||
-         !is_printable(cp);
+  if (cp < 0x20 || cp == 0x7f || cp == '"' || cp == '\\') return true;
+  if (const_check(FMT_OPTIMIZE_SIZE > 1)) return false;
+  return !is_printable(cp);
 }
 
 template <typename Char> struct find_escape_result {
@@ -1789,17 +1691,11 @@ template <typename Char> struct find_escape_result {
   uint32_t cp;
 };
 
-template <typename Char>
-using make_unsigned_char =
-    typename conditional_t<std::is_integral<Char>::value,
-                           std::make_unsigned<Char>,
-                           type_identity<uint32_t>>::type;
-
 template <typename Char>
 auto find_escape(const Char* begin, const Char* end)
     -> find_escape_result<Char> {
   for (; begin != end; ++begin) {
-    uint32_t cp = static_cast<make_unsigned_char<Char>>(*begin);
+    uint32_t cp = static_cast<unsigned_char<Char>>(*begin);
     if (const_check(sizeof(Char) == 1) && cp >= 0x80) continue;
     if (needs_escape(cp)) return {begin, begin + 1, cp};
   }
@@ -1808,7 +1704,7 @@ auto find_escape(const Char* begin, const Char* end)
 
 inline auto find_escape(const char* begin, const char* end)
     -> find_escape_result<char> {
-  if (!is_utf8()) return find_escape<char>(begin, end);
+  if (const_check(!use_utf8)) return find_escape<char>(begin, end);
   auto result = find_escape_result<char>{end, nullptr, 0};
   for_each_codepoint(string_view(begin, to_unsigned(end - begin)),
                      [&](uint32_t cp, string_view sv) {
@@ -1821,40 +1717,14 @@ inline auto find_escape(const char* begin, const char* end)
   return result;
 }
 
-#define FMT_STRING_IMPL(s, base, explicit)                                    \
-  [] {                                                                        \
-    /* Use the hidden visibility as a workaround for a GCC bug (#1973). */    \
-    /* Use a macro-like name to avoid shadowing warnings. */                  \
-    struct FMT_VISIBILITY("hidden") FMT_COMPILE_STRING : base {               \
-      using char_type FMT_MAYBE_UNUSED = fmt::remove_cvref_t<decltype(s[0])>; \
-      FMT_MAYBE_UNUSED FMT_CONSTEXPR explicit                                 \
-      operator fmt::basic_string_view<char_type>() const {                    \
-        return fmt::detail_exported::compile_string_to_view<char_type>(s);    \
-      }                                                                       \
-    };                                                                        \
-    return FMT_COMPILE_STRING();                                              \
-  }()
-
-/**
-  \rst
-  Constructs a compile-time format string from a string literal *s*.
-
-  **Example**::
-
-    // A compile-time error because 'd' is an invalid specifier for strings.
-    std::string s = fmt::format(FMT_STRING("{:d}"), "foo");
-  \endrst
- */
-#define FMT_STRING(s) FMT_STRING_IMPL(s, fmt::detail::compile_string, )
-
 template <size_t width, typename Char, typename OutputIt>
 auto write_codepoint(OutputIt out, char prefix, uint32_t cp) -> OutputIt {
   *out++ = static_cast<Char>('\\');
   *out++ = static_cast<Char>(prefix);
   Char buf[width];
   fill_n(buf, width, static_cast<Char>('0'));
-  format_uint<4>(buf, cp, width);
-  return copy_str<Char>(buf, buf + width, out);
+  format_base2e(4, buf, cp, width);
+  return copy<Char>(buf, buf + width, out);
 }
 
 template <typename OutputIt, typename Char>
@@ -1874,23 +1744,15 @@ auto write_escaped_cp(OutputIt out, const find_escape_result<Char>& escape)
     *out++ = static_cast<Char>('\\');
     c = static_cast<Char>('t');
     break;
-  case '"':
-    FMT_FALLTHROUGH;
-  case '\'':
-    FMT_FALLTHROUGH;
-  case '\\':
-    *out++ = static_cast<Char>('\\');
-    break;
+  case '"':  FMT_FALLTHROUGH;
+  case '\'': FMT_FALLTHROUGH;
+  case '\\': *out++ = static_cast<Char>('\\'); break;
   default:
-    if (escape.cp < 0x100) {
-      return write_codepoint<2, Char>(out, 'x', escape.cp);
-    }
-    if (escape.cp < 0x10000) {
+    if (escape.cp < 0x100) return write_codepoint<2, Char>(out, 'x', escape.cp);
+    if (escape.cp < 0x10000)
       return write_codepoint<4, Char>(out, 'u', escape.cp);
-    }
-    if (escape.cp < 0x110000) {
+    if (escape.cp < 0x110000)
       return write_codepoint<8, Char>(out, 'U', escape.cp);
-    }
     for (Char escape_char : basic_string_view<Char>(
              escape.begin, to_unsigned(escape.end - escape.begin))) {
       out = write_codepoint<2, Char>(out, 'x',
@@ -1909,7 +1771,7 @@ auto write_escaped_string(OutputIt out, basic_string_view<Char> str)
   auto begin = str.begin(), end = str.end();
   do {
     auto escape = find_escape(begin, end);
-    out = copy_str<Char>(begin, escape.begin, out);
+    out = copy<Char>(begin, escape.begin, out);
     begin = escape.end;
     if (!begin) break;
     out = write_escaped_cp<OutputIt, Char>(out, escape);
@@ -1936,74 +1798,23 @@ auto write_escaped_char(OutputIt out, Char v) -> OutputIt {
 
 template <typename Char, typename OutputIt>
 FMT_CONSTEXPR auto write_char(OutputIt out, Char value,
-                              const format_specs<Char>& specs) -> OutputIt {
-  bool is_debug = specs.type == presentation_type::debug;
-  return write_padded(out, specs, 1, [=](reserve_iterator<OutputIt> it) {
+                              const format_specs& specs) -> OutputIt {
+  bool is_debug = specs.type() == presentation_type::debug;
+  return write_padded<Char>(out, specs, 1, [=](reserve_iterator<OutputIt> it) {
     if (is_debug) return write_escaped_char(it, value);
     *it++ = value;
     return it;
   });
 }
 template <typename Char, typename OutputIt>
-FMT_CONSTEXPR auto write(OutputIt out, Char value,
-                         const format_specs<Char>& specs, locale_ref loc = {})
-    -> OutputIt {
+FMT_CONSTEXPR auto write(OutputIt out, Char value, const format_specs& specs,
+                         locale_ref loc = {}) -> OutputIt {
   // char is formatted as unsigned char for consistency across platforms.
   using unsigned_type =
       conditional_t<std::is_same<Char, char>::value, unsigned char, unsigned>;
   return check_char_specs(specs)
-             ? write_char(out, value, specs)
-             : write(out, static_cast<unsigned_type>(value), specs, loc);
-}
-
-// Data for write_int that doesn't depend on output iterator type. It is used to
-// avoid template code bloat.
-template <typename Char> struct write_int_data {
-  size_t size;
-  size_t padding;
-
-  FMT_CONSTEXPR write_int_data(int num_digits, unsigned prefix,
-                               const format_specs<Char>& specs)
-      : size((prefix >> 24) + to_unsigned(num_digits)), padding(0) {
-    if (specs.align == align::numeric) {
-      auto width = to_unsigned(specs.width);
-      if (width > size) {
-        padding = width - size;
-        size = width;
-      }
-    } else if (specs.precision > num_digits) {
-      size = (prefix >> 24) + to_unsigned(specs.precision);
-      padding = to_unsigned(specs.precision - num_digits);
-    }
-  }
-};
-
-// Writes an integer in the format
-//   <left-padding><prefix><numeric-padding><digits><right-padding>
-// where <digits> are written by write_digits(it).
-// prefix contains chars in three lower bytes and the size in the fourth byte.
-template <typename OutputIt, typename Char, typename W>
-FMT_CONSTEXPR FMT_INLINE auto write_int(OutputIt out, int num_digits,
-                                        unsigned prefix,
-                                        const format_specs<Char>& specs,
-                                        W write_digits) -> OutputIt {
-  // Slightly faster check for specs.width == 0 && specs.precision == -1.
-  if ((specs.width | (specs.precision + 1)) == 0) {
-    auto it = reserve(out, to_unsigned(num_digits) + (prefix >> 24));
-    if (prefix != 0) {
-      for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
-        *it++ = static_cast<Char>(p & 0xff);
-    }
-    return base_iterator(out, write_digits(it));
-  }
-  auto data = write_int_data<Char>(num_digits, prefix, specs);
-  return write_padded<align::right>(
-      out, specs, data.size, [=](reserve_iterator<OutputIt> it) {
-        for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
-          *it++ = static_cast<Char>(p & 0xff);
-        it = detail::fill_n(it, data.padding, static_cast<Char>('0'));
-        return write_digits(it);
-      });
+             ? write_char<Char>(out, value, specs)
+             : write<Char>(out, static_cast<unsigned_type>(value), specs, loc);
 }
 
 template <typename Char> class digit_grouping {
@@ -2028,7 +1839,9 @@ template <typename Char> class digit_grouping {
   }
 
  public:
-  explicit digit_grouping(locale_ref loc, bool localized = true) {
+  template <typename Locale,
+            FMT_ENABLE_IF(std::is_same<Locale, locale_ref>::value)>
+  explicit digit_grouping(Locale loc, bool localized = true) {
     if (!localized) return;
     auto sep = thousands_sep<Char>(loc);
     grouping_ = sep.grouping;
@@ -2060,9 +1873,8 @@ template <typename Char> class digit_grouping {
     for (int i = 0, sep_index = static_cast<int>(separators.size() - 1);
          i < num_digits; ++i) {
       if (num_digits - i == separators[sep_index]) {
-        out =
-            copy_str<Char>(thousands_sep_.data(),
-                           thousands_sep_.data() + thousands_sep_.size(), out);
+        out = copy<Char>(thousands_sep_.data(),
+                         thousands_sep_.data() + thousands_sep_.size(), out);
         --sep_index;
       }
       *out++ = static_cast<Char>(digits[to_unsigned(i)]);
@@ -2079,54 +1891,45 @@ FMT_CONSTEXPR inline void prefix_append(unsigned& prefix, unsigned value) {
 // Writes a decimal integer with digit grouping.
 template <typename OutputIt, typename UInt, typename Char>
 auto write_int(OutputIt out, UInt value, unsigned prefix,
-               const format_specs<Char>& specs,
-               const digit_grouping<Char>& grouping) -> OutputIt {
+               const format_specs& specs, const digit_grouping<Char>& grouping)
+    -> OutputIt {
   static_assert(std::is_same<uint64_or_128_t<UInt>, UInt>::value, "");
   int num_digits = 0;
   auto buffer = memory_buffer();
-  switch (specs.type) {
+  switch (specs.type()) {
+  default: FMT_ASSERT(false, ""); FMT_FALLTHROUGH;
   case presentation_type::none:
-  case presentation_type::dec: {
+  case presentation_type::dec:
     num_digits = count_digits(value);
     format_decimal<char>(appender(buffer), value, num_digits);
     break;
-  }
-  case presentation_type::hex_lower:
-  case presentation_type::hex_upper: {
-    bool upper = specs.type == presentation_type::hex_upper;
-    if (specs.alt)
-      prefix_append(prefix, unsigned(upper ? 'X' : 'x') << 8 | '0');
+  case presentation_type::hex:
+    if (specs.alt())
+      prefix_append(prefix, unsigned(specs.upper() ? 'X' : 'x') << 8 | '0');
     num_digits = count_digits<4>(value);
-    format_uint<4, char>(appender(buffer), value, num_digits, upper);
-    break;
-  }
-  case presentation_type::bin_lower:
-  case presentation_type::bin_upper: {
-    bool upper = specs.type == presentation_type::bin_upper;
-    if (specs.alt)
-      prefix_append(prefix, unsigned(upper ? 'B' : 'b') << 8 | '0');
-    num_digits = count_digits<1>(value);
-    format_uint<1, char>(appender(buffer), value, num_digits);
+    format_base2e<char>(4, appender(buffer), value, num_digits, specs.upper());
     break;
-  }
-  case presentation_type::oct: {
+  case presentation_type::oct:
     num_digits = count_digits<3>(value);
     // Octal prefix '0' is counted as a digit, so only add it if precision
     // is not greater than the number of digits.
-    if (specs.alt && specs.precision <= num_digits && value != 0)
+    if (specs.alt() && specs.precision <= num_digits && value != 0)
       prefix_append(prefix, '0');
-    format_uint<3, char>(appender(buffer), value, num_digits);
+    format_base2e<char>(3, appender(buffer), value, num_digits);
+    break;
+  case presentation_type::bin:
+    if (specs.alt())
+      prefix_append(prefix, unsigned(specs.upper() ? 'B' : 'b') << 8 | '0');
+    num_digits = count_digits<1>(value);
+    format_base2e<char>(1, appender(buffer), value, num_digits);
     break;
-  }
   case presentation_type::chr:
-    return write_char(out, static_cast<Char>(value), specs);
-  default:
-    throw_format_error("invalid format specifier");
+    return write_char<Char>(out, static_cast<Char>(value), specs);
   }
 
   unsigned size = (prefix != 0 ? prefix >> 24 : 0) + to_unsigned(num_digits) +
                   to_unsigned(grouping.count_separators(num_digits));
-  return write_padded<align::right>(
+  return write_padded<Char, align::right>(
       out, specs, size, size, [&](reserve_iterator<OutputIt> it) {
         for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
           *it++ = static_cast<Char>(p & 0xff);
@@ -2134,11 +1937,13 @@ auto write_int(OutputIt out, UInt value, unsigned prefix,
       });
 }
 
+#if FMT_USE_LOCALE
 // Writes a localized value.
-FMT_API auto write_loc(appender out, loc_value value,
-                       const format_specs<>& specs, locale_ref loc) -> bool;
-template <typename OutputIt, typename Char>
-inline auto write_loc(OutputIt, loc_value, const format_specs<Char>&,
+FMT_API auto write_loc(appender out, loc_value value, const format_specs& specs,
+                       locale_ref loc) -> bool;
+#endif
+template <typename OutputIt>
+inline auto write_loc(OutputIt, const loc_value&, const format_specs&,
                       locale_ref) -> bool {
   return false;
 }
@@ -2149,7 +1954,7 @@ template <typename UInt> struct write_int_arg {
 };
 
 template <typename T>
-FMT_CONSTEXPR auto make_write_int_arg(T value, sign_t sign)
+FMT_CONSTEXPR auto make_write_int_arg(T value, sign s)
     -> write_int_arg<uint32_or_64_or_128_t<T>> {
   auto prefix = 0u;
   auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);
@@ -2159,21 +1964,21 @@ FMT_CONSTEXPR auto make_write_int_arg(T value, sign_t sign)
   } else {
     constexpr const unsigned prefixes[4] = {0, 0, 0x1000000u | '+',
                                             0x1000000u | ' '};
-    prefix = prefixes[sign];
+    prefix = prefixes[static_cast<int>(s)];
   }
   return {abs_value, prefix};
 }
 
 template <typename Char = char> struct loc_writer {
-  buffer_appender<Char> out;
-  const format_specs<Char>& specs;
+  basic_appender<Char> out;
+  const format_specs& specs;
   std::basic_string<Char> sep;
   std::string grouping;
   std::basic_string<Char> decimal_point;
 
   template <typename T, FMT_ENABLE_IF(is_integer<T>::value)>
   auto operator()(T value) -> bool {
-    auto arg = make_write_int_arg(value, specs.sign);
+    auto arg = make_write_int_arg(value, specs.sign());
     write_int(out, static_cast<uint64_or_128_t<T>>(arg.abs_value), arg.prefix,
               specs, digit_grouping<Char>(grouping, sep));
     return true;
@@ -2185,167 +1990,162 @@ template <typename Char = char> struct loc_writer {
   }
 };
 
+// Size and padding computation separate from write_int to avoid template bloat.
+struct size_padding {
+  unsigned size;
+  unsigned padding;
+
+  FMT_CONSTEXPR size_padding(int num_digits, unsigned prefix,
+                             const format_specs& specs)
+      : size((prefix >> 24) + to_unsigned(num_digits)), padding(0) {
+    if (specs.align() == align::numeric) {
+      auto width = to_unsigned(specs.width);
+      if (width > size) {
+        padding = width - size;
+        size = width;
+      }
+    } else if (specs.precision > num_digits) {
+      size = (prefix >> 24) + to_unsigned(specs.precision);
+      padding = to_unsigned(specs.precision - num_digits);
+    }
+  }
+};
+
 template <typename Char, typename OutputIt, typename T>
 FMT_CONSTEXPR FMT_INLINE auto write_int(OutputIt out, write_int_arg<T> arg,
-                                        const format_specs<Char>& specs,
-                                        locale_ref) -> OutputIt {
+                                        const format_specs& specs) -> OutputIt {
   static_assert(std::is_same<T, uint32_or_64_or_128_t<T>>::value, "");
+
+  constexpr int buffer_size = num_bits<T>();
+  char buffer[buffer_size];
+  if (is_constant_evaluated()) fill_n(buffer, buffer_size, '\0');
+  const char* begin = nullptr;
+  const char* end = buffer + buffer_size;
+
   auto abs_value = arg.abs_value;
   auto prefix = arg.prefix;
-  switch (specs.type) {
+  switch (specs.type()) {
+  default: FMT_ASSERT(false, ""); FMT_FALLTHROUGH;
   case presentation_type::none:
-  case presentation_type::dec: {
-    auto num_digits = count_digits(abs_value);
-    return write_int(
-        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
-          return format_decimal<Char>(it, abs_value, num_digits).end;
-        });
-  }
-  case presentation_type::hex_lower:
-  case presentation_type::hex_upper: {
-    bool upper = specs.type == presentation_type::hex_upper;
-    if (specs.alt)
-      prefix_append(prefix, unsigned(upper ? 'X' : 'x') << 8 | '0');
-    int num_digits = count_digits<4>(abs_value);
-    return write_int(
-        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
-          return format_uint<4, Char>(it, abs_value, num_digits, upper);
-        });
-  }
-  case presentation_type::bin_lower:
-  case presentation_type::bin_upper: {
-    bool upper = specs.type == presentation_type::bin_upper;
-    if (specs.alt)
-      prefix_append(prefix, unsigned(upper ? 'B' : 'b') << 8 | '0');
-    int num_digits = count_digits<1>(abs_value);
-    return write_int(out, num_digits, prefix, specs,
-                     [=](reserve_iterator<OutputIt> it) {
-                       return format_uint<1, Char>(it, abs_value, num_digits);
-                     });
-  }
+  case presentation_type::dec:
+    begin = do_format_decimal(buffer, abs_value, buffer_size);
+    break;
+  case presentation_type::hex:
+    begin = do_format_base2e(4, buffer, abs_value, buffer_size, specs.upper());
+    if (specs.alt())
+      prefix_append(prefix, unsigned(specs.upper() ? 'X' : 'x') << 8 | '0');
+    break;
   case presentation_type::oct: {
-    int num_digits = count_digits<3>(abs_value);
+    begin = do_format_base2e(3, buffer, abs_value, buffer_size);
     // Octal prefix '0' is counted as a digit, so only add it if precision
     // is not greater than the number of digits.
-    if (specs.alt && specs.precision <= num_digits && abs_value != 0)
+    auto num_digits = end - begin;
+    if (specs.alt() && specs.precision <= num_digits && abs_value != 0)
       prefix_append(prefix, '0');
-    return write_int(out, num_digits, prefix, specs,
-                     [=](reserve_iterator<OutputIt> it) {
-                       return format_uint<3, Char>(it, abs_value, num_digits);
-                     });
+    break;
   }
+  case presentation_type::bin:
+    begin = do_format_base2e(1, buffer, abs_value, buffer_size);
+    if (specs.alt())
+      prefix_append(prefix, unsigned(specs.upper() ? 'B' : 'b') << 8 | '0');
+    break;
   case presentation_type::chr:
-    return write_char(out, static_cast<Char>(abs_value), specs);
-  default:
-    throw_format_error("invalid format specifier");
+    return write_char<Char>(out, static_cast<Char>(abs_value), specs);
   }
-  return out;
+
+  // Write an integer in the format
+  //   <left-padding><prefix><numeric-padding><digits><right-padding>
+  // prefix contains chars in three lower bytes and the size in the fourth byte.
+  int num_digits = static_cast<int>(end - begin);
+  // Slightly faster check for specs.width == 0 && specs.precision == -1.
+  if ((specs.width | (specs.precision + 1)) == 0) {
+    auto it = reserve(out, to_unsigned(num_digits) + (prefix >> 24));
+    for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
+      *it++ = static_cast<Char>(p & 0xff);
+    return base_iterator(out, copy<Char>(begin, end, it));
+  }
+  auto sp = size_padding(num_digits, prefix, specs);
+  unsigned padding = sp.padding;
+  return write_padded<Char, align::right>(
+      out, specs, sp.size, [=](reserve_iterator<OutputIt> it) {
+        for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
+          *it++ = static_cast<Char>(p & 0xff);
+        it = detail::fill_n(it, padding, static_cast<Char>('0'));
+        return copy<Char>(begin, end, it);
+      });
 }
+
 template <typename Char, typename OutputIt, typename T>
-FMT_CONSTEXPR FMT_NOINLINE auto write_int_noinline(
-    OutputIt out, write_int_arg<T> arg, const format_specs<Char>& specs,
-    locale_ref loc) -> OutputIt {
-  return write_int(out, arg, specs, loc);
+FMT_CONSTEXPR FMT_NOINLINE auto write_int_noinline(OutputIt out,
+                                                   write_int_arg<T> arg,
+                                                   const format_specs& specs)
+    -> OutputIt {
+  return write_int<Char>(out, arg, specs);
 }
-template <typename Char, typename OutputIt, typename T,
+
+template <typename Char, typename T,
           FMT_ENABLE_IF(is_integral<T>::value &&
                         !std::is_same<T, bool>::value &&
-                        std::is_same<OutputIt, buffer_appender<Char>>::value)>
-FMT_CONSTEXPR FMT_INLINE auto write(OutputIt out, T value,
-                                    const format_specs<Char>& specs,
-                                    locale_ref loc) -> OutputIt {
-  if (specs.localized && write_loc(out, value, specs, loc)) return out;
-  return write_int_noinline(out, make_write_int_arg(value, specs.sign), specs,
-                            loc);
+                        !std::is_same<T, Char>::value)>
+FMT_CONSTEXPR FMT_INLINE auto write(basic_appender<Char> out, T value,
+                                    const format_specs& specs, locale_ref loc)
+    -> basic_appender<Char> {
+  if (specs.localized() && write_loc(out, value, specs, loc)) return out;
+  return write_int_noinline<Char>(out, make_write_int_arg(value, specs.sign()),
+                                  specs);
 }
+
 // An inlined version of write used in format string compilation.
 template <typename Char, typename OutputIt, typename T,
           FMT_ENABLE_IF(is_integral<T>::value &&
                         !std::is_same<T, bool>::value &&
-                        !std::is_same<OutputIt, buffer_appender<Char>>::value)>
+                        !std::is_same<T, Char>::value &&
+                        !std::is_same<OutputIt, basic_appender<Char>>::value)>
 FMT_CONSTEXPR FMT_INLINE auto write(OutputIt out, T value,
-                                    const format_specs<Char>& specs,
-                                    locale_ref loc) -> OutputIt {
-  if (specs.localized && write_loc(out, value, specs, loc)) return out;
-  return write_int(out, make_write_int_arg(value, specs.sign), specs, loc);
+                                    const format_specs& specs, locale_ref loc)
+    -> OutputIt {
+  if (specs.localized() && write_loc(out, value, specs, loc)) return out;
+  return write_int<Char>(out, make_write_int_arg(value, specs.sign()), specs);
 }
 
-// An output iterator that counts the number of objects written to it and
-// discards them.
-class counting_iterator {
- private:
-  size_t count_;
-
- public:
-  using iterator_category = std::output_iterator_tag;
-  using difference_type = std::ptrdiff_t;
-  using pointer = void;
-  using reference = void;
-  FMT_UNCHECKED_ITERATOR(counting_iterator);
-
-  struct value_type {
-    template <typename T> FMT_CONSTEXPR void operator=(const T&) {}
-  };
-
-  FMT_CONSTEXPR counting_iterator() : count_(0) {}
-
-  FMT_CONSTEXPR auto count() const -> size_t { return count_; }
-
-  FMT_CONSTEXPR auto operator++() -> counting_iterator& {
-    ++count_;
-    return *this;
-  }
-  FMT_CONSTEXPR auto operator++(int) -> counting_iterator {
-    auto it = *this;
-    ++*this;
-    return it;
-  }
-
-  FMT_CONSTEXPR friend auto operator+(counting_iterator it, difference_type n)
-      -> counting_iterator {
-    it.count_ += static_cast<size_t>(n);
-    return it;
-  }
-
-  FMT_CONSTEXPR auto operator*() const -> value_type { return {}; }
-};
-
 template <typename Char, typename OutputIt>
 FMT_CONSTEXPR auto write(OutputIt out, basic_string_view<Char> s,
-                         const format_specs<Char>& specs) -> OutputIt {
+                         const format_specs& specs) -> OutputIt {
   auto data = s.data();
   auto size = s.size();
   if (specs.precision >= 0 && to_unsigned(specs.precision) < size)
     size = code_point_index(s, to_unsigned(specs.precision));
-  bool is_debug = specs.type == presentation_type::debug;
+
+  bool is_debug = specs.type() == presentation_type::debug;
+  if (is_debug) {
+    auto buf = counting_buffer<Char>();
+    write_escaped_string(basic_appender<Char>(buf), s);
+    size = buf.count();
+  }
+
   size_t width = 0;
   if (specs.width != 0) {
-    if (is_debug)
-      width = write_escaped_string(counting_iterator{}, s).count();
-    else
-      width = compute_width(basic_string_view<Char>(data, size));
+    width =
+        is_debug ? size : compute_width(basic_string_view<Char>(data, size));
   }
-  return write_padded(out, specs, size, width,
-                      [=](reserve_iterator<OutputIt> it) {
-                        if (is_debug) return write_escaped_string(it, s);
-                        return copy_str<Char>(data, data + size, it);
-                      });
+  return write_padded<Char>(
+      out, specs, size, width, [=](reserve_iterator<OutputIt> it) {
+        return is_debug ? write_escaped_string(it, s)
+                        : copy<Char>(data, data + size, it);
+      });
 }
 template <typename Char, typename OutputIt>
-FMT_CONSTEXPR auto write(OutputIt out,
-                         basic_string_view<type_identity_t<Char>> s,
-                         const format_specs<Char>& specs, locale_ref)
-    -> OutputIt {
-  return write(out, s, specs);
+FMT_CONSTEXPR auto write(OutputIt out, basic_string_view<Char> s,
+                         const format_specs& specs, locale_ref) -> OutputIt {
+  return write<Char>(out, s, specs);
 }
 template <typename Char, typename OutputIt>
-FMT_CONSTEXPR auto write(OutputIt out, const Char* s,
-                         const format_specs<Char>& specs, locale_ref)
-    -> OutputIt {
-  if (specs.type == presentation_type::pointer)
+FMT_CONSTEXPR auto write(OutputIt out, const Char* s, const format_specs& specs,
+                         locale_ref) -> OutputIt {
+  if (specs.type() == presentation_type::pointer)
     return write_ptr<Char>(out, bit_cast<uintptr_t>(s), &specs);
-  if (!s) throw_format_error("string pointer is null");
-  return write(out, basic_string_view<Char>(s), specs, {});
+  if (!s) report_error("string pointer is null");
+  return write<Char>(out, basic_string_view<Char>(s), specs, {});
 }
 
 template <typename Char, typename OutputIt, typename T,
@@ -2359,46 +2159,37 @@ FMT_CONSTEXPR auto write(OutputIt out, T value) -> OutputIt {
   if (negative) abs_value = ~abs_value + 1;
   int num_digits = count_digits(abs_value);
   auto size = (negative ? 1 : 0) + static_cast<size_t>(num_digits);
-  auto it = reserve(out, size);
-  if (auto ptr = to_pointer<Char>(it, size)) {
+  if (auto ptr = to_pointer<Char>(out, size)) {
     if (negative) *ptr++ = static_cast<Char>('-');
     format_decimal<Char>(ptr, abs_value, num_digits);
     return out;
   }
-  if (negative) *it++ = static_cast<Char>('-');
-  it = format_decimal<Char>(it, abs_value, num_digits).end;
-  return base_iterator(out, it);
+  if (negative) *out++ = static_cast<Char>('-');
+  return format_decimal<Char>(out, abs_value, num_digits);
 }
 
-// DEPRECATED!
 template <typename Char>
 FMT_CONSTEXPR auto parse_align(const Char* begin, const Char* end,
-                               format_specs<Char>& specs) -> const Char* {
+                               format_specs& specs) -> const Char* {
   FMT_ASSERT(begin != end, "");
-  auto align = align::none;
+  auto alignment = align::none;
   auto p = begin + code_point_length(begin);
   if (end - p <= 0) p = begin;
   for (;;) {
     switch (to_ascii(*p)) {
-    case '<':
-      align = align::left;
-      break;
-    case '>':
-      align = align::right;
-      break;
-    case '^':
-      align = align::center;
-      break;
+    case '<': alignment = align::left; break;
+    case '>': alignment = align::right; break;
+    case '^': alignment = align::center; break;
     }
-    if (align != align::none) {
+    if (alignment != align::none) {
       if (p != begin) {
         auto c = *begin;
         if (c == '}') return begin;
         if (c == '{') {
-          throw_format_error("invalid fill character '{'");
+          report_error("invalid fill character '{'");
           return begin;
         }
-        specs.fill = {begin, to_unsigned(p - begin)};
+        specs.set_fill(basic_string_view<Char>(begin, to_unsigned(p - begin)));
         begin = p + 1;
       } else {
         ++begin;
@@ -2409,88 +2200,27 @@ FMT_CONSTEXPR auto parse_align(const Char* begin, const Char* end,
     }
     p = begin;
   }
-  specs.align = align;
+  specs.set_align(alignment);
   return begin;
 }
 
-// A floating-point presentation format.
-enum class float_format : unsigned char {
-  general,  // General: exponent notation or fixed point based on magnitude.
-  exp,      // Exponent notation with the default precision of 6, e.g. 1.2e-3.
-  fixed,    // Fixed point with the default precision of 6, e.g. 0.0012.
-  hex
-};
-
-struct float_specs {
-  int precision;
-  float_format format : 8;
-  sign_t sign : 8;
-  bool upper : 1;
-  bool locale : 1;
-  bool binary32 : 1;
-  bool showpoint : 1;
-};
-
-template <typename Char>
-FMT_CONSTEXPR auto parse_float_type_spec(const format_specs<Char>& specs)
-    -> float_specs {
-  auto result = float_specs();
-  result.showpoint = specs.alt;
-  result.locale = specs.localized;
-  switch (specs.type) {
-  case presentation_type::none:
-    result.format = float_format::general;
-    break;
-  case presentation_type::general_upper:
-    result.upper = true;
-    FMT_FALLTHROUGH;
-  case presentation_type::general_lower:
-    result.format = float_format::general;
-    break;
-  case presentation_type::exp_upper:
-    result.upper = true;
-    FMT_FALLTHROUGH;
-  case presentation_type::exp_lower:
-    result.format = float_format::exp;
-    result.showpoint |= specs.precision != 0;
-    break;
-  case presentation_type::fixed_upper:
-    result.upper = true;
-    FMT_FALLTHROUGH;
-  case presentation_type::fixed_lower:
-    result.format = float_format::fixed;
-    result.showpoint |= specs.precision != 0;
-    break;
-  case presentation_type::hexfloat_upper:
-    result.upper = true;
-    FMT_FALLTHROUGH;
-  case presentation_type::hexfloat_lower:
-    result.format = float_format::hex;
-    break;
-  default:
-    throw_format_error("invalid format specifier");
-    break;
-  }
-  return result;
-}
-
 template <typename Char, typename OutputIt>
 FMT_CONSTEXPR20 auto write_nonfinite(OutputIt out, bool isnan,
-                                     format_specs<Char> specs,
-                                     const float_specs& fspecs) -> OutputIt {
+                                     format_specs specs, sign s) -> OutputIt {
   auto str =
-      isnan ? (fspecs.upper ? "NAN" : "nan") : (fspecs.upper ? "INF" : "inf");
+      isnan ? (specs.upper() ? "NAN" : "nan") : (specs.upper() ? "INF" : "inf");
   constexpr size_t str_size = 3;
-  auto sign = fspecs.sign;
-  auto size = str_size + (sign ? 1 : 0);
+  auto size = str_size + (s != sign::none ? 1 : 0);
   // Replace '0'-padding with space for non-finite values.
   const bool is_zero_fill =
-      specs.fill.size() == 1 && *specs.fill.data() == static_cast<Char>('0');
-  if (is_zero_fill) specs.fill[0] = static_cast<Char>(' ');
-  return write_padded(out, specs, size, [=](reserve_iterator<OutputIt> it) {
-    if (sign) *it++ = detail::sign<Char>(sign);
-    return copy_str<Char>(str, str + str_size, it);
-  });
+      specs.fill_size() == 1 && specs.fill_unit<Char>() == '0';
+  if (is_zero_fill) specs.set_fill(' ');
+  return write_padded<Char>(out, specs, size,
+                            [=](reserve_iterator<OutputIt> it) {
+                              if (s != sign::none)
+                                *it++ = detail::getsign<Char>(s);
+                              return copy<Char>(str, str + str_size, it);
+                            });
 }
 
 // A decimal floating-point number significand * pow(10, exp).
@@ -2511,12 +2241,12 @@ inline auto get_significand_size(const dragonbox::decimal_fp<T>& f) -> int {
 template <typename Char, typename OutputIt>
 constexpr auto write_significand(OutputIt out, const char* significand,
                                  int significand_size) -> OutputIt {
-  return copy_str<Char>(significand, significand + significand_size, out);
+  return copy<Char>(significand, significand + significand_size, out);
 }
 template <typename Char, typename OutputIt, typename UInt>
 inline auto write_significand(OutputIt out, UInt significand,
                               int significand_size) -> OutputIt {
-  return format_decimal<Char>(out, significand, significand_size).end;
+  return format_decimal<Char>(out, significand, significand_size);
 }
 template <typename Char, typename OutputIt, typename T, typename Grouping>
 FMT_CONSTEXPR20 auto write_significand(OutputIt out, T significand,
@@ -2536,14 +2266,13 @@ template <typename Char, typename UInt,
           FMT_ENABLE_IF(std::is_integral<UInt>::value)>
 inline auto write_significand(Char* out, UInt significand, int significand_size,
                               int integral_size, Char decimal_point) -> Char* {
-  if (!decimal_point)
-    return format_decimal(out, significand, significand_size).end;
+  if (!decimal_point) return format_decimal(out, significand, significand_size);
   out += significand_size + 1;
   Char* end = out;
   int floating_size = significand_size - integral_size;
   for (int i = floating_size / 2; i > 0; --i) {
     out -= 2;
-    copy2(out, digits2(static_cast<std::size_t>(significand % 100)));
+    write2digits(out, static_cast<std::size_t>(significand % 100));
     significand /= 100;
   }
   if (floating_size % 2 != 0) {
@@ -2564,19 +2293,19 @@ inline auto write_significand(OutputIt out, UInt significand,
   Char buffer[digits10<UInt>() + 2];
   auto end = write_significand(buffer, significand, significand_size,
                                integral_size, decimal_point);
-  return detail::copy_str_noinline<Char>(buffer, end, out);
+  return detail::copy_noinline<Char>(buffer, end, out);
 }
 
 template <typename OutputIt, typename Char>
 FMT_CONSTEXPR auto write_significand(OutputIt out, const char* significand,
                                      int significand_size, int integral_size,
                                      Char decimal_point) -> OutputIt {
-  out = detail::copy_str_noinline<Char>(significand,
-                                        significand + integral_size, out);
+  out = detail::copy_noinline<Char>(significand, significand + integral_size,
+                                    out);
   if (!decimal_point) return out;
   *out++ = decimal_point;
-  return detail::copy_str_noinline<Char>(significand + integral_size,
-                                         significand + significand_size, out);
+  return detail::copy_noinline<Char>(significand + integral_size,
+                                     significand + significand_size, out);
 }
 
 template <typename OutputIt, typename Char, typename T, typename Grouping>
@@ -2589,44 +2318,42 @@ FMT_CONSTEXPR20 auto write_significand(OutputIt out, T significand,
                              decimal_point);
   }
   auto buffer = basic_memory_buffer<Char>();
-  write_significand(buffer_appender<Char>(buffer), significand,
-                    significand_size, integral_size, decimal_point);
+  write_significand(basic_appender<Char>(buffer), significand, significand_size,
+                    integral_size, decimal_point);
   grouping.apply(
       out, basic_string_view<Char>(buffer.data(), to_unsigned(integral_size)));
-  return detail::copy_str_noinline<Char>(buffer.data() + integral_size,
-                                         buffer.end(), out);
+  return detail::copy_noinline<Char>(buffer.data() + integral_size,
+                                     buffer.end(), out);
 }
 
-template <typename OutputIt, typename DecimalFP, typename Char,
+template <typename Char, typename OutputIt, typename DecimalFP,
           typename Grouping = digit_grouping<Char>>
 FMT_CONSTEXPR20 auto do_write_float(OutputIt out, const DecimalFP& f,
-                                    const format_specs<Char>& specs,
-                                    float_specs fspecs, locale_ref loc)
-    -> OutputIt {
+                                    const format_specs& specs, sign s,
+                                    locale_ref loc) -> OutputIt {
   auto significand = f.significand;
   int significand_size = get_significand_size(f);
   const Char zero = static_cast<Char>('0');
-  auto sign = fspecs.sign;
-  size_t size = to_unsigned(significand_size) + (sign ? 1 : 0);
+  size_t size = to_unsigned(significand_size) + (s != sign::none ? 1 : 0);
   using iterator = reserve_iterator<OutputIt>;
 
-  Char decimal_point =
-      fspecs.locale ? detail::decimal_point<Char>(loc) : static_cast<Char>('.');
+  Char decimal_point = specs.localized() ? detail::decimal_point<Char>(loc)
+                                         : static_cast<Char>('.');
 
   int output_exp = f.exponent + significand_size - 1;
   auto use_exp_format = [=]() {
-    if (fspecs.format == float_format::exp) return true;
-    if (fspecs.format != float_format::general) return false;
+    if (specs.type() == presentation_type::exp) return true;
+    if (specs.type() == presentation_type::fixed) return false;
     // Use the fixed notation if the exponent is in [exp_lower, exp_upper),
     // e.g. 0.0001 instead of 1e-04. Otherwise use the exponent notation.
     const int exp_lower = -4, exp_upper = 16;
     return output_exp < exp_lower ||
-           output_exp >= (fspecs.precision > 0 ? fspecs.precision : exp_upper);
+           output_exp >= (specs.precision > 0 ? specs.precision : exp_upper);
   };
   if (use_exp_format()) {
     int num_zeros = 0;
-    if (fspecs.showpoint) {
-      num_zeros = fspecs.precision - significand_size;
+    if (specs.alt()) {
+      num_zeros = specs.precision - significand_size;
       if (num_zeros < 0) num_zeros = 0;
       size += to_unsigned(num_zeros);
     } else if (significand_size == 1) {
@@ -2637,9 +2364,9 @@ FMT_CONSTEXPR20 auto do_write_float(OutputIt out, const DecimalFP& f,
     if (abs_output_exp >= 100) exp_digits = abs_output_exp >= 1000 ? 4 : 3;
 
     size += to_unsigned((decimal_point ? 1 : 0) + 2 + exp_digits);
-    char exp_char = fspecs.upper ? 'E' : 'e';
+    char exp_char = specs.upper() ? 'E' : 'e';
     auto write = [=](iterator it) {
-      if (sign) *it++ = detail::sign<Char>(sign);
+      if (s != sign::none) *it++ = detail::getsign<Char>(s);
       // Insert a decimal point after the first digit and add an exponent.
       it = write_significand(it, significand, significand_size, 1,
                              decimal_point);
@@ -2647,39 +2374,41 @@ FMT_CONSTEXPR20 auto do_write_float(OutputIt out, const DecimalFP& f,
       *it++ = static_cast<Char>(exp_char);
       return write_exponent<Char>(output_exp, it);
     };
-    return specs.width > 0 ? write_padded<align::right>(out, specs, size, write)
-                           : base_iterator(out, write(reserve(out, size)));
+    return specs.width > 0
+               ? write_padded<Char, align::right>(out, specs, size, write)
+               : base_iterator(out, write(reserve(out, size)));
   }
 
   int exp = f.exponent + significand_size;
   if (f.exponent >= 0) {
     // 1234e5 -> 123400000[.0+]
     size += to_unsigned(f.exponent);
-    int num_zeros = fspecs.precision - exp;
+    int num_zeros = specs.precision - exp;
     abort_fuzzing_if(num_zeros > 5000);
-    if (fspecs.showpoint) {
+    if (specs.alt()) {
       ++size;
-      if (num_zeros <= 0 && fspecs.format != float_format::fixed) num_zeros = 0;
+      if (num_zeros <= 0 && specs.type() != presentation_type::fixed)
+        num_zeros = 0;
       if (num_zeros > 0) size += to_unsigned(num_zeros);
     }
-    auto grouping = Grouping(loc, fspecs.locale);
+    auto grouping = Grouping(loc, specs.localized());
     size += to_unsigned(grouping.count_separators(exp));
-    return write_padded<align::right>(out, specs, size, [&](iterator it) {
-      if (sign) *it++ = detail::sign<Char>(sign);
+    return write_padded<Char, align::right>(out, specs, size, [&](iterator it) {
+      if (s != sign::none) *it++ = detail::getsign<Char>(s);
       it = write_significand<Char>(it, significand, significand_size,
                                    f.exponent, grouping);
-      if (!fspecs.showpoint) return it;
+      if (!specs.alt()) return it;
       *it++ = decimal_point;
       return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;
     });
   } else if (exp > 0) {
     // 1234e-2 -> 12.34[0+]
-    int num_zeros = fspecs.showpoint ? fspecs.precision - significand_size : 0;
-    size += 1 + to_unsigned(num_zeros > 0 ? num_zeros : 0);
-    auto grouping = Grouping(loc, fspecs.locale);
+    int num_zeros = specs.alt() ? specs.precision - significand_size : 0;
+    size += 1 + static_cast<unsigned>(max_of(num_zeros, 0));
+    auto grouping = Grouping(loc, specs.localized());
     size += to_unsigned(grouping.count_separators(exp));
-    return write_padded<align::right>(out, specs, size, [&](iterator it) {
-      if (sign) *it++ = detail::sign<Char>(sign);
+    return write_padded<Char, align::right>(out, specs, size, [&](iterator it) {
+      if (s != sign::none) *it++ = detail::getsign<Char>(s);
       it = write_significand(it, significand, significand_size, exp,
                              decimal_point, grouping);
       return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;
@@ -2687,14 +2416,14 @@ FMT_CONSTEXPR20 auto do_write_float(OutputIt out, const DecimalFP& f,
   }
   // 1234e-6 -> 0.001234
   int num_zeros = -exp;
-  if (significand_size == 0 && fspecs.precision >= 0 &&
-      fspecs.precision < num_zeros) {
-    num_zeros = fspecs.precision;
+  if (significand_size == 0 && specs.precision >= 0 &&
+      specs.precision < num_zeros) {
+    num_zeros = specs.precision;
   }
-  bool pointy = num_zeros != 0 || significand_size != 0 || fspecs.showpoint;
+  bool pointy = num_zeros != 0 || significand_size != 0 || specs.alt();
   size += 1 + (pointy ? 1 : 0) + to_unsigned(num_zeros);
-  return write_padded<align::right>(out, specs, size, [&](iterator it) {
-    if (sign) *it++ = detail::sign<Char>(sign);
+  return write_padded<Char, align::right>(out, specs, size, [&](iterator it) {
+    if (s != sign::none) *it++ = detail::getsign<Char>(s);
     *it++ = zero;
     if (!pointy) return it;
     *it++ = decimal_point;
@@ -2717,22 +2446,20 @@ template <typename Char> class fallback_digit_grouping {
   }
 };
 
-template <typename OutputIt, typename DecimalFP, typename Char>
+template <typename Char, typename OutputIt, typename DecimalFP>
 FMT_CONSTEXPR20 auto write_float(OutputIt out, const DecimalFP& f,
-                                 const format_specs<Char>& specs,
-                                 float_specs fspecs, locale_ref loc)
-    -> OutputIt {
+                                 const format_specs& specs, sign s,
+                                 locale_ref loc) -> OutputIt {
   if (is_constant_evaluated()) {
-    return do_write_float<OutputIt, DecimalFP, Char,
-                          fallback_digit_grouping<Char>>(out, f, specs, fspecs,
-                                                         loc);
+    return do_write_float<Char, OutputIt, DecimalFP,
+                          fallback_digit_grouping<Char>>(out, f, specs, s, loc);
   } else {
-    return do_write_float(out, f, specs, fspecs, loc);
+    return do_write_float<Char>(out, f, specs, s, loc);
   }
 }
 
 template <typename T> constexpr auto isnan(T value) -> bool {
-  return !(value >= value);  // std::isnan doesn't support __float128.
+  return value != value;  // std::isnan doesn't support __float128.
 }
 
 template <typename T, typename Enable = void>
@@ -2780,52 +2507,48 @@ inline FMT_CONSTEXPR20 void adjust_precision(int& precision, int exp10) {
 
 class bigint {
  private:
-  // A bigint is stored as an array of bigits (big digits), with bigit at index
-  // 0 being the least significant one.
-  using bigit = uint32_t;
+  // A bigint is a number in the form bigit_[N - 1] ... bigit_[0] * 32^exp_.
+  using bigit = uint32_t;  // A big digit.
   using double_bigit = uint64_t;
+  enum { bigit_bits = num_bits<bigit>() };
   enum { bigits_capacity = 32 };
   basic_memory_buffer<bigit, bigits_capacity> bigits_;
   int exp_;
 
-  FMT_CONSTEXPR20 auto operator[](int index) const -> bigit {
-    return bigits_[to_unsigned(index)];
-  }
-  FMT_CONSTEXPR20 auto operator[](int index) -> bigit& {
-    return bigits_[to_unsigned(index)];
-  }
-
-  static constexpr const int bigit_bits = num_bits<bigit>();
-
   friend struct formatter<bigint>;
 
-  FMT_CONSTEXPR20 void subtract_bigits(int index, bigit other, bigit& borrow) {
-    auto result = static_cast<double_bigit>((*this)[index]) - other - borrow;
-    (*this)[index] = static_cast<bigit>(result);
+  FMT_CONSTEXPR auto get_bigit(int i) const -> bigit {
+    return i >= exp_ && i < num_bigits() ? bigits_[i - exp_] : 0;
+  }
+
+  FMT_CONSTEXPR void subtract_bigits(int index, bigit other, bigit& borrow) {
+    auto result = double_bigit(bigits_[index]) - other - borrow;
+    bigits_[index] = static_cast<bigit>(result);
     borrow = static_cast<bigit>(result >> (bigit_bits * 2 - 1));
   }
 
-  FMT_CONSTEXPR20 void remove_leading_zeros() {
+  FMT_CONSTEXPR void remove_leading_zeros() {
     int num_bigits = static_cast<int>(bigits_.size()) - 1;
-    while (num_bigits > 0 && (*this)[num_bigits] == 0) --num_bigits;
+    while (num_bigits > 0 && bigits_[num_bigits] == 0) --num_bigits;
     bigits_.resize(to_unsigned(num_bigits + 1));
   }
 
   // Computes *this -= other assuming aligned bigints and *this >= other.
-  FMT_CONSTEXPR20 void subtract_aligned(const bigint& other) {
+  FMT_CONSTEXPR void subtract_aligned(const bigint& other) {
     FMT_ASSERT(other.exp_ >= exp_, "unaligned bigints");
     FMT_ASSERT(compare(*this, other) >= 0, "");
     bigit borrow = 0;
     int i = other.exp_ - exp_;
     for (size_t j = 0, n = other.bigits_.size(); j != n; ++i, ++j)
       subtract_bigits(i, other.bigits_[j], borrow);
-    while (borrow > 0) subtract_bigits(i, 0, borrow);
+    if (borrow != 0) subtract_bigits(i, 0, borrow);
+    FMT_ASSERT(borrow == 0, "");
     remove_leading_zeros();
   }
 
-  FMT_CONSTEXPR20 void multiply(uint32_t value) {
-    const double_bigit wide_value = value;
+  FMT_CONSTEXPR void multiply(uint32_t value) {
     bigit carry = 0;
+    const double_bigit wide_value = value;
     for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
       double_bigit result = bigits_[i] * wide_value + carry;
       bigits_[i] = static_cast<bigit>(result);
@@ -2836,7 +2559,7 @@ class bigint {
 
   template <typename UInt, FMT_ENABLE_IF(std::is_same<UInt, uint64_t>::value ||
                                          std::is_same<UInt, uint128_t>::value)>
-  FMT_CONSTEXPR20 void multiply(UInt value) {
+  FMT_CONSTEXPR void multiply(UInt value) {
     using half_uint =
         conditional_t<std::is_same<UInt, uint128_t>::value, uint64_t, uint32_t>;
     const int shift = num_bits<half_uint>() - bigit_bits;
@@ -2857,7 +2580,7 @@ class bigint {
 
   template <typename UInt, FMT_ENABLE_IF(std::is_same<UInt, uint64_t>::value ||
                                          std::is_same<UInt, uint128_t>::value)>
-  FMT_CONSTEXPR20 void assign(UInt n) {
+  FMT_CONSTEXPR void assign(UInt n) {
     size_t num_bigits = 0;
     do {
       bigits_[num_bigits++] = static_cast<bigit>(n);
@@ -2868,30 +2591,30 @@ class bigint {
   }
 
  public:
-  FMT_CONSTEXPR20 bigint() : exp_(0) {}
+  FMT_CONSTEXPR bigint() : exp_(0) {}
   explicit bigint(uint64_t n) { assign(n); }
 
   bigint(const bigint&) = delete;
   void operator=(const bigint&) = delete;
 
-  FMT_CONSTEXPR20 void assign(const bigint& other) {
+  FMT_CONSTEXPR void assign(const bigint& other) {
     auto size = other.bigits_.size();
     bigits_.resize(size);
     auto data = other.bigits_.data();
-    copy_str<bigit>(data, data + size, bigits_.data());
+    copy<bigit>(data, data + size, bigits_.data());
     exp_ = other.exp_;
   }
 
-  template <typename Int> FMT_CONSTEXPR20 void operator=(Int n) {
+  template <typename Int> FMT_CONSTEXPR void operator=(Int n) {
     FMT_ASSERT(n > 0, "");
     assign(uint64_or_128_t<Int>(n));
   }
 
-  FMT_CONSTEXPR20 auto num_bigits() const -> int {
+  FMT_CONSTEXPR auto num_bigits() const -> int {
     return static_cast<int>(bigits_.size()) + exp_;
   }
 
-  FMT_NOINLINE FMT_CONSTEXPR20 auto operator<<=(int shift) -> bigint& {
+  FMT_CONSTEXPR auto operator<<=(int shift) -> bigint& {
     FMT_ASSERT(shift >= 0, "");
     exp_ += shift / bigit_bits;
     shift %= bigit_bits;
@@ -2906,49 +2629,39 @@ class bigint {
     return *this;
   }
 
-  template <typename Int>
-  FMT_CONSTEXPR20 auto operator*=(Int value) -> bigint& {
+  template <typename Int> FMT_CONSTEXPR auto operator*=(Int value) -> bigint& {
     FMT_ASSERT(value > 0, "");
     multiply(uint32_or_64_or_128_t<Int>(value));
     return *this;
   }
 
-  friend FMT_CONSTEXPR20 auto compare(const bigint& lhs, const bigint& rhs)
-      -> int {
-    int num_lhs_bigits = lhs.num_bigits(), num_rhs_bigits = rhs.num_bigits();
-    if (num_lhs_bigits != num_rhs_bigits)
-      return num_lhs_bigits > num_rhs_bigits ? 1 : -1;
-    int i = static_cast<int>(lhs.bigits_.size()) - 1;
-    int j = static_cast<int>(rhs.bigits_.size()) - 1;
+  friend FMT_CONSTEXPR auto compare(const bigint& b1, const bigint& b2) -> int {
+    int num_bigits1 = b1.num_bigits(), num_bigits2 = b2.num_bigits();
+    if (num_bigits1 != num_bigits2) return num_bigits1 > num_bigits2 ? 1 : -1;
+    int i = static_cast<int>(b1.bigits_.size()) - 1;
+    int j = static_cast<int>(b2.bigits_.size()) - 1;
     int end = i - j;
     if (end < 0) end = 0;
     for (; i >= end; --i, --j) {
-      bigit lhs_bigit = lhs[i], rhs_bigit = rhs[j];
-      if (lhs_bigit != rhs_bigit) return lhs_bigit > rhs_bigit ? 1 : -1;
+      bigit b1_bigit = b1.bigits_[i], b2_bigit = b2.bigits_[j];
+      if (b1_bigit != b2_bigit) return b1_bigit > b2_bigit ? 1 : -1;
     }
     if (i != j) return i > j ? 1 : -1;
     return 0;
   }
 
   // Returns compare(lhs1 + lhs2, rhs).
-  friend FMT_CONSTEXPR20 auto add_compare(const bigint& lhs1,
-                                          const bigint& lhs2, const bigint& rhs)
-      -> int {
-    auto minimum = [](int a, int b) { return a < b ? a : b; };
-    auto maximum = [](int a, int b) { return a > b ? a : b; };
-    int max_lhs_bigits = maximum(lhs1.num_bigits(), lhs2.num_bigits());
+  friend FMT_CONSTEXPR auto add_compare(const bigint& lhs1, const bigint& lhs2,
+                                        const bigint& rhs) -> int {
+    int max_lhs_bigits = max_of(lhs1.num_bigits(), lhs2.num_bigits());
     int num_rhs_bigits = rhs.num_bigits();
     if (max_lhs_bigits + 1 < num_rhs_bigits) return -1;
     if (max_lhs_bigits > num_rhs_bigits) return 1;
-    auto get_bigit = [](const bigint& n, int i) -> bigit {
-      return i >= n.exp_ && i < n.num_bigits() ? n[i - n.exp_] : 0;
-    };
     double_bigit borrow = 0;
-    int min_exp = minimum(minimum(lhs1.exp_, lhs2.exp_), rhs.exp_);
+    int min_exp = min_of(min_of(lhs1.exp_, lhs2.exp_), rhs.exp_);
     for (int i = num_rhs_bigits - 1; i >= min_exp; --i) {
-      double_bigit sum =
-          static_cast<double_bigit>(get_bigit(lhs1, i)) + get_bigit(lhs2, i);
-      bigit rhs_bigit = get_bigit(rhs, i);
+      double_bigit sum = double_bigit(lhs1.get_bigit(i)) + lhs2.get_bigit(i);
+      bigit rhs_bigit = rhs.get_bigit(i);
       if (sum > rhs_bigit + borrow) return 1;
       borrow = rhs_bigit + borrow - sum;
       if (borrow > 1) return -1;
@@ -2961,10 +2674,8 @@ class bigint {
   FMT_CONSTEXPR20 void assign_pow10(int exp) {
     FMT_ASSERT(exp >= 0, "");
     if (exp == 0) return *this = 1;
-    // Find the top bit.
-    int bitmask = 1;
-    while (exp >= bitmask) bitmask <<= 1;
-    bitmask >>= 1;
+    int bitmask = 1 << (num_bits<unsigned>() -
+                        countl_zero(static_cast<uint32_t>(exp)) - 1);
     // pow(10, exp) = pow(5, exp) * pow(2, exp). First compute pow(5, exp) by
     // repeated squaring and multiplication.
     *this = 5;
@@ -2988,17 +2699,17 @@ class bigint {
       // cross-product terms n[i] * n[j] such that i + j == bigit_index.
       for (int i = 0, j = bigit_index; j >= 0; ++i, --j) {
         // Most terms are multiplied twice which can be optimized in the future.
-        sum += static_cast<double_bigit>(n[i]) * n[j];
+        sum += double_bigit(n[i]) * n[j];
       }
-      (*this)[bigit_index] = static_cast<bigit>(sum);
+      bigits_[bigit_index] = static_cast<bigit>(sum);
       sum >>= num_bits<bigit>();  // Compute the carry.
     }
     // Do the same for the top half.
     for (int bigit_index = num_bigits; bigit_index < num_result_bigits;
          ++bigit_index) {
       for (int j = num_bigits - 1, i = bigit_index - j; i < num_bigits;)
-        sum += static_cast<double_bigit>(n[i++]) * n[j--];
-      (*this)[bigit_index] = static_cast<bigit>(sum);
+        sum += double_bigit(n[i++]) * n[j--];
+      bigits_[bigit_index] = static_cast<bigit>(sum);
       sum >>= num_bits<bigit>();
     }
     remove_leading_zeros();
@@ -3007,20 +2718,20 @@ class bigint {
 
   // If this bigint has a bigger exponent than other, adds trailing zero to make
   // exponents equal. This simplifies some operations such as subtraction.
-  FMT_CONSTEXPR20 void align(const bigint& other) {
+  FMT_CONSTEXPR void align(const bigint& other) {
     int exp_difference = exp_ - other.exp_;
     if (exp_difference <= 0) return;
     int num_bigits = static_cast<int>(bigits_.size());
     bigits_.resize(to_unsigned(num_bigits + exp_difference));
     for (int i = num_bigits - 1, j = i + exp_difference; i >= 0; --i, --j)
       bigits_[j] = bigits_[i];
-    std::uninitialized_fill_n(bigits_.data(), exp_difference, 0u);
+    memset(bigits_.data(), 0, to_unsigned(exp_difference) * sizeof(bigit));
     exp_ -= exp_difference;
   }
 
   // Divides this bignum by divisor, assigning the remainder to this and
   // returning the quotient.
-  FMT_CONSTEXPR20 auto divmod_assign(const bigint& divisor) -> int {
+  FMT_CONSTEXPR auto divmod_assign(const bigint& divisor) -> int {
     FMT_ASSERT(this != &divisor, "");
     if (compare(*this, divisor) < 0) return 0;
     FMT_ASSERT(divisor.bigits_[divisor.bigits_.size() - 1u] != 0, "");
@@ -3139,8 +2850,11 @@ FMT_CONSTEXPR20 inline void format_dragon(basic_fp<uint128_t> value,
   // Generate the given number of digits.
   exp10 -= num_digits - 1;
   if (num_digits <= 0) {
-    denominator *= 10;
-    auto digit = add_compare(numerator, numerator, denominator) > 0 ? '1' : '0';
+    auto digit = '0';
+    if (num_digits == 0) {
+      denominator *= 10;
+      digit = add_compare(numerator, numerator, denominator) > 0 ? '1' : '0';
+    }
     buf.push_back(digit);
     return;
   }
@@ -3177,8 +2891,8 @@ FMT_CONSTEXPR20 inline void format_dragon(basic_fp<uint128_t> value,
 
 // Formats a floating-point number using the hexfloat format.
 template <typename Float, FMT_ENABLE_IF(!is_double_double<Float>::value)>
-FMT_CONSTEXPR20 void format_hexfloat(Float value, int precision,
-                                     float_specs specs, buffer<char>& buf) {
+FMT_CONSTEXPR20 void format_hexfloat(Float value, format_specs specs,
+                                     buffer<char>& buf) {
   // float is passed as double to reduce the number of instantiations and to
   // simplify implementation.
   static_assert(!std::is_same<Float, float>::value, "");
@@ -3188,26 +2902,25 @@ FMT_CONSTEXPR20 void format_hexfloat(Float value, int precision,
   // Assume Float is in the format [sign][exponent][significand].
   using carrier_uint = typename info::carrier_uint;
 
-  constexpr auto num_float_significand_bits =
-      detail::num_significand_bits<Float>();
+  const auto num_float_significand_bits = detail::num_significand_bits<Float>();
 
   basic_fp<carrier_uint> f(value);
   f.e += num_float_significand_bits;
   if (!has_implicit_bit<Float>()) --f.e;
 
-  constexpr auto num_fraction_bits =
+  const auto num_fraction_bits =
       num_float_significand_bits + (has_implicit_bit<Float>() ? 1 : 0);
-  constexpr auto num_xdigits = (num_fraction_bits + 3) / 4;
+  const auto num_xdigits = (num_fraction_bits + 3) / 4;
 
-  constexpr auto leading_shift = ((num_xdigits - 1) * 4);
+  const auto leading_shift = ((num_xdigits - 1) * 4);
   const auto leading_mask = carrier_uint(0xF) << leading_shift;
   const auto leading_xdigit =
       static_cast<uint32_t>((f.f & leading_mask) >> leading_shift);
   if (leading_xdigit > 1) f.e -= (32 - countl_zero(leading_xdigit) - 1);
 
   int print_xdigits = num_xdigits - 1;
-  if (precision >= 0 && print_xdigits > precision) {
-    const int shift = ((print_xdigits - precision - 1) * 4);
+  if (specs.precision >= 0 && print_xdigits > specs.precision) {
+    const int shift = ((print_xdigits - specs.precision - 1) * 4);
     const auto mask = carrier_uint(0xF) << shift;
     const auto v = static_cast<uint32_t>((f.f & mask) >> shift);
 
@@ -3226,25 +2939,25 @@ FMT_CONSTEXPR20 void format_hexfloat(Float value, int precision,
       }
     }
 
-    print_xdigits = precision;
+    print_xdigits = specs.precision;
   }
 
   char xdigits[num_bits<carrier_uint>() / 4];
   detail::fill_n(xdigits, sizeof(xdigits), '0');
-  format_uint<4>(xdigits, f.f, num_xdigits, specs.upper);
+  format_base2e(4, xdigits, f.f, num_xdigits, specs.upper());
 
   // Remove zero tail
   while (print_xdigits > 0 && xdigits[print_xdigits] == '0') --print_xdigits;
 
   buf.push_back('0');
-  buf.push_back(specs.upper ? 'X' : 'x');
+  buf.push_back(specs.upper() ? 'X' : 'x');
   buf.push_back(xdigits[0]);
-  if (specs.showpoint || print_xdigits > 0 || print_xdigits < precision)
+  if (specs.alt() || print_xdigits > 0 || print_xdigits < specs.precision)
     buf.push_back('.');
   buf.append(xdigits + 1, xdigits + 1 + print_xdigits);
-  for (; print_xdigits < precision; ++print_xdigits) buf.push_back('0');
+  for (; print_xdigits < specs.precision; ++print_xdigits) buf.push_back('0');
 
-  buf.push_back(specs.upper ? 'P' : 'p');
+  buf.push_back(specs.upper() ? 'P' : 'p');
 
   uint32_t abs_e;
   if (f.e < 0) {
@@ -3258,9 +2971,9 @@ FMT_CONSTEXPR20 void format_hexfloat(Float value, int precision,
 }
 
 template <typename Float, FMT_ENABLE_IF(is_double_double<Float>::value)>
-FMT_CONSTEXPR20 void format_hexfloat(Float value, int precision,
-                                     float_specs specs, buffer<char>& buf) {
-  format_hexfloat(static_cast<double>(value), precision, specs, buf);
+FMT_CONSTEXPR20 void format_hexfloat(Float value, format_specs specs,
+                                     buffer<char>& buf) {
+  format_hexfloat(static_cast<double>(value), specs, buf);
 }
 
 constexpr auto fractional_part_rounding_thresholds(int index) -> uint32_t {
@@ -3275,15 +2988,15 @@ constexpr auto fractional_part_rounding_thresholds(int index) -> uint32_t {
 }
 
 template <typename Float>
-FMT_CONSTEXPR20 auto format_float(Float value, int precision, float_specs specs,
+FMT_CONSTEXPR20 auto format_float(Float value, int precision,
+                                  const format_specs& specs, bool binary32,
                                   buffer<char>& buf) -> int {
   // float is passed as double to reduce the number of instantiations.
   static_assert(!std::is_same<Float, float>::value, "");
-  FMT_ASSERT(value >= 0, "value is negative");
   auto converted_value = convert_float(value);
 
-  const bool fixed = specs.format == float_format::fixed;
-  if (value <= 0) {  // <= instead of == to silence a warning.
+  const bool fixed = specs.type() == presentation_type::fixed;
+  if (value == 0) {
     if (precision <= 0 || !fixed) {
       buf.push_back('0');
       return 0;
@@ -3308,16 +3021,6 @@ FMT_CONSTEXPR20 auto format_float(Float value, int precision, float_specs specs,
     exp = static_cast<int>(e);
     if (e > exp) ++exp;  // Compute ceil.
     dragon_flags = dragon::fixup;
-  } else if (precision < 0) {
-    // Use Dragonbox for the shortest format.
-    if (specs.binary32) {
-      auto dec = dragonbox::to_decimal(static_cast<float>(value));
-      write<char>(buffer_appender<char>(buf), dec.significand);
-      return dec.exponent;
-    }
-    auto dec = dragonbox::to_decimal(static_cast<double>(value));
-    write<char>(buffer_appender<char>(buf), dec.significand);
-    return dec.exponent;
   } else {
     // Extract significand bits and exponent bits.
     using info = dragonbox::float_info<double>;
@@ -3416,7 +3119,7 @@ FMT_CONSTEXPR20 auto format_float(Float value, int precision, float_specs specs,
         uint64_t prod;
         uint32_t digits;
         bool should_round_up;
-        int number_of_digits_to_print = precision > 9 ? 9 : precision;
+        int number_of_digits_to_print = min_of(precision, 9);
 
         // Print a 9-digits subsegment, either the first or the second.
         auto print_subsegment = [&](uint32_t subsegment, char* buffer) {
@@ -3444,7 +3147,7 @@ FMT_CONSTEXPR20 auto format_float(Float value, int precision, float_specs specs,
             // for details.
             prod = ((subsegment * static_cast<uint64_t>(450359963)) >> 20) + 1;
             digits = static_cast<uint32_t>(prod >> 32);
-            copy2(buffer, digits2(digits));
+            write2digits(buffer, digits);
             number_of_digits_printed += 2;
           }
 
@@ -3452,7 +3155,7 @@ FMT_CONSTEXPR20 auto format_float(Float value, int precision, float_specs specs,
           while (number_of_digits_printed < number_of_digits_to_print) {
             prod = static_cast<uint32_t>(prod) * static_cast<uint64_t>(100);
             digits = static_cast<uint32_t>(prod >> 32);
-            copy2(buffer + number_of_digits_printed, digits2(digits));
+            write2digits(buffer + number_of_digits_printed, digits);
             number_of_digits_printed += 2;
           }
         };
@@ -3561,9 +3264,8 @@ FMT_CONSTEXPR20 auto format_float(Float value, int precision, float_specs specs,
   }
   if (use_dragon) {
     auto f = basic_fp<uint128_t>();
-    bool is_predecessor_closer = specs.binary32
-                                     ? f.assign(static_cast<float>(value))
-                                     : f.assign(converted_value);
+    bool is_predecessor_closer = binary32 ? f.assign(static_cast<float>(value))
+                                          : f.assign(converted_value);
     if (is_predecessor_closer) dragon_flags |= dragon::predecessor_closer;
     if (fixed) dragon_flags |= dragon::fixed;
     // Limit precision to the maximum possible number of significant digits in
@@ -3572,7 +3274,7 @@ FMT_CONSTEXPR20 auto format_float(Float value, int precision, float_specs specs,
     if (precision > max_double_digits) precision = max_double_digits;
     format_dragon(f, dragon_flags, precision, buf, exp);
   }
-  if (!fixed && !specs.showpoint) {
+  if (!fixed && !specs.alt()) {
     // Remove trailing zeros.
     auto num_digits = buf.size();
     while (num_digits > 0 && buf[num_digits - 1] == '0') {
@@ -3583,97 +3285,97 @@ FMT_CONSTEXPR20 auto format_float(Float value, int precision, float_specs specs,
   }
   return exp;
 }
+
 template <typename Char, typename OutputIt, typename T>
-FMT_CONSTEXPR20 auto write_float(OutputIt out, T value,
-                                 format_specs<Char> specs, locale_ref loc)
-    -> OutputIt {
-  float_specs fspecs = parse_float_type_spec(specs);
-  fspecs.sign = specs.sign;
-  if (detail::signbit(value)) {  // value < 0 is false for NaN so use signbit.
-    fspecs.sign = sign::minus;
-    value = -value;
-  } else if (fspecs.sign == sign::minus) {
-    fspecs.sign = sign::none;
-  }
+FMT_CONSTEXPR20 auto write_float(OutputIt out, T value, format_specs specs,
+                                 locale_ref loc) -> OutputIt {
+  // Use signbit because value < 0 is false for NaN.
+  sign s = detail::signbit(value) ? sign::minus : specs.sign();
 
   if (!detail::isfinite(value))
-    return write_nonfinite(out, detail::isnan(value), specs, fspecs);
+    return write_nonfinite<Char>(out, detail::isnan(value), specs, s);
 
-  if (specs.align == align::numeric && fspecs.sign) {
-    auto it = reserve(out, 1);
-    *it++ = detail::sign<Char>(fspecs.sign);
-    out = base_iterator(out, it);
-    fspecs.sign = sign::none;
+  if (specs.align() == align::numeric && s != sign::none) {
+    *out++ = detail::getsign<Char>(s);
+    s = sign::none;
     if (specs.width != 0) --specs.width;
   }
 
+  int precision = specs.precision;
+  if (precision < 0) {
+    if (specs.type() != presentation_type::none) {
+      precision = 6;
+    } else if (is_fast_float<T>::value && !is_constant_evaluated()) {
+      // Use Dragonbox for the shortest format.
+      using floaty = conditional_t<sizeof(T) >= sizeof(double), double, float>;
+      auto dec = dragonbox::to_decimal(static_cast<floaty>(value));
+      return write_float<Char>(out, dec, specs, s, loc);
+    }
+  }
+
   memory_buffer buffer;
-  if (fspecs.format == float_format::hex) {
-    if (fspecs.sign) buffer.push_back(detail::sign<char>(fspecs.sign));
-    format_hexfloat(convert_float(value), specs.precision, fspecs, buffer);
-    return write_bytes<align::right>(out, {buffer.data(), buffer.size()},
-                                     specs);
-  }
-  int precision = specs.precision >= 0 || specs.type == presentation_type::none
-                      ? specs.precision
-                      : 6;
-  if (fspecs.format == float_format::exp) {
+  if (specs.type() == presentation_type::hexfloat) {
+    if (s != sign::none) buffer.push_back(detail::getsign<char>(s));
+    format_hexfloat(convert_float(value), specs, buffer);
+    return write_bytes<Char, align::right>(out, {buffer.data(), buffer.size()},
+                                           specs);
+  }
+
+  if (specs.type() == presentation_type::exp) {
     if (precision == max_value<int>())
-      throw_format_error("number is too big");
+      report_error("number is too big");
     else
       ++precision;
-  } else if (fspecs.format != float_format::fixed && precision == 0) {
+    if (specs.precision != 0) specs.set_alt();
+  } else if (specs.type() == presentation_type::fixed) {
+    if (specs.precision != 0) specs.set_alt();
+  } else if (precision == 0) {
     precision = 1;
   }
-  if (const_check(std::is_same<T, float>())) fspecs.binary32 = true;
-  int exp = format_float(convert_float(value), precision, fspecs, buffer);
-  fspecs.precision = precision;
+  int exp = format_float(convert_float(value), precision, specs,
+                         std::is_same<T, float>(), buffer);
+
+  specs.precision = precision;
   auto f = big_decimal_fp{buffer.data(), static_cast<int>(buffer.size()), exp};
-  return write_float(out, f, specs, fspecs, loc);
+  return write_float<Char>(out, f, specs, s, loc);
 }
 
 template <typename Char, typename OutputIt, typename T,
           FMT_ENABLE_IF(is_floating_point<T>::value)>
-FMT_CONSTEXPR20 auto write(OutputIt out, T value, format_specs<Char> specs,
+FMT_CONSTEXPR20 auto write(OutputIt out, T value, format_specs specs,
                            locale_ref loc = {}) -> OutputIt {
-  if (const_check(!is_supported_floating_point(value))) return out;
-  return specs.localized && write_loc(out, value, specs, loc)
+  return specs.localized() && write_loc(out, value, specs, loc)
              ? out
-             : write_float(out, value, specs, loc);
+             : write_float<Char>(out, value, specs, loc);
 }
 
 template <typename Char, typename OutputIt, typename T,
           FMT_ENABLE_IF(is_fast_float<T>::value)>
 FMT_CONSTEXPR20 auto write(OutputIt out, T value) -> OutputIt {
-  if (is_constant_evaluated()) return write(out, value, format_specs<Char>());
-  if (const_check(!is_supported_floating_point(value))) return out;
+  if (is_constant_evaluated()) return write<Char>(out, value, format_specs());
 
-  auto fspecs = float_specs();
-  if (detail::signbit(value)) {
-    fspecs.sign = sign::minus;
-    value = -value;
-  }
+  auto s = detail::signbit(value) ? sign::minus : sign::none;
 
-  constexpr auto specs = format_specs<Char>();
-  using floaty = conditional_t<std::is_same<T, long double>::value, double, T>;
+  constexpr auto specs = format_specs();
+  using floaty = conditional_t<sizeof(T) >= sizeof(double), double, float>;
   using floaty_uint = typename dragonbox::float_info<floaty>::carrier_uint;
   floaty_uint mask = exponent_mask<floaty>();
   if ((bit_cast<floaty_uint>(value) & mask) == mask)
-    return write_nonfinite(out, std::isnan(value), specs, fspecs);
+    return write_nonfinite<Char>(out, std::isnan(value), specs, s);
 
   auto dec = dragonbox::to_decimal(static_cast<floaty>(value));
-  return write_float(out, dec, specs, fspecs, {});
+  return write_float<Char>(out, dec, specs, s, {});
 }
 
 template <typename Char, typename OutputIt, typename T,
           FMT_ENABLE_IF(is_floating_point<T>::value &&
                         !is_fast_float<T>::value)>
 inline auto write(OutputIt out, T value) -> OutputIt {
-  return write(out, value, format_specs<Char>());
+  return write<Char>(out, value, format_specs());
 }
 
 template <typename Char, typename OutputIt>
-auto write(OutputIt out, monostate, format_specs<Char> = {}, locale_ref = {})
+auto write(OutputIt out, monostate, format_specs = {}, locale_ref = {})
     -> OutputIt {
   FMT_ASSERT(false, "");
   return out;
@@ -3682,13 +3384,11 @@ auto write(OutputIt out, monostate, format_specs<Char> = {}, locale_ref = {})
 template <typename Char, typename OutputIt>
 FMT_CONSTEXPR auto write(OutputIt out, basic_string_view<Char> value)
     -> OutputIt {
-  auto it = reserve(out, value.size());
-  it = copy_str_noinline<Char>(value.begin(), value.end(), it);
-  return base_iterator(out, it);
+  return copy_noinline<Char>(value.begin(), value.end(), out);
 }
 
 template <typename Char, typename OutputIt, typename T,
-          FMT_ENABLE_IF(is_string<T>::value)>
+          FMT_ENABLE_IF(has_to_string_view<T>::value)>
 constexpr auto write(OutputIt out, const T& value) -> OutputIt {
   return write<Char>(out, to_string_view(value));
 }
@@ -3696,10 +3396,8 @@ constexpr auto write(OutputIt out, const T& value) -> OutputIt {
 // FMT_ENABLE_IF() condition separated to workaround an MSVC bug.
 template <
     typename Char, typename OutputIt, typename T,
-    bool check =
-        std::is_enum<T>::value && !std::is_same<T, Char>::value &&
-        mapped_type_constant<T, basic_format_context<OutputIt, Char>>::value !=
-            type::custom_type,
+    bool check = std::is_enum<T>::value && !std::is_same<T, Char>::value &&
+                 mapped_type_constant<T, Char>::value != type::custom_type,
     FMT_ENABLE_IF(check)>
 FMT_CONSTEXPR auto write(OutputIt out, T value) -> OutputIt {
   return write<Char>(out, static_cast<underlying_t<T>>(value));
@@ -3707,13 +3405,12 @@ FMT_CONSTEXPR auto write(OutputIt out, T value) -> OutputIt {
 
 template <typename Char, typename OutputIt, typename T,
           FMT_ENABLE_IF(std::is_same<T, bool>::value)>
-FMT_CONSTEXPR auto write(OutputIt out, T value,
-                         const format_specs<Char>& specs = {}, locale_ref = {})
-    -> OutputIt {
-  return specs.type != presentation_type::none &&
-                 specs.type != presentation_type::string
-             ? write(out, value ? 1 : 0, specs, {})
-             : write_bytes(out, value ? "true" : "false", specs);
+FMT_CONSTEXPR auto write(OutputIt out, T value, const format_specs& specs = {},
+                         locale_ref = {}) -> OutputIt {
+  return specs.type() != presentation_type::none &&
+                 specs.type() != presentation_type::string
+             ? write<Char>(out, value ? 1 : 0, specs, {})
+             : write_bytes<Char>(out, value ? "true" : "false", specs);
 }
 
 template <typename Char, typename OutputIt>
@@ -3724,171 +3421,150 @@ FMT_CONSTEXPR auto write(OutputIt out, Char value) -> OutputIt {
 }
 
 template <typename Char, typename OutputIt>
-FMT_CONSTEXPR_CHAR_TRAITS auto write(OutputIt out, const Char* value)
-    -> OutputIt {
+FMT_CONSTEXPR20 auto write(OutputIt out, const Char* value) -> OutputIt {
   if (value) return write(out, basic_string_view<Char>(value));
-  throw_format_error("string pointer is null");
+  report_error("string pointer is null");
   return out;
 }
 
 template <typename Char, typename OutputIt, typename T,
           FMT_ENABLE_IF(std::is_same<T, void>::value)>
-auto write(OutputIt out, const T* value, const format_specs<Char>& specs = {},
+auto write(OutputIt out, const T* value, const format_specs& specs = {},
            locale_ref = {}) -> OutputIt {
   return write_ptr<Char>(out, bit_cast<uintptr_t>(value), &specs);
 }
 
-// A write overload that handles implicit conversions.
 template <typename Char, typename OutputIt, typename T,
-          typename Context = basic_format_context<OutputIt, Char>>
-FMT_CONSTEXPR auto write(OutputIt out, const T& value) -> enable_if_t<
-    std::is_class<T>::value && !is_string<T>::value &&
-        !is_floating_point<T>::value && !std::is_same<T, Char>::value &&
-        !std::is_same<T, remove_cvref_t<decltype(arg_mapper<Context>().map(
-                             value))>>::value,
-    OutputIt> {
-  return write<Char>(out, arg_mapper<Context>().map(value));
+          FMT_ENABLE_IF(mapped_type_constant<T, Char>::value ==
+                            type::custom_type &&
+                        !std::is_fundamental<T>::value)>
+FMT_CONSTEXPR auto write(OutputIt out, const T& value) -> OutputIt {
+  auto f = formatter<T, Char>();
+  auto parse_ctx = parse_context<Char>({});
+  f.parse(parse_ctx);
+  auto ctx = basic_format_context<OutputIt, Char>(out, {}, {});
+  return f.format(value, ctx);
 }
 
-template <typename Char, typename OutputIt, typename T,
-          typename Context = basic_format_context<OutputIt, Char>>
-FMT_CONSTEXPR auto write(OutputIt out, const T& value)
-    -> enable_if_t<mapped_type_constant<T, Context>::value == type::custom_type,
-                   OutputIt> {
-  auto formatter = typename Context::template formatter_type<T>();
-  auto parse_ctx = typename Context::parse_context_type({});
-  formatter.parse(parse_ctx);
-  auto ctx = Context(out, {}, {});
-  return formatter.format(value, ctx);
-}
+template <typename T>
+using is_builtin =
+    bool_constant<std::is_same<T, int>::value || FMT_BUILTIN_TYPES>;
 
 // An argument visitor that formats the argument and writes it via the output
 // iterator. It's a class and not a generic lambda for compatibility with C++11.
 template <typename Char> struct default_arg_formatter {
-  using iterator = buffer_appender<Char>;
-  using context = buffer_context<Char>;
+  using context = buffered_context<Char>;
+
+  basic_appender<Char> out;
 
-  iterator out;
-  basic_format_args<context> args;
-  locale_ref loc;
+  void operator()(monostate) { report_error("argument not found"); }
+
+  template <typename T, FMT_ENABLE_IF(is_builtin<T>::value)>
+  void operator()(T value) {
+    write<Char>(out, value);
+  }
 
-  template <typename T> auto operator()(T value) -> iterator {
-    return write<Char>(out, value);
+  template <typename T, FMT_ENABLE_IF(!is_builtin<T>::value)>
+  void operator()(T) {
+    FMT_ASSERT(false, "");
   }
-  auto operator()(typename basic_format_arg<context>::handle h) -> iterator {
-    basic_format_parse_context<Char> parse_ctx({});
-    context format_ctx(out, args, loc);
+
+  void operator()(typename basic_format_arg<context>::handle h) {
+    // Use a null locale since the default format must be unlocalized.
+    auto parse_ctx = parse_context<Char>({});
+    auto format_ctx = context(out, {}, {});
     h.format(parse_ctx, format_ctx);
-    return format_ctx.out();
   }
 };
 
 template <typename Char> struct arg_formatter {
-  using iterator = buffer_appender<Char>;
-  using context = buffer_context<Char>;
-
-  iterator out;
-  const format_specs<Char>& specs;
-  locale_ref locale;
+  basic_appender<Char> out;
+  const format_specs& specs;
+  FMT_NO_UNIQUE_ADDRESS locale_ref locale;
 
-  template <typename T>
-  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
-    return detail::write(out, value, specs, locale);
-  }
-  auto operator()(typename basic_format_arg<context>::handle) -> iterator {
-    // User-defined types are handled separately because they require access
-    // to the parse context.
-    return out;
+  template <typename T, FMT_ENABLE_IF(is_builtin<T>::value)>
+  FMT_CONSTEXPR FMT_INLINE void operator()(T value) {
+    detail::write<Char>(out, value, specs, locale);
   }
-};
 
-struct width_checker {
-  template <typename T, FMT_ENABLE_IF(is_integer<T>::value)>
-  FMT_CONSTEXPR auto operator()(T value) -> unsigned long long {
-    if (is_negative(value)) throw_format_error("negative width");
-    return static_cast<unsigned long long>(value);
+  template <typename T, FMT_ENABLE_IF(!is_builtin<T>::value)>
+  void operator()(T) {
+    FMT_ASSERT(false, "");
   }
 
-  template <typename T, FMT_ENABLE_IF(!is_integer<T>::value)>
-  FMT_CONSTEXPR auto operator()(T) -> unsigned long long {
-    throw_format_error("width is not integer");
-    return 0;
+  void operator()(typename basic_format_arg<buffered_context<Char>>::handle) {
+    // User-defined types are handled separately because they require access
+    // to the parse context.
   }
 };
 
-struct precision_checker {
+struct dynamic_spec_getter {
   template <typename T, FMT_ENABLE_IF(is_integer<T>::value)>
   FMT_CONSTEXPR auto operator()(T value) -> unsigned long long {
-    if (is_negative(value)) throw_format_error("negative precision");
-    return static_cast<unsigned long long>(value);
+    return is_negative(value) ? ~0ull : static_cast<unsigned long long>(value);
   }
 
   template <typename T, FMT_ENABLE_IF(!is_integer<T>::value)>
   FMT_CONSTEXPR auto operator()(T) -> unsigned long long {
-    throw_format_error("precision is not integer");
+    report_error("width/precision is not integer");
     return 0;
   }
 };
 
-template <typename Handler, typename FormatArg>
-FMT_CONSTEXPR auto get_dynamic_spec(FormatArg arg) -> int {
-  unsigned long long value = visit_format_arg(Handler(), arg);
-  if (value > to_unsigned(max_value<int>()))
-    throw_format_error("number is too big");
-  return static_cast<int>(value);
-}
-
 template <typename Context, typename ID>
-FMT_CONSTEXPR auto get_arg(Context& ctx, ID id) -> decltype(ctx.arg(id)) {
+FMT_CONSTEXPR auto get_arg(Context& ctx, ID id) -> basic_format_arg<Context> {
   auto arg = ctx.arg(id);
-  if (!arg) ctx.on_error("argument not found");
+  if (!arg) report_error("argument not found");
   return arg;
 }
 
-template <typename Handler, typename Context>
-FMT_CONSTEXPR void handle_dynamic_spec(int& value,
-                                       arg_ref<typename Context::char_type> ref,
-                                       Context& ctx) {
-  switch (ref.kind) {
-  case arg_id_kind::none:
-    break;
-  case arg_id_kind::index:
-    value = detail::get_dynamic_spec<Handler>(get_arg(ctx, ref.val.index));
-    break;
-  case arg_id_kind::name:
-    value = detail::get_dynamic_spec<Handler>(get_arg(ctx, ref.val.name));
-    break;
-  }
+template <typename Context>
+FMT_CONSTEXPR int get_dynamic_spec(
+    arg_id_kind kind, const arg_ref<typename Context::char_type>& ref,
+    Context& ctx) {
+  FMT_ASSERT(kind != arg_id_kind::none, "");
+  auto arg =
+      kind == arg_id_kind::index ? ctx.arg(ref.index) : ctx.arg(ref.name);
+  if (!arg) report_error("argument not found");
+  unsigned long long value = arg.visit(dynamic_spec_getter());
+  if (value > to_unsigned(max_value<int>()))
+    report_error("width/precision is out of range");
+  return static_cast<int>(value);
+}
+
+template <typename Context>
+FMT_CONSTEXPR void handle_dynamic_spec(
+    arg_id_kind kind, int& value,
+    const arg_ref<typename Context::char_type>& ref, Context& ctx) {
+  if (kind != arg_id_kind::none) value = get_dynamic_spec(kind, ref, ctx);
 }
 
-#if FMT_USE_USER_DEFINED_LITERALS
-#  if FMT_USE_NONTYPE_TEMPLATE_ARGS
+#if FMT_USE_NONTYPE_TEMPLATE_ARGS
 template <typename T, typename Char, size_t N,
-          fmt::detail_exported::fixed_string<Char, N> Str>
-struct statically_named_arg : view {
+          fmt::detail::fixed_string<Char, N> Str>
+struct static_named_arg : view {
   static constexpr auto name = Str.data;
 
   const T& value;
-  statically_named_arg(const T& v) : value(v) {}
+  static_named_arg(const T& v) : value(v) {}
 };
 
 template <typename T, typename Char, size_t N,
-          fmt::detail_exported::fixed_string<Char, N> Str>
-struct is_named_arg<statically_named_arg<T, Char, N, Str>> : std::true_type {};
+          fmt::detail::fixed_string<Char, N> Str>
+struct is_named_arg<static_named_arg<T, Char, N, Str>> : std::true_type {};
 
 template <typename T, typename Char, size_t N,
-          fmt::detail_exported::fixed_string<Char, N> Str>
-struct is_statically_named_arg<statically_named_arg<T, Char, N, Str>>
-    : std::true_type {};
+          fmt::detail::fixed_string<Char, N> Str>
+struct is_static_named_arg<static_named_arg<T, Char, N, Str>> : std::true_type {
+};
 
-template <typename Char, size_t N,
-          fmt::detail_exported::fixed_string<Char, N> Str>
+template <typename Char, size_t N, fmt::detail::fixed_string<Char, N> Str>
 struct udl_arg {
   template <typename T> auto operator=(T&& value) const {
-    return statically_named_arg<T, Char, N, Str>(std::forward<T>(value));
+    return static_named_arg<T, Char, N, Str>(std::forward<T>(value));
   }
 };
-#  else
+#else
 template <typename Char> struct udl_arg {
   const Char* str;
 
@@ -3896,149 +3572,198 @@ template <typename Char> struct udl_arg {
     return {str, std::forward<T>(value)};
   }
 };
-#  endif
-#endif  // FMT_USE_USER_DEFINED_LITERALS
+#endif  // FMT_USE_NONTYPE_TEMPLATE_ARGS
 
-template <typename Locale, typename Char>
-auto vformat(const Locale& loc, basic_string_view<Char> fmt,
-             basic_format_args<buffer_context<type_identity_t<Char>>> args)
-    -> std::basic_string<Char> {
-  auto buf = basic_memory_buffer<Char>();
-  detail::vformat_to(buf, fmt, args, detail::locale_ref(loc));
-  return {buf.data(), buf.size()};
-}
+template <typename Char> struct format_handler {
+  parse_context<Char> parse_ctx;
+  buffered_context<Char> ctx;
 
-using format_func = void (*)(detail::buffer<char>&, int, const char*);
+  void on_text(const Char* begin, const Char* end) {
+    copy_noinline<Char>(begin, end, ctx.out());
+  }
 
-FMT_API void format_error_code(buffer<char>& out, int error_code,
-                               string_view message) noexcept;
+  FMT_CONSTEXPR auto on_arg_id() -> int { return parse_ctx.next_arg_id(); }
+  FMT_CONSTEXPR auto on_arg_id(int id) -> int {
+    parse_ctx.check_arg_id(id);
+    return id;
+  }
+  FMT_CONSTEXPR auto on_arg_id(basic_string_view<Char> id) -> int {
+    parse_ctx.check_arg_id(id);
+    int arg_id = ctx.arg_id(id);
+    if (arg_id < 0) report_error("argument not found");
+    return arg_id;
+  }
 
-FMT_API void report_error(format_func func, int error_code,
-                          const char* message) noexcept;
-}  // namespace detail
+  FMT_INLINE void on_replacement_field(int id, const Char*) {
+    ctx.arg(id).visit(default_arg_formatter<Char>{ctx.out()});
+  }
 
-FMT_API auto vsystem_error(int error_code, string_view format_str,
-                           format_args args) -> std::system_error;
+  auto on_format_specs(int id, const Char* begin, const Char* end)
+      -> const Char* {
+    auto arg = get_arg(ctx, id);
+    // Not using a visitor for custom types gives better codegen.
+    if (arg.format_custom(begin, parse_ctx, ctx)) return parse_ctx.begin();
 
-/**
-  \rst
-  Constructs :class:`std::system_error` with a message formatted with
-  ``fmt::format(fmt, args...)``.
-  *error_code* is a system error code as given by ``errno``.
-
-  **Example**::
-
-    // This throws std::system_error with the description
-    //   cannot open file 'madeup': No such file or directory
-    // or similar (system message may vary).
-    const char* filename = "madeup";
-    std::FILE* file = std::fopen(filename, "r");
-    if (!file)
-      throw fmt::system_error(errno, "cannot open file '{}'", filename);
-  \endrst
- */
-template <typename... T>
-auto system_error(int error_code, format_string<T...> fmt, T&&... args)
-    -> std::system_error {
-  return vsystem_error(error_code, fmt, fmt::make_format_args(args...));
-}
+    auto specs = dynamic_format_specs<Char>();
+    begin = parse_format_specs(begin, end, specs, parse_ctx, arg.type());
+    if (specs.dynamic()) {
+      handle_dynamic_spec(specs.dynamic_width(), specs.width, specs.width_ref,
+                          ctx);
+      handle_dynamic_spec(specs.dynamic_precision(), specs.precision,
+                          specs.precision_ref, ctx);
+    }
 
-/**
-  \rst
-  Formats an error message for an error returned by an operating system or a
-  language runtime, for example a file opening error, and writes it to *out*.
-  The format is the same as the one used by ``std::system_error(ec, message)``
-  where ``ec`` is ``std::error_code(error_code, std::generic_category()})``.
-  It is implementation-defined but normally looks like:
-
-  .. parsed-literal::
-     *<message>*: *<system-message>*
-
-  where *<message>* is the passed message and *<system-message>* is the system
-  message corresponding to the error code.
-  *error_code* is a system error code as given by ``errno``.
-  \endrst
- */
-FMT_API void format_system_error(detail::buffer<char>& out, int error_code,
-                                 const char* message) noexcept;
+    arg.visit(arg_formatter<Char>{ctx.out(), specs, ctx.locale()});
+    return begin;
+  }
 
-// Reports a system error without throwing an exception.
-// Can be used to report errors from destructors.
-FMT_API void report_system_error(int error_code, const char* message) noexcept;
+  FMT_NORETURN void on_error(const char* message) { report_error(message); }
+};
 
-/** Fast integer formatter. */
-class format_int {
+using format_func = void (*)(detail::buffer<char>&, int, const char*);
+FMT_API void do_report_error(format_func func, int error_code,
+                             const char* message) noexcept;
+
+FMT_API void format_error_code(buffer<char>& out, int error_code,
+                               string_view message) noexcept;
+
+template <typename T, typename Char, type TYPE>
+template <typename FormatContext>
+FMT_CONSTEXPR auto native_formatter<T, Char, TYPE>::format(
+    const T& val, FormatContext& ctx) const -> decltype(ctx.out()) {
+  if (!specs_.dynamic())
+    return write<Char>(ctx.out(), val, specs_, ctx.locale());
+  auto specs = format_specs(specs_);
+  handle_dynamic_spec(specs.dynamic_width(), specs.width, specs_.width_ref,
+                      ctx);
+  handle_dynamic_spec(specs.dynamic_precision(), specs.precision,
+                      specs_.precision_ref, ctx);
+  return write<Char>(ctx.out(), val, specs, ctx.locale());
+}
+
+// DEPRECATED! https://github.com/fmtlib/fmt/issues/4292.
+template <typename T, typename Enable = void>
+struct is_locale : std::false_type {};
+template <typename T>
+struct is_locale<T, void_t<decltype(T::classic())>> : std::true_type {};
+
+// DEPRECATED!
+template <typename Char = char> struct vformat_args {
+  using type = basic_format_args<buffered_context<Char>>;
+};
+template <> struct vformat_args<char> {
+  using type = format_args;
+};
+
+template <typename Char>
+void vformat_to(buffer<Char>& buf, basic_string_view<Char> fmt,
+                typename vformat_args<Char>::type args, locale_ref loc = {}) {
+  auto out = basic_appender<Char>(buf);
+  parse_format_string(
+      fmt, format_handler<Char>{parse_context<Char>(fmt), {out, args, loc}});
+}
+}  // namespace detail
+
+FMT_BEGIN_EXPORT
+
+// A generic formatting context with custom output iterator and character
+// (code unit) support. Char is the format string code unit type which can be
+// different from OutputIt::value_type.
+template <typename OutputIt, typename Char> class generic_context {
  private:
-  // Buffer should be large enough to hold all digits (digits10 + 1),
-  // a sign and a null character.
-  enum { buffer_size = std::numeric_limits<unsigned long long>::digits10 + 3 };
-  mutable char buffer_[buffer_size];
-  char* str_;
+  OutputIt out_;
+  basic_format_args<generic_context> args_;
+  detail::locale_ref loc_;
 
-  template <typename UInt> auto format_unsigned(UInt value) -> char* {
-    auto n = static_cast<detail::uint32_or_64_or_128_t<UInt>>(value);
-    return detail::format_decimal(buffer_, n, buffer_size - 1).begin;
+ public:
+  using char_type = Char;
+  using iterator = OutputIt;
+  using parse_context_type FMT_DEPRECATED = parse_context<Char>;
+  template <typename T>
+  using formatter_type FMT_DEPRECATED = formatter<T, Char>;
+  enum { builtin_types = FMT_BUILTIN_TYPES };
+
+  constexpr generic_context(OutputIt out,
+                            basic_format_args<generic_context> args,
+                            detail::locale_ref loc = {})
+      : out_(out), args_(args), loc_(loc) {}
+  generic_context(generic_context&&) = default;
+  generic_context(const generic_context&) = delete;
+  void operator=(const generic_context&) = delete;
+
+  constexpr auto arg(int id) const -> basic_format_arg<generic_context> {
+    return args_.get(id);
+  }
+  auto arg(basic_string_view<Char> name) const
+      -> basic_format_arg<generic_context> {
+    return args_.get(name);
+  }
+  constexpr auto arg_id(basic_string_view<Char> name) const -> int {
+    return args_.get_id(name);
   }
 
-  template <typename Int> auto format_signed(Int value) -> char* {
-    auto abs_value = static_cast<detail::uint32_or_64_or_128_t<Int>>(value);
-    bool negative = value < 0;
-    if (negative) abs_value = 0 - abs_value;
-    auto begin = format_unsigned(abs_value);
-    if (negative) *--begin = '-';
-    return begin;
+  constexpr auto out() const -> iterator { return out_; }
+
+  void advance_to(iterator it) {
+    if (!detail::is_back_insert_iterator<iterator>()) out_ = it;
   }
 
+  constexpr auto locale() const -> detail::locale_ref { return loc_; }
+};
+
+class loc_value {
+ private:
+  basic_format_arg<context> value_;
+
  public:
-  explicit format_int(int value) : str_(format_signed(value)) {}
-  explicit format_int(long value) : str_(format_signed(value)) {}
-  explicit format_int(long long value) : str_(format_signed(value)) {}
-  explicit format_int(unsigned value) : str_(format_unsigned(value)) {}
-  explicit format_int(unsigned long value) : str_(format_unsigned(value)) {}
-  explicit format_int(unsigned long long value)
-      : str_(format_unsigned(value)) {}
+  template <typename T, FMT_ENABLE_IF(!detail::is_float128<T>::value)>
+  loc_value(T value) : value_(value) {}
 
-  /** Returns the number of characters written to the output buffer. */
-  auto size() const -> size_t {
-    return detail::to_unsigned(buffer_ - str_ + buffer_size - 1);
+  template <typename T, FMT_ENABLE_IF(detail::is_float128<T>::value)>
+  loc_value(T) {}
+
+  template <typename Visitor> auto visit(Visitor&& vis) -> decltype(vis(0)) {
+    return value_.visit(vis);
   }
+};
 
-  /**
-    Returns a pointer to the output buffer content. No terminating null
-    character is appended.
-   */
-  auto data() const -> const char* { return str_; }
+// A locale facet that formats values in UTF-8.
+// It is parameterized on the locale to avoid the heavy <locale> include.
+template <typename Locale> class format_facet : public Locale::facet {
+ private:
+  std::string separator_;
+  std::string grouping_;
+  std::string decimal_point_;
 
-  /**
-    Returns a pointer to the output buffer content with terminating null
-    character appended.
-   */
-  auto c_str() const -> const char* {
-    buffer_[buffer_size - 1] = '\0';
-    return str_;
-  }
+ protected:
+  virtual auto do_put(appender out, loc_value val,
+                      const format_specs& specs) const -> bool;
 
-  /**
-    \rst
-    Returns the content of the output buffer as an ``std::string``.
-    \endrst
-   */
-  auto str() const -> std::string { return std::string(str_, size()); }
-};
+ public:
+  static FMT_API typename Locale::id id;
 
-template <typename T, typename Char>
-struct formatter<T, Char, enable_if_t<detail::has_format_as<T>::value>>
-    : formatter<detail::format_as_t<T>, Char> {
-  template <typename FormatContext>
-  auto format(const T& value, FormatContext& ctx) const -> decltype(ctx.out()) {
-    using base = formatter<detail::format_as_t<T>, Char>;
-    return base::format(format_as(value), ctx);
+  explicit format_facet(Locale& loc);
+  explicit format_facet(string_view sep = "", std::string grouping = "\3",
+                        std::string decimal_point = ".")
+      : separator_(sep.data(), sep.size()),
+        grouping_(grouping),
+        decimal_point_(decimal_point) {}
+
+  auto put(appender out, loc_value val, const format_specs& specs) const
+      -> bool {
+    return do_put(out, val, specs);
   }
 };
 
-#define FMT_FORMAT_AS(Type, Base) \
-  template <typename Char>        \
-  struct formatter<Type, Char> : formatter<Base, Char> {}
+#define FMT_FORMAT_AS(Type, Base)                                   \
+  template <typename Char>                                          \
+  struct formatter<Type, Char> : formatter<Base, Char> {            \
+    template <typename FormatContext>                               \
+    FMT_CONSTEXPR auto format(Type value, FormatContext& ctx) const \
+        -> decltype(ctx.out()) {                                    \
+      return formatter<Base, Char>::format(value, ctx);             \
+    }                                                               \
+  }
 
 FMT_FORMAT_AS(signed char, int);
 FMT_FORMAT_AS(unsigned char, unsigned);
@@ -4047,44 +3772,58 @@ FMT_FORMAT_AS(unsigned short, unsigned);
 FMT_FORMAT_AS(long, detail::long_type);
 FMT_FORMAT_AS(unsigned long, detail::ulong_type);
 FMT_FORMAT_AS(Char*, const Char*);
-FMT_FORMAT_AS(std::basic_string<Char>, basic_string_view<Char>);
-FMT_FORMAT_AS(std::nullptr_t, const void*);
 FMT_FORMAT_AS(detail::std_string_view<Char>, basic_string_view<Char>);
+FMT_FORMAT_AS(std::nullptr_t, const void*);
 FMT_FORMAT_AS(void*, const void*);
 
 template <typename Char, size_t N>
 struct formatter<Char[N], Char> : formatter<basic_string_view<Char>, Char> {};
 
-/**
-  \rst
-  Converts ``p`` to ``const void*`` for pointer formatting.
+template <typename Char, typename Traits, typename Allocator>
+class formatter<std::basic_string<Char, Traits, Allocator>, Char>
+    : public formatter<basic_string_view<Char>, Char> {};
+
+template <int N, typename Char>
+struct formatter<detail::bitint<N>, Char> : formatter<long long, Char> {};
+template <int N, typename Char>
+struct formatter<detail::ubitint<N>, Char>
+    : formatter<unsigned long long, Char> {};
 
-  **Example**::
+template <typename Char>
+struct formatter<detail::float128, Char>
+    : detail::native_formatter<detail::float128, Char,
+                               detail::type::float_type> {};
 
-    auto s = fmt::format("{}", fmt::ptr(p));
-  \endrst
+template <typename T, typename Char>
+struct formatter<T, Char, void_t<detail::format_as_result<T>>>
+    : formatter<detail::format_as_result<T>, Char> {
+  template <typename FormatContext>
+  FMT_CONSTEXPR auto format(const T& value, FormatContext& ctx) const
+      -> decltype(ctx.out()) {
+    auto&& val = format_as(value);  // Make an lvalue reference for format.
+    return formatter<detail::format_as_result<T>, Char>::format(val, ctx);
+  }
+};
+
+/**
+ * Converts `p` to `const void*` for pointer formatting.
+ *
+ * **Example**:
+ *
+ *     auto s = fmt::format("{}", fmt::ptr(p));
  */
 template <typename T> auto ptr(T p) -> const void* {
   static_assert(std::is_pointer<T>::value, "");
   return detail::bit_cast<const void*>(p);
 }
-template <typename T, typename Deleter>
-auto ptr(const std::unique_ptr<T, Deleter>& p) -> const void* {
-  return p.get();
-}
-template <typename T> auto ptr(const std::shared_ptr<T>& p) -> const void* {
-  return p.get();
-}
 
 /**
-  \rst
-  Converts ``e`` to the underlying type.
-
-  **Example**::
-
-    enum class color { red, green, blue };
-    auto s = fmt::format("{}", fmt::underlying(color::red));
-  \endrst
+ * Converts `e` to the underlying type.
+ *
+ * **Example**:
+ *
+ *     enum class color { red, green, blue };
+ *     auto s = fmt::format("{}", fmt::underlying(color::red));  // s == "0"
  */
 template <typename Enum>
 constexpr auto underlying(Enum e) noexcept -> underlying_t<Enum> {
@@ -4098,13 +3837,22 @@ constexpr auto format_as(Enum e) noexcept -> underlying_t<Enum> {
 }
 }  // namespace enums
 
-class bytes {
- private:
-  string_view data_;
-  friend struct formatter<bytes>;
+#ifdef __cpp_lib_byte
+template <> struct formatter<std::byte> : formatter<unsigned> {
+  static auto format_as(std::byte b) -> unsigned char {
+    return static_cast<unsigned char>(b);
+  }
+  template <typename Context>
+  auto format(std::byte b, Context& ctx) const -> decltype(ctx.out()) {
+    return formatter<unsigned>::format(format_as(b), ctx);
+  }
+};
+#endif
 
- public:
-  explicit bytes(string_view data) : data_(data) {}
+struct bytes {
+  string_view data;
+
+  inline explicit bytes(string_view s) : data(s) {}
 };
 
 template <> struct formatter<bytes> {
@@ -4112,19 +3860,19 @@ template <> struct formatter<bytes> {
   detail::dynamic_format_specs<> specs_;
 
  public:
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> const char* {
+  FMT_CONSTEXPR auto parse(parse_context<>& ctx) -> const char* {
     return parse_format_specs(ctx.begin(), ctx.end(), specs_, ctx,
                               detail::type::string_type);
   }
 
   template <typename FormatContext>
-  auto format(bytes b, FormatContext& ctx) -> decltype(ctx.out()) {
-    detail::handle_dynamic_spec<detail::width_checker>(specs_.width,
-                                                       specs_.width_ref, ctx);
-    detail::handle_dynamic_spec<detail::precision_checker>(
-        specs_.precision, specs_.precision_ref, ctx);
-    return detail::write_bytes(ctx.out(), b.data_, specs_);
+  auto format(bytes b, FormatContext& ctx) const -> decltype(ctx.out()) {
+    auto specs = specs_;
+    detail::handle_dynamic_spec(specs.dynamic_width(), specs.width,
+                                specs.width_ref, ctx);
+    detail::handle_dynamic_spec(specs.dynamic_precision(), specs.precision,
+                                specs.precision_ref, ctx);
+    return detail::write_bytes<char>(ctx.out(), b.data, specs);
   }
 };
 
@@ -4134,15 +3882,13 @@ template <typename T> struct group_digits_view {
 };
 
 /**
-  \rst
-  Returns a view that formats an integer value using ',' as a locale-independent
-  thousands separator.
-
-  **Example**::
-
-    fmt::print("{}", fmt::group_digits(12345));
-    // Output: "12,345"
-  \endrst
+ * Returns a view that formats an integer value using ',' as a
+ * locale-independent thousands separator.
+ *
+ * **Example**:
+ *
+ *     fmt::print("{}", fmt::group_digits(12345));
+ *     // Output: "12,345"
  */
 template <typename T> auto group_digits(T value) -> group_digits_view<T> {
   return {value};
@@ -4153,331 +3899,255 @@ template <typename T> struct formatter<group_digits_view<T>> : formatter<T> {
   detail::dynamic_format_specs<> specs_;
 
  public:
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> const char* {
+  FMT_CONSTEXPR auto parse(parse_context<>& ctx) -> const char* {
     return parse_format_specs(ctx.begin(), ctx.end(), specs_, ctx,
                               detail::type::int_type);
   }
 
   template <typename FormatContext>
-  auto format(group_digits_view<T> t, FormatContext& ctx)
+  auto format(group_digits_view<T> view, FormatContext& ctx) const
       -> decltype(ctx.out()) {
-    detail::handle_dynamic_spec<detail::width_checker>(specs_.width,
-                                                       specs_.width_ref, ctx);
-    detail::handle_dynamic_spec<detail::precision_checker>(
-        specs_.precision, specs_.precision_ref, ctx);
+    auto specs = specs_;
+    detail::handle_dynamic_spec(specs.dynamic_width(), specs.width,
+                                specs.width_ref, ctx);
+    detail::handle_dynamic_spec(specs.dynamic_precision(), specs.precision,
+                                specs.precision_ref, ctx);
+    auto arg = detail::make_write_int_arg(view.value, specs.sign());
     return detail::write_int(
-        ctx.out(), static_cast<detail::uint64_or_128_t<T>>(t.value), 0, specs_,
-        detail::digit_grouping<char>("\3", ","));
+        ctx.out(), static_cast<detail::uint64_or_128_t<T>>(arg.abs_value),
+        arg.prefix, specs, detail::digit_grouping<char>("\3", ","));
   }
 };
 
-template <typename T> struct nested_view {
-  const formatter<T>* fmt;
+template <typename T, typename Char> struct nested_view {
+  const formatter<T, Char>* fmt;
   const T* value;
 };
 
-template <typename T> struct formatter<nested_view<T>> {
-  FMT_CONSTEXPR auto parse(format_parse_context& ctx) -> const char* {
+template <typename T, typename Char>
+struct formatter<nested_view<T, Char>, Char> {
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) -> const Char* {
     return ctx.begin();
   }
-  auto format(nested_view<T> view, format_context& ctx) const
+  template <typename FormatContext>
+  auto format(nested_view<T, Char> view, FormatContext& ctx) const
       -> decltype(ctx.out()) {
     return view.fmt->format(*view.value, ctx);
   }
 };
 
-template <typename T> struct nested_formatter {
+template <typename T, typename Char = char> struct nested_formatter {
  private:
+  basic_specs specs_;
   int width_;
-  detail::fill_t<char> fill_;
-  align_t align_ : 4;
-  formatter<T> formatter_;
+  formatter<T, Char> formatter_;
 
  public:
-  constexpr nested_formatter() : width_(0), align_(align_t::none) {}
-
-  FMT_CONSTEXPR auto parse(format_parse_context& ctx) -> const char* {
-    auto specs = detail::dynamic_format_specs<char>();
-    auto it = parse_format_specs(ctx.begin(), ctx.end(), specs, ctx,
-                                 detail::type::none_type);
-    width_ = specs.width;
-    fill_ = specs.fill;
-    align_ = specs.align;
+  constexpr nested_formatter() : width_(0) {}
+
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) -> const Char* {
+    auto it = ctx.begin(), end = ctx.end();
+    if (it == end) return it;
+    auto specs = format_specs();
+    it = detail::parse_align(it, end, specs);
+    specs_ = specs;
+    Char c = *it;
+    auto width_ref = detail::arg_ref<Char>();
+    if ((c >= '0' && c <= '9') || c == '{') {
+      it = detail::parse_width(it, end, specs, width_ref, ctx);
+      width_ = specs.width;
+    }
     ctx.advance_to(it);
     return formatter_.parse(ctx);
   }
 
-  template <typename F>
-  auto write_padded(format_context& ctx, F write) const -> decltype(ctx.out()) {
+  template <typename FormatContext, typename F>
+  auto write_padded(FormatContext& ctx, F write) const -> decltype(ctx.out()) {
     if (width_ == 0) return write(ctx.out());
-    auto buf = memory_buffer();
-    write(std::back_inserter(buf));
-    auto specs = format_specs<>();
+    auto buf = basic_memory_buffer<Char>();
+    write(basic_appender<Char>(buf));
+    auto specs = format_specs();
     specs.width = width_;
-    specs.fill = fill_;
-    specs.align = align_;
-    return detail::write(ctx.out(), string_view(buf.data(), buf.size()), specs);
-  }
-
-  auto nested(const T& value) const -> nested_view<T> {
-    return nested_view<T>{&formatter_, &value};
+    specs.copy_fill_from(specs_);
+    specs.set_align(specs_.align());
+    return detail::write<Char>(
+        ctx.out(), basic_string_view<Char>(buf.data(), buf.size()), specs);
   }
-};
-
-// DEPRECATED! join_view will be moved to ranges.h.
-template <typename It, typename Sentinel, typename Char = char>
-struct join_view : detail::view {
-  It begin;
-  Sentinel end;
-  basic_string_view<Char> sep;
-
-  join_view(It b, Sentinel e, basic_string_view<Char> s)
-      : begin(b), end(e), sep(s) {}
-};
 
-template <typename It, typename Sentinel, typename Char>
-struct formatter<join_view<It, Sentinel, Char>, Char> {
- private:
-  using value_type =
-#ifdef __cpp_lib_ranges
-      std::iter_value_t<It>;
-#else
-      typename std::iterator_traits<It>::value_type;
-#endif
-  formatter<remove_cvref_t<value_type>, Char> value_formatter_;
-
- public:
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> const Char* {
-    return value_formatter_.parse(ctx);
-  }
-
-  template <typename FormatContext>
-  auto format(const join_view<It, Sentinel, Char>& value,
-              FormatContext& ctx) const -> decltype(ctx.out()) {
-    auto it = value.begin;
-    auto out = ctx.out();
-    if (it != value.end) {
-      out = value_formatter_.format(*it, ctx);
-      ++it;
-      while (it != value.end) {
-        out = detail::copy_str<Char>(value.sep.begin(), value.sep.end(), out);
-        ctx.advance_to(out);
-        out = value_formatter_.format(*it, ctx);
-        ++it;
-      }
-    }
-    return out;
+  auto nested(const T& value) const -> nested_view<T, Char> {
+    return nested_view<T, Char>{&formatter_, &value};
   }
 };
 
-/**
-  Returns a view that formats the iterator range `[begin, end)` with elements
-  separated by `sep`.
- */
-template <typename It, typename Sentinel>
-auto join(It begin, Sentinel end, string_view sep) -> join_view<It, Sentinel> {
-  return {begin, end, sep};
+inline namespace literals {
+#if FMT_USE_NONTYPE_TEMPLATE_ARGS
+template <detail::fixed_string S> constexpr auto operator""_a() {
+  using char_t = remove_cvref_t<decltype(*S.data)>;
+  return detail::udl_arg<char_t, sizeof(S.data) / sizeof(char_t), S>();
 }
-
+#else
 /**
-  \rst
-  Returns a view that formats `range` with elements separated by `sep`.
-
-  **Example**::
-
-    std::vector<int> v = {1, 2, 3};
-    fmt::print("{}", fmt::join(v, ", "));
-    // Output: "1, 2, 3"
-
-  ``fmt::join`` applies passed format specifiers to the range elements::
-
-    fmt::print("{:02}", fmt::join(v, ", "));
-    // Output: "01, 02, 03"
-  \endrst
+ * User-defined literal equivalent of `fmt::arg`.
+ *
+ * **Example**:
+ *
+ *     using namespace fmt::literals;
+ *     fmt::print("The answer is {answer}.", "answer"_a=42);
  */
-template <typename Range>
-auto join(Range&& range, string_view sep)
-    -> join_view<detail::iterator_t<Range>, detail::sentinel_t<Range>> {
-  return join(std::begin(range), std::end(range), sep);
+constexpr auto operator""_a(const char* s, size_t) -> detail::udl_arg<char> {
+  return {s};
 }
+#endif  // FMT_USE_NONTYPE_TEMPLATE_ARGS
+}  // namespace literals
 
-/**
-  \rst
-  Converts *value* to ``std::string`` using the default format for type *T*.
-
-  **Example**::
-
-    #include <fmt/format.h>
-
-    std::string answer = fmt::to_string(42);
-  \endrst
- */
-template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value &&
-                                    !detail::has_format_as<T>::value)>
-inline auto to_string(const T& value) -> std::string {
-  auto buffer = memory_buffer();
-  detail::write<char>(appender(buffer), value);
-  return {buffer.data(), buffer.size()};
-}
+/// A fast integer formatter.
+class format_int {
+ private:
+  // Buffer should be large enough to hold all digits (digits10 + 1),
+  // a sign and a null character.
+  enum { buffer_size = std::numeric_limits<unsigned long long>::digits10 + 3 };
+  mutable char buffer_[buffer_size];
+  char* str_;
 
-template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
-FMT_NODISCARD inline auto to_string(T value) -> std::string {
-  // The buffer should be large enough to store the number including the sign
-  // or "false" for bool.
-  constexpr int max_size = detail::digits10<T>() + 2;
-  char buffer[max_size > 5 ? static_cast<unsigned>(max_size) : 5];
-  char* begin = buffer;
-  return std::string(begin, detail::write<char>(begin, value));
-}
+  template <typename UInt>
+  FMT_CONSTEXPR20 auto format_unsigned(UInt value) -> char* {
+    auto n = static_cast<detail::uint32_or_64_or_128_t<UInt>>(value);
+    return detail::do_format_decimal(buffer_, n, buffer_size - 1);
+  }
 
-template <typename Char, size_t SIZE>
-FMT_NODISCARD auto to_string(const basic_memory_buffer<Char, SIZE>& buf)
-    -> std::basic_string<Char> {
-  auto size = buf.size();
-  detail::assume(size < std::basic_string<Char>().max_size());
-  return std::basic_string<Char>(buf.data(), size);
-}
+  template <typename Int>
+  FMT_CONSTEXPR20 auto format_signed(Int value) -> char* {
+    auto abs_value = static_cast<detail::uint32_or_64_or_128_t<Int>>(value);
+    bool negative = value < 0;
+    if (negative) abs_value = 0 - abs_value;
+    auto begin = format_unsigned(abs_value);
+    if (negative) *--begin = '-';
+    return begin;
+  }
 
-template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value &&
-                                    detail::has_format_as<T>::value)>
-inline auto to_string(const T& value) -> std::string {
-  return to_string(format_as(value));
-}
+ public:
+  FMT_CONSTEXPR20 explicit format_int(int value) : str_(format_signed(value)) {}
+  FMT_CONSTEXPR20 explicit format_int(long value)
+      : str_(format_signed(value)) {}
+  FMT_CONSTEXPR20 explicit format_int(long long value)
+      : str_(format_signed(value)) {}
+  FMT_CONSTEXPR20 explicit format_int(unsigned value)
+      : str_(format_unsigned(value)) {}
+  FMT_CONSTEXPR20 explicit format_int(unsigned long value)
+      : str_(format_unsigned(value)) {}
+  FMT_CONSTEXPR20 explicit format_int(unsigned long long value)
+      : str_(format_unsigned(value)) {}
 
-FMT_END_EXPORT
+  /// Returns the number of characters written to the output buffer.
+  FMT_CONSTEXPR20 auto size() const -> size_t {
+    return detail::to_unsigned(buffer_ - str_ + buffer_size - 1);
+  }
 
-namespace detail {
+  /// Returns a pointer to the output buffer content. No terminating null
+  /// character is appended.
+  FMT_CONSTEXPR20 auto data() const -> const char* { return str_; }
 
-template <typename Char>
-void vformat_to(buffer<Char>& buf, basic_string_view<Char> fmt,
-                typename vformat_args<Char>::type args, locale_ref loc) {
-  auto out = buffer_appender<Char>(buf);
-  if (fmt.size() == 2 && equal2(fmt.data(), "{}")) {
-    auto arg = args.get(0);
-    if (!arg) throw_format_error("argument not found");
-    visit_format_arg(default_arg_formatter<Char>{out, args, loc}, arg);
-    return;
+  /// Returns a pointer to the output buffer content with terminating null
+  /// character appended.
+  FMT_CONSTEXPR20 auto c_str() const -> const char* {
+    buffer_[buffer_size - 1] = '\0';
+    return str_;
   }
 
-  struct format_handler : error_handler {
-    basic_format_parse_context<Char> parse_context;
-    buffer_context<Char> context;
-
-    format_handler(buffer_appender<Char> p_out, basic_string_view<Char> str,
-                   basic_format_args<buffer_context<Char>> p_args,
-                   locale_ref p_loc)
-        : parse_context(str), context(p_out, p_args, p_loc) {}
+  /// Returns the content of the output buffer as an `std::string`.
+  inline auto str() const -> std::string { return {str_, size()}; }
+};
 
-    void on_text(const Char* begin, const Char* end) {
-      auto text = basic_string_view<Char>(begin, to_unsigned(end - begin));
-      context.advance_to(write<Char>(context.out(), text));
-    }
+#define FMT_STRING_IMPL(s, base)                                              \
+  [] {                                                                        \
+    /* Use the hidden visibility as a workaround for a GCC bug (#1973). */    \
+    /* Use a macro-like name to avoid shadowing warnings. */                  \
+    struct FMT_VISIBILITY("hidden") FMT_COMPILE_STRING : base {               \
+      using char_type = fmt::remove_cvref_t<decltype(s[0])>;                  \
+      constexpr explicit operator fmt::basic_string_view<char_type>() const { \
+        return fmt::detail::compile_string_to_view<char_type>(s);             \
+      }                                                                       \
+    };                                                                        \
+    using FMT_STRING_VIEW =                                                   \
+        fmt::basic_string_view<typename FMT_COMPILE_STRING::char_type>;       \
+    fmt::detail::ignore_unused(FMT_STRING_VIEW(FMT_COMPILE_STRING()));        \
+    return FMT_COMPILE_STRING();                                              \
+  }()
 
-    FMT_CONSTEXPR auto on_arg_id() -> int {
-      return parse_context.next_arg_id();
-    }
-    FMT_CONSTEXPR auto on_arg_id(int id) -> int {
-      return parse_context.check_arg_id(id), id;
-    }
-    FMT_CONSTEXPR auto on_arg_id(basic_string_view<Char> id) -> int {
-      int arg_id = context.arg_id(id);
-      if (arg_id < 0) throw_format_error("argument not found");
-      return arg_id;
-    }
+/**
+ * Constructs a legacy compile-time format string from a string literal `s`.
+ *
+ * **Example**:
+ *
+ *     // A compile-time error because 'd' is an invalid specifier for strings.
+ *     std::string s = fmt::format(FMT_STRING("{:d}"), "foo");
+ */
+#define FMT_STRING(s) FMT_STRING_IMPL(s, fmt::detail::compile_string)
 
-    FMT_INLINE void on_replacement_field(int id, const Char*) {
-      auto arg = get_arg(context, id);
-      context.advance_to(visit_format_arg(
-          default_arg_formatter<Char>{context.out(), context.args(),
-                                      context.locale()},
-          arg));
-    }
+FMT_API auto vsystem_error(int error_code, string_view fmt, format_args args)
+    -> std::system_error;
 
-    auto on_format_specs(int id, const Char* begin, const Char* end)
-        -> const Char* {
-      auto arg = get_arg(context, id);
-      // Not using a visitor for custom types gives better codegen.
-      if (arg.format_custom(begin, parse_context, context))
-        return parse_context.begin();
-      auto specs = detail::dynamic_format_specs<Char>();
-      begin = parse_format_specs(begin, end, specs, parse_context, arg.type());
-      detail::handle_dynamic_spec<detail::width_checker>(
-          specs.width, specs.width_ref, context);
-      detail::handle_dynamic_spec<detail::precision_checker>(
-          specs.precision, specs.precision_ref, context);
-      if (begin == end || *begin != '}')
-        throw_format_error("missing '}' in format string");
-      auto f = arg_formatter<Char>{context.out(), specs, context.locale()};
-      context.advance_to(visit_format_arg(f, arg));
-      return begin;
-    }
-  };
-  detail::parse_format_string<false>(fmt, format_handler(out, fmt, args, loc));
+/**
+ * Constructs `std::system_error` with a message formatted with
+ * `fmt::format(fmt, args...)`.
+ * `error_code` is a system error code as given by `errno`.
+ *
+ * **Example**:
+ *
+ *     // This throws std::system_error with the description
+ *     //   cannot open file 'madeup': No such file or directory
+ *     // or similar (system message may vary).
+ *     const char* filename = "madeup";
+ *     FILE* file = fopen(filename, "r");
+ *     if (!file)
+ *       throw fmt::system_error(errno, "cannot open file '{}'", filename);
+ */
+template <typename... T>
+auto system_error(int error_code, format_string<T...> fmt, T&&... args)
+    -> std::system_error {
+  return vsystem_error(error_code, fmt.str, vargs<T...>{{args...}});
 }
 
-FMT_BEGIN_EXPORT
-
-#ifndef FMT_HEADER_ONLY
-extern template FMT_API void vformat_to(buffer<char>&, string_view,
-                                        typename vformat_args<>::type,
-                                        locale_ref);
-extern template FMT_API auto thousands_sep_impl<char>(locale_ref)
-    -> thousands_sep_result<char>;
-extern template FMT_API auto thousands_sep_impl<wchar_t>(locale_ref)
-    -> thousands_sep_result<wchar_t>;
-extern template FMT_API auto decimal_point_impl(locale_ref) -> char;
-extern template FMT_API auto decimal_point_impl(locale_ref) -> wchar_t;
-#endif  // FMT_HEADER_ONLY
-
-}  // namespace detail
-
-#if FMT_USE_USER_DEFINED_LITERALS
-inline namespace literals {
 /**
-  \rst
-  User-defined literal equivalent of :func:`fmt::arg`.
-
-  **Example**::
-
-    using namespace fmt::literals;
-    fmt::print("Elapsed time: {s:.2f} seconds", "s"_a=1.23);
-  \endrst
+ * Formats an error message for an error returned by an operating system or a
+ * language runtime, for example a file opening error, and writes it to `out`.
+ * The format is the same as the one used by `std::system_error(ec, message)`
+ * where `ec` is `std::error_code(error_code, std::generic_category())`.
+ * It is implementation-defined but normally looks like:
+ *
+ *     <message>: <system-message>
+ *
+ * where `<message>` is the passed message and `<system-message>` is the system
+ * message corresponding to the error code.
+ * `error_code` is a system error code as given by `errno`.
  */
-#  if FMT_USE_NONTYPE_TEMPLATE_ARGS
-template <detail_exported::fixed_string Str> constexpr auto operator""_a() {
-  using char_t = remove_cvref_t<decltype(Str.data[0])>;
-  return detail::udl_arg<char_t, sizeof(Str.data) / sizeof(char_t), Str>();
-}
-#  else
-constexpr auto operator""_a(const char* s, size_t) -> detail::udl_arg<char> {
-  return {s};
-}
-#  endif
-}  // namespace literals
-#endif  // FMT_USE_USER_DEFINED_LITERALS
+FMT_API void format_system_error(detail::buffer<char>& out, int error_code,
+                                 const char* message) noexcept;
+
+// Reports a system error without throwing an exception.
+// Can be used to report errors from destructors.
+FMT_API void report_system_error(int error_code, const char* message) noexcept;
 
 template <typename Locale, FMT_ENABLE_IF(detail::is_locale<Locale>::value)>
 inline auto vformat(const Locale& loc, string_view fmt, format_args args)
     -> std::string {
-  return detail::vformat(loc, fmt, args);
+  auto buf = memory_buffer();
+  detail::vformat_to(buf, fmt, args, detail::locale_ref(loc));
+  return {buf.data(), buf.size()};
 }
 
 template <typename Locale, typename... T,
           FMT_ENABLE_IF(detail::is_locale<Locale>::value)>
-inline auto format(const Locale& loc, format_string<T...> fmt, T&&... args)
+FMT_INLINE auto format(const Locale& loc, format_string<T...> fmt, T&&... args)
     -> std::string {
-  return fmt::vformat(loc, string_view(fmt), fmt::make_format_args(args...));
+  return vformat(loc, fmt.str, vargs<T...>{{args...}});
 }
 
 template <typename OutputIt, typename Locale,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value&&
-                            detail::is_locale<Locale>::value)>
+          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
 auto vformat_to(OutputIt out, const Locale& loc, string_view fmt,
                 format_args args) -> OutputIt {
-  using detail::get_buffer;
-  auto&& buf = get_buffer<char>(out);
+  auto&& buf = detail::get_buffer<char>(out);
   detail::vformat_to(buf, fmt, args, detail::locale_ref(loc));
   return detail::get_iterator(buf, out);
 }
@@ -4487,7 +4157,7 @@ template <typename OutputIt, typename Locale, typename... T,
                             detail::is_locale<Locale>::value)>
 FMT_INLINE auto format_to(OutputIt out, const Locale& loc,
                           format_string<T...> fmt, T&&... args) -> OutputIt {
-  return vformat_to(out, loc, fmt, fmt::make_format_args(args...));
+  return fmt::vformat_to(out, loc, fmt.str, vargs<T...>{{args...}});
 }
 
 template <typename Locale, typename... T,
@@ -4496,40 +4166,67 @@ FMT_NODISCARD FMT_INLINE auto formatted_size(const Locale& loc,
                                              format_string<T...> fmt,
                                              T&&... args) -> size_t {
   auto buf = detail::counting_buffer<>();
-  detail::vformat_to<char>(buf, fmt, fmt::make_format_args(args...),
-                           detail::locale_ref(loc));
+  detail::vformat_to(buf, fmt.str, vargs<T...>{{args...}},
+                     detail::locale_ref(loc));
   return buf.count();
 }
 
-FMT_END_EXPORT
+FMT_API auto vformat(string_view fmt, format_args args) -> std::string;
 
-template <typename T, typename Char>
-template <typename FormatContext>
-FMT_CONSTEXPR FMT_INLINE auto
-formatter<T, Char,
-          enable_if_t<detail::type_constant<T, Char>::value !=
-                      detail::type::custom_type>>::format(const T& val,
-                                                          FormatContext& ctx)
-    const -> decltype(ctx.out()) {
-  if (specs_.width_ref.kind == detail::arg_id_kind::none &&
-      specs_.precision_ref.kind == detail::arg_id_kind::none) {
-    return detail::write<Char>(ctx.out(), val, specs_, ctx.locale());
-  }
-  auto specs = specs_;
-  detail::handle_dynamic_spec<detail::width_checker>(specs.width,
-                                                     specs.width_ref, ctx);
-  detail::handle_dynamic_spec<detail::precision_checker>(
-      specs.precision, specs.precision_ref, ctx);
-  return detail::write<Char>(ctx.out(), val, specs, ctx.locale());
+/**
+ * Formats `args` according to specifications in `fmt` and returns the result
+ * as a string.
+ *
+ * **Example**:
+ *
+ *     #include <fmt/format.h>
+ *     std::string message = fmt::format("The answer is {}.", 42);
+ */
+template <typename... T>
+FMT_NODISCARD FMT_INLINE auto format(format_string<T...> fmt, T&&... args)
+    -> std::string {
+  return vformat(fmt.str, vargs<T...>{{args...}});
+}
+
+/**
+ * Converts `value` to `std::string` using the default format for type `T`.
+ *
+ * **Example**:
+ *
+ *     std::string answer = fmt::to_string(42);
+ */
+template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
+FMT_NODISCARD auto to_string(T value) -> std::string {
+  // The buffer should be large enough to store the number including the sign
+  // or "false" for bool.
+  char buffer[max_of(detail::digits10<T>() + 2, 5)];
+  return {buffer, detail::write<char>(buffer, value)};
 }
 
+template <typename T, FMT_ENABLE_IF(detail::use_format_as<T>::value)>
+FMT_NODISCARD auto to_string(const T& value) -> std::string {
+  return to_string(format_as(value));
+}
+
+template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value &&
+                                    !detail::use_format_as<T>::value)>
+FMT_NODISCARD auto to_string(const T& value) -> std::string {
+  auto buffer = memory_buffer();
+  detail::write<char>(appender(buffer), value);
+  return {buffer.data(), buffer.size()};
+}
+
+FMT_END_EXPORT
 FMT_END_NAMESPACE
 
 #ifdef FMT_HEADER_ONLY
 #  define FMT_FUNC inline
 #  include "format-inl.h"
-#else
-#  define FMT_FUNC
+#endif
+
+// Restore _LIBCPP_REMOVE_TRANSITIVE_INCLUDES.
+#ifdef FMT_REMOVE_TRANSITIVE_INCLUDES
+#  undef _LIBCPP_REMOVE_TRANSITIVE_INCLUDES
 #endif
 
 #endif  // FMT_FORMAT_H_
diff --git a/3rdparty/fmt/include/fmt/os.h b/3rdparty/fmt/include/fmt/os.h
index 3c7b3ccb481ec..b2cc5e4b85ff0 100644
--- a/3rdparty/fmt/include/fmt/os.h
+++ b/3rdparty/fmt/include/fmt/os.h
@@ -8,18 +8,18 @@
 #ifndef FMT_OS_H_
 #define FMT_OS_H_
 
-#include <cerrno>
-#include <cstddef>
-#include <cstdio>
-#include <system_error>  // std::system_error
-
 #include "format.h"
 
-#if defined __APPLE__ || defined(__FreeBSD__)
+#ifndef FMT_MODULE
+#  include <cerrno>
+#  include <cstddef>
+#  include <cstdio>
+#  include <system_error>  // std::system_error
+
 #  if FMT_HAS_INCLUDE(<xlocale.h>)
-#    include <xlocale.h>  // for LC_NUMERIC_MASK on OS X
+#    include <xlocale.h>  // LC_NUMERIC_MASK on macOS
 #  endif
-#endif
+#endif  // FMT_MODULE
 
 #ifndef FMT_USE_FCNTL
 // UWP doesn't provide _pipe.
@@ -77,46 +77,33 @@ FMT_BEGIN_NAMESPACE
 FMT_BEGIN_EXPORT
 
 /**
-  \rst
-  A reference to a null-terminated string. It can be constructed from a C
-  string or ``std::string``.
-
-  You can use one of the following type aliases for common character types:
-
-  +---------------+-----------------------------+
-  | Type          | Definition                  |
-  +===============+=============================+
-  | cstring_view  | basic_cstring_view<char>    |
-  +---------------+-----------------------------+
-  | wcstring_view | basic_cstring_view<wchar_t> |
-  +---------------+-----------------------------+
-
-  This class is most useful as a parameter type to allow passing
-  different types of strings to a function, for example::
-
-    template <typename... Args>
-    std::string format(cstring_view format_str, const Args & ... args);
-
-    format("{}", 42);
-    format(std::string("{}"), 42);
-  \endrst
+ * A reference to a null-terminated string. It can be constructed from a C
+ * string or `std::string`.
+ *
+ * You can use one of the following type aliases for common character types:
+ *
+ * +---------------+-----------------------------+
+ * | Type          | Definition                  |
+ * +===============+=============================+
+ * | cstring_view  | basic_cstring_view<char>    |
+ * +---------------+-----------------------------+
+ * | wcstring_view | basic_cstring_view<wchar_t> |
+ * +---------------+-----------------------------+
+ *
+ * This class is most useful as a parameter type for functions that wrap C APIs.
  */
 template <typename Char> class basic_cstring_view {
  private:
   const Char* data_;
 
  public:
-  /** Constructs a string reference object from a C string. */
+  /// Constructs a string reference object from a C string.
   basic_cstring_view(const Char* s) : data_(s) {}
 
-  /**
-    \rst
-    Constructs a string reference from an ``std::string`` object.
-    \endrst
-   */
+  /// Constructs a string reference from an `std::string` object.
   basic_cstring_view(const std::basic_string<Char>& s) : data_(s.c_str()) {}
 
-  /** Returns the pointer to a C string. */
+  /// Returns the pointer to a C string.
   auto c_str() const -> const Char* { return data_; }
 };
 
@@ -131,41 +118,38 @@ FMT_API void format_windows_error(buffer<char>& out, int error_code,
                                   const char* message) noexcept;
 }
 
-FMT_API std::system_error vwindows_error(int error_code, string_view format_str,
+FMT_API std::system_error vwindows_error(int error_code, string_view fmt,
                                          format_args args);
 
 /**
- \rst
- Constructs a :class:`std::system_error` object with the description
- of the form
-
- .. parsed-literal::
-   *<message>*: *<system-message>*
-
- where *<message>* is the formatted message and *<system-message>* is the
- system message corresponding to the error code.
- *error_code* is a Windows error code as given by ``GetLastError``.
- If *error_code* is not a valid error code such as -1, the system message
- will look like "error -1".
-
- **Example**::
-
-   // This throws a system_error with the description
-   //   cannot open file 'madeup': The system cannot find the file specified.
-   // or similar (system message may vary).
-   const char *filename = "madeup";
-   LPOFSTRUCT of = LPOFSTRUCT();
-   HFILE file = OpenFile(filename, &of, OF_READ);
-   if (file == HFILE_ERROR) {
-     throw fmt::windows_error(GetLastError(),
-                              "cannot open file '{}'", filename);
-   }
- \endrst
-*/
-template <typename... Args>
-std::system_error windows_error(int error_code, string_view message,
-                                const Args&... args) {
-  return vwindows_error(error_code, message, fmt::make_format_args(args...));
+ * Constructs a `std::system_error` object with the description of the form
+ *
+ *     <message>: <system-message>
+ *
+ * where `<message>` is the formatted message and `<system-message>` is the
+ * system message corresponding to the error code.
+ * `error_code` is a Windows error code as given by `GetLastError`.
+ * If `error_code` is not a valid error code such as -1, the system message
+ * will look like "error -1".
+ *
+ * **Example**:
+ *
+ *     // This throws a system_error with the description
+ *     //   cannot open file 'madeup': The system cannot find the file
+ * specified.
+ *     // or similar (system message may vary).
+ *     const char *filename = "madeup";
+ *     LPOFSTRUCT of = LPOFSTRUCT();
+ *     HFILE file = OpenFile(filename, &of, OF_READ);
+ *     if (file == HFILE_ERROR) {
+ *       throw fmt::windows_error(GetLastError(),
+ *                                "cannot open file '{}'", filename);
+ *     }
+ */
+template <typename... T>
+auto windows_error(int error_code, string_view message, const T&... args)
+    -> std::system_error {
+  return vwindows_error(error_code, message, vargs<T...>{{args...}});
 }
 
 // Reports a Windows error without throwing an exception.
@@ -180,8 +164,8 @@ inline auto system_category() noexcept -> const std::error_category& {
 // std::system is not available on some platforms such as iOS (#2248).
 #ifdef __OSX__
 template <typename S, typename... Args, typename Char = char_t<S>>
-void say(const S& format_str, Args&&... args) {
-  std::system(format("say \"{}\"", format(format_str, args...)).c_str());
+void say(const S& fmt, Args&&... args) {
+  std::system(format("say \"{}\"", format(fmt, args...)).c_str());
 }
 #endif
 
@@ -192,24 +176,24 @@ class buffered_file {
 
   friend class file;
 
-  explicit buffered_file(FILE* f) : file_(f) {}
+  inline explicit buffered_file(FILE* f) : file_(f) {}
 
  public:
   buffered_file(const buffered_file&) = delete;
   void operator=(const buffered_file&) = delete;
 
   // Constructs a buffered_file object which doesn't represent any file.
-  buffered_file() noexcept : file_(nullptr) {}
+  inline buffered_file() noexcept : file_(nullptr) {}
 
   // Destroys the object closing the file it represents if any.
   FMT_API ~buffered_file() noexcept;
 
  public:
-  buffered_file(buffered_file&& other) noexcept : file_(other.file_) {
+  inline buffered_file(buffered_file&& other) noexcept : file_(other.file_) {
     other.file_ = nullptr;
   }
 
-  auto operator=(buffered_file&& other) -> buffered_file& {
+  inline auto operator=(buffered_file&& other) -> buffered_file& {
     close();
     file_ = other.file_;
     other.file_ = nullptr;
@@ -223,21 +207,20 @@ class buffered_file {
   FMT_API void close();
 
   // Returns the pointer to a FILE object representing this file.
-  auto get() const noexcept -> FILE* { return file_; }
+  inline auto get() const noexcept -> FILE* { return file_; }
 
   FMT_API auto descriptor() const -> int;
 
-  void vprint(string_view format_str, format_args args) {
-    fmt::vprint(file_, format_str, args);
-  }
-
-  template <typename... Args>
-  inline void print(string_view format_str, const Args&... args) {
-    vprint(format_str, fmt::make_format_args(args...));
+  template <typename... T>
+  inline void print(string_view fmt, const T&... args) {
+    fmt::vargs<T...> vargs = {{args...}};
+    detail::is_locking<T...>() ? fmt::vprint_buffered(file_, fmt, vargs)
+                               : fmt::vprint(file_, fmt, vargs);
   }
 };
 
 #if FMT_USE_FCNTL
+
 // A file. Closed file is represented by a file object with descriptor -1.
 // Methods that are not declared with noexcept may throw
 // fmt::system_error in case of failure. Note that some errors such as
@@ -251,6 +234,8 @@ class FMT_API file {
   // Constructs a file object with a given descriptor.
   explicit file(int fd) : fd_(fd) {}
 
+  friend struct pipe;
+
  public:
   // Possible values for the oflag argument to the constructor.
   enum {
@@ -263,7 +248,7 @@ class FMT_API file {
   };
 
   // Constructs a file object which doesn't represent any file.
-  file() noexcept : fd_(-1) {}
+  inline file() noexcept : fd_(-1) {}
 
   // Opens a file and constructs a file object representing this file.
   file(cstring_view path, int oflag);
@@ -272,10 +257,10 @@ class FMT_API file {
   file(const file&) = delete;
   void operator=(const file&) = delete;
 
-  file(file&& other) noexcept : fd_(other.fd_) { other.fd_ = -1; }
+  inline file(file&& other) noexcept : fd_(other.fd_) { other.fd_ = -1; }
 
   // Move assignment is not noexcept because close may throw.
-  auto operator=(file&& other) -> file& {
+  inline auto operator=(file&& other) -> file& {
     close();
     fd_ = other.fd_;
     other.fd_ = -1;
@@ -286,7 +271,7 @@ class FMT_API file {
   ~file() noexcept;
 
   // Returns the file descriptor.
-  auto descriptor() const noexcept -> int { return fd_; }
+  inline auto descriptor() const noexcept -> int { return fd_; }
 
   // Closes the file.
   void close();
@@ -313,11 +298,6 @@ class FMT_API file {
   // necessary.
   void dup2(int fd, std::error_code& ec) noexcept;
 
-  // Creates a pipe setting up read_end and write_end file objects for reading
-  // and writing respectively.
-  // DEPRECATED! Taking files as out parameters is deprecated.
-  static void pipe(file& read_end, file& write_end);
-
   // Creates a buffered_file object associated with this file and detaches
   // this file object from the file.
   auto fdopen(const char* mode) -> buffered_file;
@@ -329,15 +309,24 @@ class FMT_API file {
 #  endif
 };
 
+struct FMT_API pipe {
+  file read_end;
+  file write_end;
+
+  // Creates a pipe setting up read_end and write_end file objects for reading
+  // and writing respectively.
+  pipe();
+};
+
 // Returns the memory page size.
 auto getpagesize() -> long;
 
 namespace detail {
 
 struct buffer_size {
-  buffer_size() = default;
+  constexpr buffer_size() = default;
   size_t value = 0;
-  auto operator=(size_t val) const -> buffer_size {
+  FMT_CONSTEXPR auto operator=(size_t val) const -> buffer_size {
     auto bs = buffer_size();
     bs.value = val;
     return bs;
@@ -348,7 +337,7 @@ struct ostream_params {
   int oflag = file::WRONLY | file::CREATE | file::TRUNC;
   size_t buffer_size = BUFSIZ > 32768 ? BUFSIZ : 32768;
 
-  ostream_params() {}
+  constexpr ostream_params() {}
 
   template <typename... T>
   ostream_params(T... params, int new_oflag) : ostream_params(params...) {
@@ -369,79 +358,62 @@ struct ostream_params {
 #  endif
 };
 
-class file_buffer final : public buffer<char> {
-  file file_;
-
-  FMT_API void grow(size_t) override;
-
- public:
-  FMT_API file_buffer(cstring_view path, const ostream_params& params);
-  FMT_API file_buffer(file_buffer&& other);
-  FMT_API ~file_buffer();
-
-  void flush() {
-    if (size() == 0) return;
-    file_.write(data(), size() * sizeof(data()[0]));
-    clear();
-  }
-
-  void close() {
-    flush();
-    file_.close();
-  }
-};
-
 }  // namespace detail
 
-// Added {} below to work around default constructor error known to
-// occur in Xcode versions 7.2.1 and 8.2.1.
-constexpr detail::buffer_size buffer_size{};
+FMT_INLINE_VARIABLE constexpr auto buffer_size = detail::buffer_size();
 
-/** A fast output stream which is not thread-safe. */
-class FMT_API ostream {
+/// A fast buffered output stream for writing from a single thread. Writing from
+/// multiple threads without external synchronization may result in a data race.
+class FMT_API ostream : private detail::buffer<char> {
  private:
-  FMT_MSC_WARNING(suppress : 4251)
-  detail::file_buffer buffer_;
+  file file_;
 
-  ostream(cstring_view path, const detail::ostream_params& params)
-      : buffer_(path, params) {}
+  ostream(cstring_view path, const detail::ostream_params& params);
 
- public:
-  ostream(ostream&& other) : buffer_(std::move(other.buffer_)) {}
+  static void grow(buffer<char>& buf, size_t);
 
+ public:
+  ostream(ostream&& other) noexcept;
   ~ostream();
 
-  void flush() { buffer_.flush(); }
+  operator writer() {
+    detail::buffer<char>& buf = *this;
+    return buf;
+  }
+
+  inline void flush() {
+    if (size() == 0) return;
+    file_.write(data(), size() * sizeof(data()[0]));
+    clear();
+  }
 
   template <typename... T>
   friend auto output_file(cstring_view path, T... params) -> ostream;
 
-  void close() { buffer_.close(); }
+  inline void close() {
+    flush();
+    file_.close();
+  }
 
-  /**
-    Formats ``args`` according to specifications in ``fmt`` and writes the
-    output to the file.
-   */
+  /// Formats `args` according to specifications in `fmt` and writes the
+  /// output to the file.
   template <typename... T> void print(format_string<T...> fmt, T&&... args) {
-    vformat_to(std::back_inserter(buffer_), fmt,
-               fmt::make_format_args(args...));
+    vformat_to(appender(*this), fmt.str, vargs<T...>{{args...}});
   }
 };
 
 /**
-  \rst
-  Opens a file for writing. Supported parameters passed in *params*:
-
-  * ``<integer>``: Flags passed to `open
-    <https://pubs.opengroup.org/onlinepubs/007904875/functions/open.html>`_
-    (``file::WRONLY | file::CREATE | file::TRUNC`` by default)
-  * ``buffer_size=<integer>``: Output buffer size
-
-  **Example**::
-
-    auto out = fmt::output_file("guide.txt");
-    out.print("Don't {}", "Panic");
-  \endrst
+ * Opens a file for writing. Supported parameters passed in `params`:
+ *
+ * - `<integer>`: Flags passed to [open](
+ *   https://pubs.opengroup.org/onlinepubs/007904875/functions/open.html)
+ *   (`file::WRONLY | file::CREATE | file::TRUNC` by default)
+ * - `buffer_size=<integer>`: Output buffer size
+ *
+ * **Example**:
+ *
+ *     auto out = fmt::output_file("guide.txt");
+ *     out.print("Don't {}", "Panic");
  */
 template <typename... T>
 inline auto output_file(cstring_view path, T... params) -> ostream {
diff --git a/3rdparty/fmt/include/fmt/ostream.h b/3rdparty/fmt/include/fmt/ostream.h
index cdd99303fa19f..5d893c92164c8 100644
--- a/3rdparty/fmt/include/fmt/ostream.h
+++ b/3rdparty/fmt/include/fmt/ostream.h
@@ -8,7 +8,9 @@
 #ifndef FMT_OSTREAM_H_
 #define FMT_OSTREAM_H_
 
-#include <fstream>  // std::filebuf
+#ifndef FMT_MODULE
+#  include <fstream>  // std::filebuf
+#endif
 
 #ifdef _WIN32
 #  ifdef __GLIBCXX__
@@ -18,42 +20,19 @@
 #  include <io.h>
 #endif
 
-#include "format.h"
+#include "chrono.h"  // formatbuf
+
+#ifdef _MSVC_STL_UPDATE
+#  define FMT_MSVC_STL_UPDATE _MSVC_STL_UPDATE
+#elif defined(_MSC_VER) && _MSC_VER < 1912  // VS 15.5
+#  define FMT_MSVC_STL_UPDATE _MSVC_LANG
+#else
+#  define FMT_MSVC_STL_UPDATE 0
+#endif
 
 FMT_BEGIN_NAMESPACE
 namespace detail {
 
-template <typename Streambuf> class formatbuf : public Streambuf {
- private:
-  using char_type = typename Streambuf::char_type;
-  using streamsize = decltype(std::declval<Streambuf>().sputn(nullptr, 0));
-  using int_type = typename Streambuf::int_type;
-  using traits_type = typename Streambuf::traits_type;
-
-  buffer<char_type>& buffer_;
-
- public:
-  explicit formatbuf(buffer<char_type>& buf) : buffer_(buf) {}
-
- protected:
-  // The put area is always empty. This makes the implementation simpler and has
-  // the advantage that the streambuf and the buffer are always in sync and
-  // sputc never writes into uninitialized memory. A disadvantage is that each
-  // call to sputc always results in a (virtual) call to overflow. There is no
-  // disadvantage here for sputn since this always results in a call to xsputn.
-
-  auto overflow(int_type ch) -> int_type override {
-    if (!traits_type::eq_int_type(ch, traits_type::eof()))
-      buffer_.push_back(static_cast<char_type>(ch));
-    return ch;
-  }
-
-  auto xsputn(const char_type* s, streamsize count) -> streamsize override {
-    buffer_.append(s, s + count);
-    return count;
-  }
-};
-
 // Generate a unique explicit instantion in every translation unit using a tag
 // type in an anonymous namespace.
 namespace {
@@ -64,53 +43,18 @@ class file_access {
   friend auto get_file(BufType& obj) -> FILE* { return obj.*FileMemberPtr; }
 };
 
-#if FMT_MSC_VERSION
+#if FMT_MSVC_STL_UPDATE
 template class file_access<file_access_tag, std::filebuf,
                            &std::filebuf::_Myfile>;
 auto get_file(std::filebuf&) -> FILE*;
 #endif
 
-inline auto write_ostream_unicode(std::ostream& os, fmt::string_view data)
-    -> bool {
-  FILE* f = nullptr;
-#if FMT_MSC_VERSION && false
-  if (auto* buf = dynamic_cast<std::filebuf*>(os.rdbuf()))
-    f = get_file(*buf);
-  else
-    return false;
-#elif defined(_WIN32) && defined(__GLIBCXX__)
-  auto* rdbuf = os.rdbuf();
-  if (auto* sfbuf = dynamic_cast<__gnu_cxx::stdio_sync_filebuf<char>*>(rdbuf))
-    f = sfbuf->file();
-  else if (auto* fbuf = dynamic_cast<__gnu_cxx::stdio_filebuf<char>*>(rdbuf))
-    f = fbuf->file();
-  else
-    return false;
-#else
-  ignore_unused(os, data, f);
-#endif
-#ifdef _WIN32
-  if (f) {
-    int fd = _fileno(f);
-    if (_isatty(fd)) {
-      os.flush();
-      return write_console(fd, data);
-    }
-  }
-#endif
-  return false;
-}
-inline auto write_ostream_unicode(std::wostream&,
-                                  fmt::basic_string_view<wchar_t>) -> bool {
-  return false;
-}
-
 // Write the content of buf to os.
 // It is a separate function rather than a part of vprint to simplify testing.
 template <typename Char>
 void write_buffer(std::basic_ostream<Char>& os, buffer<Char>& buf) {
   const Char* buf_data = buf.data();
-  using unsigned_streamsize = std::make_unsigned<std::streamsize>::type;
+  using unsigned_streamsize = make_unsigned_t<std::streamsize>;
   unsigned_streamsize size = buf.size();
   unsigned_streamsize max_size = to_unsigned(max_value<std::streamsize>());
   do {
@@ -121,21 +65,9 @@ void write_buffer(std::basic_ostream<Char>& os, buffer<Char>& buf) {
   } while (size != 0);
 }
 
-template <typename Char, typename T>
-void format_value(buffer<Char>& buf, const T& value) {
-  auto&& format_buf = formatbuf<std::basic_streambuf<Char>>(buf);
-  auto&& output = std::basic_ostream<Char>(&format_buf);
-#if !defined(FMT_STATIC_THOUSANDS_SEPARATOR)
-  output.imbue(std::locale::classic());  // The default is always unlocalized.
-#endif
-  output << value;
-  output.exceptions(std::ios_base::failbit | std::ios_base::badbit);
-}
-
 template <typename T> struct streamed_view {
   const T& value;
 };
-
 }  // namespace detail
 
 // Formats an object of type T that has an overloaded ostream operator<<.
@@ -143,11 +75,14 @@ template <typename Char>
 struct basic_ostream_formatter : formatter<basic_string_view<Char>, Char> {
   void set_debug_format() = delete;
 
-  template <typename T, typename OutputIt>
-  auto format(const T& value, basic_format_context<OutputIt, Char>& ctx) const
-      -> OutputIt {
+  template <typename T, typename Context>
+  auto format(const T& value, Context& ctx) const -> decltype(ctx.out()) {
     auto buffer = basic_memory_buffer<Char>();
-    detail::format_value(buffer, value);
+    auto&& formatbuf = detail::formatbuf<std::basic_streambuf<Char>>(buffer);
+    auto&& output = std::basic_ostream<Char>(&formatbuf);
+    output.imbue(std::locale::classic());  // The default is always unlocalized.
+    output << value;
+    output.exceptions(std::ios_base::failbit | std::ios_base::badbit);
     return formatter<basic_string_view<Char>, Char>::format(
         {buffer.data(), buffer.size()}, ctx);
   }
@@ -158,73 +93,67 @@ using ostream_formatter = basic_ostream_formatter<char>;
 template <typename T, typename Char>
 struct formatter<detail::streamed_view<T>, Char>
     : basic_ostream_formatter<Char> {
-  template <typename OutputIt>
-  auto format(detail::streamed_view<T> view,
-              basic_format_context<OutputIt, Char>& ctx) const -> OutputIt {
+  template <typename Context>
+  auto format(detail::streamed_view<T> view, Context& ctx) const
+      -> decltype(ctx.out()) {
     return basic_ostream_formatter<Char>::format(view.value, ctx);
   }
 };
 
 /**
-  \rst
-  Returns a view that formats `value` via an ostream ``operator<<``.
-
-  **Example**::
-
-    fmt::print("Current thread id: {}\n",
-               fmt::streamed(std::this_thread::get_id()));
-  \endrst
+ * Returns a view that formats `value` via an ostream `operator<<`.
+ *
+ * **Example**:
+ *
+ *     fmt::print("Current thread id: {}\n",
+ *                fmt::streamed(std::this_thread::get_id()));
  */
 template <typename T>
 constexpr auto streamed(const T& value) -> detail::streamed_view<T> {
   return {value};
 }
 
-namespace detail {
-
-inline void vprint_directly(std::ostream& os, string_view format_str,
-                            format_args args) {
+inline void vprint(std::ostream& os, string_view fmt, format_args args) {
   auto buffer = memory_buffer();
-  detail::vformat_to(buffer, format_str, args);
-  detail::write_buffer(os, buffer);
-}
-
-}  // namespace detail
-
-FMT_EXPORT template <typename Char>
-void vprint(std::basic_ostream<Char>& os,
-            basic_string_view<type_identity_t<Char>> format_str,
-            basic_format_args<buffer_context<type_identity_t<Char>>> args) {
-  auto buffer = basic_memory_buffer<Char>();
-  detail::vformat_to(buffer, format_str, args);
-  if (detail::write_ostream_unicode(os, {buffer.data(), buffer.size()})) return;
+  detail::vformat_to(buffer, fmt, args);
+  FILE* f = nullptr;
+#if FMT_MSVC_STL_UPDATE && FMT_USE_RTTI
+  if (auto* buf = dynamic_cast<std::filebuf*>(os.rdbuf()))
+    f = detail::get_file(*buf);
+#elif defined(_WIN32) && defined(__GLIBCXX__) && FMT_USE_RTTI
+  auto* rdbuf = os.rdbuf();
+  if (auto* sfbuf = dynamic_cast<__gnu_cxx::stdio_sync_filebuf<char>*>(rdbuf))
+    f = sfbuf->file();
+  else if (auto* fbuf = dynamic_cast<__gnu_cxx::stdio_filebuf<char>*>(rdbuf))
+    f = fbuf->file();
+#endif
+#ifdef _WIN32
+  if (f) {
+    int fd = _fileno(f);
+    if (_isatty(fd)) {
+      os.flush();
+      if (detail::write_console(fd, {buffer.data(), buffer.size()})) return;
+    }
+  }
+#endif
+  detail::ignore_unused(f);
   detail::write_buffer(os, buffer);
 }
 
 /**
-  \rst
-  Prints formatted data to the stream *os*.
-
-  **Example**::
-
-    fmt::print(cerr, "Don't {}!", "panic");
-  \endrst
+ * Prints formatted data to the stream `os`.
+ *
+ * **Example**:
+ *
+ *     fmt::print(cerr, "Don't {}!", "panic");
  */
 FMT_EXPORT template <typename... T>
 void print(std::ostream& os, format_string<T...> fmt, T&&... args) {
-  const auto& vargs = fmt::make_format_args(args...);
-  if (detail::is_utf8())
-    vprint(os, fmt, vargs);
-  else
-    detail::vprint_directly(os, fmt, vargs);
-}
-
-FMT_EXPORT
-template <typename... Args>
-void print(std::wostream& os,
-           basic_format_string<wchar_t, type_identity_t<Args>...> fmt,
-           Args&&... args) {
-  vprint(os, fmt, fmt::make_format_args<buffer_context<wchar_t>>(args...));
+  fmt::vargs<T...> vargs = {{args...}};
+  if (detail::use_utf8) return vprint(os, fmt.str, vargs);
+  auto buffer = memory_buffer();
+  detail::vformat_to(buffer, fmt.str, vargs);
+  detail::write_buffer(os, buffer);
 }
 
 FMT_EXPORT template <typename... T>
@@ -232,14 +161,6 @@ void println(std::ostream& os, format_string<T...> fmt, T&&... args) {
   fmt::print(os, "{}\n", fmt::format(fmt, std::forward<T>(args)...));
 }
 
-FMT_EXPORT
-template <typename... Args>
-void println(std::wostream& os,
-             basic_format_string<wchar_t, type_identity_t<Args>...> fmt,
-             Args&&... args) {
-  print(os, L"{}\n", fmt::format(fmt, std::forward<Args>(args)...));
-}
-
 FMT_END_NAMESPACE
 
 #endif  // FMT_OSTREAM_H_
diff --git a/3rdparty/fmt/include/fmt/printf.h b/3rdparty/fmt/include/fmt/printf.h
index 07e81577cf320..e72684018546b 100644
--- a/3rdparty/fmt/include/fmt/printf.h
+++ b/3rdparty/fmt/include/fmt/printf.h
@@ -8,8 +8,10 @@
 #ifndef FMT_PRINTF_H_
 #define FMT_PRINTF_H_
 
-#include <algorithm>  // std::max
-#include <limits>     // std::numeric_limits
+#ifndef FMT_MODULE
+#  include <algorithm>  // std::max
+#  include <limits>     // std::numeric_limits
+#endif
 
 #include "format.h"
 
@@ -22,7 +24,7 @@ template <typename T> struct printf_formatter {
 
 template <typename Char> class basic_printf_context {
  private:
-  detail::buffer_appender<Char> out_;
+  basic_appender<Char> out_;
   basic_format_args<basic_printf_context> args_;
 
   static_assert(std::is_same<Char, char>::value ||
@@ -31,43 +33,53 @@ template <typename Char> class basic_printf_context {
 
  public:
   using char_type = Char;
-  using parse_context_type = basic_format_parse_context<Char>;
+  using parse_context_type = parse_context<Char>;
   template <typename T> using formatter_type = printf_formatter<T>;
+  enum { builtin_types = 1 };
 
-  /**
-    \rst
-    Constructs a ``printf_context`` object. References to the arguments are
-    stored in the context object so make sure they have appropriate lifetimes.
-    \endrst
-   */
-  basic_printf_context(detail::buffer_appender<Char> out,
+  /// Constructs a `printf_context` object. References to the arguments are
+  /// stored in the context object so make sure they have appropriate lifetimes.
+  basic_printf_context(basic_appender<Char> out,
                        basic_format_args<basic_printf_context> args)
       : out_(out), args_(args) {}
 
-  auto out() -> detail::buffer_appender<Char> { return out_; }
-  void advance_to(detail::buffer_appender<Char>) {}
+  auto out() -> basic_appender<Char> { return out_; }
+  void advance_to(basic_appender<Char>) {}
 
   auto locale() -> detail::locale_ref { return {}; }
 
   auto arg(int id) const -> basic_format_arg<basic_printf_context> {
     return args_.get(id);
   }
-
-  FMT_CONSTEXPR void on_error(const char* message) {
-    detail::error_handler().on_error(message);
-  }
 };
 
 namespace detail {
 
+// Return the result via the out param to workaround gcc bug 77539.
+template <bool IS_CONSTEXPR, typename T, typename Ptr = const T*>
+FMT_CONSTEXPR auto find(Ptr first, Ptr last, T value, Ptr& out) -> bool {
+  for (out = first; out != last; ++out) {
+    if (*out == value) return true;
+  }
+  return false;
+}
+
+template <>
+inline auto find<false, char>(const char* first, const char* last, char value,
+                              const char*& out) -> bool {
+  out =
+      static_cast<const char*>(memchr(first, value, to_unsigned(last - first)));
+  return out != nullptr;
+}
+
 // Checks if a value fits in int - used to avoid warnings about comparing
 // signed and unsigned integers.
 template <bool IsSigned> struct int_checker {
   template <typename T> static auto fits_in_int(T value) -> bool {
-    unsigned max = max_value<int>();
+    unsigned max = to_unsigned(max_value<int>());
     return value <= max;
   }
-  static auto fits_in_int(bool) -> bool { return true; }
+  inline static auto fits_in_int(bool) -> bool { return true; }
 };
 
 template <> struct int_checker<true> {
@@ -75,20 +87,20 @@ template <> struct int_checker<true> {
     return value >= (std::numeric_limits<int>::min)() &&
            value <= max_value<int>();
   }
-  static auto fits_in_int(int) -> bool { return true; }
+  inline static auto fits_in_int(int) -> bool { return true; }
 };
 
 struct printf_precision_handler {
   template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
   auto operator()(T value) -> int {
     if (!int_checker<std::numeric_limits<T>::is_signed>::fits_in_int(value))
-      throw_format_error("number is too big");
+      report_error("number is too big");
     return (std::max)(static_cast<int>(value), 0);
   }
 
   template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
   auto operator()(T) -> int {
-    throw_format_error("precision is not integer");
+    report_error("precision is not integer");
     return 0;
   }
 };
@@ -133,25 +145,19 @@ template <typename T, typename Context> class arg_converter {
     using target_type = conditional_t<std::is_same<T, void>::value, U, T>;
     if (const_check(sizeof(target_type) <= sizeof(int))) {
       // Extra casts are used to silence warnings.
-      if (is_signed) {
-        auto n = static_cast<int>(static_cast<target_type>(value));
-        arg_ = detail::make_arg<Context>(n);
-      } else {
-        using unsigned_type = typename make_unsigned_or_bool<target_type>::type;
-        auto n = static_cast<unsigned>(static_cast<unsigned_type>(value));
-        arg_ = detail::make_arg<Context>(n);
-      }
+      using unsigned_type = typename make_unsigned_or_bool<target_type>::type;
+      if (is_signed)
+        arg_ = static_cast<int>(static_cast<target_type>(value));
+      else
+        arg_ = static_cast<unsigned>(static_cast<unsigned_type>(value));
     } else {
-      if (is_signed) {
-        // glibc's printf doesn't sign extend arguments of smaller types:
-        //   std::printf("%lld", -42);  // prints "4294967254"
-        // but we don't have to do the same because it's a UB.
-        auto n = static_cast<long long>(value);
-        arg_ = detail::make_arg<Context>(n);
-      } else {
-        auto n = static_cast<typename make_unsigned_or_bool<U>::type>(value);
-        arg_ = detail::make_arg<Context>(n);
-      }
+      // glibc's printf doesn't sign extend arguments of smaller types:
+      //   std::printf("%lld", -42);  // prints "4294967254"
+      // but we don't have to do the same because it's a UB.
+      if (is_signed)
+        arg_ = static_cast<long long>(value);
+      else
+        arg_ = static_cast<typename make_unsigned_or_bool<U>::type>(value);
     }
   }
 
@@ -165,7 +171,7 @@ template <typename T, typename Context> class arg_converter {
 // unsigned).
 template <typename T, typename Context, typename Char>
 void convert_arg(basic_format_arg<Context>& arg, Char type) {
-  visit_format_arg(arg_converter<T, Context>(arg, type), arg);
+  arg.visit(arg_converter<T, Context>(arg, type));
 }
 
 // Converts an integer argument to char for printf.
@@ -178,8 +184,7 @@ template <typename Context> class char_converter {
 
   template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
   void operator()(T value) {
-    auto c = static_cast<typename Context::char_type>(value);
-    arg_ = detail::make_arg<Context>(c);
+    arg_ = static_cast<typename Context::char_type>(value);
   }
 
   template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
@@ -195,28 +200,28 @@ template <typename Char> struct get_cstring {
 
 // Checks if an argument is a valid printf width specifier and sets
 // left alignment if it is negative.
-template <typename Char> class printf_width_handler {
+class printf_width_handler {
  private:
-  format_specs<Char>& specs_;
+  format_specs& specs_;
 
  public:
-  explicit printf_width_handler(format_specs<Char>& specs) : specs_(specs) {}
+  inline explicit printf_width_handler(format_specs& specs) : specs_(specs) {}
 
   template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
   auto operator()(T value) -> unsigned {
     auto width = static_cast<uint32_or_64_or_128_t<T>>(value);
     if (detail::is_negative(value)) {
-      specs_.align = align::left;
+      specs_.set_align(align::left);
       width = 0 - width;
     }
-    unsigned int_max = max_value<int>();
-    if (width > int_max) throw_format_error("number is too big");
+    unsigned int_max = to_unsigned(max_value<int>());
+    if (width > int_max) report_error("number is too big");
     return static_cast<unsigned>(width);
   }
 
   template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
   auto operator()(T) -> unsigned {
-    throw_format_error("width is not integer");
+    report_error("width is not integer");
     return 0;
   }
 };
@@ -224,12 +229,12 @@ template <typename Char> class printf_width_handler {
 // Workaround for a bug with the XL compiler when initializing
 // printf_arg_formatter's base class.
 template <typename Char>
-auto make_arg_formatter(buffer_appender<Char> iter, format_specs<Char>& s)
+auto make_arg_formatter(basic_appender<Char> iter, format_specs& s)
     -> arg_formatter<Char> {
   return {iter, s, locale_ref()};
 }
 
-// The ``printf`` argument formatter.
+// The `printf` argument formatter.
 template <typename Char>
 class printf_arg_formatter : public arg_formatter<Char> {
  private:
@@ -240,105 +245,96 @@ class printf_arg_formatter : public arg_formatter<Char> {
 
   void write_null_pointer(bool is_string = false) {
     auto s = this->specs;
-    s.type = presentation_type::none;
-    write_bytes(this->out, is_string ? "(null)" : "(nil)", s);
+    s.set_type(presentation_type::none);
+    write_bytes<Char>(this->out, is_string ? "(null)" : "(nil)", s);
+  }
+
+  template <typename T> void write(T value) {
+    detail::write<Char>(this->out, value, this->specs, this->locale);
   }
 
  public:
-  printf_arg_formatter(buffer_appender<Char> iter, format_specs<Char>& s,
+  printf_arg_formatter(basic_appender<Char> iter, format_specs& s,
                        context_type& ctx)
       : base(make_arg_formatter(iter, s)), context_(ctx) {}
 
-  void operator()(monostate value) { base::operator()(value); }
+  void operator()(monostate value) { write(value); }
 
   template <typename T, FMT_ENABLE_IF(detail::is_integral<T>::value)>
   void operator()(T value) {
     // MSVC2013 fails to compile separate overloads for bool and Char so use
     // std::is_same instead.
     if (!std::is_same<T, Char>::value) {
-      base::operator()(value);
+      write(value);
       return;
     }
-    format_specs<Char> fmt_specs = this->specs;
-    if (fmt_specs.type != presentation_type::none &&
-        fmt_specs.type != presentation_type::chr) {
+    format_specs s = this->specs;
+    if (s.type() != presentation_type::none &&
+        s.type() != presentation_type::chr) {
       return (*this)(static_cast<int>(value));
     }
-    fmt_specs.sign = sign::none;
-    fmt_specs.alt = false;
-    fmt_specs.fill[0] = ' ';  // Ignore '0' flag for char types.
+    s.set_sign(sign::none);
+    s.clear_alt();
+    s.set_fill(' ');  // Ignore '0' flag for char types.
     // align::numeric needs to be overwritten here since the '0' flag is
     // ignored for non-numeric types
-    if (fmt_specs.align == align::none || fmt_specs.align == align::numeric)
-      fmt_specs.align = align::right;
-    write<Char>(this->out, static_cast<Char>(value), fmt_specs);
+    if (s.align() == align::none || s.align() == align::numeric)
+      s.set_align(align::right);
+    detail::write<Char>(this->out, static_cast<Char>(value), s);
   }
 
   template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
   void operator()(T value) {
-    base::operator()(value);
+    write(value);
   }
 
-  /** Formats a null-terminated C string. */
   void operator()(const char* value) {
     if (value)
-      base::operator()(value);
+      write(value);
     else
-      write_null_pointer(this->specs.type != presentation_type::pointer);
+      write_null_pointer(this->specs.type() != presentation_type::pointer);
   }
 
-  /** Formats a null-terminated wide C string. */
   void operator()(const wchar_t* value) {
     if (value)
-      base::operator()(value);
+      write(value);
     else
-      write_null_pointer(this->specs.type != presentation_type::pointer);
+      write_null_pointer(this->specs.type() != presentation_type::pointer);
   }
 
-  void operator()(basic_string_view<Char> value) { base::operator()(value); }
+  void operator()(basic_string_view<Char> value) { write(value); }
 
-  /** Formats a pointer. */
   void operator()(const void* value) {
     if (value)
-      base::operator()(value);
+      write(value);
     else
       write_null_pointer();
   }
 
-  /** Formats an argument of a custom (user-defined) type. */
   void operator()(typename basic_format_arg<context_type>::handle handle) {
-    auto parse_ctx = basic_format_parse_context<Char>({});
+    auto parse_ctx = parse_context<Char>({});
     handle.format(parse_ctx, context_);
   }
 };
 
 template <typename Char>
-void parse_flags(format_specs<Char>& specs, const Char*& it, const Char* end) {
+void parse_flags(format_specs& specs, const Char*& it, const Char* end) {
   for (; it != end; ++it) {
     switch (*it) {
-    case '-':
-      specs.align = align::left;
-      break;
-    case '+':
-      specs.sign = sign::plus;
-      break;
-    case '0':
-      specs.fill[0] = '0';
-      break;
+    case '-': specs.set_align(align::left); break;
+    case '+': specs.set_sign(sign::plus); break;
+    case '0': specs.set_fill('0'); break;
     case ' ':
-      if (specs.sign != sign::plus) specs.sign = sign::space;
-      break;
-    case '#':
-      specs.alt = true;
+      if (specs.sign() != sign::plus) specs.set_sign(sign::space);
       break;
-    default:
-      return;
+    case '#': specs.set_alt(); break;
+    default:  return;
     }
   }
 }
 
 template <typename Char, typename GetArg>
-auto parse_header(const Char*& it, const Char* end, format_specs<Char>& specs,
+auto parse_header(const Char*& it, const Char* end, format_specs& specs,
                   GetArg get_arg) -> int {
   int arg_index = -1;
   Char c = *it;
@@ -350,11 +346,11 @@ auto parse_header(const Char*& it, const Char* end, format_specs<Char>& specs,
       ++it;
       arg_index = value != -1 ? value : max_value<int>();
     } else {
-      if (c == '0') specs.fill[0] = '0';
+      if (c == '0') specs.set_fill('0');
       if (value != 0) {
         // Nonzero value means that we parsed width and don't need to
         // parse it or flags again, so return now.
-        if (value == -1) throw_format_error("number is too big");
+        if (value == -1) report_error("number is too big");
         specs.width = value;
         return arg_index;
       }
@@ -365,63 +361,47 @@ auto parse_header(const Char*& it, const Char* end, format_specs<Char>& specs,
   if (it != end) {
     if (*it >= '0' && *it <= '9') {
       specs.width = parse_nonnegative_int(it, end, -1);
-      if (specs.width == -1) throw_format_error("number is too big");
+      if (specs.width == -1) report_error("number is too big");
     } else if (*it == '*') {
       ++it;
-      specs.width = static_cast<int>(visit_format_arg(
-          detail::printf_width_handler<Char>(specs), get_arg(-1)));
+      specs.width = static_cast<int>(
+          get_arg(-1).visit(detail::printf_width_handler(specs)));
     }
   }
   return arg_index;
 }
 
-inline auto parse_printf_presentation_type(char c, type t)
+inline auto parse_printf_presentation_type(char c, type t, bool& upper)
     -> presentation_type {
   using pt = presentation_type;
   constexpr auto integral_set = sint_set | uint_set | bool_set | char_set;
   switch (c) {
-  case 'd':
-    return in(t, integral_set) ? pt::dec : pt::none;
-  case 'o':
-    return in(t, integral_set) ? pt::oct : pt::none;
-  case 'x':
-    return in(t, integral_set) ? pt::hex_lower : pt::none;
-  case 'X':
-    return in(t, integral_set) ? pt::hex_upper : pt::none;
-  case 'a':
-    return in(t, float_set) ? pt::hexfloat_lower : pt::none;
-  case 'A':
-    return in(t, float_set) ? pt::hexfloat_upper : pt::none;
-  case 'e':
-    return in(t, float_set) ? pt::exp_lower : pt::none;
-  case 'E':
-    return in(t, float_set) ? pt::exp_upper : pt::none;
-  case 'f':
-    return in(t, float_set) ? pt::fixed_lower : pt::none;
-  case 'F':
-    return in(t, float_set) ? pt::fixed_upper : pt::none;
-  case 'g':
-    return in(t, float_set) ? pt::general_lower : pt::none;
-  case 'G':
-    return in(t, float_set) ? pt::general_upper : pt::none;
-  case 'c':
-    return in(t, integral_set) ? pt::chr : pt::none;
-  case 's':
-    return in(t, string_set | cstring_set) ? pt::string : pt::none;
-  case 'p':
-    return in(t, pointer_set | cstring_set) ? pt::pointer : pt::none;
-  default:
-    return pt::none;
+  case 'd': return in(t, integral_set) ? pt::dec : pt::none;
+  case 'o': return in(t, integral_set) ? pt::oct : pt::none;
+  case 'X': upper = true; FMT_FALLTHROUGH;
+  case 'x': return in(t, integral_set) ? pt::hex : pt::none;
+  case 'E': upper = true; FMT_FALLTHROUGH;
+  case 'e': return in(t, float_set) ? pt::exp : pt::none;
+  case 'F': upper = true; FMT_FALLTHROUGH;
+  case 'f': return in(t, float_set) ? pt::fixed : pt::none;
+  case 'G': upper = true; FMT_FALLTHROUGH;
+  case 'g': return in(t, float_set) ? pt::general : pt::none;
+  case 'A': upper = true; FMT_FALLTHROUGH;
+  case 'a': return in(t, float_set) ? pt::hexfloat : pt::none;
+  case 'c': return in(t, integral_set) ? pt::chr : pt::none;
+  case 's': return in(t, string_set | cstring_set) ? pt::string : pt::none;
+  case 'p': return in(t, pointer_set | cstring_set) ? pt::pointer : pt::none;
+  default:  return pt::none;
   }
 }
 
 template <typename Char, typename Context>
 void vprintf(buffer<Char>& buf, basic_string_view<Char> format,
              basic_format_args<Context> args) {
-  using iterator = buffer_appender<Char>;
+  using iterator = basic_appender<Char>;
   auto out = iterator(buf);
   auto context = basic_printf_context<Char>(out, args);
-  auto parse_ctx = basic_format_parse_context<Char>(format);
+  auto parse_ctx = parse_context<Char>(format);
 
   // Returns the argument with specified index or, if arg_index is -1, the next
   // argument.
@@ -449,12 +429,12 @@ void vprintf(buffer<Char>& buf, basic_string_view<Char> format,
     }
     write(out, basic_string_view<Char>(start, to_unsigned(it - 1 - start)));
 
-    auto specs = format_specs<Char>();
-    specs.align = align::right;
+    auto specs = format_specs();
+    specs.set_align(align::right);
 
     // Parse argument index, flags and width.
     int arg_index = parse_header(it, end, specs, get_arg);
-    if (arg_index == 0) throw_format_error("argument not found");
+    if (arg_index == 0) report_error("argument not found");
 
     // Parse precision.
     if (it != end && *it == '.') {
@@ -464,8 +444,8 @@ void vprintf(buffer<Char>& buf, basic_string_view<Char> format,
         specs.precision = parse_nonnegative_int(it, end, 0);
       } else if (c == '*') {
         ++it;
-        specs.precision = static_cast<int>(
-            visit_format_arg(printf_precision_handler(), get_arg(-1)));
+        specs.precision =
+            static_cast<int>(get_arg(-1).visit(printf_precision_handler()));
       } else {
         specs.precision = 0;
       }
@@ -474,25 +454,26 @@ void vprintf(buffer<Char>& buf, basic_string_view<Char> format,
     auto arg = get_arg(arg_index);
     // For d, i, o, u, x, and X conversion specifiers, if a precision is
     // specified, the '0' flag is ignored
-    if (specs.precision >= 0 && arg.is_integral()) {
+    if (specs.precision >= 0 && is_integral_type(arg.type())) {
       // Ignore '0' for non-numeric types or if '-' present.
-      specs.fill[0] = ' ';
+      specs.set_fill(' ');
     }
     if (specs.precision >= 0 && arg.type() == type::cstring_type) {
-      auto str = visit_format_arg(get_cstring<Char>(), arg);
+      auto str = arg.visit(get_cstring<Char>());
       auto str_end = str + specs.precision;
       auto nul = std::find(str, str_end, Char());
       auto sv = basic_string_view<Char>(
           str, to_unsigned(nul != str_end ? nul - str : specs.precision));
-      arg = make_arg<basic_printf_context<Char>>(sv);
+      arg = sv;
     }
-    if (specs.alt && visit_format_arg(is_zero_int(), arg)) specs.alt = false;
-    if (specs.fill[0] == '0') {
-      if (arg.is_arithmetic() && specs.align != align::left)
-        specs.align = align::numeric;
-      else
-        specs.fill[0] = ' ';  // Ignore '0' flag for non-numeric types or if '-'
-                              // flag is also present.
+    if (specs.alt() && arg.visit(is_zero_int())) specs.clear_alt();
+    if (specs.fill_unit<Char>() == '0') {
+      if (is_arithmetic_type(arg.type()) && specs.align() != align::left) {
+        specs.set_align(align::numeric);
+      } else {
+        // Ignore '0' flag for non-numeric types or if '-' flag is also present.
+        specs.set_fill(' ');
+      }
     }
 
     // Parse length and convert the argument to the required type.
@@ -517,47 +498,39 @@ void vprintf(buffer<Char>& buf, basic_string_view<Char> format,
         convert_arg<long>(arg, t);
       }
       break;
-    case 'j':
-      convert_arg<intmax_t>(arg, t);
-      break;
-    case 'z':
-      convert_arg<size_t>(arg, t);
-      break;
-    case 't':
-      convert_arg<std::ptrdiff_t>(arg, t);
-      break;
+    case 'j': convert_arg<intmax_t>(arg, t); break;
+    case 'z': convert_arg<size_t>(arg, t); break;
+    case 't': convert_arg<std::ptrdiff_t>(arg, t); break;
     case 'L':
       // printf produces garbage when 'L' is omitted for long double, no
       // need to do the same.
       break;
-    default:
-      --it;
-      convert_arg<void>(arg, c);
+    default: --it; convert_arg<void>(arg, c);
     }
 
     // Parse type.
-    if (it == end) throw_format_error("invalid format string");
+    if (it == end) report_error("invalid format string");
     char type = static_cast<char>(*it++);
-    if (arg.is_integral()) {
+    if (is_integral_type(arg.type())) {
       // Normalize type.
       switch (type) {
       case 'i':
-      case 'u':
-        type = 'd';
-        break;
+      case 'u': type = 'd'; break;
       case 'c':
-        visit_format_arg(char_converter<basic_printf_context<Char>>(arg), arg);
+        arg.visit(char_converter<basic_printf_context<Char>>(arg));
         break;
       }
     }
-    specs.type = parse_printf_presentation_type(type, arg.type());
-    if (specs.type == presentation_type::none)
-      throw_format_error("invalid format specifier");
+    bool upper = false;
+    specs.set_type(parse_printf_presentation_type(type, arg.type(), upper));
+    if (specs.type() == presentation_type::none)
+      report_error("invalid format specifier");
+    if (upper) specs.set_upper();
 
     start = it;
 
     // Format argument.
-    visit_format_arg(printf_arg_formatter<Char>(out, specs, context), arg);
+    arg.visit(printf_arg_formatter<Char>(out, specs, context));
   }
   write(out, basic_string_view<Char>(start, to_unsigned(it - start)));
 }
@@ -569,56 +542,44 @@ using wprintf_context = basic_printf_context<wchar_t>;
 using printf_args = basic_format_args<printf_context>;
 using wprintf_args = basic_format_args<wprintf_context>;
 
-/**
-  \rst
-  Constructs an `~fmt::format_arg_store` object that contains references to
-  arguments and can be implicitly converted to `~fmt::printf_args`.
-  \endrst
- */
-template <typename... T>
-inline auto make_printf_args(const T&... args)
-    -> format_arg_store<printf_context, T...> {
-  return {args...};
+/// Constructs an `format_arg_store` object that contains references to
+/// arguments and can be implicitly converted to `printf_args`.
+template <typename Char = char, typename... T>
+inline auto make_printf_args(T&... args)
+    -> decltype(fmt::make_format_args<basic_printf_context<Char>>(args...)) {
+  return fmt::make_format_args<basic_printf_context<Char>>(args...);
 }
 
-// DEPRECATED!
-template <typename... T>
-inline auto make_wprintf_args(const T&... args)
-    -> format_arg_store<wprintf_context, T...> {
-  return {args...};
-}
+template <typename Char> struct vprintf_args {
+  using type = basic_format_args<basic_printf_context<Char>>;
+};
 
 template <typename Char>
-inline auto vsprintf(
-    basic_string_view<Char> fmt,
-    basic_format_args<basic_printf_context<type_identity_t<Char>>> args)
+inline auto vsprintf(basic_string_view<Char> fmt,
+                     typename vprintf_args<Char>::type args)
     -> std::basic_string<Char> {
   auto buf = basic_memory_buffer<Char>();
   detail::vprintf(buf, fmt, args);
-  return to_string(buf);
+  return {buf.data(), buf.size()};
 }
 
 /**
-  \rst
-  Formats arguments and returns the result as a string.
-
-  **Example**::
-
-    std::string message = fmt::sprintf("The answer is %d", 42);
-  \endrst
-*/
-template <typename S, typename... T,
-          typename Char = enable_if_t<detail::is_string<S>::value, char_t<S>>>
+ * Formats `args` according to specifications in `fmt` and returns the result
+ * as as string.
+ *
+ * **Example**:
+ *
+ *     std::string message = fmt::sprintf("The answer is %d", 42);
+ */
+template <typename S, typename... T, typename Char = detail::char_t<S>>
 inline auto sprintf(const S& fmt, const T&... args) -> std::basic_string<Char> {
   return vsprintf(detail::to_string_view(fmt),
                   fmt::make_format_args<basic_printf_context<Char>>(args...));
 }
 
 template <typename Char>
-inline auto vfprintf(
-    std::FILE* f, basic_string_view<Char> fmt,
-    basic_format_args<basic_printf_context<type_identity_t<Char>>> args)
-    -> int {
+inline auto vfprintf(std::FILE* f, basic_string_view<Char> fmt,
+                     typename vprintf_args<Char>::type args) -> int {
   auto buf = basic_memory_buffer<Char>();
   detail::vprintf(buf, fmt, args);
   size_t size = buf.size();
@@ -628,36 +589,33 @@ inline auto vfprintf(
 }
 
 /**
-  \rst
-  Prints formatted data to the file *f*.
-
-  **Example**::
-
-    fmt::fprintf(stderr, "Don't %s!", "panic");
-  \endrst
+ * Formats `args` according to specifications in `fmt` and writes the output
+ * to `f`.
+ *
+ * **Example**:
+ *
+ *     fmt::fprintf(stderr, "Don't %s!", "panic");
  */
-template <typename S, typename... T, typename Char = char_t<S>>
+template <typename S, typename... T, typename Char = detail::char_t<S>>
 inline auto fprintf(std::FILE* f, const S& fmt, const T&... args) -> int {
   return vfprintf(f, detail::to_string_view(fmt),
-                  fmt::make_format_args<basic_printf_context<Char>>(args...));
+                  make_printf_args<Char>(args...));
 }
 
 template <typename Char>
-FMT_DEPRECATED inline auto vprintf(
-    basic_string_view<Char> fmt,
-    basic_format_args<basic_printf_context<type_identity_t<Char>>> args)
+FMT_DEPRECATED inline auto vprintf(basic_string_view<Char> fmt,
+                                   typename vprintf_args<Char>::type args)
     -> int {
   return vfprintf(stdout, fmt, args);
 }
 
 /**
-  \rst
-  Prints formatted data to ``stdout``.
-
-  **Example**::
-
-    fmt::printf("Elapsed time: %.2f seconds", 1.23);
-  \endrst
+ * Formats `args` according to specifications in `fmt` and writes the output
+ * to `stdout`.
+ *
+ * **Example**:
+ *
+ *   fmt::printf("Elapsed time: %.2f seconds", 1.23);
  */
 template <typename... T>
 inline auto printf(string_view fmt, const T&... args) -> int {
@@ -666,7 +624,7 @@ inline auto printf(string_view fmt, const T&... args) -> int {
 template <typename... T>
 FMT_DEPRECATED inline auto printf(basic_string_view<wchar_t> fmt,
                                   const T&... args) -> int {
-  return vfprintf(stdout, fmt, make_wprintf_args(args...));
+  return vfprintf(stdout, fmt, make_printf_args<wchar_t>(args...));
 }
 
 FMT_END_EXPORT
diff --git a/3rdparty/fmt/include/fmt/ranges.h b/3rdparty/fmt/include/fmt/ranges.h
index 3638fffb83bce..118d24fe81a80 100644
--- a/3rdparty/fmt/include/fmt/ranges.h
+++ b/3rdparty/fmt/include/fmt/ranges.h
@@ -8,67 +8,31 @@
 #ifndef FMT_RANGES_H_
 #define FMT_RANGES_H_
 
-#include <initializer_list>
-#include <tuple>
-#include <type_traits>
+#ifndef FMT_MODULE
+#  include <initializer_list>
+#  include <iterator>
+#  include <string>
+#  include <tuple>
+#  include <type_traits>
+#  include <utility>
+#endif
 
 #include "format.h"
 
 FMT_BEGIN_NAMESPACE
 
-namespace detail {
-
-template <typename Range, typename OutputIt>
-auto copy(const Range& range, OutputIt out) -> OutputIt {
-  for (auto it = range.begin(), end = range.end(); it != end; ++it)
-    *out++ = *it;
-  return out;
-}
-
-template <typename OutputIt>
-auto copy(const char* str, OutputIt out) -> OutputIt {
-  while (*str) *out++ = *str++;
-  return out;
-}
-
-template <typename OutputIt> auto copy(char ch, OutputIt out) -> OutputIt {
-  *out++ = ch;
-  return out;
-}
-
-template <typename OutputIt> auto copy(wchar_t ch, OutputIt out) -> OutputIt {
-  *out++ = ch;
-  return out;
-}
-
-// Returns true if T has a std::string-like interface, like std::string_view.
-template <typename T> class is_std_string_like {
-  template <typename U>
-  static auto check(U* p)
-      -> decltype((void)p->find('a'), p->length(), (void)p->data(), int());
-  template <typename> static void check(...);
-
- public:
-  static constexpr const bool value =
-      is_string<T>::value ||
-      std::is_convertible<T, std_string_view<char>>::value ||
-      !std::is_void<decltype(check<T>(nullptr))>::value;
-};
+FMT_EXPORT
+enum class range_format { disabled, map, set, sequence, string, debug_string };
 
-template <typename Char>
-struct is_std_string_like<fmt::basic_string_view<Char>> : std::true_type {};
+namespace detail {
 
 template <typename T> class is_map {
   template <typename U> static auto check(U*) -> typename U::mapped_type;
   template <typename> static void check(...);
 
  public:
-#ifdef FMT_FORMAT_MAP_AS_LIST  // DEPRECATED!
-  static constexpr const bool value = false;
-#else
   static constexpr const bool value =
       !std::is_void<decltype(check<T>(nullptr))>::value;
-#endif
 };
 
 template <typename T> class is_set {
@@ -76,26 +40,10 @@ template <typename T> class is_set {
   template <typename> static void check(...);
 
  public:
-#ifdef FMT_FORMAT_SET_AS_LIST  // DEPRECATED!
-  static constexpr const bool value = false;
-#else
   static constexpr const bool value =
       !std::is_void<decltype(check<T>(nullptr))>::value && !is_map<T>::value;
-#endif
 };
 
-template <typename... Ts> struct conditional_helper {};
-
-template <typename T, typename _ = void> struct is_range_ : std::false_type {};
-
-#if !FMT_MSC_VERSION || FMT_MSC_VERSION > 1800
-
-#  define FMT_DECLTYPE_RETURN(val)  \
-    ->decltype(val) { return val; } \
-    static_assert(                  \
-        true, "")  // This makes it so that a semicolon is required after the
-                   // macro, which helps clang-format handle the formatting.
-
 // C array overload
 template <typename T, std::size_t N>
 auto range_begin(const T (&arr)[N]) -> const T* {
@@ -110,17 +58,21 @@ template <typename T, typename Enable = void>
 struct has_member_fn_begin_end_t : std::false_type {};
 
 template <typename T>
-struct has_member_fn_begin_end_t<T, void_t<decltype(std::declval<T>().begin()),
+struct has_member_fn_begin_end_t<T, void_t<decltype(*std::declval<T>().begin()),
                                            decltype(std::declval<T>().end())>>
     : std::true_type {};
 
-// Member function overload
+// Member function overloads.
 template <typename T>
-auto range_begin(T&& rng) FMT_DECLTYPE_RETURN(static_cast<T&&>(rng).begin());
+auto range_begin(T&& rng) -> decltype(static_cast<T&&>(rng).begin()) {
+  return static_cast<T&&>(rng).begin();
+}
 template <typename T>
-auto range_end(T&& rng) FMT_DECLTYPE_RETURN(static_cast<T&&>(rng).end());
+auto range_end(T&& rng) -> decltype(static_cast<T&&>(rng).end()) {
+  return static_cast<T&&>(rng).end();
+}
 
-// ADL overload. Only participates in overload resolution if member functions
+// ADL overloads. Only participate in overload resolution if member functions
 // are not found.
 template <typename T>
 auto range_begin(T&& rng)
@@ -141,31 +93,30 @@ struct has_mutable_begin_end : std::false_type {};
 
 template <typename T>
 struct has_const_begin_end<
-    T,
-    void_t<
-        decltype(detail::range_begin(std::declval<const remove_cvref_t<T>&>())),
-        decltype(detail::range_end(std::declval<const remove_cvref_t<T>&>()))>>
+    T, void_t<decltype(*detail::range_begin(
+                  std::declval<const remove_cvref_t<T>&>())),
+              decltype(detail::range_end(
+                  std::declval<const remove_cvref_t<T>&>()))>>
     : std::true_type {};
 
 template <typename T>
 struct has_mutable_begin_end<
-    T, void_t<decltype(detail::range_begin(std::declval<T>())),
-              decltype(detail::range_end(std::declval<T>())),
+    T, void_t<decltype(*detail::range_begin(std::declval<T&>())),
+              decltype(detail::range_end(std::declval<T&>())),
               // the extra int here is because older versions of MSVC don't
               // SFINAE properly unless there are distinct types
               int>> : std::true_type {};
 
+template <typename T, typename _ = void> struct is_range_ : std::false_type {};
 template <typename T>
 struct is_range_<T, void>
     : std::integral_constant<bool, (has_const_begin_end<T>::value ||
                                     has_mutable_begin_end<T>::value)> {};
-#  undef FMT_DECLTYPE_RETURN
-#endif
 
 // tuple_size and tuple_element check.
 template <typename T> class is_tuple_like_ {
-  template <typename U>
-  static auto check(U* p) -> decltype(std::tuple_size<U>::value, int());
+  template <typename U, typename V = typename std::remove_cv<U>::type>
+  static auto check(U* p) -> decltype(std::tuple_size<V>::value, 0);
   template <typename> static void check(...);
 
  public:
@@ -206,12 +157,13 @@ class is_tuple_formattable_ {
   static constexpr const bool value = false;
 };
 template <typename T, typename C> class is_tuple_formattable_<T, C, true> {
-  template <std::size_t... Is>
-  static auto check2(index_sequence<Is...>,
-                     integer_sequence<bool, (Is == Is)...>) -> std::true_type;
-  static auto check2(...) -> std::false_type;
-  template <std::size_t... Is>
-  static auto check(index_sequence<Is...>) -> decltype(check2(
+  template <size_t... Is>
+  static auto all_true(index_sequence<Is...>,
+                       integer_sequence<bool, (Is >= 0)...>) -> std::true_type;
+  static auto all_true(...) -> std::false_type;
+
+  template <size_t... Is>
+  static auto check(index_sequence<Is...>) -> decltype(all_true(
       index_sequence<Is...>{},
       integer_sequence<bool,
                        (is_formattable<typename std::tuple_element<Is, T>::type,
@@ -292,21 +244,32 @@ FMT_CONSTEXPR auto maybe_set_debug_format(Formatter& f, bool set)
 template <typename Formatter>
 FMT_CONSTEXPR void maybe_set_debug_format(Formatter&, ...) {}
 
+template <typename T>
+struct range_format_kind_
+    : std::integral_constant<range_format,
+                             std::is_same<uncvref_type<T>, T>::value
+                                 ? range_format::disabled
+                             : is_map<T>::value ? range_format::map
+                             : is_set<T>::value ? range_format::set
+                                                : range_format::sequence> {};
+
+template <range_format K>
+using range_format_constant = std::integral_constant<range_format, K>;
+
 // These are not generic lambdas for compatibility with C++11.
-template <typename ParseContext> struct parse_empty_specs {
+template <typename Char> struct parse_empty_specs {
   template <typename Formatter> FMT_CONSTEXPR void operator()(Formatter& f) {
     f.parse(ctx);
     detail::maybe_set_debug_format(f, true);
   }
-  ParseContext& ctx;
+  parse_context<Char>& ctx;
 };
 template <typename FormatContext> struct format_tuple_element {
   using char_type = typename FormatContext::char_type;
 
   template <typename T>
   void operator()(const formatter<T, char_type>& f, const T& v) {
-    if (i > 0)
-      ctx.advance_to(detail::copy_str<char_type>(separator, ctx.out()));
+    if (i > 0) ctx.advance_to(detail::copy<char_type>(separator, ctx.out()));
     ctx.advance_to(f.format(v, ctx));
     ++i;
   }
@@ -355,66 +318,48 @@ struct formatter<Tuple, Char,
     closing_bracket_ = close;
   }
 
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) -> const Char* {
     auto it = ctx.begin();
-    if (it != ctx.end() && *it != '}')
-      FMT_THROW(format_error("invalid format specifier"));
-    detail::for_each(formatters_, detail::parse_empty_specs<ParseContext>{ctx});
+    auto end = ctx.end();
+    if (it != end && detail::to_ascii(*it) == 'n') {
+      ++it;
+      set_brackets({}, {});
+      set_separator({});
+    }
+    if (it != end && *it != '}') report_error("invalid format specifier");
+    ctx.advance_to(it);
+    detail::for_each(formatters_, detail::parse_empty_specs<Char>{ctx});
     return it;
   }
 
   template <typename FormatContext>
   auto format(const Tuple& value, FormatContext& ctx) const
       -> decltype(ctx.out()) {
-    ctx.advance_to(detail::copy_str<Char>(opening_bracket_, ctx.out()));
+    ctx.advance_to(detail::copy<Char>(opening_bracket_, ctx.out()));
     detail::for_each2(
         formatters_, value,
         detail::format_tuple_element<FormatContext>{0, ctx, separator_});
-    return detail::copy_str<Char>(closing_bracket_, ctx.out());
+    return detail::copy<Char>(closing_bracket_, ctx.out());
   }
 };
 
 template <typename T, typename Char> struct is_range {
   static constexpr const bool value =
-      detail::is_range_<T>::value && !detail::is_std_string_like<T>::value &&
-      !std::is_convertible<T, std::basic_string<Char>>::value &&
-      !std::is_convertible<T, detail::std_string_view<Char>>::value;
+      detail::is_range_<T>::value && !detail::has_to_string_view<T>::value;
 };
 
 namespace detail {
-template <typename Context> struct range_mapper {
-  using mapper = arg_mapper<Context>;
-
-  template <typename T,
-            FMT_ENABLE_IF(has_formatter<remove_cvref_t<T>, Context>::value)>
-  static auto map(T&& value) -> T&& {
-    return static_cast<T&&>(value);
-  }
-  template <typename T,
-            FMT_ENABLE_IF(!has_formatter<remove_cvref_t<T>, Context>::value)>
-  static auto map(T&& value)
-      -> decltype(mapper().map(static_cast<T&&>(value))) {
-    return mapper().map(static_cast<T&&>(value));
-  }
-};
 
 template <typename Char, typename Element>
-using range_formatter_type =
-    formatter<remove_cvref_t<decltype(range_mapper<buffer_context<Char>>{}.map(
-                  std::declval<Element>()))>,
-              Char>;
+using range_formatter_type = formatter<remove_cvref_t<Element>, Char>;
 
 template <typename R>
 using maybe_const_range =
     conditional_t<has_const_begin_end<R>::value, const R, R>;
 
-// Workaround a bug in MSVC 2015 and earlier.
-#if !FMT_MSC_VERSION || FMT_MSC_VERSION >= 1910
 template <typename R, typename Char>
 struct is_formattable_delayed
     : is_formattable<uncvref_type<maybe_const_range<R>>, Char> {};
-#endif
 }  // namespace detail
 
 template <typename...> struct conjunction : std::true_type {};
@@ -438,6 +383,24 @@ struct range_formatter<
       detail::string_literal<Char, '['>{};
   basic_string_view<Char> closing_bracket_ =
       detail::string_literal<Char, ']'>{};
+  bool is_debug = false;
+
+  template <typename Output, typename It, typename Sentinel, typename U = T,
+            FMT_ENABLE_IF(std::is_same<U, Char>::value)>
+  auto write_debug_string(Output& out, It it, Sentinel end) const -> Output {
+    auto buf = basic_memory_buffer<Char>();
+    for (; it != end; ++it) buf.push_back(*it);
+    auto specs = format_specs();
+    specs.set_type(presentation_type::debug);
+    return detail::write<Char>(
+        out, basic_string_view<Char>(buf.data(), buf.size()), specs);
+  }
+
+  template <typename Output, typename It, typename Sentinel, typename U = T,
+            FMT_ENABLE_IF(!std::is_same<U, Char>::value)>
+  auto write_debug_string(Output& out, It, Sentinel) const -> Output {
+    return out;
+  }
 
  public:
   FMT_CONSTEXPR range_formatter() {}
@@ -456,21 +419,40 @@ struct range_formatter<
     closing_bracket_ = close;
   }
 
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) -> const Char* {
     auto it = ctx.begin();
     auto end = ctx.end();
+    detail::maybe_set_debug_format(underlying_, true);
+    if (it == end) return underlying_.parse(ctx);
 
-    if (it != end && *it == 'n') {
+    switch (detail::to_ascii(*it)) {
+    case 'n':
       set_brackets({}, {});
       ++it;
+      break;
+    case '?':
+      is_debug = true;
+      set_brackets({}, {});
+      ++it;
+      if (it == end || *it != 's') report_error("invalid format specifier");
+      FMT_FALLTHROUGH;
+    case 's':
+      if (!std::is_same<T, Char>::value)
+        report_error("invalid format specifier");
+      if (!is_debug) {
+        set_brackets(detail::string_literal<Char, '"'>{},
+                     detail::string_literal<Char, '"'>{});
+        set_separator({});
+        detail::maybe_set_debug_format(underlying_, false);
+      }
+      ++it;
+      return it;
     }
 
     if (it != end && *it != '}') {
-      if (*it != ':') FMT_THROW(format_error("invalid format specifier"));
+      if (*it != ':') report_error("invalid format specifier");
+      detail::maybe_set_debug_format(underlying_, false);
       ++it;
-    } else {
-      detail::maybe_set_debug_format(underlying_, true);
     }
 
     ctx.advance_to(it);
@@ -479,106 +461,218 @@ struct range_formatter<
 
   template <typename R, typename FormatContext>
   auto format(R&& range, FormatContext& ctx) const -> decltype(ctx.out()) {
-    detail::range_mapper<buffer_context<Char>> mapper;
     auto out = ctx.out();
-    out = detail::copy_str<Char>(opening_bracket_, out);
-    int i = 0;
     auto it = detail::range_begin(range);
     auto end = detail::range_end(range);
+    if (is_debug) return write_debug_string(out, std::move(it), end);
+
+    out = detail::copy<Char>(opening_bracket_, out);
+    int i = 0;
     for (; it != end; ++it) {
-      if (i > 0) out = detail::copy_str<Char>(separator_, out);
+      if (i > 0) out = detail::copy<Char>(separator_, out);
       ctx.advance_to(out);
-      auto&& item = *it;
-      out = underlying_.format(mapper.map(item), ctx);
+      auto&& item = *it;  // Need an lvalue
+      out = underlying_.format(item, ctx);
       ++i;
     }
-    out = detail::copy_str<Char>(closing_bracket_, out);
+    out = detail::copy<Char>(closing_bracket_, out);
     return out;
   }
 };
 
-enum class range_format { disabled, map, set, sequence, string, debug_string };
+FMT_EXPORT
+template <typename T, typename Char, typename Enable = void>
+struct range_format_kind
+    : conditional_t<
+          is_range<T, Char>::value, detail::range_format_kind_<T>,
+          std::integral_constant<range_format, range_format::disabled>> {};
 
-namespace detail {
-template <typename T>
-struct range_format_kind_
-    : std::integral_constant<range_format,
-                             std::is_same<uncvref_type<T>, T>::value
-                                 ? range_format::disabled
-                             : is_map<T>::value ? range_format::map
-                             : is_set<T>::value ? range_format::set
-                                                : range_format::sequence> {};
+template <typename R, typename Char>
+struct formatter<
+    R, Char,
+    enable_if_t<conjunction<
+        bool_constant<
+            range_format_kind<R, Char>::value != range_format::disabled &&
+            range_format_kind<R, Char>::value != range_format::map &&
+            range_format_kind<R, Char>::value != range_format::string &&
+            range_format_kind<R, Char>::value != range_format::debug_string>,
+        detail::is_formattable_delayed<R, Char>>::value>> {
+ private:
+  using range_type = detail::maybe_const_range<R>;
+  range_formatter<detail::uncvref_type<range_type>, Char> range_formatter_;
 
-template <range_format K, typename R, typename Char, typename Enable = void>
-struct range_default_formatter;
+ public:
+  using nonlocking = void;
+
+  FMT_CONSTEXPR formatter() {
+    if (detail::const_check(range_format_kind<R, Char>::value !=
+                            range_format::set))
+      return;
+    range_formatter_.set_brackets(detail::string_literal<Char, '{'>{},
+                                  detail::string_literal<Char, '}'>{});
+  }
 
-template <range_format K>
-using range_format_constant = std::integral_constant<range_format, K>;
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) -> const Char* {
+    return range_formatter_.parse(ctx);
+  }
 
-template <range_format K, typename R, typename Char>
-struct range_default_formatter<
-    K, R, Char,
-    enable_if_t<(K == range_format::sequence || K == range_format::map ||
-                 K == range_format::set)>> {
-  using range_type = detail::maybe_const_range<R>;
-  range_formatter<detail::uncvref_type<range_type>, Char> underlying_;
+  template <typename FormatContext>
+  auto format(range_type& range, FormatContext& ctx) const
+      -> decltype(ctx.out()) {
+    return range_formatter_.format(range, ctx);
+  }
+};
+
+// A map formatter.
+template <typename R, typename Char>
+struct formatter<
+    R, Char,
+    enable_if_t<range_format_kind<R, Char>::value == range_format::map>> {
+ private:
+  using map_type = detail::maybe_const_range<R>;
+  using element_type = detail::uncvref_type<map_type>;
 
-  FMT_CONSTEXPR range_default_formatter() { init(range_format_constant<K>()); }
+  decltype(detail::tuple::get_formatters<element_type, Char>(
+      detail::tuple_index_sequence<element_type>())) formatters_;
+  bool no_delimiters_ = false;
 
-  FMT_CONSTEXPR void init(range_format_constant<range_format::set>) {
-    underlying_.set_brackets(detail::string_literal<Char, '{'>{},
-                             detail::string_literal<Char, '}'>{});
+ public:
+  FMT_CONSTEXPR formatter() {}
+
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) -> const Char* {
+    auto it = ctx.begin();
+    auto end = ctx.end();
+    if (it != end) {
+      if (detail::to_ascii(*it) == 'n') {
+        no_delimiters_ = true;
+        ++it;
+      }
+      if (it != end && *it != '}') {
+        if (*it != ':') report_error("invalid format specifier");
+        ++it;
+      }
+      ctx.advance_to(it);
+    }
+    detail::for_each(formatters_, detail::parse_empty_specs<Char>{ctx});
+    return it;
   }
 
-  FMT_CONSTEXPR void init(range_format_constant<range_format::map>) {
-    underlying_.set_brackets(detail::string_literal<Char, '{'>{},
-                             detail::string_literal<Char, '}'>{});
-    underlying_.underlying().set_brackets({}, {});
-    underlying_.underlying().set_separator(
-        detail::string_literal<Char, ':', ' '>{});
+  template <typename FormatContext>
+  auto format(map_type& map, FormatContext& ctx) const -> decltype(ctx.out()) {
+    auto out = ctx.out();
+    basic_string_view<Char> open = detail::string_literal<Char, '{'>{};
+    if (!no_delimiters_) out = detail::copy<Char>(open, out);
+    int i = 0;
+    basic_string_view<Char> sep = detail::string_literal<Char, ',', ' '>{};
+    for (auto&& value : map) {
+      if (i > 0) out = detail::copy<Char>(sep, out);
+      ctx.advance_to(out);
+      detail::for_each2(formatters_, value,
+                        detail::format_tuple_element<FormatContext>{
+                            0, ctx, detail::string_literal<Char, ':', ' '>{}});
+      ++i;
+    }
+    basic_string_view<Char> close = detail::string_literal<Char, '}'>{};
+    if (!no_delimiters_) out = detail::copy<Char>(close, out);
+    return out;
   }
+};
+
+// A (debug_)string formatter.
+template <typename R, typename Char>
+struct formatter<
+    R, Char,
+    enable_if_t<range_format_kind<R, Char>::value == range_format::string ||
+                range_format_kind<R, Char>::value ==
+                    range_format::debug_string>> {
+ private:
+  using range_type = detail::maybe_const_range<R>;
+  using string_type =
+      conditional_t<std::is_constructible<
+                        detail::std_string_view<Char>,
+                        decltype(detail::range_begin(std::declval<R>())),
+                        decltype(detail::range_end(std::declval<R>()))>::value,
+                    detail::std_string_view<Char>, std::basic_string<Char>>;
 
-  FMT_CONSTEXPR void init(range_format_constant<range_format::sequence>) {}
+  formatter<string_type, Char> underlying_;
 
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
+ public:
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) -> const Char* {
     return underlying_.parse(ctx);
   }
 
   template <typename FormatContext>
   auto format(range_type& range, FormatContext& ctx) const
       -> decltype(ctx.out()) {
-    return underlying_.format(range, ctx);
+    auto out = ctx.out();
+    if (detail::const_check(range_format_kind<R, Char>::value ==
+                            range_format::debug_string))
+      *out++ = '"';
+    out = underlying_.format(
+        string_type{detail::range_begin(range), detail::range_end(range)}, ctx);
+    if (detail::const_check(range_format_kind<R, Char>::value ==
+                            range_format::debug_string))
+      *out++ = '"';
+    return out;
   }
 };
-}  // namespace detail
 
-template <typename T, typename Char, typename Enable = void>
-struct range_format_kind
-    : conditional_t<
-          is_range<T, Char>::value, detail::range_format_kind_<T>,
-          std::integral_constant<range_format, range_format::disabled>> {};
+template <typename It, typename Sentinel, typename Char = char>
+struct join_view : detail::view {
+  It begin;
+  Sentinel end;
+  basic_string_view<Char> sep;
 
-template <typename R, typename Char>
-struct formatter<
-    R, Char,
-    enable_if_t<conjunction<bool_constant<range_format_kind<R, Char>::value !=
-                                          range_format::disabled>
-// Workaround a bug in MSVC 2015 and earlier.
-#if !FMT_MSC_VERSION || FMT_MSC_VERSION >= 1910
-                            ,
-                            detail::is_formattable_delayed<R, Char>
+  join_view(It b, Sentinel e, basic_string_view<Char> s)
+      : begin(std::move(b)), end(e), sep(s) {}
+};
+
+template <typename It, typename Sentinel, typename Char>
+struct formatter<join_view<It, Sentinel, Char>, Char> {
+ private:
+  using value_type =
+#ifdef __cpp_lib_ranges
+      std::iter_value_t<It>;
+#else
+      typename std::iterator_traits<It>::value_type;
 #endif
-                            >::value>>
-    : detail::range_default_formatter<range_format_kind<R, Char>::value, R,
-                                      Char> {
+  formatter<remove_cvref_t<value_type>, Char> value_formatter_;
+
+  using view = conditional_t<std::is_copy_constructible<It>::value,
+                             const join_view<It, Sentinel, Char>,
+                             join_view<It, Sentinel, Char>>;
+
+ public:
+  using nonlocking = void;
+
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) -> const Char* {
+    return value_formatter_.parse(ctx);
+  }
+
+  template <typename FormatContext>
+  auto format(view& value, FormatContext& ctx) const -> decltype(ctx.out()) {
+    using iter =
+        conditional_t<std::is_copy_constructible<view>::value, It, It&>;
+    iter it = value.begin;
+    auto out = ctx.out();
+    if (it == value.end) return out;
+    out = value_formatter_.format(*it, ctx);
+    ++it;
+    while (it != value.end) {
+      out = detail::copy<Char>(value.sep.begin(), value.sep.end(), out);
+      ctx.advance_to(out);
+      out = value_formatter_.format(*it, ctx);
+      ++it;
+    }
+    return out;
+  }
 };
 
-template <typename Char, typename... T> struct tuple_join_view : detail::view {
-  const std::tuple<T...>& tuple;
+template <typename Char, typename Tuple> struct tuple_join_view : detail::view {
+  const Tuple& tuple;
   basic_string_view<Char> sep;
 
-  tuple_join_view(const std::tuple<T...>& t, basic_string_view<Char> s)
+  tuple_join_view(const Tuple& t, basic_string_view<Char> s)
       : tuple(t), sep{s} {}
 };
 
@@ -589,65 +683,64 @@ template <typename Char, typename... T> struct tuple_join_view : detail::view {
 #  define FMT_TUPLE_JOIN_SPECIFIERS 0
 #endif
 
-template <typename Char, typename... T>
-struct formatter<tuple_join_view<Char, T...>, Char> {
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
-    return do_parse(ctx, std::integral_constant<size_t, sizeof...(T)>());
+template <typename Char, typename Tuple>
+struct formatter<tuple_join_view<Char, Tuple>, Char,
+                 enable_if_t<is_tuple_like<Tuple>::value>> {
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) -> const Char* {
+    return do_parse(ctx, std::tuple_size<Tuple>());
   }
 
   template <typename FormatContext>
-  auto format(const tuple_join_view<Char, T...>& value,
+  auto format(const tuple_join_view<Char, Tuple>& value,
               FormatContext& ctx) const -> typename FormatContext::iterator {
-    return do_format(value, ctx,
-                     std::integral_constant<size_t, sizeof...(T)>());
+    return do_format(value, ctx, std::tuple_size<Tuple>());
   }
 
  private:
-  std::tuple<formatter<typename std::decay<T>::type, Char>...> formatters_;
+  decltype(detail::tuple::get_formatters<Tuple, Char>(
+      detail::tuple_index_sequence<Tuple>())) formatters_;
 
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto do_parse(ParseContext& ctx,
+  FMT_CONSTEXPR auto do_parse(parse_context<Char>& ctx,
                               std::integral_constant<size_t, 0>)
-      -> decltype(ctx.begin()) {
+      -> const Char* {
     return ctx.begin();
   }
 
-  template <typename ParseContext, size_t N>
-  FMT_CONSTEXPR auto do_parse(ParseContext& ctx,
+  template <size_t N>
+  FMT_CONSTEXPR auto do_parse(parse_context<Char>& ctx,
                               std::integral_constant<size_t, N>)
-      -> decltype(ctx.begin()) {
+      -> const Char* {
     auto end = ctx.begin();
 #if FMT_TUPLE_JOIN_SPECIFIERS
-    end = std::get<sizeof...(T) - N>(formatters_).parse(ctx);
+    end = std::get<std::tuple_size<Tuple>::value - N>(formatters_).parse(ctx);
     if (N > 1) {
       auto end1 = do_parse(ctx, std::integral_constant<size_t, N - 1>());
       if (end != end1)
-        FMT_THROW(format_error("incompatible format specs for tuple elements"));
+        report_error("incompatible format specs for tuple elements");
     }
 #endif
     return end;
   }
 
   template <typename FormatContext>
-  auto do_format(const tuple_join_view<Char, T...>&, FormatContext& ctx,
+  auto do_format(const tuple_join_view<Char, Tuple>&, FormatContext& ctx,
                  std::integral_constant<size_t, 0>) const ->
       typename FormatContext::iterator {
     return ctx.out();
   }
 
   template <typename FormatContext, size_t N>
-  auto do_format(const tuple_join_view<Char, T...>& value, FormatContext& ctx,
+  auto do_format(const tuple_join_view<Char, Tuple>& value, FormatContext& ctx,
                  std::integral_constant<size_t, N>) const ->
       typename FormatContext::iterator {
-    auto out = std::get<sizeof...(T) - N>(formatters_)
-                   .format(std::get<sizeof...(T) - N>(value.tuple), ctx);
-    if (N > 1) {
-      out = std::copy(value.sep.begin(), value.sep.end(), out);
-      ctx.advance_to(out);
-      return do_format(value, ctx, std::integral_constant<size_t, N - 1>());
-    }
-    return out;
+    using std::get;
+    auto out =
+        std::get<std::tuple_size<Tuple>::value - N>(formatters_)
+            .format(get<std::tuple_size<Tuple>::value - N>(value.tuple), ctx);
+    if (N <= 1) return out;
+    out = detail::copy<Char>(value.sep, out);
+    ctx.advance_to(out);
+    return do_format(value, ctx, std::integral_constant<size_t, N - 1>());
   }
 };
 
@@ -691,40 +784,57 @@ struct formatter<
 
 FMT_BEGIN_EXPORT
 
-/**
-  \rst
-  Returns an object that formats `tuple` with elements separated by `sep`.
-
-  **Example**::
+/// Returns a view that formats the iterator range `[begin, end)` with elements
+/// separated by `sep`.
+template <typename It, typename Sentinel>
+auto join(It begin, Sentinel end, string_view sep) -> join_view<It, Sentinel> {
+  return {std::move(begin), end, sep};
+}
 
-    std::tuple<int, char> t = {1, 'a'};
-    fmt::print("{}", fmt::join(t, ", "));
-    // Output: "1, a"
-  \endrst
+/**
+ * Returns a view that formats `range` with elements separated by `sep`.
+ *
+ * **Example**:
+ *
+ *     auto v = std::vector<int>{1, 2, 3};
+ *     fmt::print("{}", fmt::join(v, ", "));
+ *     // Output: 1, 2, 3
+ *
+ * `fmt::join` applies passed format specifiers to the range elements:
+ *
+ *     fmt::print("{:02}", fmt::join(v, ", "));
+ *     // Output: 01, 02, 03
  */
-template <typename... T>
-FMT_CONSTEXPR auto join(const std::tuple<T...>& tuple, string_view sep)
-    -> tuple_join_view<char, T...> {
-  return {tuple, sep};
+template <typename Range, FMT_ENABLE_IF(!is_tuple_like<Range>::value)>
+auto join(Range&& r, string_view sep)
+    -> join_view<decltype(detail::range_begin(r)),
+                 decltype(detail::range_end(r))> {
+  return {detail::range_begin(r), detail::range_end(r), sep};
 }
 
-template <typename... T>
-FMT_CONSTEXPR auto join(const std::tuple<T...>& tuple,
-                        basic_string_view<wchar_t> sep)
-    -> tuple_join_view<wchar_t, T...> {
+/**
+ * Returns an object that formats `std::tuple` with elements separated by `sep`.
+ *
+ * **Example**:
+ *
+ *     auto t = std::tuple<int, char>{1, 'a'};
+ *     fmt::print("{}", fmt::join(t, ", "));
+ *     // Output: 1, a
+ */
+template <typename Tuple, FMT_ENABLE_IF(is_tuple_like<Tuple>::value)>
+FMT_CONSTEXPR auto join(const Tuple& tuple, string_view sep)
+    -> tuple_join_view<char, Tuple> {
   return {tuple, sep};
 }
 
 /**
-  \rst
-  Returns an object that formats `initializer_list` with elements separated by
-  `sep`.
-
-  **Example**::
-
-    fmt::print("{}", fmt::join({1, 2, 3}, ", "));
-    // Output: "1, 2, 3"
-  \endrst
+ * Returns an object that formats `std::initializer_list` with elements
+ * separated by `sep`.
+ *
+ * **Example**:
+ *
+ *     fmt::print("{}", fmt::join({1, 2, 3}, ", "));
+ *     // Output: "1, 2, 3"
  */
 template <typename T>
 auto join(std::initializer_list<T> list, string_view sep)
diff --git a/3rdparty/fmt/include/fmt/std.h b/3rdparty/fmt/include/fmt/std.h
index 7cff1159201d2..54eb2c2a73d43 100644
--- a/3rdparty/fmt/include/fmt/std.h
+++ b/3rdparty/fmt/include/fmt/std.h
@@ -8,38 +8,48 @@
 #ifndef FMT_STD_H_
 #define FMT_STD_H_
 
-#include <atomic>
-#include <bitset>
-#include <cstdlib>
-#include <exception>
-#include <memory>
-#include <thread>
-#include <type_traits>
-#include <typeinfo>
-#include <utility>
-#include <vector>
-
 #include "format.h"
 #include "ostream.h"
 
-#if FMT_HAS_INCLUDE(<version>)
-#  include <version>
-#endif
-// Checking FMT_CPLUSPLUS for warning suppression in MSVC.
-#if FMT_CPLUSPLUS >= 201703L
-#  if FMT_HAS_INCLUDE(<filesystem>)
-#    include <filesystem>
+#ifndef FMT_MODULE
+#  include <atomic>
+#  include <bitset>
+#  include <complex>
+#  include <cstdlib>
+#  include <exception>
+#  include <functional>
+#  include <memory>
+#  include <thread>
+#  include <type_traits>
+#  include <typeinfo>
+#  include <utility>
+#  include <vector>
+
+// Check FMT_CPLUSPLUS to suppress a bogus warning in MSVC.
+#  if FMT_CPLUSPLUS >= 201703L
+#    if FMT_HAS_INCLUDE(<filesystem>) && \
+        (!defined(FMT_CPP_LIB_FILESYSTEM) || FMT_CPP_LIB_FILESYSTEM != 0)
+#      include <filesystem>
+#    endif
+#    if FMT_HAS_INCLUDE(<variant>)
+#      include <variant>
+#    endif
+#    if FMT_HAS_INCLUDE(<optional>)
+#      include <optional>
+#    endif
 #  endif
-#  if FMT_HAS_INCLUDE(<variant>)
-#    include <variant>
+// Use > instead of >= in the version check because <source_location> may be
+// available after C++17 but before C++20 is marked as implemented.
+#  if FMT_CPLUSPLUS > 201703L && FMT_HAS_INCLUDE(<source_location>)
+#    include <source_location>
 #  endif
-#  if FMT_HAS_INCLUDE(<optional>)
-#    include <optional>
+#  if FMT_CPLUSPLUS > 202002L && FMT_HAS_INCLUDE(<expected>)
+#    include <expected>
 #  endif
-#endif
+#endif  // FMT_MODULE
 
-#if FMT_CPLUSPLUS > 201703L && FMT_HAS_INCLUDE(<source_location>)
-#  include <source_location>
+#if FMT_HAS_INCLUDE(<version>)
+#  include <version>
 #endif
 
 // GCC 4 does not support FMT_HAS_INCLUDE.
@@ -52,17 +62,6 @@
 #  endif
 #endif
 
-// Check if typeid is available.
-#ifndef FMT_USE_TYPEID
-// __RTTI is for EDG compilers. In MSVC typeid is available without RTTI.
-#  if defined(__GXX_RTTI) || FMT_HAS_FEATURE(cxx_rtti) || FMT_MSC_VERSION || \
-      defined(__INTEL_RTTI__) || defined(__RTTI)
-#    define FMT_USE_TYPEID 1
-#  else
-#    define FMT_USE_TYPEID 0
-#  endif
-#endif
-
 // For older Xcode versions, __cpp_lib_xxx flags are inaccurately defined.
 #ifndef FMT_CPP_LIB_FILESYSTEM
 #  ifdef __cpp_lib_filesystem
@@ -117,7 +116,7 @@ void write_escaped_path(basic_memory_buffer<Char>& quoted,
 FMT_EXPORT
 template <typename Char> struct formatter<std::filesystem::path, Char> {
  private:
-  format_specs<Char> specs_;
+  format_specs specs_;
   detail::arg_ref<Char> width_ref_;
   bool debug_ = false;
   char path_type_ = 0;
@@ -125,33 +124,33 @@ template <typename Char> struct formatter<std::filesystem::path, Char> {
  public:
   FMT_CONSTEXPR void set_debug_format(bool set = true) { debug_ = set; }
 
-  template <typename ParseContext> FMT_CONSTEXPR auto parse(ParseContext& ctx) {
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) {
     auto it = ctx.begin(), end = ctx.end();
     if (it == end) return it;
 
     it = detail::parse_align(it, end, specs_);
     if (it == end) return it;
 
-    it = detail::parse_dynamic_spec(it, end, specs_.width, width_ref_, ctx);
+    Char c = *it;
+    if ((c >= '0' && c <= '9') || c == '{')
+      it = detail::parse_width(it, end, specs_, width_ref_, ctx);
     if (it != end && *it == '?') {
       debug_ = true;
       ++it;
     }
-    if (it != end && (*it == 'g')) path_type_ = *it++;
+    if (it != end && (*it == 'g')) path_type_ = detail::to_ascii(*it++);
     return it;
   }
 
   template <typename FormatContext>
   auto format(const std::filesystem::path& p, FormatContext& ctx) const {
     auto specs = specs_;
-#  ifdef _WIN32
-    auto path_string = !path_type_ ? p.native() : p.generic_wstring();
-#  else
-    auto path_string = !path_type_ ? p.native() : p.generic_string();
-#  endif
+    auto path_string =
+        !path_type_ ? p.native()
+                    : p.generic_string<std::filesystem::path::value_type>();
 
-    detail::handle_dynamic_spec<detail::width_checker>(specs.width, width_ref_,
-                                                       ctx);
+    detail::handle_dynamic_spec(specs.dynamic_width(), specs.width, width_ref_,
+                                ctx);
     if (!debug_) {
       auto s = detail::get_path_string<Char>(p, path_string);
       return detail::write(ctx.out(), basic_string_view<Char>(s), specs);
@@ -163,13 +162,30 @@ template <typename Char> struct formatter<std::filesystem::path, Char> {
                          specs);
   }
 };
+
+class path : public std::filesystem::path {
+ public:
+  auto display_string() const -> std::string {
+    const std::filesystem::path& base = *this;
+    return fmt::format(FMT_STRING("{}"), base);
+  }
+  auto system_string() const -> std::string { return string(); }
+
+  auto generic_display_string() const -> std::string {
+    const std::filesystem::path& base = *this;
+    return fmt::format(FMT_STRING("{:g}"), base);
+  }
+  auto generic_system_string() const -> std::string { return generic_string(); }
+};
+
 FMT_END_NAMESPACE
 #endif  // FMT_CPP_LIB_FILESYSTEM
 
 FMT_BEGIN_NAMESPACE
 FMT_EXPORT
 template <std::size_t N, typename Char>
-struct formatter<std::bitset<N>, Char> : nested_formatter<string_view> {
+struct formatter<std::bitset<N>, Char>
+    : nested_formatter<basic_string_view<Char>, Char> {
  private:
   // Functor because C++11 doesn't support generic lambdas.
   struct writer {
@@ -189,7 +205,7 @@ struct formatter<std::bitset<N>, Char> : nested_formatter<string_view> {
   template <typename FormatContext>
   auto format(const std::bitset<N>& bs, FormatContext& ctx) const
       -> decltype(ctx.out()) {
-    return write_padded(ctx, writer{bs});
+    return this->write_padded(ctx, writer{bs});
   }
 };
 
@@ -222,7 +238,7 @@ struct formatter<std::optional<T>, Char,
   FMT_CONSTEXPR static void maybe_set_debug_format(U&, ...) {}
 
  public:
-  template <typename ParseContext> FMT_CONSTEXPR auto parse(ParseContext& ctx) {
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) {
     maybe_set_debug_format(underlying_, true);
     return underlying_.parse(ctx);
   }
@@ -242,14 +258,63 @@ struct formatter<std::optional<T>, Char,
 FMT_END_NAMESPACE
 #endif  // __cpp_lib_optional
 
-#ifdef __cpp_lib_source_location
+#if defined(__cpp_lib_expected) || FMT_CPP_LIB_VARIANT
+
+FMT_BEGIN_NAMESPACE
+namespace detail {
+
+template <typename Char, typename OutputIt, typename T>
+auto write_escaped_alternative(OutputIt out, const T& v) -> OutputIt {
+  if constexpr (has_to_string_view<T>::value)
+    return write_escaped_string<Char>(out, detail::to_string_view(v));
+  if constexpr (std::is_same_v<T, Char>) return write_escaped_char(out, v);
+  return write<Char>(out, v);
+}
+
+}  // namespace detail
+
+FMT_END_NAMESPACE
+#endif
+
+#ifdef __cpp_lib_expected
 FMT_BEGIN_NAMESPACE
+
 FMT_EXPORT
-template <> struct formatter<std::source_location> {
-  template <typename ParseContext> FMT_CONSTEXPR auto parse(ParseContext& ctx) {
+template <typename T, typename E, typename Char>
+struct formatter<std::expected<T, E>, Char,
+                 std::enable_if_t<(std::is_void<T>::value ||
+                                   is_formattable<T, Char>::value) &&
+                                  is_formattable<E, Char>::value>> {
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) -> const Char* {
     return ctx.begin();
   }
 
+  template <typename FormatContext>
+  auto format(const std::expected<T, E>& value, FormatContext& ctx) const
+      -> decltype(ctx.out()) {
+    auto out = ctx.out();
+
+    if (value.has_value()) {
+      out = detail::write<Char>(out, "expected(");
+      if constexpr (!std::is_void<T>::value)
+        out = detail::write_escaped_alternative<Char>(out, *value);
+    } else {
+      out = detail::write<Char>(out, "unexpected(");
+      out = detail::write_escaped_alternative<Char>(out, value.error());
+    }
+    *out++ = ')';
+    return out;
+  }
+};
+FMT_END_NAMESPACE
+#endif  // __cpp_lib_expected
+
+#ifdef __cpp_lib_source_location
+FMT_BEGIN_NAMESPACE
+FMT_EXPORT
+template <> struct formatter<std::source_location> {
+  FMT_CONSTEXPR auto parse(parse_context<>& ctx) { return ctx.begin(); }
+
   template <typename FormatContext>
   auto format(const std::source_location& loc, FormatContext& ctx) const
       -> decltype(ctx.out()) {
@@ -291,16 +356,6 @@ template <typename T, typename C> class is_variant_formattable_ {
       decltype(check(variant_index_sequence<T>{}))::value;
 };
 
-template <typename Char, typename OutputIt, typename T>
-auto write_variant_alternative(OutputIt out, const T& v) -> OutputIt {
-  if constexpr (is_string<T>::value)
-    return write_escaped_string<Char>(out, detail::to_string_view(v));
-  else if constexpr (std::is_same_v<T, Char>)
-    return write_escaped_char(out, v);
-  else
-    return write<Char>(out, v);
-}
-
 }  // namespace detail
 
 template <typename T> struct is_variant_like {
@@ -314,8 +369,7 @@ template <typename T, typename C> struct is_variant_formattable {
 
 FMT_EXPORT
 template <typename Char> struct formatter<std::monostate, Char> {
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) -> const Char* {
     return ctx.begin();
   }
 
@@ -332,8 +386,7 @@ struct formatter<
     Variant, Char,
     std::enable_if_t<std::conjunction_v<
         is_variant_like<Variant>, is_variant_formattable<Variant, Char>>>> {
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) -> const Char* {
     return ctx.begin();
   }
 
@@ -346,7 +399,7 @@ struct formatter<
     FMT_TRY {
       std::visit(
           [&](const auto& v) {
-            out = detail::write_variant_alternative<Char>(out, v);
+            out = detail::write_escaped_alternative<Char>(out, v);
           },
           value);
     }
@@ -362,22 +415,127 @@ FMT_END_NAMESPACE
 
 FMT_BEGIN_NAMESPACE
 FMT_EXPORT
-template <typename Char> struct formatter<std::error_code, Char> {
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
-    return ctx.begin();
+template <> struct formatter<std::error_code> {
+ private:
+  format_specs specs_;
+  detail::arg_ref<char> width_ref_;
+
+ public:
+  FMT_CONSTEXPR auto parse(parse_context<>& ctx) -> const char* {
+    auto it = ctx.begin(), end = ctx.end();
+    if (it == end) return it;
+
+    it = detail::parse_align(it, end, specs_);
+    if (it == end) return it;
+
+    char c = *it;
+    if ((c >= '0' && c <= '9') || c == '{')
+      it = detail::parse_width(it, end, specs_, width_ref_, ctx);
+    return it;
   }
 
   template <typename FormatContext>
-  FMT_CONSTEXPR auto format(const std::error_code& ec, FormatContext& ctx) const
+  FMT_CONSTEXPR20 auto format(const std::error_code& ec,
+                              FormatContext& ctx) const -> decltype(ctx.out()) {
+    auto specs = specs_;
+    detail::handle_dynamic_spec(specs.dynamic_width(), specs.width, width_ref_,
+                                ctx);
+    memory_buffer buf;
+    buf.append(string_view(ec.category().name()));
+    buf.push_back(':');
+    detail::write<char>(appender(buf), ec.value());
+    return detail::write<char>(ctx.out(), string_view(buf.data(), buf.size()),
+                               specs);
+  }
+};
+
+#if FMT_USE_RTTI
+namespace detail {
+
+template <typename Char, typename OutputIt>
+auto write_demangled_name(OutputIt out, const std::type_info& ti) -> OutputIt {
+#  ifdef FMT_HAS_ABI_CXA_DEMANGLE
+  int status = 0;
+  std::size_t size = 0;
+  std::unique_ptr<char, void (*)(void*)> demangled_name_ptr(
+      abi::__cxa_demangle(ti.name(), nullptr, &size, &status), &std::free);
+
+  string_view demangled_name_view;
+  if (demangled_name_ptr) {
+    demangled_name_view = demangled_name_ptr.get();
+
+    // Normalization of stdlib inline namespace names.
+    // libc++ inline namespaces.
+    //  std::__1::*       -> std::*
+    //  std::__1::__fs::* -> std::*
+    // libstdc++ inline namespaces.
+    //  std::__cxx11::*             -> std::*
+    //  std::filesystem::__cxx11::* -> std::filesystem::*
+    if (demangled_name_view.starts_with("std::")) {
+      char* begin = demangled_name_ptr.get();
+      char* to = begin + 5;  // std::
+      for (char *from = to, *end = begin + demangled_name_view.size();
+           from < end;) {
+        // This is safe, because demangled_name is NUL-terminated.
+        if (from[0] == '_' && from[1] == '_') {
+          char* next = from + 1;
+          while (next < end && *next != ':') next++;
+          if (next[0] == ':' && next[1] == ':') {
+            from = next + 2;
+            continue;
+          }
+        }
+        *to++ = *from++;
+      }
+      demangled_name_view = {begin, detail::to_unsigned(to - begin)};
+    }
+  } else {
+    demangled_name_view = string_view(ti.name());
+  }
+  return detail::write_bytes<Char>(out, demangled_name_view);
+#  elif FMT_MSC_VERSION
+  const string_view demangled_name(ti.name());
+  for (std::size_t i = 0; i < demangled_name.size(); ++i) {
+    auto sub = demangled_name;
+    sub.remove_prefix(i);
+    if (sub.starts_with("enum ")) {
+      i += 4;
+      continue;
+    }
+    if (sub.starts_with("class ") || sub.starts_with("union ")) {
+      i += 5;
+      continue;
+    }
+    if (sub.starts_with("struct ")) {
+      i += 6;
+      continue;
+    }
+    if (*sub.begin() != ' ') *out++ = *sub.begin();
+  }
+  return out;
+#  else
+  return detail::write_bytes<Char>(out, string_view(ti.name()));
+#  endif
+}
+
+}  // namespace detail
+
+FMT_EXPORT
+template <typename Char>
+struct formatter<std::type_info, Char  // DEPRECATED! Mixing code unit types.
+                 > {
+ public:
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) -> const Char* {
+    return ctx.begin();
+  }
+
+  template <typename Context>
+  auto format(const std::type_info& ti, Context& ctx) const
       -> decltype(ctx.out()) {
-    auto out = ctx.out();
-    out = detail::write_bytes(out, ec.category().name(), format_specs<Char>());
-    out = detail::write<Char>(out, Char(':'));
-    out = detail::write<Char>(out, ec.value());
-    return out;
+    return detail::write_demangled_name<Char>(ctx.out(), ti);
   }
 };
+#endif
 
 FMT_EXPORT
 template <typename T, typename Char>
@@ -388,81 +546,29 @@ struct formatter<
   bool with_typename_ = false;
 
  public:
-  FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)
-      -> decltype(ctx.begin()) {
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) -> const Char* {
     auto it = ctx.begin();
     auto end = ctx.end();
     if (it == end || *it == '}') return it;
     if (*it == 't') {
       ++it;
-      with_typename_ = FMT_USE_TYPEID != 0;
+      with_typename_ = FMT_USE_RTTI != 0;
     }
     return it;
   }
 
-  template <typename OutputIt>
-  auto format(const std::exception& ex,
-              basic_format_context<OutputIt, Char>& ctx) const -> OutputIt {
-    format_specs<Char> spec;
+  template <typename Context>
+  auto format(const std::exception& ex, Context& ctx) const
+      -> decltype(ctx.out()) {
     auto out = ctx.out();
-    if (!with_typename_)
-      return detail::write_bytes(out, string_view(ex.what()), spec);
-
-#if FMT_USE_TYPEID
-    const std::type_info& ti = typeid(ex);
-#  ifdef FMT_HAS_ABI_CXA_DEMANGLE
-    int status = 0;
-    std::size_t size = 0;
-    std::unique_ptr<char, void (*)(void*)> demangled_name_ptr(
-        abi::__cxa_demangle(ti.name(), nullptr, &size, &status), &std::free);
-
-    string_view demangled_name_view;
-    if (demangled_name_ptr) {
-      demangled_name_view = demangled_name_ptr.get();
-
-      // Normalization of stdlib inline namespace names.
-      // libc++ inline namespaces.
-      //  std::__1::*       -> std::*
-      //  std::__1::__fs::* -> std::*
-      // libstdc++ inline namespaces.
-      //  std::__cxx11::*             -> std::*
-      //  std::filesystem::__cxx11::* -> std::filesystem::*
-      if (demangled_name_view.starts_with("std::")) {
-        char* begin = demangled_name_ptr.get();
-        char* to = begin + 5;  // std::
-        for (char *from = to, *end = begin + demangled_name_view.size();
-             from < end;) {
-          // This is safe, because demangled_name is NUL-terminated.
-          if (from[0] == '_' && from[1] == '_') {
-            char* next = from + 1;
-            while (next < end && *next != ':') next++;
-            if (next[0] == ':' && next[1] == ':') {
-              from = next + 2;
-              continue;
-            }
-          }
-          *to++ = *from++;
-        }
-        demangled_name_view = {begin, detail::to_unsigned(to - begin)};
-      }
-    } else {
-      demangled_name_view = string_view(ti.name());
+#if FMT_USE_RTTI
+    if (with_typename_) {
+      out = detail::write_demangled_name<Char>(out, typeid(ex));
+      *out++ = ':';
+      *out++ = ' ';
     }
-    out = detail::write_bytes(out, demangled_name_view, spec);
-#  elif FMT_MSC_VERSION
-    string_view demangled_name_view(ti.name());
-    if (demangled_name_view.starts_with("class "))
-      demangled_name_view.remove_prefix(6);
-    else if (demangled_name_view.starts_with("struct "))
-      demangled_name_view.remove_prefix(7);
-    out = detail::write_bytes(out, demangled_name_view, spec);
-#  else
-    out = detail::write_bytes(out, string_view(ti.name()), spec);
-#  endif
-    *out++ = ':';
-    *out++ = ' ';
-    return detail::write_bytes(out, string_view(ex.what()), spec);
 #endif
+    return detail::write_bytes<Char>(out, string_view(ex.what()));
   }
 };
 
@@ -509,6 +615,14 @@ struct formatter<BitRef, Char,
   }
 };
 
+template <typename T, typename Deleter>
+auto ptr(const std::unique_ptr<T, Deleter>& p) -> const void* {
+  return p.get();
+}
+template <typename T> auto ptr(const std::shared_ptr<T>& p) -> const void* {
+  return p.get();
+}
+
 FMT_EXPORT
 template <typename T, typename Char>
 struct formatter<std::atomic<T>, Char,
@@ -533,5 +647,80 @@ struct formatter<std::atomic_flag, Char> : formatter<bool, Char> {
 };
 #endif  // __cpp_lib_atomic_flag_test
 
+FMT_EXPORT
+template <typename T, typename Char> struct formatter<std::complex<T>, Char> {
+ private:
+  detail::dynamic_format_specs<Char> specs_;
+
+  template <typename FormatContext, typename OutputIt>
+  FMT_CONSTEXPR auto do_format(const std::complex<T>& c,
+                               detail::dynamic_format_specs<Char>& specs,
+                               FormatContext& ctx, OutputIt out) const
+      -> OutputIt {
+    if (c.real() != 0) {
+      *out++ = Char('(');
+      out = detail::write<Char>(out, c.real(), specs, ctx.locale());
+      specs.set_sign(sign::plus);
+      out = detail::write<Char>(out, c.imag(), specs, ctx.locale());
+      if (!detail::isfinite(c.imag())) *out++ = Char(' ');
+      *out++ = Char('i');
+      *out++ = Char(')');
+      return out;
+    }
+    out = detail::write<Char>(out, c.imag(), specs, ctx.locale());
+    if (!detail::isfinite(c.imag())) *out++ = Char(' ');
+    *out++ = Char('i');
+    return out;
+  }
+
+ public:
+  FMT_CONSTEXPR auto parse(parse_context<Char>& ctx) -> const Char* {
+    if (ctx.begin() == ctx.end() || *ctx.begin() == '}') return ctx.begin();
+    return parse_format_specs(ctx.begin(), ctx.end(), specs_, ctx,
+                              detail::type_constant<T, Char>::value);
+  }
+
+  template <typename FormatContext>
+  auto format(const std::complex<T>& c, FormatContext& ctx) const
+      -> decltype(ctx.out()) {
+    auto specs = specs_;
+    if (specs.dynamic()) {
+      detail::handle_dynamic_spec(specs.dynamic_width(), specs.width,
+                                  specs.width_ref, ctx);
+      detail::handle_dynamic_spec(specs.dynamic_precision(), specs.precision,
+                                  specs.precision_ref, ctx);
+    }
+
+    if (specs.width == 0) return do_format(c, specs, ctx, ctx.out());
+    auto buf = basic_memory_buffer<Char>();
+
+    auto outer_specs = format_specs();
+    outer_specs.width = specs.width;
+    outer_specs.copy_fill_from(specs);
+    outer_specs.set_align(specs.align());
+
+    specs.width = 0;
+    specs.set_fill({});
+    specs.set_align(align::none);
+
+    do_format(c, specs, ctx, basic_appender<Char>(buf));
+    return detail::write<Char>(ctx.out(),
+                               basic_string_view<Char>(buf.data(), buf.size()),
+                               outer_specs);
+  }
+};
+
+FMT_EXPORT
+template <typename T, typename Char>
+struct formatter<std::reference_wrapper<T>, Char,
+                 enable_if_t<is_formattable<remove_cvref_t<T>, Char>::value>>
+    : formatter<remove_cvref_t<T>, Char> {
+  template <typename FormatContext>
+  auto format(std::reference_wrapper<T> ref, FormatContext& ctx) const
+      -> decltype(ctx.out()) {
+    return formatter<remove_cvref_t<T>, Char>::format(ref.get(), ctx);
+  }
+};
+
 FMT_END_NAMESPACE
 #endif  // FMT_STD_H_
diff --git a/3rdparty/fmt/include/fmt/xchar.h b/3rdparty/fmt/include/fmt/xchar.h
index f609c5c41a229..9f7f889d64d5a 100644
--- a/3rdparty/fmt/include/fmt/xchar.h
+++ b/3rdparty/fmt/include/fmt/xchar.h
@@ -8,12 +8,16 @@
 #ifndef FMT_XCHAR_H_
 #define FMT_XCHAR_H_
 
-#include <cwchar>
-
+#include "color.h"
 #include "format.h"
-
-#ifndef FMT_STATIC_THOUSANDS_SEPARATOR
-#  include <locale>
+#include "ostream.h"
+#include "ranges.h"
+
+#ifndef FMT_MODULE
+#  include <cwchar>
+#  if FMT_USE_LOCALE
+#    include <locale>
+#  endif
 #endif
 
 FMT_BEGIN_NAMESPACE
@@ -22,10 +26,26 @@ namespace detail {
 template <typename T>
 using is_exotic_char = bool_constant<!std::is_same<T, char>::value>;
 
-inline auto write_loc(std::back_insert_iterator<detail::buffer<wchar_t>> out,
-                      loc_value value, const format_specs<wchar_t>& specs,
-                      locale_ref loc) -> bool {
-#ifndef FMT_STATIC_THOUSANDS_SEPARATOR
+template <typename S, typename = void> struct format_string_char {};
+
+template <typename S>
+struct format_string_char<
+    S, void_t<decltype(sizeof(detail::to_string_view(std::declval<S>())))>> {
+  using type = char_t<S>;
+};
+
+template <typename S>
+struct format_string_char<
+    S, enable_if_t<std::is_base_of<detail::compile_string, S>::value>> {
+  using type = typename S::char_type;
+};
+
+template <typename S>
+using format_string_char_t = typename format_string_char<S>::type;
+
+inline auto write_loc(basic_appender<wchar_t> out, loc_value value,
+                      const format_specs& specs, locale_ref loc) -> bool {
+#if FMT_USE_LOCALE
   auto& numpunct =
       std::use_facet<std::numpunct<wchar_t>>(loc.get<std::locale>());
   auto separator = std::wstring();
@@ -40,42 +60,79 @@ inline auto write_loc(std::back_insert_iterator<detail::buffer<wchar_t>> out,
 FMT_BEGIN_EXPORT
 
 using wstring_view = basic_string_view<wchar_t>;
-using wformat_parse_context = basic_format_parse_context<wchar_t>;
-using wformat_context = buffer_context<wchar_t>;
+using wformat_parse_context = parse_context<wchar_t>;
+using wformat_context = buffered_context<wchar_t>;
 using wformat_args = basic_format_args<wformat_context>;
 using wmemory_buffer = basic_memory_buffer<wchar_t>;
 
-#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
-// Workaround broken conversion on older gcc.
-template <typename... Args> using wformat_string = wstring_view;
-inline auto runtime(wstring_view s) -> wstring_view { return s; }
-#else
-template <typename... Args>
-using wformat_string = basic_format_string<wchar_t, type_identity_t<Args>...>;
+template <typename Char, typename... T> struct basic_fstring {
+ private:
+  basic_string_view<Char> str_;
+
+  static constexpr int num_static_named_args =
+      detail::count_static_named_args<T...>();
+
+  using checker = detail::format_string_checker<
+      Char, static_cast<int>(sizeof...(T)), num_static_named_args,
+      num_static_named_args != detail::count_named_args<T...>()>;
+
+  using arg_pack = detail::arg_pack<T...>;
+
+ public:
+  using t = basic_fstring;
+
+  template <typename S,
+            FMT_ENABLE_IF(
+                std::is_convertible<const S&, basic_string_view<Char>>::value)>
+  FMT_CONSTEVAL FMT_ALWAYS_INLINE basic_fstring(const S& s) : str_(s) {
+    if (FMT_USE_CONSTEVAL)
+      detail::parse_format_string<Char>(s, checker(s, arg_pack()));
+  }
+  template <typename S,
+            FMT_ENABLE_IF(std::is_base_of<detail::compile_string, S>::value&&
+                              std::is_same<typename S::char_type, Char>::value)>
+  FMT_ALWAYS_INLINE basic_fstring(const S&) : str_(S()) {
+    FMT_CONSTEXPR auto sv = basic_string_view<Char>(S());
+    FMT_CONSTEXPR int ignore =
+        (parse_format_string(sv, checker(sv, arg_pack())), 0);
+    detail::ignore_unused(ignore);
+  }
+  basic_fstring(runtime_format_string<Char> fmt) : str_(fmt.str) {}
+
+  operator basic_string_view<Char>() const { return str_; }
+  auto get() const -> basic_string_view<Char> { return str_; }
+};
+
+template <typename Char, typename... T>
+using basic_format_string = basic_fstring<Char, T...>;
+
+template <typename... T>
+using wformat_string = typename basic_format_string<wchar_t, T...>::t;
 inline auto runtime(wstring_view s) -> runtime_format_string<wchar_t> {
   return {{s}};
 }
-#endif
 
 template <> struct is_char<wchar_t> : std::true_type {};
-template <> struct is_char<detail::char8_type> : std::true_type {};
 template <> struct is_char<char16_t> : std::true_type {};
 template <> struct is_char<char32_t> : std::true_type {};
 
+#ifdef __cpp_char8_t
+template <> struct is_char<char8_t> : bool_constant<detail::is_utf8_enabled> {};
+#endif
+
 template <typename... T>
-constexpr auto make_wformat_args(const T&... args)
-    -> format_arg_store<wformat_context, T...> {
-  return {args...};
+constexpr auto make_wformat_args(T&... args)
+    -> decltype(fmt::make_format_args<wformat_context>(args...)) {
+  return fmt::make_format_args<wformat_context>(args...);
 }
 
+#if !FMT_USE_NONTYPE_TEMPLATE_ARGS
 inline namespace literals {
-#if FMT_USE_USER_DEFINED_LITERALS && !FMT_USE_NONTYPE_TEMPLATE_ARGS
-constexpr auto operator""_a(const wchar_t* s, size_t)
-    -> detail::udl_arg<wchar_t> {
+inline auto operator""_a(const wchar_t* s, size_t) -> detail::udl_arg<wchar_t> {
   return {s};
 }
-#endif
 }  // namespace literals
+#endif
 
 template <typename It, typename Sentinel>
 auto join(It begin, Sentinel end, wstring_view sep)
@@ -83,9 +140,9 @@ auto join(It begin, Sentinel end, wstring_view sep)
   return {begin, end, sep};
 }
 
-template <typename Range>
+template <typename Range, FMT_ENABLE_IF(!is_tuple_like<Range>::value)>
 auto join(Range&& range, wstring_view sep)
-    -> join_view<detail::iterator_t<Range>, detail::sentinel_t<Range>,
+    -> join_view<decltype(std::begin(range)), decltype(std::end(range)),
                  wchar_t> {
   return join(std::begin(range), std::end(range), sep);
 }
@@ -96,13 +153,19 @@ auto join(std::initializer_list<T> list, wstring_view sep)
   return join(std::begin(list), std::end(list), sep);
 }
 
+template <typename Tuple, FMT_ENABLE_IF(is_tuple_like<Tuple>::value)>
+auto join(const Tuple& tuple, basic_string_view<wchar_t> sep)
+    -> tuple_join_view<wchar_t, Tuple> {
+  return {tuple, sep};
+}
+
 template <typename Char, FMT_ENABLE_IF(!std::is_same<Char, char>::value)>
-auto vformat(basic_string_view<Char> format_str,
-             basic_format_args<buffer_context<type_identity_t<Char>>> args)
+auto vformat(basic_string_view<Char> fmt,
+             typename detail::vformat_args<Char>::type args)
     -> std::basic_string<Char> {
   auto buf = basic_memory_buffer<Char>();
-  detail::vformat_to(buf, format_str, args);
-  return to_string(buf);
+  detail::vformat_to(buf, fmt, args);
+  return {buf.data(), buf.size()};
 }
 
 template <typename... T>
@@ -110,110 +173,122 @@ auto format(wformat_string<T...> fmt, T&&... args) -> std::wstring {
   return vformat(fmt::wstring_view(fmt), fmt::make_wformat_args(args...));
 }
 
+template <typename OutputIt, typename... T>
+auto format_to(OutputIt out, wformat_string<T...> fmt, T&&... args)
+    -> OutputIt {
+  return vformat_to(out, fmt::wstring_view(fmt),
+                    fmt::make_wformat_args(args...));
+}
+
 // Pass char_t as a default template parameter instead of using
 // std::basic_string<char_t<S>> to reduce the symbol size.
-template <typename S, typename... T, typename Char = char_t<S>,
+template <typename S, typename... T,
+          typename Char = detail::format_string_char_t<S>,
           FMT_ENABLE_IF(!std::is_same<Char, char>::value &&
                         !std::is_same<Char, wchar_t>::value)>
-auto format(const S& format_str, T&&... args) -> std::basic_string<Char> {
-  return vformat(detail::to_string_view(format_str),
-                 fmt::make_format_args<buffer_context<Char>>(args...));
+auto format(const S& fmt, T&&... args) -> std::basic_string<Char> {
+  return vformat(detail::to_string_view(fmt),
+                 fmt::make_format_args<buffered_context<Char>>(args...));
 }
 
-template <typename Locale, typename S, typename Char = char_t<S>,
+template <typename Locale, typename S,
+          typename Char = detail::format_string_char_t<S>,
           FMT_ENABLE_IF(detail::is_locale<Locale>::value&&
                             detail::is_exotic_char<Char>::value)>
-inline auto vformat(
-    const Locale& loc, const S& format_str,
-    basic_format_args<buffer_context<type_identity_t<Char>>> args)
+inline auto vformat(const Locale& loc, const S& fmt,
+                    typename detail::vformat_args<Char>::type args)
     -> std::basic_string<Char> {
-  return detail::vformat(loc, detail::to_string_view(format_str), args);
+  auto buf = basic_memory_buffer<Char>();
+  detail::vformat_to(buf, detail::to_string_view(fmt), args,
+                     detail::locale_ref(loc));
+  return {buf.data(), buf.size()};
 }
 
-template <typename Locale, typename S, typename... T, typename Char = char_t<S>,
+template <typename Locale, typename S, typename... T,
+          typename Char = detail::format_string_char_t<S>,
           FMT_ENABLE_IF(detail::is_locale<Locale>::value&&
                             detail::is_exotic_char<Char>::value)>
-inline auto format(const Locale& loc, const S& format_str, T&&... args)
+inline auto format(const Locale& loc, const S& fmt, T&&... args)
     -> std::basic_string<Char> {
-  return detail::vformat(loc, detail::to_string_view(format_str),
-                         fmt::make_format_args<buffer_context<Char>>(args...));
+  return vformat(loc, detail::to_string_view(fmt),
+                 fmt::make_format_args<buffered_context<Char>>(args...));
 }
 
-template <typename OutputIt, typename S, typename Char = char_t<S>,
+template <typename OutputIt, typename S,
+          typename Char = detail::format_string_char_t<S>,
           FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value&&
                             detail::is_exotic_char<Char>::value)>
-auto vformat_to(OutputIt out, const S& format_str,
-                basic_format_args<buffer_context<type_identity_t<Char>>> args)
-    -> OutputIt {
+auto vformat_to(OutputIt out, const S& fmt,
+                typename detail::vformat_args<Char>::type args) -> OutputIt {
   auto&& buf = detail::get_buffer<Char>(out);
-  detail::vformat_to(buf, detail::to_string_view(format_str), args);
+  detail::vformat_to(buf, detail::to_string_view(fmt), args);
   return detail::get_iterator(buf, out);
 }
 
 template <typename OutputIt, typename S, typename... T,
-          typename Char = char_t<S>,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value&&
-                            detail::is_exotic_char<Char>::value)>
+          typename Char = detail::format_string_char_t<S>,
+          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value &&
+                        !std::is_same<Char, char>::value &&
+                        !std::is_same<Char, wchar_t>::value)>
 inline auto format_to(OutputIt out, const S& fmt, T&&... args) -> OutputIt {
   return vformat_to(out, detail::to_string_view(fmt),
-                    fmt::make_format_args<buffer_context<Char>>(args...));
+                    fmt::make_format_args<buffered_context<Char>>(args...));
 }
 
 template <typename Locale, typename S, typename OutputIt, typename... Args,
-          typename Char = char_t<S>,
+          typename Char = detail::format_string_char_t<S>,
           FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value&&
                             detail::is_locale<Locale>::value&&
                                 detail::is_exotic_char<Char>::value)>
-inline auto vformat_to(
-    OutputIt out, const Locale& loc, const S& format_str,
-    basic_format_args<buffer_context<type_identity_t<Char>>> args) -> OutputIt {
+inline auto vformat_to(OutputIt out, const Locale& loc, const S& fmt,
+                       typename detail::vformat_args<Char>::type args)
+    -> OutputIt {
   auto&& buf = detail::get_buffer<Char>(out);
-  vformat_to(buf, detail::to_string_view(format_str), args,
-             detail::locale_ref(loc));
+  vformat_to(buf, detail::to_string_view(fmt), args, detail::locale_ref(loc));
   return detail::get_iterator(buf, out);
 }
 
-template <typename OutputIt, typename Locale, typename S, typename... T,
-          typename Char = char_t<S>,
+template <typename Locale, typename OutputIt, typename S, typename... T,
+          typename Char = detail::format_string_char_t<S>,
           bool enable = detail::is_output_iterator<OutputIt, Char>::value &&
                         detail::is_locale<Locale>::value &&
                         detail::is_exotic_char<Char>::value>
-inline auto format_to(OutputIt out, const Locale& loc, const S& format_str,
+inline auto format_to(OutputIt out, const Locale& loc, const S& fmt,
                       T&&... args) ->
     typename std::enable_if<enable, OutputIt>::type {
-  return vformat_to(out, loc, detail::to_string_view(format_str),
-                    fmt::make_format_args<buffer_context<Char>>(args...));
+  return vformat_to(out, loc, detail::to_string_view(fmt),
+                    fmt::make_format_args<buffered_context<Char>>(args...));
 }
 
 template <typename OutputIt, typename Char, typename... Args,
           FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value&&
                             detail::is_exotic_char<Char>::value)>
-inline auto vformat_to_n(
-    OutputIt out, size_t n, basic_string_view<Char> format_str,
-    basic_format_args<buffer_context<type_identity_t<Char>>> args)
+inline auto vformat_to_n(OutputIt out, size_t n, basic_string_view<Char> fmt,
+                         typename detail::vformat_args<Char>::type args)
     -> format_to_n_result<OutputIt> {
   using traits = detail::fixed_buffer_traits;
   auto buf = detail::iterator_buffer<OutputIt, Char, traits>(out, n);
-  detail::vformat_to(buf, format_str, args);
+  detail::vformat_to(buf, fmt, args);
   return {buf.out(), buf.count()};
 }
 
 template <typename OutputIt, typename S, typename... T,
-          typename Char = char_t<S>,
+          typename Char = detail::format_string_char_t<S>,
           FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value&&
                             detail::is_exotic_char<Char>::value)>
 inline auto format_to_n(OutputIt out, size_t n, const S& fmt, T&&... args)
     -> format_to_n_result<OutputIt> {
-  return vformat_to_n(out, n, detail::to_string_view(fmt),
-                      fmt::make_format_args<buffer_context<Char>>(args...));
+  return vformat_to_n(out, n, fmt::basic_string_view<Char>(fmt),
+                      fmt::make_format_args<buffered_context<Char>>(args...));
 }
 
-template <typename S, typename... T, typename Char = char_t<S>,
+template <typename S, typename... T,
+          typename Char = detail::format_string_char_t<S>,
           FMT_ENABLE_IF(detail::is_exotic_char<Char>::value)>
 inline auto formatted_size(const S& fmt, T&&... args) -> size_t {
   auto buf = detail::counting_buffer<Char>();
   detail::vformat_to(buf, detail::to_string_view(fmt),
-                     fmt::make_format_args<buffer_context<Char>>(args...));
+                     fmt::make_format_args<buffered_context<Char>>(args...));
   return buf.count();
 }
 
@@ -247,9 +322,48 @@ template <typename... T> void println(wformat_string<T...> fmt, T&&... args) {
   return print(L"{}\n", fmt::format(fmt, std::forward<T>(args)...));
 }
 
-/**
-  Converts *value* to ``std::wstring`` using the default format for type *T*.
- */
+inline auto vformat(const text_style& ts, wstring_view fmt, wformat_args args)
+    -> std::wstring {
+  auto buf = wmemory_buffer();
+  detail::vformat_to(buf, ts, fmt, args);
+  return {buf.data(), buf.size()};
+}
+
+template <typename... T>
+inline auto format(const text_style& ts, wformat_string<T...> fmt, T&&... args)
+    -> std::wstring {
+  return fmt::vformat(ts, fmt, fmt::make_wformat_args(args...));
+}
+
+template <typename... T>
+FMT_DEPRECATED void print(std::FILE* f, const text_style& ts,
+                          wformat_string<T...> fmt, const T&... args) {
+  vprint(f, ts, fmt, fmt::make_wformat_args(args...));
+}
+
+template <typename... T>
+FMT_DEPRECATED void print(const text_style& ts, wformat_string<T...> fmt,
+                          const T&... args) {
+  return print(stdout, ts, fmt, args...);
+}
+
+inline void vprint(std::wostream& os, wstring_view fmt, wformat_args args) {
+  auto buffer = basic_memory_buffer<wchar_t>();
+  detail::vformat_to(buffer, fmt, args);
+  detail::write_buffer(os, buffer);
+}
+
+template <typename... T>
+void print(std::wostream& os, wformat_string<T...> fmt, T&&... args) {
+  vprint(os, fmt, fmt::make_format_args<buffered_context<wchar_t>>(args...));
+}
+
+template <typename... T>
+void println(std::wostream& os, wformat_string<T...> fmt, T&&... args) {
+  print(os, L"{}\n", fmt::format(fmt, std::forward<T>(args)...));
+}
+
+/// Converts `value` to `std::wstring` using the default format for type `T`.
 template <typename T> inline auto to_wstring(const T& value) -> std::wstring {
   return format(FMT_STRING(L"{}"), value);
 }
diff --git a/3rdparty/fmt/src/fmt.cc b/3rdparty/fmt/src/fmt.cc
index 5330463a932cf..2dc4ef2f64d92 100644
--- a/3rdparty/fmt/src/fmt.cc
+++ b/3rdparty/fmt/src/fmt.cc
@@ -1,38 +1,57 @@
 module;
 
+#ifdef _MSVC_LANG
+#  define FMT_CPLUSPLUS _MSVC_LANG
+#else
+#  define FMT_CPLUSPLUS __cplusplus
+#endif
+
 // Put all implementation-provided headers into the global module fragment
 // to prevent attachment to this module.
-#include <algorithm>
+#ifndef FMT_IMPORT_STD
+#  include <algorithm>
+#  include <bitset>
+#  include <chrono>
+#  include <cmath>
+#  include <complex>
+#  include <cstddef>
+#  include <cstdint>
+#  include <cstdio>
+#  include <cstdlib>
+#  include <cstring>
+#  include <ctime>
+#  include <exception>
+#  if FMT_CPLUSPLUS > 202002L
+#    include <expected>
+#  endif
+#  include <filesystem>
+#  include <fstream>
+#  include <functional>
+#  include <iterator>
+#  include <limits>
+#  include <locale>
+#  include <memory>
+#  include <optional>
+#  include <ostream>
+#  include <source_location>
+#  include <stdexcept>
+#  include <string>
+#  include <string_view>
+#  include <system_error>
+#  include <thread>
+#  include <type_traits>
+#  include <typeinfo>
+#  include <utility>
+#  include <variant>
+#  include <vector>
+#else
+#  include <limits.h>
+#  include <stdint.h>
+#  include <stdio.h>
+#  include <time.h>
+#endif
 #include <cerrno>
-#include <chrono>
 #include <climits>
-#include <cmath>
-#include <cstddef>
-#include <cstdint>
-#include <cstdio>
-#include <cstdlib>
-#include <cstring>
-#include <ctime>
-#include <exception>
-#include <filesystem>
-#include <fstream>
-#include <functional>
-#include <iterator>
-#include <limits>
-#include <locale>
-#include <memory>
-#include <optional>
-#include <ostream>
-#include <stdexcept>
-#include <string>
-#include <string_view>
-#include <system_error>
-#include <thread>
-#include <type_traits>
-#include <typeinfo>
-#include <utility>
-#include <variant>
-#include <vector>
 #include <version>
 
 #if __has_include(<cxxabi.h>)
@@ -70,6 +89,10 @@ module;
 
 export module fmt;
 
+#ifdef FMT_IMPORT_STD
+import std;
+#endif
+
 #define FMT_EXPORT export
 #define FMT_BEGIN_EXPORT export {
 #define FMT_END_EXPORT }
@@ -83,6 +106,10 @@ export module fmt;
 extern "C++" {
 #endif
 
+#ifndef FMT_OS
+#  define FMT_OS 1
+#endif
+
 // All library-provided declarations and definitions must be in the module
 // purview to be exported.
 #include "fmt/args.h"
@@ -90,8 +117,12 @@ extern "C++" {
 #include "fmt/color.h"
 #include "fmt/compile.h"
 #include "fmt/format.h"
-#include "fmt/os.h"
+#if FMT_OS
+#  include "fmt/os.h"
+#endif
+#include "fmt/ostream.h"
 #include "fmt/printf.h"
+#include "fmt/ranges.h"
 #include "fmt/std.h"
 #include "fmt/xchar.h"
 
@@ -104,5 +135,17 @@ extern "C++" {
 module :private;
 #endif
 
-#include "format.cc"
-#include "os.cc"
+#ifdef FMT_ATTACH_TO_GLOBAL_MODULE
+extern "C++" {
+#endif
+
+#if FMT_HAS_INCLUDE("format.cc")
+#  include "format.cc"
+#endif
+#if FMT_OS && FMT_HAS_INCLUDE("os.cc")
+#  include "os.cc"
+#endif
+
+#ifdef FMT_ATTACH_TO_GLOBAL_MODULE
+}
+#endif
diff --git a/3rdparty/fmt/src/format.cc b/3rdparty/fmt/src/format.cc
index 391d3a248c261..3ccd8068483cc 100644
--- a/3rdparty/fmt/src/format.cc
+++ b/3rdparty/fmt/src/format.cc
@@ -15,7 +15,8 @@ template FMT_API auto dragonbox::to_decimal(float x) noexcept
 template FMT_API auto dragonbox::to_decimal(double x) noexcept
     -> dragonbox::decimal_fp<double>;
 
-#ifndef FMT_STATIC_THOUSANDS_SEPARATOR
+#if FMT_USE_LOCALE
+// DEPRECATED! locale_ref in the detail namespace
 template FMT_API locale_ref::locale_ref(const std::locale& loc);
 template FMT_API auto locale_ref::get<std::locale>() const -> std::locale;
 #endif
@@ -26,8 +27,10 @@ template FMT_API auto thousands_sep_impl(locale_ref)
     -> thousands_sep_result<char>;
 template FMT_API auto decimal_point_impl(locale_ref) -> char;
 
+// DEPRECATED!
 template FMT_API void buffer<char>::append(const char*, const char*);
 
+// DEPRECATED!
 template FMT_API void vformat_to(buffer<char>&, string_view,
                                  typename vformat_args<>::type, locale_ref);
 
diff --git a/3rdparty/fmt/src/os.cc b/3rdparty/fmt/src/os.cc
index a639e78c6028e..c833a0514186b 100644
--- a/3rdparty/fmt/src/os.cc
+++ b/3rdparty/fmt/src/os.cc
@@ -12,47 +12,51 @@
 
 #include "fmt/os.h"
 
-#include <climits>
+#ifndef FMT_MODULE
+#  include <climits>
 
-#if FMT_USE_FCNTL
-#  include <sys/stat.h>
-#  include <sys/types.h>
-
-#  ifdef _WRS_KERNEL    // VxWorks7 kernel
-#    include <ioLib.h>  // getpagesize
-#  endif
+#  if FMT_USE_FCNTL
+#    include <sys/stat.h>
+#    include <sys/types.h>
 
-#  ifndef _WIN32
-#    include <unistd.h>
-#  else
-#    ifndef WIN32_LEAN_AND_MEAN
-#      define WIN32_LEAN_AND_MEAN
+#    ifdef _WRS_KERNEL    // VxWorks7 kernel
+#      include <ioLib.h>  // getpagesize
 #    endif
-#    include <io.h>
 
-#    ifndef S_IRUSR
-#      define S_IRUSR _S_IREAD
-#    endif
-#    ifndef S_IWUSR
-#      define S_IWUSR _S_IWRITE
-#    endif
-#    ifndef S_IRGRP
-#      define S_IRGRP 0
-#    endif
-#    ifndef S_IWGRP
-#      define S_IWGRP 0
-#    endif
-#    ifndef S_IROTH
-#      define S_IROTH 0
-#    endif
-#    ifndef S_IWOTH
-#      define S_IWOTH 0
-#    endif
-#  endif  // _WIN32
-#endif    // FMT_USE_FCNTL
+#    ifndef _WIN32
+#      include <unistd.h>
+#    else
+#      ifndef WIN32_LEAN_AND_MEAN
+#        define WIN32_LEAN_AND_MEAN
+#      endif
+#      include <io.h>
+#    endif  // _WIN32
+#  endif    // FMT_USE_FCNTL
+
+#  ifdef _WIN32
+#    include <windows.h>
+#  endif
+#endif
 
 #ifdef _WIN32
-#  include <windows.h>
+#  ifndef S_IRUSR
+#    define S_IRUSR _S_IREAD
+#  endif
+#  ifndef S_IWUSR
+#    define S_IWUSR _S_IWRITE
+#  endif
+#  ifndef S_IRGRP
+#    define S_IRGRP 0
+#  endif
+#  ifndef S_IWGRP
+#    define S_IWGRP 0
+#  endif
+#  ifndef S_IROTH
+#    define S_IROTH 0
+#  endif
+#  ifndef S_IWOTH
+#    define S_IWOTH 0
+#  endif
 #endif
 
 namespace {
@@ -156,7 +160,7 @@ void detail::format_windows_error(detail::buffer<char>& out, int error_code,
 }
 
 void report_windows_error(int error_code, const char* message) noexcept {
-  report_error(detail::format_windows_error, error_code, message);
+  do_report_error(detail::format_windows_error, error_code, message);
 }
 #endif  // _WIN32
 
@@ -182,12 +186,14 @@ void buffered_file::close() {
 }
 
 int buffered_file::descriptor() const {
-#if !defined(fileno)
+#ifdef FMT_HAS_SYSTEM
+  // fileno is a macro on OpenBSD.
+#  ifdef fileno
+#    undef fileno
+#  endif
   int fd = FMT_POSIX_CALL(fileno(file_));
-#elif defined(FMT_HAS_SYSTEM)
-  // fileno is a macro on OpenBSD so we cannot use FMT_POSIX_CALL.
-#  define FMT_DISABLE_MACRO
-  int fd = FMT_SYSTEM(fileno FMT_DISABLE_MACRO(file_));
+#elif defined(_WIN32)
+  int fd = _fileno(file_);
 #else
   int fd = fileno(file_);
 #endif
@@ -200,6 +206,7 @@ int buffered_file::descriptor() const {
 #  ifdef _WIN32
 using mode_t = int;
 #  endif
+
 constexpr mode_t default_open_mode =
     S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;
 
@@ -301,29 +308,6 @@ void file::dup2(int fd, std::error_code& ec) noexcept {
   if (result == -1) ec = std::error_code(errno, std::generic_category());
 }
 
-void file::pipe(file& read_end, file& write_end) {
-  // Close the descriptors first to make sure that assignments don't throw
-  // and there are no leaks.
-  read_end.close();
-  write_end.close();
-  int fds[2] = {};
-#  ifdef _WIN32
-  // Make the default pipe capacity same as on Linux 2.6.11+.
-  enum { DEFAULT_CAPACITY = 65536 };
-  int result = FMT_POSIX_CALL(pipe(fds, DEFAULT_CAPACITY, _O_BINARY));
-#  else
-  // Don't retry as the pipe function doesn't return EINTR.
-  // http://pubs.opengroup.org/onlinepubs/009696799/functions/pipe.html
-  int result = FMT_POSIX_CALL(pipe(fds));
-#  endif
-  if (result != 0)
-    FMT_THROW(system_error(errno, FMT_STRING("cannot create pipe")));
-  // The following assignments don't throw because read_fd and write_fd
-  // are closed.
-  read_end = file(fds[0]);
-  write_end = file(fds[1]);
-}
-
 buffered_file file::fdopen(const char* mode) {
 // Don't retry as fdopen doesn't return EINTR.
 #  if defined(__MINGW32__) && defined(_POSIX_)
@@ -352,6 +336,24 @@ file file::open_windows_file(wcstring_view path, int oflag) {
 }
 #  endif
 
+pipe::pipe() {
+  int fds[2] = {};
+#  ifdef _WIN32
+  // Make the default pipe capacity same as on Linux 2.6.11+.
+  enum { DEFAULT_CAPACITY = 65536 };
+  int result = FMT_POSIX_CALL(pipe(fds, DEFAULT_CAPACITY, _O_BINARY));
+#  else
+  // Don't retry as the pipe function doesn't return EINTR.
+  // http://pubs.opengroup.org/onlinepubs/009696799/functions/pipe.html
+  int result = FMT_POSIX_CALL(pipe(fds));
+#  endif
+  if (result != 0)
+    FMT_THROW(system_error(errno, FMT_STRING("cannot create pipe")));
+  // The following assignments don't throw.
+  read_end = file(fds[0]);
+  write_end = file(fds[1]);
+}
+
 #  if !defined(__MSDOS__)
 long getpagesize() {
 #    ifdef _WIN32
@@ -372,31 +374,25 @@ long getpagesize() {
 }
 #  endif
 
-namespace detail {
-
-void file_buffer::grow(size_t) {
-  if (this->size() == this->capacity()) flush();
+void ostream::grow(buffer<char>& buf, size_t) {
+  if (buf.size() == buf.capacity()) static_cast<ostream&>(buf).flush();
 }
 
-file_buffer::file_buffer(cstring_view path,
-                         const detail::ostream_params& params)
-    : file_(path, params.oflag) {
+ostream::ostream(cstring_view path, const detail::ostream_params& params)
+    : buffer<char>(grow), file_(path, params.oflag) {
   set(new char[params.buffer_size], params.buffer_size);
 }
 
-file_buffer::file_buffer(file_buffer&& other)
-    : detail::buffer<char>(other.data(), other.size(), other.capacity()),
+ostream::ostream(ostream&& other) noexcept
+    : buffer<char>(grow, other.data(), other.size(), other.capacity()),
       file_(std::move(other.file_)) {
   other.clear();
   other.set(nullptr, 0);
 }
 
-file_buffer::~file_buffer() {
+ostream::~ostream() {
   flush();
   delete[] data();
 }
-}  // namespace detail
-
-ostream::~ostream() = default;
 #endif  // FMT_USE_FCNTL
 FMT_END_NAMESPACE
diff --git a/cmake/SearchForStuff.cmake b/cmake/SearchForStuff.cmake
index ff66f9cdd41ed..12306df6875a6 100644
--- a/cmake/SearchForStuff.cmake
+++ b/cmake/SearchForStuff.cmake
@@ -125,7 +125,7 @@ elseif(_M_ARM64)
 endif()
 
 # Prevent fmt from being built with exceptions, or being thrown at call sites.
-set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DFMT_EXCEPTIONS=0")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DFMT_USE_EXCEPTIONS=0 -DFMT_USE_RTTI=0")
 add_subdirectory(3rdparty/fmt EXCLUDE_FROM_ALL)
 
 # Deliberately at the end. We don't want to set the flag on third-party projects.
From 56aa5d9657a0742473f12aa27c9391480b37184f Mon Sep 17 00:00:00 2001
From: TheLastRar <TheLastRar@users.noreply.github.com>
Date: Wed, 15 Jan 2025 21:26:10 +0000
Subject: [PATCH] SmallString: Prep for fmt update

---
 common/SmallString.h | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/common/SmallString.h b/common/SmallString.h
index c756dda389640..00bfa76b3c98c 100644
--- a/common/SmallString.h
+++ b/common/SmallString.h
@@ -10,6 +10,7 @@
 #include <algorithm>
 #include <cstdarg>
 #include <cstring>
+#include <iterator>
 #include <limits>
 #include <string>
 #include <string_view>
@@ -177,7 +178,7 @@ class SmallStringBase
 	__fi const char* end_ptr() const { return m_buffer + m_length; }
 
 	// STL adapters
-	__fi void push_back(value_type&& val) { append(val); }
+	__fi void push_back(value_type val) { append(val); }
 
 	// returns a string view for this string
 	std::string_view view() const;
@@ -413,7 +414,7 @@ __fi void SmallStringBase::format(fmt::format_string<T...> fmt, T&&... args)
 		} \
 \
 		template <typename FormatContext> \
-		auto format(const type& str, FormatContext& ctx) \
+		auto format(const type& str, FormatContext& ctx) const \
 		{ \
 			return fmt::format_to(ctx.out(), "{}", str.view()); \
 		} \
