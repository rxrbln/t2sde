# --- T2-COPYRIGHT-BEGIN ---
# t2/package/*/linux/hotfix-ps3-gelic.patch
# Copyright (C) 2025 The T2 SDE Project
# SPDX-License-Identifier: GPL-2.0 or patched project license
# --- T2-COPYRIGHT-END ---

Gracefully handle SKB allocation failures, by keeping napi polling.
And use napi* functions instead of net* to receive and alloc SKBs.

Before:	[  5]   0.00-10.00  sec   752 MBytes   631 Mbits/sec  3917             sender
After:	[  5]   0.00-10.00  sec  1.09 GBytes   940 Mbits/sec   40             sender

Signed-off-by: Florian Fuchs <fuchsfl@gmail.com>
Tested-By: Ren√© Rebe <rene@exactcode.de>

--- linux-6.17/drivers/net/ethernet/toshiba/ps3_gelic_net.c.vanilla	2025-11-02 01:26:59.998000000 +0100
+++ linux-6.17/drivers/net/ethernet/toshiba/ps3_gelic_net.c	2025-11-03 22:51:18.828000000 +0100
@@ -373,7 +373,8 @@
  * must be a multiple of GELIC_NET_RXBUF_ALIGN.
  */
 static int gelic_descr_prepare_rx(struct gelic_card *card,
-				  struct gelic_descr *descr)
+				  struct gelic_descr *descr,
+				  bool napi_mode)
 {
 	static const unsigned int rx_skb_size =
 		ALIGN(GELIC_NET_MAX_FRAME, GELIC_NET_RXBUF_ALIGN) +
@@ -391,9 +392,15 @@
 	descr->hw_regs.payload.dev_addr = 0;
 	descr->hw_regs.payload.size = 0;
 
-	descr->skb = netdev_alloc_skb(*card->netdev, rx_skb_size);
+	if (likely(napi_mode)) { 
+		descr->skb = napi_alloc_skb(&card->napi, rx_skb_size);
+	} else {
+		descr->skb = netdev_alloc_skb(*card->netdev, rx_skb_size);
+	}
+	
 	if (!descr->skb) {
 		descr->hw_regs.payload.dev_addr = 0; /* tell DMAC don't touch memory */
+		net_err_ratelimited("SKB allocation failed\n");
 		return -ENOMEM;
 	}
 
@@ -456,14 +463,14 @@
  * and iommu-maps them.
  * returns 0 on success, < 0 on failure
  */
-static int gelic_card_fill_rx_chain(struct gelic_card *card)
+static int gelic_card_fill_rx_chain(struct gelic_card *card, bool napi_mode)
 {
 	struct gelic_descr *descr = card->rx_chain.head;
 	int ret;
 
 	do {
 		if (!descr->skb) {
-			ret = gelic_descr_prepare_rx(card, descr);
+		    	ret = gelic_descr_prepare_rx(card, descr, napi_mode);
 			if (ret)
 				goto rewind;
 		}
@@ -482,12 +489,12 @@
  *
  * returns 0 on success, < 0 on failure
  */
-static int gelic_card_alloc_rx_skbs(struct gelic_card *card)
+static int gelic_card_alloc_rx_skbs(struct gelic_card *card, bool napi_mode)
 {
 	struct gelic_descr_chain *chain;
 	int ret;
 	chain = &card->rx_chain;
-	ret = gelic_card_fill_rx_chain(card);
+	ret = gelic_card_fill_rx_chain(card, napi_mode);
 	chain->tail = card->rx_top->prev; /* point to the last */
 	return ret;
 }
@@ -963,7 +970,7 @@
 	netdev->stats.rx_bytes += skb->len;
 
 	/* pass skb up to stack */
-	netif_receive_skb(skb);
+	napi_gro_receive(&card->napi, skb);
 }
 
 /**
@@ -975,13 +982,14 @@
  * processes an rx descriptor by iommu-unmapping the data buffer and passing
  * the packet up to the stack
  */
-static int gelic_card_decode_one_descr(struct gelic_card *card)
+static int gelic_card_decode_one_descr(struct gelic_card *card, bool napi_mode)
 {
 	enum gelic_descr_dma_status status;
 	struct gelic_descr_chain *chain = &card->rx_chain;
 	struct gelic_descr *descr = chain->head;
 	struct net_device *netdev = NULL;
 	int dmac_chain_ended;
+	bool no_pkg_processed = false;
 
 	status = gelic_descr_get_status(descr);
 
@@ -993,6 +1001,12 @@
 		return 0;
 	}
 
+	if(!descr->skb) { 
+		no_pkg_processed = true;
+                net_err_ratelimited("SKB is not set, refilling..\n");
+		goto refill;
+	}
+
 	/* netdevice select */
 	if (card->vlan_required) {
 		unsigned int i;
@@ -1065,7 +1079,11 @@
 	 * this call can fail, but for now, just leave this
 	 * descriptor without skb
 	 */
-	gelic_descr_prepare_rx(card, descr);
+	int ret = gelic_descr_prepare_rx(card, descr, napi_mode);
+	if (ret) {
+                net_err_ratelimited("Refill SKB allocation failed\n");
+		return -1;
+	}
 
 	chain->tail = descr;
 	chain->head = descr->next;
@@ -1084,7 +1102,7 @@
 	if (dmac_chain_ended)
 		gelic_card_enable_rxdmac(card);
 
-	return 1;
+	return no_pkg_processed ? 0 : 1;
 }
 
 /**
@@ -1099,15 +1117,24 @@
 {
 	struct gelic_card *card = container_of(napi, struct gelic_card, napi);
 	int packets_done = 0;
+	bool alloc_failed = false;
 
 	while (packets_done < budget) {
-		if (!gelic_card_decode_one_descr(card))
+		int err = gelic_card_decode_one_descr(card, true);
+		if (err == -1) {
+			net_err_ratelimited("get_net_poll: SKB allocation failed\n");
+			alloc_failed = true;
 			break;
+		}
+		if (!err) {
+			break;
+		}
 
 		packets_done++;
 	}
 
 	if (packets_done < budget) {
+		if(alloc_failed) return budget;
 		napi_complete_done(napi, packets_done);
 		gelic_card_rx_irq_on(card);
 	}
@@ -1814,7 +1841,7 @@
 		card->rx_top, card->tx_top, sizeof(struct gelic_descr),
 		GELIC_NET_RX_DESCRIPTORS);
 	/* allocate rx skbs */
-	result = gelic_card_alloc_rx_skbs(card);
+	result = gelic_card_alloc_rx_skbs(card, false);
 	if (result)
 		goto fail_alloc_skbs;
 
