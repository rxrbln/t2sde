# --- T2-COPYRIGHT-BEGIN ---
# t2/package/*/linux/revert-sunhme.patch
# Copyright (C) 2026 The T2 SDE Project
# SPDX-License-Identifier: GPL-2.0 or patched project license
# --- T2-COPYRIGHT-END ---

reverted:
--- b/drivers/net/ethernet/sun/sunhme.c
+++ a/drivers/net/ethernet/sun/sunhme.c
@@ -2430,58 +2430,6 @@
 	}
 }
 
-static int happy_meal_common_probe(struct happy_meal *hp,
-				   struct device_node *dp)
-{
-	struct net_device *dev = hp->dev;
-	int err;
-
-#ifdef CONFIG_SPARC
-	hp->hm_revision = of_getintprop_default(dp, "hm-rev", hp->hm_revision);
-#endif
-
-	/* Now enable the feature flags we can. */
-	if (hp->hm_revision == 0x20 || hp->hm_revision == 0x21)
-		hp->happy_flags |= HFLAG_20_21;
-	else if (hp->hm_revision != 0xa0)
-		hp->happy_flags |= HFLAG_NOT_A0;
-
-	hp->happy_block = dmam_alloc_coherent(hp->dma_dev, PAGE_SIZE,
-					      &hp->hblock_dvma, GFP_KERNEL);
-	if (!hp->happy_block)
-		return -ENOMEM;
-
-	/* Force check of the link first time we are brought up. */
-	hp->linkcheck = 0;
-
-	/* Force timer state to 'asleep' with count of zero. */
-	hp->timer_state = asleep;
-	hp->timer_ticks = 0;
-
-	timer_setup(&hp->happy_timer, happy_meal_timer, 0);
-
-	dev->netdev_ops = &hme_netdev_ops;
-	dev->watchdog_timeo = 5 * HZ;
-	dev->ethtool_ops = &hme_ethtool_ops;
-
-	/* Happy Meal can do it all... */
-	dev->hw_features = NETIF_F_SG | NETIF_F_HW_CSUM;
-	dev->features |= dev->hw_features | NETIF_F_RXCSUM;
-
-
-	/* Grrr, Happy Meal comes up by default not advertising
-	 * full duplex 100baseT capabilities, fix this.
-	 */
-	spin_lock_irq(&hp->happy_lock);
-	happy_meal_set_initial_advertisement(hp);
-	spin_unlock_irq(&hp->happy_lock);
-
-	err = devm_register_netdev(hp->dma_dev, dev);
-	if (err)
-		dev_err(hp->dma_dev, "Cannot register net device, aborting.\n");
-	return err;
-}
-
 #ifdef CONFIG_SBUS
 static int happy_meal_sbus_probe_one(struct platform_device *op, int is_qfe)
 {
@@ -2563,18 +2511,50 @@
 		goto err_out_clear_quattro;
 	}
 
+	hp->hm_revision = of_getintprop_default(dp, "hm-rev", 0xff);
+	if (hp->hm_revision == 0xff)
+		hp->hm_revision = 0xa0;
+
+	/* Now enable the feature flags we can. */
+	if (hp->hm_revision == 0x20 || hp->hm_revision == 0x21)
+		hp->happy_flags = HFLAG_20_21;
+	else if (hp->hm_revision != 0xa0)
+		hp->happy_flags = HFLAG_NOT_A0;
-	hp->hm_revision = 0xa0;
 
 	if (qp != NULL)
 		hp->happy_flags |= HFLAG_QUATTRO;
 
-	hp->irq = op->archdata.irqs[0];
-
 	/* Get the supported DVMA burst sizes from our Happy SBUS. */
 	hp->happy_bursts = of_getintprop_default(sbus_dp,
 						 "burst-sizes", 0x00);
 
+	hp->happy_block = dmam_alloc_coherent(&op->dev, PAGE_SIZE,
+					      &hp->hblock_dvma, GFP_KERNEL);
+	if (!hp->happy_block) {
+		err = -ENOMEM;
+		goto err_out_clear_quattro;
+	}
+
+	/* Force check of the link first time we are brought up. */
+	hp->linkcheck = 0;
+
+	/* Force timer state to 'asleep' with count of zero. */
+	hp->timer_state = asleep;
+	hp->timer_ticks = 0;
+
+	timer_setup(&hp->happy_timer, happy_meal_timer, 0);
+
+	dev->netdev_ops = &hme_netdev_ops;
+	dev->watchdog_timeo = 5*HZ;
+	dev->ethtool_ops = &hme_ethtool_ops;
+
+	/* Happy Meal can do it all... */
+	dev->hw_features = NETIF_F_SG | NETIF_F_HW_CSUM;
+	dev->features |= dev->hw_features | NETIF_F_RXCSUM;
+
+	hp->irq = op->archdata.irqs[0];
+
+#if defined(CONFIG_SBUS) && defined(CONFIG_PCI)
-#ifdef CONFIG_PCI
 	/* Hook up SBUS register/descriptor accessors. */
 	hp->read_desc32 = sbus_hme_read_desc32;
 	hp->write_txd = sbus_hme_write_txd;
@@ -2583,9 +2563,18 @@
 	hp->write32 = sbus_hme_write32;
 #endif
 
+	/* Grrr, Happy Meal comes up by default not advertising
+	 * full duplex 100baseT capabilities, fix this.
+	 */
+	spin_lock_irq(&hp->happy_lock);
+	happy_meal_set_initial_advertisement(hp);
+	spin_unlock_irq(&hp->happy_lock);
+
+	err = devm_register_netdev(&op->dev, dev);
+	if (err) {
+		dev_err(&op->dev, "Cannot register net device, aborting.\n");
-	err = happy_meal_common_probe(hp, dp);
-	if (err)
 		goto err_out_clear_quattro;
+	}
 
 	platform_set_drvdata(op, hp);
 
@@ -2700,10 +2689,20 @@
 	hp->bigmacregs = (hpreg_base + 0x6000UL);
 	hp->tcvregs    = (hpreg_base + 0x7000UL);
 
+#ifdef CONFIG_SPARC
+	hp->hm_revision = of_getintprop_default(dp, "hm-rev", 0xff);
+	if (hp->hm_revision == 0xff)
-	if (IS_ENABLED(CONFIG_SPARC))
 		hp->hm_revision = 0xc0 | (pdev->revision & 0x0f);
+#else
+	/* works with this on non-sparc hosts */
+	hp->hm_revision = 0x20;
+#endif
+
+	/* Now enable the feature flags we can. */
+	if (hp->hm_revision == 0x20 || hp->hm_revision == 0x21)
+		hp->happy_flags = HFLAG_20_21;
+	else if (hp->hm_revision != 0xa0 && hp->hm_revision != 0xc0)
+		hp->happy_flags = HFLAG_NOT_A0;
-	else
-		hp->hm_revision = 0x20;
 
 	if (qp != NULL)
 		hp->happy_flags |= HFLAG_QUATTRO;
@@ -2715,9 +2714,30 @@
 	/* Assume PCI happy meals can handle all burst sizes. */
 	hp->happy_bursts = DMA_BURSTBITS;
 #endif
+
+	hp->happy_block = dmam_alloc_coherent(&pdev->dev, PAGE_SIZE,
+					      &hp->hblock_dvma, GFP_KERNEL);
+	if (!hp->happy_block) {
+		err = -ENOMEM;
+		goto err_out_clear_quattro;
+	}
+
+	hp->linkcheck = 0;
+	hp->timer_state = asleep;
+	hp->timer_ticks = 0;
+
+	timer_setup(&hp->happy_timer, happy_meal_timer, 0);
+
 	hp->irq = pdev->irq;
+	dev->netdev_ops = &hme_netdev_ops;
+	dev->watchdog_timeo = 5*HZ;
+	dev->ethtool_ops = &hme_ethtool_ops;
 
+	/* Happy Meal can do it all... */
+	dev->hw_features = NETIF_F_SG | NETIF_F_HW_CSUM;
+	dev->features |= dev->hw_features | NETIF_F_RXCSUM;
+
+#if defined(CONFIG_SBUS) && defined(CONFIG_PCI)
-#ifdef CONFIG_SBUS
 	/* Hook up PCI register/descriptor accessors. */
 	hp->read_desc32 = pci_hme_read_desc32;
 	hp->write_txd = pci_hme_write_txd;
@@ -2726,9 +2746,18 @@
 	hp->write32 = pci_hme_write32;
 #endif
 
+	/* Grrr, Happy Meal comes up by default not advertising
+	 * full duplex 100baseT capabilities, fix this.
+	 */
+	spin_lock_irq(&hp->happy_lock);
+	happy_meal_set_initial_advertisement(hp);
+	spin_unlock_irq(&hp->happy_lock);
+
+	err = devm_register_netdev(&pdev->dev, dev);
+	if (err) {
+		dev_err(&pdev->dev, "Cannot register net device, aborting.\n");
-	err = happy_meal_common_probe(hp, dp);
-	if (err)
 		goto err_out_clear_quattro;
+	}
 
 	pci_set_drvdata(pdev, hp);
 
reverted:
--- b/drivers/net/ethernet/sun/sunhme.c
+++ a/drivers/net/ethernet/sun/sunhme.c
@@ -2622,25 +2622,29 @@
 
 	err = pcim_enable_device(pdev);
 	if (err)
+		goto err_out;
-		return err;
 	pci_set_master(pdev);
 
 	if (!strcmp(prom_name, "SUNW,qfe") || !strcmp(prom_name, "qfe")) {
 		qp = quattro_pci_find(pdev);
+		if (IS_ERR(qp)) {
+			err = PTR_ERR(qp);
+			goto err_out;
+		}
-		if (IS_ERR(qp))
-			return PTR_ERR(qp);
 
 		for (qfe_slot = 0; qfe_slot < 4; qfe_slot++)
 			if (!qp->happy_meals[qfe_slot])
 				break;
 
 		if (qfe_slot == 4)
+			goto err_out;
-			return -ENODEV;
 	}
 
 	dev = devm_alloc_etherdev(&pdev->dev, sizeof(struct happy_meal));
+	if (!dev) {
+		err = -ENOMEM;
+		goto err_out;
+	}
-	if (!dev)
-		return -ENOMEM;
 	SET_NETDEV_DEV(dev, &pdev->dev);
 
 	hp = netdev_priv(dev);
@@ -2788,6 +2792,8 @@
 err_out_clear_quattro:
 	if (qp != NULL)
 		qp->happy_meals[qfe_slot] = NULL;
+
+err_out:
 	return err;
 }
 
reverted:
--- b/drivers/net/ethernet/sun/sunhme.c
+++ a/drivers/net/ethernet/sun/sunhme.c
@@ -2348,7 +2348,9 @@
 		p += 6;
 
 		if (index == 0) {
+			int i;
+
+			for (i = 0; i < 6; i++)
-			for (int i = 0; i < 6; i++)
 				dev_addr[i] = readb(p + i);
 			return 1;
 		}
@@ -2360,10 +2362,9 @@
 static void __maybe_unused get_hme_mac_nonsparc(struct pci_dev *pdev,
 						unsigned char *dev_addr)
 {
-	void __iomem *p;
 	size_t size;
+	void __iomem *p = pci_map_rom(pdev, &size);
 
-	p = pci_map_rom(pdev, &size);
 	if (p) {
 		int index = 0;
 		int found;
@@ -2385,7 +2386,7 @@
 	dev_addr[2] = 0x20;
 	get_random_bytes(&dev_addr[3], 3);
 }
+#endif /* !(CONFIG_SPARC) */
-#endif
 
 static void happy_meal_addr_init(struct happy_meal *hp,
 				 struct device_node *dp, int qfe_slot)
reverted:
--- b/drivers/net/ethernet/sun/sunhme.c
+++ a/drivers/net/ethernet/sun/sunhme.c
@@ -2304,133 +2304,6 @@
 	.ndo_validate_addr	= eth_validate_addr,
 };
 
-#ifdef CONFIG_PCI
-static int is_quattro_p(struct pci_dev *pdev)
-{
-	struct pci_dev *busdev = pdev->bus->self;
-	struct pci_dev *this_pdev;
-	int n_hmes;
-
-	if (!busdev || busdev->vendor != PCI_VENDOR_ID_DEC ||
-	    busdev->device != PCI_DEVICE_ID_DEC_21153)
-		return 0;
-
-	n_hmes = 0;
-	list_for_each_entry(this_pdev, &pdev->bus->devices, bus_list) {
-		if (this_pdev->vendor == PCI_VENDOR_ID_SUN &&
-		    this_pdev->device == PCI_DEVICE_ID_SUN_HAPPYMEAL)
-			n_hmes++;
-	}
-
-	if (n_hmes != 4)
-		return 0;
-
-	return 1;
-}
-
-/* Fetch MAC address from vital product data of PCI ROM. */
-static int find_eth_addr_in_vpd(void __iomem *rom_base, int len, int index, unsigned char *dev_addr)
-{
-	int this_offset;
-
-	for (this_offset = 0x20; this_offset < len; this_offset++) {
-		void __iomem *p = rom_base + this_offset;
-
-		if (readb(p + 0) != 0x90 ||
-		    readb(p + 1) != 0x00 ||
-		    readb(p + 2) != 0x09 ||
-		    readb(p + 3) != 0x4e ||
-		    readb(p + 4) != 0x41 ||
-		    readb(p + 5) != 0x06)
-			continue;
-
-		this_offset += 6;
-		p += 6;
-
-		if (index == 0) {
-			int i;
-
-			for (i = 0; i < 6; i++)
-				dev_addr[i] = readb(p + i);
-			return 1;
-		}
-		index--;
-	}
-	return 0;
-}
-
-static void __maybe_unused get_hme_mac_nonsparc(struct pci_dev *pdev,
-						unsigned char *dev_addr)
-{
-	size_t size;
-	void __iomem *p = pci_map_rom(pdev, &size);
-
-	if (p) {
-		int index = 0;
-		int found;
-
-		if (is_quattro_p(pdev))
-			index = PCI_SLOT(pdev->devfn);
-
-		found = readb(p) == 0x55 &&
-			readb(p + 1) == 0xaa &&
-			find_eth_addr_in_vpd(p, (64 * 1024), index, dev_addr);
-		pci_unmap_rom(pdev, p);
-		if (found)
-			return;
-	}
-
-	/* Sun MAC prefix then 3 random bytes. */
-	dev_addr[0] = 0x08;
-	dev_addr[1] = 0x00;
-	dev_addr[2] = 0x20;
-	get_random_bytes(&dev_addr[3], 3);
-}
-#endif /* !(CONFIG_SPARC) */
-
-static void happy_meal_addr_init(struct happy_meal *hp,
-				 struct device_node *dp, int qfe_slot)
-{
-	int i;
-
-	for (i = 0; i < 6; i++) {
-		if (macaddr[i] != 0)
-			break;
-	}
-
-	if (i < 6) { /* a mac address was given */
-		u8 addr[ETH_ALEN];
-
-		for (i = 0; i < 6; i++)
-			addr[i] = macaddr[i];
-		eth_hw_addr_set(hp->dev, addr);
-		macaddr[5]++;
-	} else {
-#ifdef CONFIG_SPARC
-		const unsigned char *addr;
-		int len;
-
-		/* If user did not specify a MAC address specifically, use
-		 * the Quattro local-mac-address property...
-		 */
-		if (qfe_slot != -1) {
-			addr = of_get_property(dp, "local-mac-address", &len);
-			if (addr && len == 6) {
-				eth_hw_addr_set(hp->dev, addr);
-				return;
-			}
-		}
-
-		eth_hw_addr_set(hp->dev, idprom->id_ethaddr);
-#else
-		u8 addr[ETH_ALEN];
-
-		get_hme_mac_nonsparc(hp->happy_dev, addr);
-		eth_hw_addr_set(hp->dev, addr);
-#endif
-	}
-}
-
 #ifdef CONFIG_SBUS
 static int happy_meal_sbus_probe_one(struct platform_device *op, int is_qfe)
 {
@@ -2438,7 +2311,8 @@
 	struct quattro *qp = NULL;
 	struct happy_meal *hp;
 	struct net_device *dev;
+	int i, qfe_slot = -1;
+	u8 addr[ETH_ALEN];
-	int qfe_slot = -1;
 	int err;
 
 	sbus_dp = op->dev.parent->of_node;
@@ -2463,11 +2337,34 @@
 		return -ENOMEM;
 	SET_NETDEV_DEV(dev, &op->dev);
 
+	/* If user did not specify a MAC address specifically, use
+	 * the Quattro local-mac-address property...
+	 */
+	for (i = 0; i < 6; i++) {
+		if (macaddr[i] != 0)
+			break;
+	}
+	if (i < 6) { /* a mac address was given */
+		for (i = 0; i < 6; i++)
+			addr[i] = macaddr[i];
+		eth_hw_addr_set(dev, addr);
+		macaddr[5]++;
+	} else {
+		const unsigned char *addr;
+		int len;
+
+		addr = of_get_property(dp, "local-mac-address", &len);
+
+		if (qfe_slot != -1 && addr && len == ETH_ALEN)
+			eth_hw_addr_set(dev, addr);
+		else
+			eth_hw_addr_set(dev, idprom->id_ethaddr);
+	}
+
 	hp = netdev_priv(dev);
+
-	hp->dev = dev;
 	hp->happy_dev = op;
 	hp->dma_dev = &op->dev;
-	happy_meal_addr_init(hp, dp, qfe_slot);
 
 	spin_lock_init(&hp->happy_lock);
 
@@ -2545,6 +2442,7 @@
 
 	timer_setup(&hp->happy_timer, happy_meal_timer, 0);
 
+	hp->dev = dev;
 	dev->netdev_ops = &hme_netdev_ops;
 	dev->watchdog_timeo = 5*HZ;
 	dev->ethtool_ops = &hme_ethtool_ops;
@@ -2597,17 +2495,104 @@
 #endif
 
 #ifdef CONFIG_PCI
+#ifndef CONFIG_SPARC
+static int is_quattro_p(struct pci_dev *pdev)
+{
+	struct pci_dev *busdev = pdev->bus->self;
+	struct pci_dev *this_pdev;
+	int n_hmes;
+
+	if (busdev == NULL ||
+	    busdev->vendor != PCI_VENDOR_ID_DEC ||
+	    busdev->device != PCI_DEVICE_ID_DEC_21153)
+		return 0;
+
+	n_hmes = 0;
+	list_for_each_entry(this_pdev, &pdev->bus->devices, bus_list) {
+		if (this_pdev->vendor == PCI_VENDOR_ID_SUN &&
+		    this_pdev->device == PCI_DEVICE_ID_SUN_HAPPYMEAL)
+			n_hmes++;
+	}
+
+	if (n_hmes != 4)
+		return 0;
+
+	return 1;
+}
+
+/* Fetch MAC address from vital product data of PCI ROM. */
+static int find_eth_addr_in_vpd(void __iomem *rom_base, int len, int index, unsigned char *dev_addr)
+{
+	int this_offset;
+
+	for (this_offset = 0x20; this_offset < len; this_offset++) {
+		void __iomem *p = rom_base + this_offset;
+
+		if (readb(p + 0) != 0x90 ||
+		    readb(p + 1) != 0x00 ||
+		    readb(p + 2) != 0x09 ||
+		    readb(p + 3) != 0x4e ||
+		    readb(p + 4) != 0x41 ||
+		    readb(p + 5) != 0x06)
+			continue;
+
+		this_offset += 6;
+		p += 6;
+
+		if (index == 0) {
+			int i;
+
+			for (i = 0; i < 6; i++)
+				dev_addr[i] = readb(p + i);
+			return 1;
+		}
+		index--;
+	}
+	return 0;
+}
+
+static void get_hme_mac_nonsparc(struct pci_dev *pdev, unsigned char *dev_addr)
+{
+	size_t size;
+	void __iomem *p = pci_map_rom(pdev, &size);
+
+	if (p) {
+		int index = 0;
+		int found;
+
+		if (is_quattro_p(pdev))
+			index = PCI_SLOT(pdev->devfn);
+
+		found = readb(p) == 0x55 &&
+			readb(p + 1) == 0xaa &&
+			find_eth_addr_in_vpd(p, (64 * 1024), index, dev_addr);
+		pci_unmap_rom(pdev, p);
+		if (found)
+			return;
+	}
+
+	/* Sun MAC prefix then 3 random bytes. */
+	dev_addr[0] = 0x08;
+	dev_addr[1] = 0x00;
+	dev_addr[2] = 0x20;
+	get_random_bytes(&dev_addr[3], 3);
+}
+#endif /* !(CONFIG_SPARC) */
+
 static int happy_meal_pci_probe(struct pci_dev *pdev,
 				const struct pci_device_id *ent)
 {
-	struct device_node *dp = NULL;
 	struct quattro *qp = NULL;
+#ifdef CONFIG_SPARC
+	struct device_node *dp;
+#endif
 	struct happy_meal *hp;
 	struct net_device *dev;
 	void __iomem *hpreg_base;
 	struct resource *hpreg_res;
+	int i, qfe_slot = -1;
 	char prom_name[64];
+	u8 addr[ETH_ALEN];
-	int qfe_slot = -1;
 	int err = -ENODEV;
 
 	/* Now make sure pci_dev cookie is there. */
@@ -2649,7 +2634,7 @@
 	SET_NETDEV_DEV(dev, &pdev->dev);
 
 	hp = netdev_priv(dev);
+
-	hp->dev = dev;
 	hp->happy_dev = pdev;
 	hp->dma_dev = &pdev->dev;
 
@@ -2685,7 +2670,35 @@
 		goto err_out_clear_quattro;
 	}
 
+	for (i = 0; i < 6; i++) {
+		if (macaddr[i] != 0)
+			break;
+	}
+	if (i < 6) { /* a mac address was given */
+		for (i = 0; i < 6; i++)
+			addr[i] = macaddr[i];
+		eth_hw_addr_set(dev, addr);
+		macaddr[5]++;
+	} else {
+#ifdef CONFIG_SPARC
+		const unsigned char *addr;
+		int len;
+
+		if (qfe_slot != -1 &&
+		    (addr = of_get_property(dp, "local-mac-address", &len))
+			!= NULL &&
+		    len == 6) {
+			eth_hw_addr_set(dev, addr);
+		} else {
+			eth_hw_addr_set(dev, idprom->id_ethaddr);
+		}
+#else
+		u8 addr[ETH_ALEN];
+
+		get_hme_mac_nonsparc(pdev, addr);
+		eth_hw_addr_set(dev, addr);
+#endif
+	}
-	happy_meal_addr_init(hp, dp, qfe_slot);
 
 	/* Layout registers. */
 	hp->gregs      = (hpreg_base + 0x0000UL);
@@ -2734,6 +2747,7 @@
 	timer_setup(&hp->happy_timer, happy_meal_timer, 0);
 
 	hp->irq = pdev->irq;
+	hp->dev = dev;
 	dev->netdev_ops = &hme_netdev_ops;
 	dev->watchdog_timeo = 5*HZ;
 	dev->ethtool_ops = &hme_ethtool_ops;
reverted:
--- b/drivers/net/ethernet/sun/sunhme.c
+++ a/drivers/net/ethernet/sun/sunhme.c
@@ -2313,28 +2313,29 @@
 	struct net_device *dev;
 	int i, qfe_slot = -1;
 	u8 addr[ETH_ALEN];
+	int err = -ENODEV;
-	int err;
 
 	sbus_dp = op->dev.parent->of_node;
 
 	/* We can match PCI devices too, do not accept those here. */
 	if (!of_node_name_eq(sbus_dp, "sbus") && !of_node_name_eq(sbus_dp, "sbi"))
+		return err;
-		return -ENODEV;
 
 	if (is_qfe) {
 		qp = quattro_sbus_find(op);
 		if (qp == NULL)
+			goto err_out;
-			return -ENODEV;
 		for (qfe_slot = 0; qfe_slot < 4; qfe_slot++)
 			if (qp->happy_meals[qfe_slot] == NULL)
 				break;
 		if (qfe_slot == 4)
+			goto err_out;
-			return -ENODEV;
 	}
 
+	err = -ENOMEM;
+	dev = alloc_etherdev(sizeof(struct happy_meal));
-	dev = devm_alloc_etherdev(&op->dev, sizeof(struct happy_meal));
 	if (!dev)
+		goto err_out;
-		return -ENOMEM;
 	SET_NETDEV_DEV(dev, &op->dev);
 
 	/* If user did not specify a MAC address specifically, use
@@ -2368,45 +2369,46 @@
 
 	spin_lock_init(&hp->happy_lock);
 
+	err = -ENODEV;
 	if (qp != NULL) {
 		hp->qfe_parent = qp;
 		hp->qfe_ent = qfe_slot;
 		qp->happy_meals[qfe_slot] = dev;
 	}
 
+	hp->gregs = of_ioremap(&op->resource[0], 0,
+			       GREG_REG_SIZE, "HME Global Regs");
+	if (!hp->gregs) {
-	hp->gregs = devm_platform_ioremap_resource(op, 0);
-	if (IS_ERR(hp->gregs)) {
 		dev_err(&op->dev, "Cannot map global registers.\n");
+		goto err_out_free_netdev;
-		err = PTR_ERR(hp->gregs);
-		goto err_out_clear_quattro;
 	}
 
+	hp->etxregs = of_ioremap(&op->resource[1], 0,
+				 ETX_REG_SIZE, "HME TX Regs");
+	if (!hp->etxregs) {
-	hp->etxregs = devm_platform_ioremap_resource(op, 1);
-	if (IS_ERR(hp->etxregs)) {
 		dev_err(&op->dev, "Cannot map MAC TX registers.\n");
+		goto err_out_iounmap;
-		err = PTR_ERR(hp->etxregs);
-		goto err_out_clear_quattro;
 	}
 
+	hp->erxregs = of_ioremap(&op->resource[2], 0,
+				 ERX_REG_SIZE, "HME RX Regs");
+	if (!hp->erxregs) {
-	hp->erxregs = devm_platform_ioremap_resource(op, 2);
-	if (IS_ERR(hp->erxregs)) {
 		dev_err(&op->dev, "Cannot map MAC RX registers.\n");
+		goto err_out_iounmap;
-		err = PTR_ERR(hp->erxregs);
-		goto err_out_clear_quattro;
 	}
 
+	hp->bigmacregs = of_ioremap(&op->resource[3], 0,
+				    BMAC_REG_SIZE, "HME BIGMAC Regs");
+	if (!hp->bigmacregs) {
-	hp->bigmacregs = devm_platform_ioremap_resource(op, 3);
-	if (IS_ERR(hp->bigmacregs)) {
 		dev_err(&op->dev, "Cannot map BIGMAC registers.\n");
+		goto err_out_iounmap;
-		err = PTR_ERR(hp->bigmacregs);
-		goto err_out_clear_quattro;
 	}
 
+	hp->tcvregs = of_ioremap(&op->resource[4], 0,
+				 TCVR_REG_SIZE, "HME Tranceiver Regs");
+	if (!hp->tcvregs) {
-	hp->tcvregs = devm_platform_ioremap_resource(op, 4);
-	if (IS_ERR(hp->tcvregs)) {
 		dev_err(&op->dev, "Cannot map TCVR registers.\n");
+		goto err_out_iounmap;
-		err = PTR_ERR(hp->tcvregs);
-		goto err_out_clear_quattro;
 	}
 
 	hp->hm_revision = of_getintprop_default(dp, "hm-rev", 0xff);
@@ -2426,12 +2428,13 @@
 	hp->happy_bursts = of_getintprop_default(sbus_dp,
 						 "burst-sizes", 0x00);
 
+	hp->happy_block = dma_alloc_coherent(hp->dma_dev,
+					     PAGE_SIZE,
+					     &hp->hblock_dvma,
+					     GFP_ATOMIC);
+	err = -ENOMEM;
+	if (!hp->happy_block)
+		goto err_out_iounmap;
-	hp->happy_block = dmam_alloc_coherent(&op->dev, PAGE_SIZE,
-					      &hp->hblock_dvma, GFP_KERNEL);
-	if (!hp->happy_block) {
-		err = -ENOMEM;
-		goto err_out_clear_quattro;
-	}
 
 	/* Force check of the link first time we are brought up. */
 	hp->linkcheck = 0;
@@ -2469,10 +2472,10 @@
 	happy_meal_set_initial_advertisement(hp);
 	spin_unlock_irq(&hp->happy_lock);
 
+	err = register_netdev(hp->dev);
-	err = devm_register_netdev(&op->dev, dev);
 	if (err) {
 		dev_err(&op->dev, "Cannot register net device, aborting.\n");
+		goto err_out_free_coherent;
-		goto err_out_clear_quattro;
 	}
 
 	platform_set_drvdata(op, hp);
@@ -2487,9 +2490,31 @@
 
 	return 0;
 
+err_out_free_coherent:
+	dma_free_coherent(hp->dma_dev,
+			  PAGE_SIZE,
+			  hp->happy_block,
+			  hp->hblock_dvma);
+
+err_out_iounmap:
+	if (hp->gregs)
+		of_iounmap(&op->resource[0], hp->gregs, GREG_REG_SIZE);
+	if (hp->etxregs)
+		of_iounmap(&op->resource[1], hp->etxregs, ETX_REG_SIZE);
+	if (hp->erxregs)
+		of_iounmap(&op->resource[2], hp->erxregs, ERX_REG_SIZE);
+	if (hp->bigmacregs)
+		of_iounmap(&op->resource[3], hp->bigmacregs, BMAC_REG_SIZE);
+	if (hp->tcvregs)
+		of_iounmap(&op->resource[4], hp->tcvregs, TCVR_REG_SIZE);
+
-err_out_clear_quattro:
 	if (qp)
 		qp->happy_meals[qfe_slot] = NULL;
+
+err_out_free_netdev:
+	free_netdev(dev);
+
+err_out:
 	return err;
 }
 #endif
@@ -2866,6 +2891,28 @@
 	return happy_meal_sbus_probe_one(op, is_qfe);
 }
 
+static void hme_sbus_remove(struct platform_device *op)
+{
+	struct happy_meal *hp = platform_get_drvdata(op);
+	struct net_device *net_dev = hp->dev;
+
+	unregister_netdev(net_dev);
+
+	of_iounmap(&op->resource[0], hp->gregs, GREG_REG_SIZE);
+	of_iounmap(&op->resource[1], hp->etxregs, ETX_REG_SIZE);
+	of_iounmap(&op->resource[2], hp->erxregs, ERX_REG_SIZE);
+	of_iounmap(&op->resource[3], hp->bigmacregs, BMAC_REG_SIZE);
+	of_iounmap(&op->resource[4], hp->tcvregs, TCVR_REG_SIZE);
+	dma_free_coherent(hp->dma_dev,
+			  PAGE_SIZE,
+			  hp->happy_block,
+			  hp->hblock_dvma);
+
+	free_netdev(net_dev);
+
+	/*return 0;*/
+}
+
 static const struct of_device_id hme_sbus_match[] = {
 	{
 		.name = "SUNW,hme",
@@ -2889,6 +2936,7 @@
 		.of_match_table = hme_sbus_match,
 	},
 	.probe		= hme_sbus_probe,
+	.remove		= hme_sbus_remove,
 };
 
 static int __init happy_meal_sbus_init(void)
