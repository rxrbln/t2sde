# --- ROCK-COPYRIGHT-NOTE-BEGIN ---
# 
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# Please add additional copyright information _after_ the line containing
# the ROCK-COPYRIGHT-NOTE-END tag. Otherwise it might get removed by
# the ./scripts/Create-CopyPatch script. Do not edit this copyright text!
# 
# ROCK Linux: rock-src/package/tsa/slrn/collapse_subthread.patch
# ROCK Linux is Copyright (C) 1998 - 2003 Clifford Wolf
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version. A copy of the GNU General Public
# License can be found at Documentation/COPYING.
# 
# Many people helped and are helping developing ROCK Linux. Please
# have a look at http://www.rocklinux.org/ and the Documentation/TEAM
# file for details.
# 
# --- ROCK-COPYRIGHT-NOTE-END ---

--- ./src/art.c	Fri Sep 13 19:52:44 2002
+++ ./src/art.c	Sat Sep 14 14:39:25 2002
@@ -4575,9 +4575,81 @@
 
 /*}}}*/
 
+void slrn_uncollapse_this_subthread (Slrn_Header_Type *h, int sync_linenum) /*{{{*/
+{
+   Slrn_Header_Type *child;
+   int back = 0;
+
+   while ((h->parent != NULL) && (h->prev != NULL) && (h->sister == NULL))
+     {
+	/* Special case: rightmost child has no "sister" reference, so we
+	 * check backwards for a sister reference in the leftmost child
+	 * (h->parent->child is guaranteed as not NULL).
+	 */
+        if (h->parent->child->sister != NULL) break;
+	
+	h = h->prev;
+	back++;
+     }
+
+   if ((child = h->child) == NULL) return;
+   if (0 == (child->flags & HEADER_HIDDEN)) return;
+
+   for_this_family (child, uncollapse_header);
+
+   if (sync_linenum)
+     {
+       Slrn_Full_Screen_Update = 1;
+       Slrn_Current_Header = h;
+       Slrn_Header_Window.current_line = (SLscroll_Type *) h;
+       Slrn_Header_Window.line_num -= back;
+       Slrn_Header_Window.num_lines += h->num_children;
+     }
+
+  _art_Threads_Collapsed = -1; 
+}
+
+/*}}}*/
+
+void slrn_collapse_this_subthread (Slrn_Header_Type *h, int sync_linenum) /*{{{*/
+{
+   Slrn_Header_Type *child;
+   int back = 0;
+
+   while ((h->parent != NULL) && (h->prev != NULL) && (h->sister == NULL))
+     {
+	/* Special case: rightmost child has no "sister" reference, so we
+	 * check backwards for a sister reference in the leftmost child
+	 * (h->parent->child is guaranteed as not NULL).
+	 */
+        if (h->parent->child->sister != NULL) break;
+	
+        h = h->prev;
+        back++;
+     }
+
+   if ((child = h->child) == NULL) return;
+   if (child->flags & HEADER_HIDDEN) return;
+   
+   for_this_family (child, collapse_header);
+
+   if (sync_linenum)
+     {
+        Slrn_Full_Screen_Update = 1;
+        Slrn_Current_Header = h;
+        Slrn_Header_Window.current_line = (SLscroll_Type *) h;
+        Slrn_Header_Window.line_num -= back;
+        Slrn_Header_Window.num_lines -= h->num_children;
+     }
+
+   _art_Threads_Collapsed = -1;        /* uncertain */
+}
+
+/*}}}*/
+
 static void toggle_collapse_threads (void) /*{{{*/
 {
-   if (Slrn_Prefix_Arg_Ptr != NULL)
+   if ((Slrn_Prefix_Arg_Ptr != NULL) && (*Slrn_Prefix_Arg_Ptr == 1))
      {
 	if (_art_Threads_Collapsed == 1)
 	  {
@@ -4586,6 +4658,15 @@
 	else slrn_collapse_threads (0);
 	Slrn_Prefix_Arg_Ptr = NULL;
      }
+   else if ((Slrn_Prefix_Arg_Ptr != NULL) && (*Slrn_Prefix_Arg_Ptr == 2))
+     {
+	if (0 == slrn_is_subthread_collapsed (Slrn_Current_Header))
+	  slrn_collapse_this_subthread (Slrn_Current_Header, 0);
+	else
+	  slrn_uncollapse_this_subthread (Slrn_Current_Header, 0);
+
+	find_non_hidden_header ();
+     }
    else
      {
 	if (0 == slrn_is_thread_collapsed (Slrn_Current_Header))
@@ -4610,6 +4691,13 @@
 {
    if (h == NULL) return 1;
    while (h->parent != NULL) h = h->parent;
+   if (h->child == NULL) return 0;
+   return (h->child->flags & HEADER_HIDDEN);
+}
+
+int slrn_is_subthread_collapsed (Slrn_Header_Type *h)
+{
+   if (h == NULL) return 1;
    if (h->child == NULL) return 0;
    return (h->child->flags & HEADER_HIDDEN);
 }
diff -ur slrn/src/art.h slrn.subthreads/src/art.h
--- slrn/src/art.h	Fri Sep 13 19:52:44 2002
+++ slrn.subthreads/src/art.h	Fri Sep 13 19:54:52 2002
@@ -226,6 +226,7 @@
 extern void slrn_uncollapse_this_thread (Slrn_Header_Type *, int);
 extern unsigned int slrn_thread_size (Slrn_Header_Type *);
 extern int slrn_is_thread_collapsed (Slrn_Header_Type *);
+extern int slrn_is_subthread_collapsed (Slrn_Header_Type *);
 
 extern int slrn_next_unread_header (void);
 extern int slrn_goto_num_tagged_header (int *);
diff -ur slrn/src/help.c slrn.subthreads/src/help.c
--- slrn/src/help.c	Fri Sep 13 19:52:44 2002
+++ slrn.subthreads/src/help.c	Fri Sep 13 19:54:52 2002
@@ -135,6 +135,7 @@
    N_("Header window commands:"),
    N_("  ESC t              Collapse / Uncollapse thread."),
    N_("      ESC 1 ESC t    Collapse / Uncollapse all threads."),
+   N_("      ESC 2 ESC t    Collapse / Uncollapse current sub-thread."),
    N_("  ESC a              Toggle between header display formats."),
    N_("  ESC s              Select threading and sorting method."),
    N_("Miscellaneous actions:"),
diff -ur slrn/src/interp.c slrn.subthreads/src/interp.c
--- slrn/src/interp.c	Fri Sep 13 19:52:45 2002
+++ slrn.subthreads/src/interp.c	Fri Sep 13 19:54:52 2002
@@ -983,6 +983,18 @@
      slrn_uncollapse_this_thread (Slrn_Current_Header, 1);
 }
 
+static void collapse_subthread (void)
+{
+   if (0 == check_article_mode())
+     slrn_collapse_this_subthread (Slrn_Current_Header, 1);
+}
+
+static void uncollapse_subthread (void)
+{
+   if (0 == check_article_mode())
+     slrn_uncollapse_this_subthread (Slrn_Current_Header, 1);
+}
+
 static int thread_size (void)
 {
    if (check_article_mode ()) return -1;
@@ -1001,6 +1013,12 @@
    return slrn_is_thread_collapsed (Slrn_Current_Header);
 }
 
+static int is_subthread_collapsed (void)
+{
+   if (check_article_mode ()) return -1;
+   return slrn_is_subthread_collapsed (Slrn_Current_Header);
+}
+
 static int header_down (int *num) /*{{{*/
 {
    if ((-1 == check_article_mode ())
@@ -1429,6 +1447,7 @@
    MAKE_INTRINSIC_S("call", slrn_call_command, SLANG_VOID_TYPE),
    MAKE_INTRINSIC_0("collapse_thread", collapse_thread, SLANG_VOID_TYPE),
    MAKE_INTRINSIC_0("collapse_threads", collapse_threads, SLANG_VOID_TYPE),
+   MAKE_INTRINSIC_0("collapse_subthread", collapse_subthread, SLANG_VOID_TYPE),
    MAKE_INTRINSIC_0("current_newsgroup", current_group_name, SLANG_STRING_TYPE),
    MAKE_INTRINSIC_S("datestring_to_unixtime", slrn_date_to_order_parm, SLANG_INT_TYPE),
    MAKE_INTRINSIC_SSS("definekey", definekey, SLANG_VOID_TYPE),
@@ -1464,6 +1483,7 @@
    MAKE_INTRINSIC_0("is_article_window_zoomed", slrn_is_article_win_zoomed, SLANG_INT_TYPE),
    MAKE_INTRINSIC_0("is_group_mode", is_group_mode, SLANG_INT_TYPE),
    MAKE_INTRINSIC_0("is_thread_collapsed", is_thread_collapsed, SLANG_INT_TYPE),
+   MAKE_INTRINSIC_0("is_subthread_collapsed", is_subthread_collapsed, SLANG_INT_TYPE),
    MAKE_INTRINSIC_S("make_home_filename", make_home_filename, SLANG_VOID_TYPE),
    MAKE_INTRINSIC_0("next_tagged_header", slrn_next_tagged_header, SLANG_INT_TYPE),
    MAKE_INTRINSIC_S("pipe_article", pipe_article_cmd, SLANG_VOID_TYPE),
@@ -1518,6 +1538,7 @@
    MAKE_INTRINSIC_S("tt_send", tt_send, SLANG_VOID_TYPE),
    MAKE_INTRINSIC_0("uncollapse_thread", uncollapse_thread, SLANG_VOID_TYPE),
    MAKE_INTRINSIC_0("uncollapse_threads", uncollapse_threads, SLANG_VOID_TYPE),
+   MAKE_INTRINSIC_0("uncollapse_subthread", uncollapse_subthread, SLANG_VOID_TYPE),
    MAKE_INTRINSIC_SS("undefinekey", undefinekey, SLANG_VOID_TYPE),
    MAKE_INTRINSIC_I("ungetkey", ungetkey, SLANG_VOID_TYPE),
    MAKE_INTRINSIC_SS("unregister_hook", slrn_unregister_hook_by_name, SLANG_INT_TYPE),
