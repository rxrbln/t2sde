# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../yaboot/link_with_new_e2fsprogs.patch
# Copyright (C) 2015 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

From cf53e4804fb8862bf6ac6564ba5fa458bf3c0600 Mon Sep 17 00:00:00 2001
From: Tony Breeds <tony@bakeyournoodle.com>
Date: Tue, 12 Jun 2012 15:19:02 +1000
Subject: [PATCH] Add more libc helper functions for e2fsprogs.

I've added debug() statements for all of the stub functions.  So if
things get "strange" we at least know we've been playing around in this
backwater.

Portions of this patch are based on the work by Joseph Jezak <josejx@gentoo.org>
specifically the *_chk() functions.

Signed-off-by: Tony Breeds <tony@bakeyournoodle.com>
---
 include/nonstd.h |   48 +++++++++++-
 lib/malloc.c     |    7 ++
 lib/nonstd.c     |  235 ++++++++++++++++++++++++++++++++++++++++++++++++++++-
 3 files changed, 284 insertions(+), 6 deletions(-)

diff --git a/include/nonstd.h b/include/nonstd.h
index bad5f48..a967380 100644
--- a/include/nonstd.h
+++ b/include/nonstd.h
@@ -22,14 +22,60 @@
 #ifndef NONSTD_H
 #define NONSTD_H
 
+/* Copied from asm-generic/errno-base.h */
+#define	EPERM		 1	/* Operation not permitted */
+#define	EBADF		 9	/* Bad file number */
+#define	EACCES		13	/* Permission denied */
+
 typedef int FILE;
 
+typedef unsigned int uid_t;
+typedef int pid_t;
+typedef unsigned int mode_t;
+typedef int ssize_t;
+typedef long long off64_t;
+typedef long off_t;
+
+struct stat;
+struct timezone;
+struct timeval;
+
 extern FILE *stdout;
+extern FILE *stderr;
 
 int printf(const char *format, ...);
 int fprintf(FILE *stream, const char *format, ...);
 int fputs(const char *s, FILE *stream);
 int fflush(FILE *stream);
 char *getenv(const char *name);
-
+int gethostname(char *name, size_t len);
+int gettimeofday(struct timeval *tv, struct timezone *tz);
+int * __errno_location(void);
+unsigned int sleep(unsigned int seconds);
+int rand(void);
+void srand(unsigned int seed);
+long int random(void);
+void srandom(unsigned int seed);
+uid_t geteuid(void);
+uid_t getuid(void);
+pid_t getpid(void);
+int stat(const char *path, struct stat *buf);
+int stat64(const char *path, struct stat *buf);
+int fstat(int fd, struct stat *buf);
+int fstat64(int fd, struct stat *buf);
+int open(const char *pathname, int flags, mode_t mode);
+int open64(const char *pathname, int flags, mode_t mode);
+off_t lseek(int fd, off_t offset, int whence);
+off64_t lseek64(int fd, off64_t offset, int whence);
+ssize_t read(int fildes, void *buf, size_t nbyte);
+int close(int fd);
+void *calloc(size_t nmemb, size_t size);
+void perror(const char *s);
+void exit(int status);
+int ioctl(int d, int request, ...);
+size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
+long sysconf(int name);
+int getpagesize(void);
+void qsort(void *base, size_t nmemb, size_t size,
+           int(*compar)(const void *, const void *));
 #endif
diff --git a/lib/malloc.c b/lib/malloc.c
index 0121112..b21490c 100644
--- a/lib/malloc.c
+++ b/lib/malloc.c
@@ -107,6 +107,13 @@ int posix_memalign(void **memptr, size_t alignment, size_t size)
     return 0;
 }
 
+void *calloc(size_t nmemb, size_t size)
+{
+	unsigned char *p = malloc(nmemb * size);
+	memset(p, 0x0, nmemb * size);
+	return p;
+}
+
 void *realloc(void *ptr, unsigned int size)
 {
     char *caddr, *oaddr = ptr;
diff --git a/lib/nonstd.c b/lib/nonstd.c
index 5aeb0cb..6549283 100644
--- a/lib/nonstd.c
+++ b/lib/nonstd.c
@@ -23,11 +23,142 @@
 #include "types.h"
 #include "stddef.h"
 #include "stdlib.h"
+#include "string.h"
 #include "ctype.h"
 #include "prom.h"
 #include "nonstd.h"
+#include "debug.h"
 
-FILE *stdout;
+#define	__unused	__attribute__((unused))
+
+static FILE _stdout;
+static FILE _stderr;
+FILE *stdout = &_stdout;
+FILE *stderr = &_stderr;
+
+static int fake_errno;
+
+int * __errno_location(void)
+{
+	DEBUG_F("Stub function called");
+	return &fake_errno;
+}
+
+uid_t geteuid(void)
+{
+	DEBUG_F("Stub function called");
+	return 0;
+}
+
+uid_t getuid(void)
+{
+	DEBUG_F("Stub function called");
+	return 0;
+}
+
+pid_t getpid(void)
+{
+	DEBUG_F("Stub function called");
+	return 1;
+}
+
+/* selected by roll of a six sided dice ... that's random right? */
+int rand(void)
+{
+	DEBUG_F("Stub function called");
+	return 4;
+}
+
+void srand(unsigned int seed __unused)
+{
+	DEBUG_F("Stub function called");
+}
+
+long int random(void)
+{
+	DEBUG_F("Stub function called");
+	return 4;
+}
+
+void srandom(unsigned int seed __unused)
+{
+	DEBUG_F("Stub function called");
+}
+
+unsigned int sleep(unsigned int seconds)
+{
+	prom_sleep(seconds);
+	return 0;
+}
+
+int stat(const char *path __unused, struct stat *buf __unused)
+{
+	DEBUG_F("Stub function called");
+	return EACCES;
+}
+
+int stat64(const char *path __unused, struct stat *buf __unused)
+{
+	DEBUG_F("Stub function called");
+	return EACCES;
+}
+
+int fstat(int fd __unused, struct stat *buf __unused)
+{
+	DEBUG_F("Stub function called");
+	return EBADF;
+}
+
+int fstat64(int fd __unused, struct stat *buf __unused)
+{
+	DEBUG_F("Stub function called");
+	return EBADF;
+}
+
+int open(const char *pathname, int flags __unused, mode_t mode __unused)
+{
+	return (int) prom_open((char *)pathname);
+}
+
+int open64(const char *pathname, int flags __unused, mode_t mode __unused)
+{
+	return (int) prom_open((char *)pathname);
+}
+
+off_t lseek(int fd __unused, off_t offset __unused, int whence __unused)
+{
+	DEBUG_F("Stub function called");
+	return EBADF;
+}
+
+off64_t lseek64(int fd __unused, off64_t offset __unused, int whence __unused)
+{
+	DEBUG_F("Stub function called");
+	return EBADF;
+}
+
+ssize_t read(int filedes, void *buf, size_t nbyte)
+{
+	return prom_read((void *)filedes, buf, nbyte);
+}
+
+int close(int fd __unused)
+{
+	prom_close((void *)fd);
+	return 0;
+}
+
+int gethostname(char *name __unused, size_t len __unused)
+{
+	DEBUG_F("Stub function called");
+	return EPERM;
+}
+
+int gettimeofday(struct timeval *tv __unused, struct timezone *tz __unused)
+{
+	DEBUG_F("Stub function called");
+	return EPERM;
+}
 
 int printf(const char *format, ...)
 {
@@ -39,7 +170,7 @@ int printf(const char *format, ...)
 	return 0;
 }
 
-int fprintf(FILE *stream, const char *format, ...)
+int fprintf(FILE *stream __unused, const char *format, ...)
 {
 	va_list ap;
 	va_start (ap, format);
@@ -49,19 +180,113 @@ int fprintf(FILE *stream, const char *format, ...)
 	return 0;
 }
 
-int fputs(const char *s, FILE *stream)
+int fputs(const char *s, FILE *stream __unused)
 {
 	prom_printf("%s", s);
 
 	return 0;
 }
 
-int fflush(FILE *stream)
+int fflush(FILE *stream __unused)
 {
+	DEBUG_F("Stub function called");
 	return 0;
 }
 
-char *getenv(const char *name)
+char *getenv(const char *name __unused)
 {
+	DEBUG_F("Stub function called");
 	return NULL;
 }
+
+int __printf_chk(int flag __unused, const char *format, ...)
+{
+	va_list ap;
+	va_start (ap, format);
+	prom_vfprintf (prom_stdout, format, ap);
+	va_end (ap);
+
+	DEBUG_F("Stub function called");
+	return 0;
+}
+
+int __sprintf_chk(char *str __unused, int flag __unused,
+                  size_t strlen __unused, const char * format __unused, ...)
+{
+	DEBUG_F("Stub function called");
+	return 0;
+
+}
+
+int __fprintf_chk(FILE *stream __unused, int flag __unused,
+                  const char *format, ...)
+{
+	va_list ap;
+	va_start (ap, format);
+	prom_vfprintf (prom_stdout, format, ap);
+	va_end (ap);
+
+	return 0;
+}
+
+void *__memcpy_chk(void *dest, const void *src, size_t n,
+                   size_t destlen __unused)
+{
+	DEBUG_F("Stub function called");
+	/* FIXME: We really could check that dest+destlen < src, to ensure
+	 * we're not overwriting the src */
+	return memcpy(dest, src, n);
+}
+
+void perror(const char *s)
+{
+	DEBUG_F("Stub function called");
+	prom_printf(s);
+}
+
+void exit(int status __unused)
+{
+	prom_exit();
+	for(;;);
+}
+
+int ioctl(int d __unused, int request __unused, ...)
+{
+	DEBUG_F("Stub function called");
+	return 0;
+}
+
+/* As we do not implement fopen() I think we're only going to get called
+ * with stdout and stderr.  If that's the case we degenerate to prom_write()
+ * on stdout */
+size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)
+{
+	if ((stream == stdout) || (stream == stderr)) {
+		DEBUG_F("Stub function called on known stream");
+		prom_write(prom_stdout, (void *)ptr, size * nmemb);
+	} else {
+		DEBUG_F("Stub function called on unknown stream");
+	}
+	return nmemb;
+}
+
+long sysconf(int name __unused)
+{
+	DEBUG_F("Stub function called");
+	return -1;
+}
+
+int getpagesize(void)
+{
+	DEBUG_F("Stub function called");
+	/* I think this is safe to assume */
+	return 4096;
+}
+
+void qsort(void *base __unused, size_t nmemb __unused, size_t size __unused,
+           int(*compar)(const void *, const void *))
+{
+	DEBUG_F("Stub function called");
+	/* I'm quite nervous about not implementing this.  Could we end up with
+	 * disk corruption.  Couldn't we? */
+}
-- 
1.7.7.6

