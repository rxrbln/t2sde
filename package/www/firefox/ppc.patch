# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../firefox/ppc.patch
# Copyright (C) 2020 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

--- firefox-81.0.2/js/src/gc/GC.cpp.vanilla	2020-10-16 17:56:10.646378448 +0200
+++ firefox-81.0.2/js/src/gc/GC.cpp	2020-10-16 17:56:21.090378391 +0200
@@ -292,8 +292,10 @@
               "CellFlagBitsReservedForGC should support LifoAlloc");
 static_assert(CellAlignBytes >= MinFirstWordAlignment,
               "CellFlagBitsReservedForGC should support gc::Cell");
+#ifndef JS_CODEGEN_NONE
 static_assert(js::jit::CodeAlignment >= MinFirstWordAlignment,
               "CellFlagBitsReservedForGC should support JIT code");
+#endif
 static_assert(js::gc::JSClassAlignBytes >= MinFirstWordAlignment,
               "CellFlagBitsReservedForGC should support JSClass pointers");
 static_assert(js::ScopeDataAlignBytes >= MinFirstWordAlignment,
--- firefox-81.0.2/xpcom/reflect/xptcall/md/unix/xptcinvoke_ppc_linux.cpp.vanilla	2020-10-16 17:40:11.138383612 +0200
+++ firefox-81.0.2/xpcom/reflect/xptcall/md/unix/xptcinvoke_ppc_linux.cpp	2020-10-16 17:57:09.014378133 +0200
@@ -45,11 +45,11 @@
     uint64_t tempu64;
 
     for(uint32_t i = 0; i < paramCount; i++, s++) {
-        if(s->IsPtrData()) {
+        if(s->IsIndirect()) {
             if(s->type == nsXPTType::T_JSVAL)
-                tempu32 = (uint32_t) &s->ptr;
+                tempu32 = (uint32_t) &s->val;
             else
-                tempu32 = (uint32_t) s->ptr;
+                tempu32 = (uint32_t) &s->val;
         }
         else {
             switch(s->type) {
@@ -70,7 +70,7 @@
             }
         }
 
-        if (!s->IsPtrData() && s->type == nsXPTType::T_DOUBLE) {
+        if (!s->IsIndirect() && s->type == nsXPTType::T_DOUBLE) {
 #ifndef __NO_FPRS__
             if (fpr < FPR_COUNT)
                 fpregs[fpr++]    = s->val.d;
@@ -88,7 +88,7 @@
                 d += 2;
             }
         }
-        else if (!s->IsPtrData() && s->type == nsXPTType::T_FLOAT) {
+        else if (!s->IsIndirect() && s->type == nsXPTType::T_FLOAT) {
 #ifndef __NO_FPRS__
             if (fpr < FPR_COUNT)
                 fpregs[fpr++]   = s->val.f; // if passed in registers, floats are promoted to doubles
@@ -99,7 +99,7 @@
             else
                 *((float*) d++) = s->val.f;
         }
-        else if (!s->IsPtrData() && (s->type == nsXPTType::T_I64
+        else if (!s->IsIndirect() && (s->type == nsXPTType::T_I64
                                      || s->type == nsXPTType::T_U64)) {
             if (gpr & 1) gpr++; // longlongs are aligned in odd/even register pairs, eg. r5/r6
             if ((gpr + 1) < GPR_COUNT) {
