# --- ROCK-COPYRIGHT-NOTE-BEGIN ---
# 
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# Please add additional copyright information _after_ the line containing
# the ROCK-COPYRIGHT-NOTE-END tag. Otherwise it might get removed by
# the ./scripts/Create-CopyPatch script. Do not edit this copyright text!
# 
# ROCK Linux: rock-src/package/jimmy/ne/cancel-number.patch
# ROCK Linux is Copyright (C) 1998 - 2003 Clifford Wolf
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version. A copy of the GNU General Public
# License can be found at Documentation/COPYING.
# 
# Many people helped and are helping developing ROCK Linux. Please
# have a look at http://www.rocklinux.org/ and the Documentation/TEAM
# file for details.
# 
# --- ROCK-COPYRIGHT-NOTE-END ---

--- ./src/actions.c.orig	2001-09-01 00:32:32.000000000 +0300
+++ ./src/actions.c	2003-02-02 15:39:29.000000000 +0200
@@ -44,6 +44,12 @@
 }
 
 
+/* This macro converts a non-positive result from request_number() to OK if the
+function was aborted or not-a-number error if an invalid number was read. */
+
+#define NUMERIC_ERROR(c) ((c) == ABORT ? OK : NOT_A_NUMBER)
+
+
 
 
 /* This is the vector table through which all actions which have some effect
@@ -218,13 +224,13 @@
 			return(BOOKMARK_OUT_OF_RANGE);
 
 		case GOTOLINE_A:
-			if (c<0 && (c = request_number("Line", b->cur_line+1))<0) return NOT_A_NUMBER;
+			if (c<0 && (c = request_number("Line", b->cur_line+1))<0) return NUMERIC_ERROR(c);
 			if (c == 0 || c>b->line_num) c = b->line_num;
 			goto_line(b, --c);
 			return(OK);
 
 		case GOTOCOLUMN_A:
-			if (c<0 && (c = request_number("Column", b->cur_x+b->win_x+1))<0) return NOT_A_NUMBER;
+			if (c<0 && (c = request_number("Column", b->cur_x+b->win_x+1))<0) return NUMERIC_ERROR(c);
 			goto_column(b, c ? --c : 0);
 			return(OK);
 
@@ -253,7 +259,7 @@
 		   	static int last_ic = 32;
 				if (b->opt.read_only) return(FILE_IS_READ_ONLY);
 
-				if (c<0 && (c = request_number("Char Code", last_ic))<0) return NOT_A_NUMBER;
+				if (c<0 && (c = request_number("Char Code", last_ic))<0) return NUMERIC_ERROR(c);
 				if (c == 0) return(CANT_INSERT_0);
 				if (c > 255) return(ERROR);
          	last_ic = c;
@@ -604,7 +610,7 @@
 			return(OK);
 
 		case ESCAPETIME_A:
-			if (c<0 && (c = request_number("Timeout (1/10s)", -1))<0) return NOT_A_NUMBER;
+			if (c<0 && (c = request_number("Timeout (1/10s)", -1))<0) return NUMERIC_ERROR(c);
 			if (c < 256) {
 				set_escape_time(c);
 				return(OK);
@@ -612,7 +618,7 @@
 			else return(ESCAPE_TIME_OUT_OF_RANGE);
 
 		case TABSIZE_A:
-			if (c<0 && (c = request_number("TAB Size", b->opt.tab_size))<=0) return NOT_A_NUMBER;
+			if (c<0 && (c = request_number("TAB Size", b->opt.tab_size))<=0) return NUMERIC_ERROR(c);
 			if (c<ne_columns/2) {
 				move_to_sol(b);
 				b->opt.tab_size = c;
@@ -622,17 +628,17 @@
 			return(TAB_SIZE_OUT_OF_RANGE);
 
 		case TURBO_A:
-			if (c<0 && (c = request_number("Turbo Threshold", turbo))<0) return NOT_A_NUMBER;
+			if (c<0 && (c = request_number("Turbo Threshold", turbo))<0) return NUMERIC_ERROR(c);
 			turbo = c;
 			return(OK);
 
 		case CLIPNUMBER_A:
-			if (c<0 && (c = request_number("Clip Number", b->opt.cur_clip))<0) return NOT_A_NUMBER;
+			if (c<0 && (c = request_number("Clip Number", b->opt.cur_clip))<0) return NUMERIC_ERROR(c);
 			b->opt.cur_clip = c;
 			return(OK);
 
 		case RIGHTMARGIN_A:
-			if (c<0 && (c = request_number("Right Margin", b->opt.right_margin))<0) return NOT_A_NUMBER;
+			if (c<0 && (c = request_number("Right Margin", b->opt.right_margin))<0) return NUMERIC_ERROR(c);
 			b->opt.right_margin = c;
          return(OK);
 
@@ -722,7 +728,7 @@
 
 		case PLAY_A:
 			if (!b->recording && !b->executing_internal_macro) {
-				if (c<0 && (c = request_number("Times", 1))<=0) return NOT_A_NUMBER;
+				if (c<0 && (c = request_number("Times", 1))<=0) return NUMERIC_ERROR(c);
 				b->executing_internal_macro = 1;
 				for(i=0; i<c && !(error = play_macro(b, b->cur_macro)); i++);
 				b->executing_internal_macro = 0;
--- ./src/errors.h.orig	2001-09-01 00:32:32.000000000 +0300
+++ ./src/errors.h	2003-02-02 15:39:29.000000000 +0200
@@ -37,6 +37,11 @@
 #undef ERROR
 #endif
 
+#ifdef ABORT
+#undef ABORT
+#endif
+
+#define ABORT	(-2)
 #define ERROR	(-1)
 #define OK		(0)
 
--- ./src/input.c.orig	2001-09-01 00:32:32.000000000 +0300
+++ ./src/input.c	2003-02-02 15:39:29.000000000 +0200
@@ -126,7 +126,8 @@
 
 	if (default_value >= 0) sprintf(t, "%d", default_value);
 
-	if (!(result = request(prompt, default_value >= 0 ? t : NULL, FALSE, 0)) || !*result) return(ERROR);
+	if (!(result = request(prompt, default_value >= 0 ? t : NULL, FALSE, 0))) return(ABORT);
+	if (!*result) return(ERROR);
 
 	n = strtol(result, &p, 0);
 
--- ./src/menu.c.orig	2001-09-01 00:32:32.000000000 +0300
+++ ./src/menu.c	2003-02-02 15:39:29.000000000 +0200
@@ -510,7 +510,7 @@
 
 static void do_menu_action(void) {
 	undraw_last_menu();
-	execute_command_line(cur_buffer, menus[current_menu].items[menus[current_menu].cur_item].command_line);
+	print_error(execute_command_line(cur_buffer, menus[current_menu].items[menus[current_menu].cur_item].command_line));
 }
 
 
