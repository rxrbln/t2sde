# --- ROCK-COPYRIGHT-NOTE-BEGIN ---
# 
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# Please add additional copyright information _after_ the line containing
# the ROCK-COPYRIGHT-NOTE-END tag. Otherwise it might get removed by
# the ./scripts/Create-CopyPatch script. Do not edit this copyright text!
# 
# ROCK Linux: rock-src/package/jimmy/zgv/pre-5.7-stuff.patch
# ROCK Linux is Copyright (C) 1998 - 2003 Clifford Wolf
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version. A copy of the GNU General Public
# License can be found at Documentation/COPYING.
# 
# Many people helped and are helping developing ROCK Linux. Please
# have a look at http://www.rocklinux.org/ and the Documentation/TEAM
# file for details.
# 
# --- ROCK-COPYRIGHT-NOTE-END ---

--- ./doc/makeman.awk.orig	2001-09-20 21:59:49.000000000 +0300
+++ ./doc/makeman.awk	2003-07-12 13:59:13.000000000 +0300
@@ -216,7 +216,7 @@
     {
     $0=gensub(/^@itemx?[[:blank:]]+(.*)/, \
     	(first_item[table_lvl]?"":".RE\n") \
-        table_type[table_lvl] "{\\1}\n.RS", 0)
+        table_type[table_lvl] "{\\1}\n.RS", 1)
     }
   
   first_item[table_lvl]=0
@@ -290,8 +290,8 @@
   # @value
   while(/@value\{/)
     {
-    valname=gensub(/.*@value\{([^}]+)\}.*/, "\\1", 0, para)
-    para=gensub(/@value\{([^}]+)\}/, var_value[valname], 0, para)
+    valname=gensub(/.*@value\{([^}]+)\}.*/, "\\1", 1, para)
+    para=gensub(/@value\{([^}]+)\}/, var_value[valname], 1, para)
     }
   
   # @{samp,file,var,cite,emph} -> italic
--- ./doc/zgv.texi.orig	2002-05-05 04:06:54.000000000 +0300
+++ ./doc/zgv.texi	2003-07-12 13:59:13.000000000 +0300
@@ -387,6 +387,14 @@
 If disabled, don't prompt for confirmation when deleting all tagged
 files.
 
+@vindex auto-mode-fit-diff
+@item --auto-mode-fit-diff @var{delta_val}
+When choosing an auto-mode-fit mode, add delta to each mode's width and
+height. For example, with a delta of 20 any picture up to 820x620 will
+be displayed in an 800x600 mode if possible. If delta is negative, for
+example -20, the effect is reverse: any picture above 780x580 will be
+displayed in a mode with a resolution higher than 800x600 if possible.
+
 @vindex dither-16col-fast
 @item --dither-16col-fast
 (Normally enabled, use @code{--dither-16col-fast=off} to disable.) By
--- ./src/mousecur.c.orig	1999-06-28 19:04:11.000000000 +0300
+++ ./src/mousecur.c	2003-07-12 13:59:13.000000000 +0300
@@ -37,9 +37,9 @@
 #define MOUSECUR_YSIZE	16
 #define MOUSECUR_PIXMAP_SIZE	(MOUSECUR_XSIZE*MOUSECUR_YSIZE)
 
-/* next two pixmaps are *3 as must be able to handle up to 24-bit modes */
-static unsigned char mouseptr_save[MOUSECUR_PIXMAP_SIZE*3];
-static unsigned char mouseptr_pixmap[MOUSECUR_PIXMAP_SIZE*3];
+/* next two pixmaps are *4 as must be able to handle up to 32-bpp modes */
+static unsigned char mouseptr_save[MOUSECUR_PIXMAP_SIZE*4];
+static unsigned char mouseptr_pixmap[MOUSECUR_PIXMAP_SIZE*4];
 static unsigned char mouseptr_pixmap_orig[MOUSECUR_PIXMAP_SIZE]=
   {
   /* 1 is black, 2 is white, 0 is transparent */
@@ -94,15 +94,7 @@
 
 if(!has_mouse) return;
 
-switch(cols)
-  {
-  case 16777216:
-    screen_bytepp=3; break;
-  case 65536: case 32768:
-    screen_bytepp=2; break;
-  default:
-    screen_bytepp=1;
-  }
+screen_bytepp=vga_getmodeinfo(mode)->bytesperpixel;
 
 screen_width =vga_getxdim();
 screen_height=vga_getydim();
@@ -139,6 +131,12 @@
   
   switch(screen_bytepp)
     {
+    case 4:
+      mouseptr_pixmap[f*4  ]=(val&255);
+      mouseptr_pixmap[f*4+1]=(val>>8);
+      mouseptr_pixmap[f*4+2]=(val>>16);
+      mouseptr_pixmap[f*4+3]=0;
+      break;
     case 3:
       mouseptr_pixmap[f*3  ]=(val&255);
       mouseptr_pixmap[f*3+1]=(val>>8);
@@ -175,7 +173,7 @@
 /* we need to save existing data, then draw the mouse. */
 if(usegl)
   {
-  /* gl-using 8/15/16/24-bit version */
+  /* gl-using 8/15/16/24/32-bpp version */
   gl_getbox(savex,savey,savew,saveh,mouseptr_save);
   /* since there's no gl_putboxpartmask, and clipping doesn't work for
    * gl_putboxmask, we have to do either masking or clipping ourselves.
--- ./src/options.src.orig	2002-04-07 04:34:12.000000000 +0300
+++ ./src/options.src	2003-07-12 13:59:13.000000000 +0300
@@ -57,6 +57,7 @@
 "contrast"	0	1 1 REQ_ARG	get_double	&cfg.contrast
 "delete-single-prompt" 0 1 1 OPT_ARG 	get_bool_and_inv &cfg.nodelprompt
 "delete-tagged-prompt" 0 1 1 OPT_ARG 	get_bool_and_inv &cfg.nodelprompt_tagged
+"auto-mode-fit-diff"   0 1 1 REQ_ARG	get_int		&cfg.deltamodefit
 "dither-16col-fast" 0	1 1 OPT_ARG	get_bool	&cfg.fastdither16col
 "fake-cols"	0	1 1 OPT_ARG	get_bool	&cfg.fakecols
 "force-fs-16col" 0	1 1 OPT_ARG	get_bool	&cfg.force16fs
--- ./src/rc_config.h.orig	2002-04-07 04:33:25.000000000 +0300
+++ ./src/rc_config.h	2003-07-12 13:59:13.000000000 +0300
@@ -37,6 +37,7 @@
   int bc_order_rev;
   int xzgvkeys;
   int automodefit;
+  int deltamodefit;
   double initial_picgamma;
   int fsmagic;
   int black_bg;
--- ./src/rcfile.c.orig	2002-04-07 04:34:58.000000000 +0300
+++ ./src/rcfile.c	2003-07-12 13:59:13.000000000 +0300
@@ -240,6 +243,7 @@
 cfg.bc_order_rev=0;
 cfg.xzgvkeys=0;
 cfg.automodefit=0;
+cfg.deltamodefit=0;
 cfg.initial_picgamma=1.0;
 cfg.fsmagic=0;
 cfg.black_bg=0;
@@ -676,6 +680,9 @@
 "			(normally enabled, use --delete-tagged-prompt=off to\n"
 "			disable) if *disabled*, don't prompt for confirmation\n"
 "			when deleting tagged files (with `D').\n"
+"	--auto-mode-fit-diff delta_val\n"
+"			Add delta to the width and height of each mode when\n"
+"			doing an auto-mode-fit (default 0, may be negative).\n"
 "	--dither-16col-fast\n"
 "			(normally enabled, use --dither-16col-fast=off to\n"
 "			disable) if *disabled*, use (much) slower but\n"
--- ./src/vgadisp.c.orig	2002-05-05 04:16:12.000000000 +0300
+++ ./src/vgadisp.c	2003-07-12 13:59:13.000000000 +0300
@@ -606,8 +606,9 @@
   h=md_ptr->height;
   
   /* has to be >= pic size, but <= current best-fit mode. */
-  if(w>=width && h>=height && w<=newmode_w && h<=newmode_h)
-    newmode=md_ptr->mode,newmode_w=w,newmode_h=h;
+  if(w+cfg.deltamodefit>=width && h+cfg.deltamodefit>=height)
+    if(w<=newmode_w && h<=newmode_h)
+      newmode=md_ptr->mode,newmode_w=w,newmode_h=h;
   
   /* also track biggest mode as backup in case no mode fits it all. */
   if(w>=bigmode_w && h>=bigmode_h)
