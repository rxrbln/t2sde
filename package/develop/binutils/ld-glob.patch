# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../binutils/ld-glob.patch
# Copyright (C) 2004 - 2020 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

This adds /etc/ld.so.conf globbing to the GNU linker. We need this, since we
also patch the glibc's dynamic linker and the linker needs to be able to
scan the directories, too.

Signed-of-by: Ren√© Rebe <rene@exactcode.de>

--- binutils-2.35/ld/ldelf.c.vanilla	2020-10-06 19:30:24.354063941 +0200
+++ binutils-2.35/ld/ldelf.c	2020-10-06 19:29:55.114064099 +0200
@@ -861,7 +861,7 @@
 	    }
 	  while (c != '\0');
 	}
-      else
+      else /* normal dir (e.g. no include) */
 	{
 	  char *dir = p;
 	  while (*p && *p != '=' && *p != ' ' && *p != '\t' && *p != '\f'
@@ -870,14 +870,45 @@
 
 	  while (p != dir && p[-1] == '/')
 	    --p;
-	  if (info->path == NULL)
+
+	  /* cut trailing comments and such */
+	  p[1] = 0;
+
+	  /* assume path is a pattern - compare with quite equal glibc patch -ReneR */
+	  const unsigned ld_syslen = ld_sysroot ? strlen(ld_sysroot) : 0;
+	  char tmpdir[ld_syslen ? ld_syslen + strlen(dir) + 1 : 0];
+	  if (ld_syslen) snprintf(tmpdir, sizeof(tmpdir), "%s%s", ld_sysroot, dir);
+
+	  glob_t result;
+	  if (glob(ld_syslen ? tmpdir : dir, GLOB_ONLYDIR, NULL, &result) == 0) {
+	    size_t j;
+	    for (j = 0; j < result.gl_pathc; j++)
 	    {
+	      char* x = result.gl_pathv[j] + ld_syslen;
+	      if (info->path == NULL) {
+	        info->alloc = strlen(x) + 256;
+	        info->path = xmalloc (info->alloc);
+	        info->len = 0;
+	      }
+	      else {
+	        if (info->len + 1 + strlen(x) + 1 >= info->alloc) {
+		  info->alloc += strlen(x) + 1 + 256;
+		  info->path = xrealloc (info->path, info->alloc);
+		}
+	        info->path[info->len++] = ':';
+	      }
+	      strcpy (info->path + info->len, x);
+	      info->len += strlen(x);
+
+	    }
+	  } else {
+	    /* error orig. code from binutils - in theory we do not need it? */
+	    if (info->path == NULL) {
 	      info->alloc = p - dir + 1 + 256;
 	      info->path = xmalloc (info->alloc);
 	      info->len = 0;
 	    }
-	  else
-	    {
+	    else {
 	      if (info->len + 1 + (p - dir) >= info->alloc)
 		{
 		  info->alloc += p - dir + 256;
@@ -885,9 +916,11 @@
 		}
 	      info->path[info->len++] = config.rpath_separator;
 	    }
-	  memcpy (info->path + info->len, dir, p - dir);
-	  info->len += p - dir;
-	  info->path[info->len] = '\0';
+	    memcpy (info->path + info->len, dir, p - dir);
+	    info->len += p - dir;
+	    info->path[info->len] = '\0';
+	  }
+	  globfree (&result);
 	}
     }
   while (! feof (f));
