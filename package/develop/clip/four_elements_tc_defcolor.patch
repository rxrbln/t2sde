# --- ROCK-COPYRIGHT-NOTE-BEGIN ---
# 
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# Please add additional copyright information _after_ the line containing
# the ROCK-COPYRIGHT-NOTE-END tag. Otherwise it might get removed by
# the ./scripts/Create-CopyPatch script. Do not edit this copyright text!
# 
# ROCK Linux: rock-src/package/*/clip/four_elements_tc_defcolor.patch
# Copyright (C) 1998 - 2004 ROCK Linux Project
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# 
# --- ROCK-COPYRIGHT-NOTE-END ---

diff -uNdr clip-prg-1.1.8-1/clip/classes/tb_obj.prg clip-prg-1.1.8-1.new/clip/classes/tb_obj.prg
--- clip-prg-1.1.8-1/clip/classes/tb_obj.prg	2004-02-04 18:40:25.000000000 -0300
+++ clip-prg-1.1.8-1.new/clip/classes/tb_obj.prg	2004-02-05 17:40:37.000000000 -0300
@@ -293,49 +293,75 @@
 static func __sayTable
    local visLen,col,colSep,lensep,lenhsep
    local strsep1,strsep2,strseph,scol,len,strings
-   local i,j,k,s,ccc,headsep,strhsep1, x,y
+   local i,j,k,s,ccc,ccs,headsep,strhsep1, x,y
    local heading:=.t., footing:=.t.
 #ifdef DEBUG_CALL
 	outlog(__FILE__,__LINE__,"sayTable")
 #endif
    if ::winbuffer==nil; dispBegin(); endif
 
+   // separators: NIL  don't separate
+   //             ""   empty separation (for cols "" act as NIL)
+   //             *    use those chars
+
+   // heading/footing if at least one has separator defined
    visLen= len(::__colVisible)
    j=0;k=0
    for i=1 to visLen
 	col=::__colVisible[i]
 	headSep:=::__columns[col]:headSep
-	if headSep!=NIL .and. headSep==""
+	//INFO: cleaner to honor the semantic descripted above
+	//if headSep!=NIL .and. headSep==""
+	if headSep==NIL
 	   j++
 	endif
 	headSep:=::__columns[col]:footSep
-	if headSep!=NIL .and. headSep==""
+	//if headSep!=NIL .and. headSep==""
+	if headSep==NIL
 	   k++
 	endif
    next
-   heading := !(j==visLen)
-   footing := !(k==vislen)
+   heading := iif( (j==visLen),::headSep!=NIL, .t. )
+   footing := iif( (k==vislen),::footSep!=NIL, .t. )
    for i=1 to visLen
 	  col=::__colVisible[i]
 	  len=::__columnsLen[col]
 	  colSep:=::__columns[col]:colSep
 	  colsep:=iif(colSep==NIL,::colSep,colSep)
 	  lenSep:=len(colSep)
-	  strsep1:=iif(lenSep>2,substr(colsep,3,1),"")
-	  lenSep:=iif(lenSep==3,3,1)
-	  strsep1:=space(len(strsep1))
-	  strsep2:=substr(colsep,1,2)
-	  strsep2:=space(len(strsep2))
+	  if lenSep>2
+		strsep1:=" "
+		strsep2:="  "
+		lenSep:=3
+	  else
+		strsep1:=""
+		if lenSep==0
+			strsep2:=""
+		else
+			strsep2:=" "
+			lenSep:=1
+		endif
+	  endif
 	  scol=::__whereVisible[i]
 	  len=min(len,::nright-scol-lenSep+len(strSep2))
 	  strings:=::__HeadStrings[col]
-	  ccc:=::__colors[1]
-	  if ::__columns[col]:defColor!=NIL
-		ccc:=::__colors[::__columns[col]:defColor[1]]
-	  endif
+	  // choose heading color
+	  //INFO: the whole header must use defColor[3], including sep.
+	  //      but we can trick this using colorHeading
 	  if ::__columns[col]:colorHeading!=NIL
 		ccc:=::__colors[::__columns[col]:colorHeading]
+	  elseif ::__columns[col]:defColor!=NIL
+		ccc:=::__colors[::__columns[col]:defColor[3]]
+	  else
+	  	ccc:=::__colors[1]
+	  endif
+	  // and heading separator color ;-)
+	  if ::__columns[col]:defColor!=NIL
+		ccs:=::__colors[::__columns[col]:defColor[3]]
+	  else
+	  	ccs:=::__colors[1]
 	  endif
+	  // display strings
 	  for j=1 to len(strings )
 		s=padr(strings[j],len)
 		y := ::nTop+j-1
@@ -343,42 +369,44 @@
 		if ::__columns[col]:colSepH != nil
 			strseph:=substr(::__columns[col]:colSepH,j,1)
 			if ::winbuffer == nil
-				dispOutAt(::nTop+j-1, scol-1,strseph,::__colors[1])
+				dispOutAt(::nTop+j-1, scol-1,strseph,ccs)
 			else
-				winbuf_out_at(::winbuffer,::nTop+j-1, scol-1,strseph,::__colors[1])
+				winbuf_out_at(::winbuffer,::nTop+j-1, scol-1,strseph,ccs)
 			endif
 			x := scol-1 + len(strseph)
 		else
 			if ::winbuffer == nil
-				dispOutAt(::nTop+j-1, scol,strsep1,::__colors[1])
+				dispOutAt(::nTop+j-1, scol,strsep1,ccs)
 			else
-				winbuf_out_at(::winbuffer,::nTop+j-1, scol,strsep1,::__colors[1])
+				winbuf_out_at(::winbuffer,::nTop+j-1, scol,strsep1,ccs)
 			endif
 			x := scol + len(strsep1)
 		endif
 		if ::winbuffer == nil
 			dispOut(s,ccc)
-			dispOut(iif(i<visLen,strSep2,""),::__colors[1])
+			dispOut(iif(i<visLen,strSep2,""),ccs)
 		else
 			winbuf_out_at(::winbuffer,y,x,s,ccc)
 			x += len(s)
-			winbuf_out_at(::winbuffer,y,x,iif(i<visLen,strSep2,""),::__colors[1])
+			winbuf_out_at(::winbuffer,y,x,iif(i<visLen,strSep2,""),ccs)
 			x += len(iif(i<visLen,strSep2,""))
 		endif
 		if i==visLen
 			if ::winbuffer == nil
-				dispout(space(::nRight-col()+1),::__colors[1])
+				dispout(space(::nRight-col()+1),ccs)
 			else
-				winbuf_out_at(::winbuffer,y,x,space(::nRight-col()+1),::__colors[1])
+				winbuf_out_at(::winbuffer,y,x,space(::nRight-col()+1),ccs)
 			endif
 		endif
 	next
+	// heading separator
 	headSep:=::__columns[col]:headSep
 	headSep:=iif(headSep==NIL,::headSep,headSep)
 	lenHSep=len(headSep)
-	strhsep1=right(headsep,1)
 	j:=len(strings)
-	if heading .and. ((j>0 .and. lenHSep>0 ) .or. !empty(::headSep))
+	if heading 
+		if headSep != ""
+		strhsep1=right(headsep,1)
 		if ::__columns[col]:colSepH != nil .and. len(::__columns[col]:colSepH)>j
 			strseph:=substr(::__columns[col]:colSepH,j+1,1)
 			if ::winbuffer == nil
@@ -401,36 +429,45 @@
 				winbuf_out_at(::winbuffer,y,x, replicate(strHsep1,::nright-col()+1),::__colors[1])
 			endif
 		endif
+		endif
 		j++
 	endif
 	::__rect[1]=::nTop+j
 	strings:=::__footStrings[col]
-	ccc:=::__colors[1]
-	if ::__columns[col]:defColor!=NIL
-		ccc:=::__colors[::__columns[col]:defColor[1]]
-	endif
+	// choose footing color
 	if ::__columns[col]:colorFooting!=NIL
 		ccc:=::__colors[::__columns[col]:colorFooting]
+	elseif ::__columns[col]:defColor!=NIL
+		ccc:=::__colors[::__columns[col]:defColor[4]]
+	else
+	  	ccc:=::__colors[1]
+	endif
+	// and footing separator color
+	if ::__columns[col]:defColor!=NIL
+		ccc:=::__colors[::__columns[col]:defColor[4]]
+	else
+	  	ccc:=::__colors[1]
 	endif
+	// display strings
 	for j=1 to len(strings)
 		s=padr(strings[j],len)
 		if ::winbuffer == nil
-			dispOutAt(::nBottom-j+1, scol, strsep1, ::__colors[1])
+			dispOutAt(::nBottom-j+1, scol, strsep1, ccs)
 			dispOut(s, ccc)
-			dispOut(iif(i<visLen,strSep2,"") , ::__colors[1])
+			dispOut(iif(i<visLen,strSep2,"") , ccs)
 			if i==visLen
-				dispout(space(::nRight-col()+1),::__colors[1])
+				dispout(space(::nRight-col()+1),ccs)
 			endif
 		else
-			winbuf_out_at(::winbuffer,::nBottom-j+1, scol, strsep1, ::__colors[1])
+			winbuf_out_at(::winbuffer,::nBottom-j+1, scol, strsep1, ccs)
 			y := ::nBottom-j+1
 			x := scol + len(strsep1)
 			winbuf_out_at(::winbuffer,y,x,s,ccc)
 			x += len(s)
-			winbuf_out_at(::winbuffer,y,x,iif(i<visLen,strSep2,"") , ::__colors[1])
+			winbuf_out_at(::winbuffer,y,x,iif(i<visLen,strSep2,"") , ccs)
 			x += len(iif(i<visLen,strSep2,""))
 			if i==visLen
-				winbuf_out_at(::winbuffer,y,x,space(::nRight-col()+1),::__colors[1])
+				winbuf_out_at(::winbuffer,y,x,space(::nRight-col()+1),ccs)
 			endif
 		endif
 	next
@@ -442,7 +479,8 @@
 	//endif
 	j:=len(strings)
 	//if ( j>0 .and. lenHSep>0 ) .or. !empty(::footSep)
-	if footing .and. lenHSep>0  .and. !empty(headSep)
+	if footing .and. j>0
+		if headSep != ""
 		if ::winbuffer == nil
 			dispOutAt(::nBottom-j, scol, replicate(strHsep1,len)+iif(i<visLen,headsep,"") , ::__colors[1])
 			if i==vislen
@@ -457,6 +495,7 @@
 				winbuf_out_at(::winbuffer,y,x,replicate(strHsep1,::nright-col()+1),::__colors[1])
 			endif
 		endif
+		endif
 		j++
 	endif
 	::__rect[3]=::nBottom-j
@@ -483,6 +522,19 @@
    ::__footStrings:={}
    max_hr:=0; max_hf:=0
    for i=1 to len(::__columns)
+	  // acording to clipper 5.3 documentation defColor has 4 elements.
+	  // hack to ensure those 4 elements.
+	  if ::__columns[i]:defColor!=NIL
+		a := {,,,}
+		for j=1 to len(::__columns[i]:defColor)
+			a[j] := ::__columns[i]:defColor[j]
+		next
+		do while j<=4
+			a[j++] := ::__columns[i]:defColor[1]
+		enddo
+		::__columns[i]:defColor := a
+	  endif
+
 	  h:=::__columns[i]:heading
 	  //hr:=iif(empty(h),0,occurs(";",h)+1)
 	  hr:=iif(h==NIL .or. h=="",0,occurs(";",h)+1)
