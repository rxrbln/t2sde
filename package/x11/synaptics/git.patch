# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../synaptics/git.patch
# Copyright (C) 2008 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

diff -urN synaptics-0.14.6/FILES synaptics-git/FILES
--- synaptics-0.14.6/FILES	2006-04-16 21:31:42.000000000 +0200
+++ synaptics-git/FILES	2008-05-28 14:56:57.000000000 +0200
@@ -9,5 +9,5 @@
 			an external USB-mouse is attached
 syndaemon.c		A user space program that disables the touchpad
 			when the keyboard is used.
-alps.patch		Patch for 2.6 kernels that makes it possible to
+alps.patch		Patch for older 2.6 kernels that makes it possible to
 			use the driver with an ALPS GlidePoint device.
diff -urN synaptics-0.14.6/INSTALL synaptics-git/INSTALL
--- synaptics-0.14.6/INSTALL	2006-06-05 18:58:22.000000000 +0200
+++ synaptics-git/INSTALL	2008-05-28 14:56:57.000000000 +0200
@@ -49,24 +49,28 @@
    following lines:
 
 Section "InputDevice"
-  Identifier  	"Synaptics Mouse"
-  Driver  	"synaptics"
-  Option 	"Device"  	"/dev/psaux"
-  Option	"Protocol"	"auto-dev"
-  Option	"LeftEdge"      "1700"
-  Option	"RightEdge"     "5300"
-  Option	"TopEdge"       "1700"
-  Option	"BottomEdge"    "4200"
-  Option	"FingerLow"	"25"
-  Option	"FingerHigh"	"30"
-  Option	"MaxTapTime"	"180"
-  Option	"MaxTapMove"	"220"
-  Option	"VertScrollDelta" "100"
-  Option	"MinSpeed"	"0.09"
-  Option	"MaxSpeed"	"0.18"
-  Option	"AccelFactor"	"0.0015"
-  Option	"SHMConfig"	"on"
-#  Option	"Repeater"	"/dev/ps2mouse"
+  Identifier	"Synaptics Mouse"
+  Driver	"synaptics"
+  Option	"Device"		"/dev/psaux"
+  Option	"Protocol"		"auto-dev"
+# enable SHMConfig if you want to enable synclient
+# NB: enabling SHMConfig is insecure, since any user can invoke it
+#  Option	 "SHMConfig"		 "on"
+  Option	"LeftEdge"		"1700"
+  Option	"RightEdge"		"5300"
+  Option	"TopEdge"		"1700"
+  Option	"BottomEdge"		"4200"
+  Option	"FingerLow"		"25"
+  Option	"FingerHigh"		"30"
+  Option	"MaxTapTime"		"180"
+  Option	"MaxTapMove"		"220"
+  Option	"VertScrollDelta" 	"100"
+  Option	"CornerCoasting" 	"1"
+  Option	"CoastingSpeed"		"3"
+  Option	"MinSpeed"		"0.09"
+  Option	"MaxSpeed"		"0.18"
+  Option	"AccelFactor"		"0.0015"
+#  Option	"Repeater"		"/dev/ps2mouse"
 EndSection
 
 Change the Identifier to the same name as in the ServerLayout section.
diff -urN synaptics-0.14.6/README synaptics-git/README
--- synaptics-0.14.6/README	2006-07-15 17:54:29.000000000 +0200
+++ synaptics-git/README	2008-05-28 14:56:57.000000000 +0200
@@ -28,6 +28,7 @@
   for right button events. (Needs hardware support. Not all models
   implement this feature.)
 - Pressure dependent motion speed.
+- Trackstick emulation.
 - Run-time configuration using shared memory. This means you can
   change parameter settings without restarting the X server.
 
diff -urN synaptics-0.14.6/alpscomm.c synaptics-git/alpscomm.c
--- synaptics-0.14.6/alpscomm.c	2006-04-16 21:31:43.000000000 +0200
+++ synaptics-git/alpscomm.c	2008-05-28 14:56:57.000000000 +0200
@@ -1,7 +1,7 @@
 /* Copyright (C) 2001 Stefan Gmeiner <riddlebox@freesurf.ch>
  *
  * Copyright (c) 2003 Neil Brown <neilb@cse.unsw.edu.au>
- * Copyright (c) 2003-2004 Peter Osterlund <petero2@telia.com>
+ * Copyright (c) 2003-2005,2007 Peter Osterlund <petero2@telia.com>
  *
  *   This program is free software; you can redistribute it and/or
  *   modify it under the terms of the GNU General Public License
@@ -72,7 +72,7 @@
 }
 
 static void
-ALPSDeviceOnHook(LocalDevicePtr local)
+ALPSDeviceOnHook(LocalDevicePtr local, SynapticsSHM *para)
 {
 }
 
diff -urN synaptics-0.14.6/eventcomm.c synaptics-git/eventcomm.c
--- synaptics-0.14.6/eventcomm.c	2006-07-15 17:54:29.000000000 +0200
+++ synaptics-git/eventcomm.c	2008-05-28 14:56:57.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- *   Copyright 2004 Peter Osterlund <petero2@telia.com>
+ *   Copyright 2004-2007 Peter Osterlund <petero2@telia.com>
  *
  *   This program is free software; you can redistribute it and/or
  *   modify it under the terms of the GNU General Public License
@@ -24,6 +24,7 @@
 #include <fcntl.h>
 #include <stdio.h>
 #include "synproto.h"
+#define SYNAPTICS_PRIVATE
 #include "synaptics.h"
 #include <xf86.h>
 
@@ -41,14 +42,16 @@
  ****************************************************************************/
 
 static void
-EventDeviceOnHook(LocalDevicePtr local)
+EventDeviceOnHook(LocalDevicePtr local, SynapticsSHM *para)
 {
-    /* Try to grab the event device so that data don't leak to /dev/input/mice */
-    int ret;
-    SYSCALL(ret = ioctl(local->fd, EVIOCGRAB, (pointer)1));
-    if (ret < 0) {
-	xf86Msg(X_WARNING, "%s can't grab event device, errno=%d\n",
-		local->name, errno);
+    if (para->grab_event_device) {
+	/* Try to grab the event device so that data don't leak to /dev/input/mice */
+	int ret;
+	SYSCALL(ret = ioctl(local->fd, EVIOCGRAB, (pointer)1));
+	if (ret < 0) {
+	    xf86Msg(X_WARNING, "%s can't grab event device, errno=%d\n",
+		    local->name, errno);
+	}
     }
 }
 
@@ -57,6 +60,27 @@
 {
 }
 
+static void
+event_query_abs_params(LocalDevicePtr local, int fd)
+{
+        int ret;
+        SynapticsPrivate *priv = (SynapticsPrivate *) (local->private);
+        struct input_absinfo absinfo;
+        SYSCALL(ret = ioctl(fd, EVIOCGABS(ABS_X), &absinfo));
+        if (ret < 0)
+                return;
+
+        priv->minx = absinfo.minimum;
+        priv->maxx = absinfo.maximum;
+
+        SYSCALL(ret = ioctl(fd, EVIOCGABS(ABS_Y), &absinfo));
+        if (ret < 0)
+                return;
+
+        priv->miny = absinfo.minimum;
+        priv->maxy = absinfo.maximum;
+}
+
 static Bool
 event_query_is_touchpad(int fd)
 {
@@ -86,6 +110,8 @@
 	return FALSE;
     if (!TEST_BIT(BTN_TOOL_FINGER, evbits))
 	return FALSE;
+    if (TEST_BIT(BTN_TOOL_PEN, evbits))
+	return FALSE;			    /* Don't match wacom tablets */
 
     return TRUE;
 }
@@ -263,13 +289,15 @@
 	noent_cnt = 0;
 	have_evdev = TRUE;
 	is_touchpad = event_query_is_touchpad(fd);
-	SYSCALL(close(fd));
 	if (is_touchpad) {
 	    xf86Msg(X_PROBED, "%s auto-dev sets device to %s\n",
 		    local->name, fname);
 	    xf86ReplaceStrOption(local->options, "Device", fname);
+	    event_query_abs_params(local, fd);
+	    SYSCALL(close(fd));
 	    return TRUE;
 	}
+	SYSCALL(close(fd));
     }
     ErrorF("%s no synaptics event device found (checked %d nodes)\n",
 	   local->name, i + 1);
diff -urN synaptics-0.14.6/linux_input.h synaptics-git/linux_input.h
--- synaptics-0.14.6/linux_input.h	2006-07-15 17:54:29.000000000 +0200
+++ synaptics-git/linux_input.h	2008-05-28 14:56:57.000000000 +0200
@@ -24,10 +24,18 @@
 	unsigned short version;
 };
 
+struct input_absinfo {
+        int value;
+        int minimum;
+        int maximum;
+        int fuzz;
+        int flat;
+};
+
 #define EVIOCGID		_IOR('E', 0x02, struct input_id)	/* get device ID */
 #define EVIOCGRAB		_IOW('E', 0x90, int)			/* Grab/Release device */
 #define EVIOCGBIT(ev,len)	_IOC(_IOC_READ, 'E', 0x20 + ev, len)	/* get event bits */
-
+#define EVIOCGABS(abs)          _IOR('E', 0x40 + abs, struct input_absinfo) /* get abs value/limits */
 
 #define EV_SYN			0x00
 #define EV_KEY			0x01
@@ -53,6 +61,7 @@
 #define BTN_7			0x107
 #define BTN_A			0x130
 #define BTN_B			0x131
+#define BTN_TOOL_PEN		0x140
 #define BTN_TOOL_FINGER		0x145
 #define BTN_TOOL_DOUBLETAP	0x14d
 #define BTN_TOOL_TRIPLETAP	0x14e
diff -urN synaptics-0.14.6/manpages/synaptics.5 synaptics-git/manpages/synaptics.5
--- synaptics-0.14.6/manpages/synaptics.5	2006-07-15 17:59:04.000000000 +0200
+++ synaptics-git/manpages/synaptics.5	2008-05-28 14:56:57.000000000 +0200
@@ -61,7 +61,9 @@
 These parameters are options in the InputDevice section in the
 XOrg/XFree86 config file.
 .
-See the INSTALL file for a working example.
+See the INSTALL file for a working example for a synaptics touchpad.
+.
+See the README.alps file for a working example for an ALPS touchpad.
 .
 If you have the SHMConfig parameter enabled, these parameters can also
 be changed at runtime with the synclient(1) program.
@@ -103,6 +105,13 @@
 When finger pressure goes above this value, the driver counts it as a
 touch.
 .TP
+\fBFingerPress\fR (Integer)
+When finger pressure goes above this value, the driver counts it as a
+press.
+.
+Currently a press is equivalent to putting the touchpad in trackstick
+emulation mode.
+.TP
 \fBMaxTapTime\fR (Integer)
 Maximum time (in milliseconds) for detecting a tap.
 .TP
@@ -125,6 +134,9 @@
 \fBHorizEdgeScroll\fR (Bool)
 Enable horizontal scrolling when dragging along the bottom edge.
 .TP
+\fBCornerCoasting\fR (Bool)
+Enable edge scrolling to continue while the finger stays in an edge corner.
+.TP
 \fBVertTwoFingerScroll\fR (Bool)
 Enable vertical scrolling when dragging with two fingers anywhere on
 the touchpad.
@@ -166,7 +178,10 @@
 Maximum speed factor.
 .TP
 \fBAccelFactor\fR (Float)
-Acceleration factor.
+Acceleration factor for normal pointer movements.
+.TP
+\fBTrackstickSpeed\fR (Float)
+Speed scale when in trackstick emulation mode.
 .TP
 \fBPressureMotionMinZ\fR (Integer)
 Finger pressure at which minimum pressure motion factor is applied.
@@ -191,12 +206,12 @@
 .
 If off, the left/right buttons both generate button 2 events.
 .TP
-\fBUpDownRepeat\fR (Bool)
+\fBUpDownScrollRepeat\fR (Bool)
 If on, and the up/down buttons are used for scrolling
 (\fBUpDownScrolling\fR), these buttons will send auto-repeating 4/5 events,
 with the delay between repeats determined by \fBScrollButtonRepeat\fR.
 .TP
-\fBLeftRightRepeat\fR (Bool)
+\fBLeftRightScrollRepeat\fR (Bool)
 If on, and the left/right buttons are used for scrolling
 (\fBLeftRightScrolling\fR), these buttons will send auto-repeating 6/7 events,
 with the delay between repeats determined by \fBScrollButtonRepeat\fR.
@@ -208,6 +223,10 @@
 \fBEmulateMidButtonTime\fR (Integer)
 Maximum time (in milliseconds) for middle button emulation.
 .TP
+\fBEmulateTwoFingerMinZ\fR (Integer)
+For touchpads not capable of detecting multiple fingers (Alps), this sets the
+Z pressure threshold to emulate a two finger press.
+.TP
 \fBTouchpadOff\fR (Integer)
 Switch off the touchpad.
 .
@@ -225,7 +244,13 @@
 \fBLockedDrags\fR (Bool)
 If off, a tap and drag gesture ends when you release the finger.
 .
-If on, the gesture is active until you tap a second time.
+If on, the gesture is active until you tap a second time, or until
+LockedDragTimeout expires.
+.TP
+\fBLockedDragTimeout\fR (Integer)
+This parameter specifies how long it takes (in milliseconds) for the
+LockedDrags mode to be automatically turned off after the finger is
+released from the touchpad.
 .TP
 \fBRTCornerButton\fR (Integer)
 .
@@ -310,6 +335,26 @@
 .TP
 \fBSingleTapTimeout\fR (Integer)
 Timeout after a tap to recognize it as a single tap.
+.TP
+\fBGrabEventDevice\fR (Bool)
+If GrabEventDevice is true, the driver will grab the event device for
+exclusive use when using the linux 2.6 event protocol.
+.
+When using other protocols, this option has no effect.
+.
+Grabbing the event device means that no other user space or kernel
+space program sees the touchpad events. 
+.
+This is desirable if the X config file includes /dev/input/mice as an
+input device, but is undesirable if you want to monitor the device
+from user space.
+.
+When changing this parameter with the synclient program, the change
+will not take effect until the synaptics driver is disabled and
+reenabled. 
+.
+This can be achieved by switching to a text console and then switching
+back to X.
 .
 .
 .LP
@@ -459,15 +504,15 @@
 generates a middle mouse button event.
 .
 .LP
-Circular scrolling acts like a scrolling wheel on the trackpad.
+Circular scrolling acts like a scrolling wheel on the touchpad.
 .
 Scrolling is engaged when a drag starts in the given CircScrollTrigger
 region, which can be all edges, a particular side, or a particular
 corner.
 .
 Once scrolling is engaged, moving your finger in clockwise circles
-around the trackpad will generate scroll down events and counter
-clockwise scroll up events.
+around the center of the touchpad will generate scroll down events and
+counter clockwise motion will generate scroll up events.
 .
 Lifting your finger will disengage circular scrolling.
 .
@@ -482,9 +527,15 @@
 Coasting is enabled by setting the CoastingSpeed parameter to a
 non-zero value.
 .
-When coasting is enabled, horizontal/vertical scrolling can continue
-after the finger is released from the lower/right edge of the
-touchpad.
+Coasting comes in two flavors: conventional (finger off) coasting, and
+corner (finger on) coasting.
+.LP
+Conventional coasting is enabled when coasting is enabled,
+and CornerCoasting is set to false.
+.
+When conventional coasting is enabled, horizontal/vertical scrolling
+can continue after the finger is released from the lower/right edge of
+the touchpad.
 .
 The driver computes the scrolling speed corresponding to the finger
 speed immediately before the finger leaves the touchpad.
@@ -493,6 +544,41 @@
 (measured in scroll events per second), the scrolling will continue
 with the same speed in the same direction until the finger touches the
 touchpad again.
+.
+.LP
+Corner coasting is enabled when coasting is enabled, and
+CornerCoasting is set to true.
+.
+When corner coasting is enabled, edge scrolling can continue as long
+as the finger stays in a corner.
+.
+Coasting begins when the finger enters the corner, and continues until
+the finger leaves the corner.
+.
+CornerCoasting takes precedence over the seamless switch from edge
+scrolling to circular scrolling.  That is, if CornerCoasting is
+active, scrolling will stop, and circular scrolling will not start,
+when the finger leaves the corner.
+.
+.LP
+Trackstick emulation mode is entered when pressing the finger hard on
+the touchpad.
+.
+The FingerPress parameter controls the minimum required finger
+pressure.
+.
+If the finger hasn't moved more than MaxTapMove after MaxTapTime has
+elapsed, trackstick mode is entered.
+.
+In this mode, moving the finger slightly in any direction gives a
+speed vector that moves the pointer.
+.
+The TrackstickSpeed parameter controls the ratio between pointer speed
+and finger movement distance.
+.
+Trackstick mode is exited when the finger pressure drops below
+FingerLow or when the finger is moved further than MaxTapMove away
+from the initial position.
 .SH "AUTHORS"
 .LP
 Peter Osterlund <petero2@telia.com> and many others.
diff -urN synaptics-0.14.6/ps2comm.c synaptics-git/ps2comm.c
--- synaptics-0.14.6/ps2comm.c	2006-04-17 00:20:10.000000000 +0200
+++ synaptics-git/ps2comm.c	2008-05-28 14:56:57.000000000 +0200
@@ -60,6 +60,10 @@
 #define PS2DBG(x)
 #endif
 
+#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 1
+#define DBG(a,b)
+#endif
+
 /*****************************************************************************
  *	PS/2 Utility functions.
  *     Many parts adapted from tpconfig.c by C. Scott Ananian
@@ -429,7 +433,7 @@
 
 
 static void
-PS2DeviceOnHook(LocalDevicePtr local)
+PS2DeviceOnHook(LocalDevicePtr local, SynapticsSHM* para)
 {
 }
 
diff -urN synaptics-0.14.6/psmcomm.c synaptics-git/psmcomm.c
--- synaptics-0.14.6/psmcomm.c	2006-07-09 18:53:02.000000000 +0200
+++ synaptics-git/psmcomm.c	2008-05-28 14:56:57.000000000 +0200
@@ -89,7 +89,7 @@
 }
 
 static void
-PSMDeviceOnHook(LocalDevicePtr local)
+PSMDeviceOnHook(LocalDevicePtr local, SynapticsSHM *para)
 {
 }
 
diff -urN synaptics-0.14.6/synaptics.c synaptics-git/synaptics.c
--- synaptics-0.14.6/synaptics.c	2006-07-15 17:54:29.000000000 +0200
+++ synaptics-git/synaptics.c	2008-05-28 14:56:57.000000000 +0200
@@ -1,4 +1,10 @@
 /*
+ *   Copyright 2007 Joseph P. Skudlarek <Jskud@Jskud.com>
+ *     patch for corner coasting (originally called corner edge scrolling)
+ *
+ *   Copyright 2006 Christian Thaeter <chth@gmx.net>
+ *     patch for Trackstick mode
+ *
  *   Copyright 2006 Stefan Bethge <stefan.bethge@web.de>
  *     patch for two-fingered scrolling
  *
@@ -103,6 +109,8 @@
 #define TIME_DIFF(a, b) ((int)((a)-(b)))
 #define SYSCALL(call) while (((call) == -1) && (errno == EINTR))
 
+#define SQR(x) ((x) * (x))
+
 #ifndef M_PI
 #define M_PI 3.14159265358979323846
 #endif
@@ -111,6 +119,10 @@
 #define M_SQRT1_2  0.70710678118654752440  /* 1/sqrt(2) */
 #endif
 
+#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 1
+#define DBG(a,b)
+#endif
+
 /*****************************************************************************
  * Forward declaration
  ****************************************************************************/
@@ -321,8 +333,10 @@
     local->private_flags           = 0;
     local->flags                   = XI86_POINTER_CAPABLE | XI86_SEND_DRAG_EVENTS;
     local->conf_idev               = dev;
+#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 0
     local->motion_history_proc     = xf86GetMotionEvents;
     local->history_size            = 0;
+#endif
     local->always_core_feedback    = 0;
 
     xf86Msg(X_INFO, "Synaptics touchpad driver version %s (%d)\n", VERSION, VERSION_ID);
@@ -359,12 +373,54 @@
     /* read the parameters */
     pars = &priv->synpara_default;
     pars->version = VERSION_ID;
-    pars->left_edge = xf86SetIntOption(opts, "LeftEdge", 1900);
-    pars->right_edge = xf86SetIntOption(opts, "RightEdge", 5400);
-    pars->top_edge = xf86SetIntOption(opts, "TopEdge", 1900);
-    pars->bottom_edge = xf86SetIntOption(opts, "BottomEdge", 4000);
+
+    if (priv->maxx && priv->maxy) {
+	    int xsize = priv->maxx - priv->minx;
+	    int ysize = priv->maxy - priv->miny;
+	    int xedgesize = xsize * 0.1;
+	    int yedgesize = ysize * 0.1;
+
+	    pars->left_edge = xf86SetIntOption(opts, "LeftEdge", priv->minx +
+					       xedgesize);
+	    pars->right_edge = xf86SetIntOption(opts, "RightEdge", priv->maxx -
+						xedgesize);
+	    pars->top_edge = xf86SetIntOption(opts, "TopEdge", priv->miny +
+					      yedgesize);
+	    pars->bottom_edge = xf86SetIntOption(opts, "BottomEdge",
+						 priv->maxy - yedgesize);
+	    pars->scroll_dist_vert = xf86SetIntOption(opts, "VertScrollDelta",
+						      0.02*ysize);
+	    pars->scroll_dist_horiz = xf86SetIntOption(opts,
+						       "HorizScrollDelta",
+						       0.02*xsize);
+	    pars->edge_motion_min_speed = xf86SetIntOption(opts,
+							   "EdgeMotionMinSpeed", 1);
+	    pars->edge_motion_max_speed = xf86SetIntOption(opts,
+							   "EdgeMotionMaxSpeed", ysize * 0.1);
+	    pars->min_speed = synSetFloatOption(opts, "MinSpeed", 250.0 / ysize);
+	    pars->max_speed = synSetFloatOption(opts, "MaxSpeed", 600.0 / ysize);
+	    pars->accl = synSetFloatOption(opts, "AccelFactor", 5.0 / ysize);
+    } else {
+	    pars->left_edge = xf86SetIntOption(opts, "LeftEdge", 1900);
+	    pars->right_edge = xf86SetIntOption(opts, "RightEdge", 5400);
+	    pars->top_edge = xf86SetIntOption(opts, "TopEdge", 1900);
+	    pars->bottom_edge = xf86SetIntOption(opts, "BottomEdge", 4000);
+	    pars->scroll_dist_vert = xf86SetIntOption(opts, "VertScrollDelta",
+						      100);
+	    pars->scroll_dist_horiz = xf86SetIntOption(opts,
+						       "HorizScrollDelta",
+						       100);
+	    pars->edge_motion_min_speed = xf86SetIntOption(opts,
+							   "EdgeMotionMinSpeed", 1);
+	    pars->edge_motion_max_speed = xf86SetIntOption(opts,
+							   "EdgeMotionMaxSpeed", 400);
+	    pars->min_speed = synSetFloatOption(opts, "MinSpeed", 0.09);
+	    pars->max_speed = synSetFloatOption(opts, "MaxSpeed", 0.18);
+	    pars->accl = synSetFloatOption(opts, "AccelFactor", 0.0015);
+    }
     pars->finger_low = xf86SetIntOption(opts, "FingerLow", 25);
     pars->finger_high = xf86SetIntOption(opts, "FingerHigh", 30);
+    pars->finger_press = xf86SetIntOption(opts, "FingerPress", 256);
     pars->tap_time = xf86SetIntOption(opts, "MaxTapTime", 180);
     pars->tap_move = xf86SetIntOption(opts, "MaxTapMove", 220);
     pars->tap_time_2 = xf86SetIntOption(opts, "MaxDoubleTapTime", 180);
@@ -372,16 +428,14 @@
     pars->fast_taps = xf86SetIntOption(opts, "FastTaps", FALSE);
     pars->emulate_mid_button_time = xf86SetIntOption(opts,
 							      "EmulateMidButtonTime", 75);
-    pars->scroll_dist_vert = xf86SetIntOption(opts, "VertScrollDelta", 100);
-    pars->scroll_dist_horiz = xf86SetIntOption(opts, "HorizScrollDelta", 100);
+    pars->emulate_twofinger_z = xf86SetIntOption(opts, "EmulateTwoFingerMinZ", 257);
     pars->scroll_edge_vert = xf86SetBoolOption(opts, "VertEdgeScroll", TRUE);
     pars->scroll_edge_horiz = xf86SetBoolOption(opts, "HorizEdgeScroll", TRUE);
+    pars->scroll_edge_corner = xf86SetBoolOption(opts, "CornerCoasting", FALSE);
     pars->scroll_twofinger_vert = xf86SetBoolOption(opts, "VertTwoFingerScroll", FALSE);
     pars->scroll_twofinger_horiz = xf86SetBoolOption(opts, "HorizTwoFingerScroll", FALSE);
     pars->edge_motion_min_z = xf86SetIntOption(opts, "EdgeMotionMinZ", 30);
     pars->edge_motion_max_z = xf86SetIntOption(opts, "EdgeMotionMaxZ", 160);
-    pars->edge_motion_min_speed = xf86SetIntOption(opts, "EdgeMotionMinSpeed", 1);
-    pars->edge_motion_max_speed = xf86SetIntOption(opts, "EdgeMotionMaxSpeed", 400);
     pars->edge_motion_use_always = xf86SetBoolOption(opts, "EdgeMotionUseAlways", FALSE);
     repeater = xf86SetStrOption(opts, "Repeater", NULL);
     pars->updown_button_scrolling = xf86SetBoolOption(opts, "UpDownScrolling", TRUE);
@@ -392,6 +446,7 @@
     pars->touchpad_off = xf86SetIntOption(opts, "TouchpadOff", 0);
     pars->guestmouse_off = xf86SetBoolOption(opts, "GuestMouseOff", FALSE);
     pars->locked_drags = xf86SetBoolOption(opts, "LockedDrags", FALSE);
+    pars->locked_drag_time = xf86SetIntOption(opts, "LockedDragTimeout", 5000);
     pars->tap_action[RT_TAP] = xf86SetIntOption(opts, "RTCornerButton", 2);
     pars->tap_action[RB_TAP] = xf86SetIntOption(opts, "RBCornerButton", 3);
     pars->tap_action[LT_TAP] = xf86SetIntOption(opts, "LTCornerButton", 0);
@@ -409,13 +464,12 @@
     pars->press_motion_min_z = xf86SetIntOption(opts, "PressureMotionMinZ", pars->edge_motion_min_z);
     pars->press_motion_max_z = xf86SetIntOption(opts, "PressureMotionMaxZ", pars->edge_motion_max_z);
 
-    pars->min_speed = synSetFloatOption(opts, "MinSpeed", 0.09);
-    pars->max_speed = synSetFloatOption(opts, "MaxSpeed", 0.18);
-    pars->accl = synSetFloatOption(opts, "AccelFactor", 0.0015);
+    pars->trackstick_speed = synSetFloatOption(opts, "TrackstickSpeed", 40);
     pars->scroll_dist_circ = synSetFloatOption(opts, "CircScrollDelta", 0.1);
     pars->coasting_speed = synSetFloatOption(opts, "CoastingSpeed", 0.0);
     pars->press_motion_min_factor = synSetFloatOption(opts, "PressureMotionMinFactor", 1.0);
     pars->press_motion_max_factor = synSetFloatOption(opts, "PressureMotionMaxFactor", 1.0);
+    pars->grab_event_device = xf86SetBoolOption(opts, "GrabEventDevice", TRUE);
 
     /* Warn about (and fix) incorrectly configured TopEdge/BottomEdge parameters */
     if (pars->top_edge > pars->bottom_edge) {
@@ -455,8 +509,6 @@
 	goto SetupProc_fail;
     }
 
-    local->history_size = xf86SetIntOption(opts, "HistorySize", 0);
-
     xf86ProcessCommonOptions(local, opts);
     local->flags |= XI86_CONFIGURED;
 
@@ -543,7 +595,7 @@
 	return !Success;
     }
 
-    priv->proto_ops->DeviceOnHook(local);
+    priv->proto_ops->DeviceOnHook(local, priv->synpara);
 
     priv->comm.buffer = XisbNew(local->fd, 64);
     if (!priv->comm.buffer) {
@@ -613,17 +665,25 @@
 
     InitPointerDeviceStruct((DevicePtr)dev, map,
 			    SYN_MAX_BUTTONS,
-			    miPointerGetMotionEvents, SynapticsCtrl,
-			    miPointerGetMotionBufferSize());
-
+#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 0
+			    miPointerGetMotionEvents,
+			    SynapticsCtrl,
+			    miPointerGetMotionBufferSize()
+#else
+			    GetMotionHistory,
+			    SynapticsCtrl,
+			    GetMotionHistorySize(), 2
+#endif
+			    );
     /* X valuator */
     xf86InitValuatorAxisStruct(dev, 0, 0, -1, 1, 0, 1);
     xf86InitValuatorDefaults(dev, 0);
     /* Y valuator */
     xf86InitValuatorAxisStruct(dev, 1, 0, -1, 1, 0, 1);
     xf86InitValuatorDefaults(dev, 1);
-
+#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) == 0
     xf86MotionHistoryAllocate(local);
+#endif
 
     if (!alloc_param_data(local))
 	return !Success;
@@ -634,7 +694,7 @@
 static int
 move_distance(int dx, int dy)
 {
-    return xf86sqrt((dx * dx) + (dy * dy));
+    return xf86sqrt(SQR(dx) + SQR(dy));
 }
 
 /*
@@ -691,7 +751,7 @@
     double relX, relY, relR;
 
     relative_coords(priv, x, y, &relX, &relY);
-    relR = relX * relX + relY * relY;
+    relR = SQR(relX) + SQR(relY);
 
     if (relR > 1) {
 	/* we are outside the ellipse enclosed by the edge parameters */
@@ -895,8 +955,10 @@
     int finger;
 
     /* finger detection thru pressure and threshold */
-    finger = (((hw->z > para->finger_high) && !priv->finger_flag) ||
-	      ((hw->z > para->finger_low)  &&  priv->finger_flag));
+    finger = ((hw->z > para->finger_press) && priv->finger_state < FS_PRESSED) ? FS_PRESSED
+	: ((hw->z > para->finger_high) && priv->finger_state < FS_TOUCHED) ? FS_TOUCHED
+	: ((hw->z < para->finger_low)  &&  priv->finger_state > FS_UNTOUCHED) ? FS_UNTOUCHED
+	: priv->finger_state;
 
     if (!para->palm_detect)
 	return finger;
@@ -912,7 +974,7 @@
 	priv->avg_width = 0;
     else
 	priv->avg_width += (hw->fingerWidth - priv->avg_width + 1) / 2;
-    if (finger && !priv->finger_flag) {
+    if (finger && !priv->finger_state) {
 	int safe_width = MAX(hw->fingerWidth, priv->avg_width);
 	if (hw->numFingers > 1)
 	    finger = TRUE;			/* more than one finger -> not a palm */
@@ -1025,6 +1087,19 @@
     priv->tap_state = tap_state;
 }
 
+static void
+SetMovingState(SynapticsPrivate *priv, enum MovingState moving_state, int millis)
+{
+    DBG(7, ErrorF("SetMovingState - %d -> %d center at %d/%d (millis:%d)\n", priv->moving_state,
+		  moving_state,priv->hwState.x, priv->hwState.y, millis));
+
+    if (moving_state == MS_TRACKSTICK) {
+	priv->trackstick_neutral_x = priv->hwState.x;
+	priv->trackstick_neutral_y = priv->hwState.y;
+    }
+    priv->moving_state = moving_state;
+}
+
 static int
 GetTimeOut(SynapticsPrivate *priv)
 {
@@ -1041,6 +1116,8 @@
 	return para->single_tap_timeout;
     case TS_2B:
 	return para->tap_time_2;
+    case TS_4:
+	return para->locked_drag_time;
     default:
 	return -1;			    /* No timeout */
     }
@@ -1048,7 +1125,7 @@
 
 static int
 HandleTapProcessing(SynapticsPrivate *priv, struct SynapticsHwState *hw,
-		    edge_type edge, Bool finger)
+		    edge_type edge, enum FingerState finger)
 {
     SynapticsSHM *para = priv->synpara;
     Bool touch, release, is_timeout, move;
@@ -1058,18 +1135,18 @@
     if (priv->palm)
 	return delay;
 
-    touch = finger && !priv->finger_flag;
-    release = !finger && priv->finger_flag;
-    move = FALSE;
+    touch = finger && !priv->finger_state;
+    release = !finger && priv->finger_state;
+    move = ((priv->tap_max_fingers <= 1) &&
+	    ((abs(hw->x - priv->touch_on.x) >= para->tap_move) ||
+	     (abs(hw->y - priv->touch_on.y) >= para->tap_move)));
+
     if (touch) {
 	priv->touch_on.x = hw->x;
 	priv->touch_on.y = hw->y;
 	priv->touch_on.millis = hw->millis;
     } else if (release) {
 	priv->touch_on.millis = hw->millis;
-	move = ((priv->tap_max_fingers <= 1) &&
-		((abs(hw->x - priv->touch_on.x) >= para->tap_move) ||
-		 (abs(hw->y - priv->touch_on.y) >= para->tap_move)));
     }
     if (hw->z > para->finger_high)
 	if (priv->tap_max_fingers < hw->numFingers)
@@ -1085,7 +1162,16 @@
 	    SetTapState(priv, TS_1, hw->millis);
 	break;
     case TS_1:
-	if (is_timeout || move) {
+	if (move) {
+	    SetMovingState(priv, MS_TOUCHPAD_RELATIVE, hw->millis);
+	    SetTapState(priv, TS_MOVE, hw->millis);
+	    goto restart;
+	} else if (is_timeout) {
+	    if (finger == FS_TOUCHED) {
+		SetMovingState(priv, MS_TOUCHPAD_RELATIVE, hw->millis);
+	    } else if (finger == FS_PRESSED) {
+		SetMovingState(priv, MS_TRACKSTICK, hw->millis);
+	    }
 	    SetTapState(priv, TS_MOVE, hw->millis);
 	    goto restart;
 	} else if (release) {
@@ -1094,8 +1180,13 @@
 	}
 	break;
     case TS_MOVE:
-	if (release)
+	if (move && priv->moving_state == MS_TRACKSTICK) {
+	    SetMovingState(priv, MS_TOUCHPAD_RELATIVE, hw->millis);
+	}
+	if (release) {
+	    SetMovingState(priv, MS_FALSE, hw->millis);
 	    SetTapState(priv, TS_START, hw->millis);
+	}
 	break;
     case TS_2A:
 	if (touch)
@@ -1118,21 +1209,39 @@
 	    SetTapState(priv, TS_START, hw->millis);
 	break;
     case TS_3:
-	if (is_timeout || move) {
+	if (move) {
+	    SetMovingState(priv, MS_TOUCHPAD_RELATIVE, hw->millis);
+	    SetTapState(priv, TS_DRAG, hw->millis);
+	    goto restart;
+	} else if (is_timeout) {
+	    if (finger == FS_TOUCHED) {
+		SetMovingState(priv, MS_TOUCHPAD_RELATIVE, hw->millis);
+	    } else if (finger == FS_PRESSED) {
+		SetMovingState(priv, MS_TRACKSTICK, hw->millis);
+	    }
 	    SetTapState(priv, TS_DRAG, hw->millis);
 	    goto restart;
-	} else if (release)
+	} else if (release) {
 	    SetTapState(priv, TS_2B, hw->millis);
+	}
 	break;
     case TS_DRAG:
+	if (move)
+	    SetMovingState(priv, MS_TOUCHPAD_RELATIVE, hw->millis);
 	if (release) {
-	    if (para->locked_drags)
+	    SetMovingState(priv, MS_FALSE, hw->millis);
+	    if (para->locked_drags) {
 		SetTapState(priv, TS_4, hw->millis);
-	    else
+	    } else {
 		SetTapState(priv, TS_START, hw->millis);
+	    }
 	}
 	break;
     case TS_4:
+	if (is_timeout) {
+	    SetTapState(priv, TS_START, hw->millis);
+	    goto restart;
+	}
 	if (touch)
 	    SetTapState(priv, TS_5, hw->millis);
 	break;
@@ -1140,8 +1249,10 @@
 	if (is_timeout || move) {
 	    SetTapState(priv, TS_DRAG, hw->millis);
 	    goto restart;
-	} else if (release)
+	} else if (release) {
+	    SetMovingState(priv, MS_FALSE, hw->millis);
 	    SetTapState(priv, TS_START, hw->millis);
+	}
 	break;
     }
 
@@ -1181,7 +1292,7 @@
 	      edge_type edge, int *dxP, int *dyP)
 {
     SynapticsSHM *para = priv->synpara;
-    Bool moving_state;
+    enum MovingState moving_state;
     int dist;
     double dx, dy;
     double speed, integral;
@@ -1189,20 +1300,22 @@
 
     dx = dy = 0;
 
-    moving_state = FALSE;
-    switch (priv->tap_state) {
-    case TS_MOVE:
-    case TS_DRAG:
-	moving_state = TRUE;
-	break;
-    case TS_1:
-    case TS_3:
-    case TS_5:
-	if (hw->numFingers == 1)
-	    moving_state = TRUE;
-	break;
-    default:
-	break;
+    moving_state = priv->moving_state;
+    if (moving_state == MS_FALSE) {
+	switch (priv->tap_state) {
+	case TS_MOVE:
+	case TS_DRAG:
+	    moving_state = MS_TOUCHPAD_RELATIVE;
+	    break;
+	case TS_1:
+	case TS_3:
+	case TS_5:
+	    if (hw->numFingers == 1)
+		moving_state = MS_TOUCHPAD_RELATIVE;
+	    break;
+	default:
+	    break;
+	}
     }
     if (moving_state && !priv->palm &&
 	!priv->vert_scroll_edge_on && !priv->horiz_scroll_edge_on &&
@@ -1214,42 +1327,51 @@
 	    int x_edge_speed = 0;
 	    int y_edge_speed = 0;
 	    double dtime = (hw->millis - HIST(0).millis) / 1000.0;
-	    dx = estimate_delta(hw->x, HIST(0).x, HIST(1).x, HIST(2).x);
-	    dy = estimate_delta(hw->y, HIST(0).y, HIST(1).y, HIST(2).y);
 
-	    if ((priv->tap_state == TS_DRAG) || para->edge_motion_use_always) {
-		int minZ = para->edge_motion_min_z;
-		int maxZ = para->edge_motion_max_z;
-		int minSpd = para->edge_motion_min_speed;
-		int maxSpd = para->edge_motion_max_speed;
-		int edge_speed;
-
-		if (hw->z <= minZ) {
-		    edge_speed = minSpd;
-		} else if (hw->z >= maxZ) {
-		    edge_speed = maxSpd;
-		} else {
-		    edge_speed = minSpd + (hw->z - minZ) * (maxSpd - minSpd) / (maxZ - minZ);
-		}
-		if (!priv->synpara->circular_pad) {
-		    /* on rectangular pad */
-		    if (edge & RIGHT_EDGE) {
-			x_edge_speed = edge_speed;
-		    } else if (edge & LEFT_EDGE) {
-			x_edge_speed = -edge_speed;
+	    if (priv->moving_state == MS_TRACKSTICK) {
+		dx = (hw->x - priv->trackstick_neutral_x);
+		dy = (hw->y - priv->trackstick_neutral_y);
+
+		dx = dx * dtime * para->trackstick_speed;
+		dy = dy * dtime * para->trackstick_speed;
+	    } else if (moving_state == MS_TOUCHPAD_RELATIVE) {
+		dx = estimate_delta(hw->x, HIST(0).x, HIST(1).x, HIST(2).x);
+		dy = estimate_delta(hw->y, HIST(0).y, HIST(1).y, HIST(2).y);
+
+		if ((priv->tap_state == TS_DRAG) || para->edge_motion_use_always) {
+		    int minZ = para->edge_motion_min_z;
+		    int maxZ = para->edge_motion_max_z;
+		    int minSpd = para->edge_motion_min_speed;
+		    int maxSpd = para->edge_motion_max_speed;
+		    int edge_speed;
+
+		    if (hw->z <= minZ) {
+			edge_speed = minSpd;
+		    } else if (hw->z >= maxZ) {
+			edge_speed = maxSpd;
+		    } else {
+			edge_speed = minSpd + (hw->z - minZ) * (maxSpd - minSpd) / (maxZ - minZ);
 		    }
-		    if (edge & TOP_EDGE) {
-			y_edge_speed = -edge_speed;
-		    } else if (edge & BOTTOM_EDGE) {
-			y_edge_speed = edge_speed;
+		    if (!priv->synpara->circular_pad) {
+			/* on rectangular pad */
+			if (edge & RIGHT_EDGE) {
+			    x_edge_speed = edge_speed;
+			} else if (edge & LEFT_EDGE) {
+			    x_edge_speed = -edge_speed;
+			}
+			if (edge & TOP_EDGE) {
+			    y_edge_speed = -edge_speed;
+			} else if (edge & BOTTOM_EDGE) {
+			    y_edge_speed = edge_speed;
+			}
+		    } else if (edge) {
+			/* at edge of circular pad */
+			double relX, relY;
+
+			relative_coords(priv, hw->x, hw->y, &relX, &relY);
+			x_edge_speed = (int)(edge_speed * relX);
+			y_edge_speed = (int)(edge_speed * relY);
 		    }
-		} else if (edge) {
-		    /* at edge of circular pad */
-		    double relX, relY;
-
-		    relative_coords(priv, hw->x, hw->y, &relX, &relY);
-		    x_edge_speed = (int)(edge_speed * relX);
-		    y_edge_speed = (int)(edge_speed * relY);
 		}
 	    }
 
@@ -1263,7 +1385,7 @@
 	    }
 
 	    /* modify speed according to pressure */
-	    {
+	    if (priv->moving_state == MS_TOUCHPAD_RELATIVE) {
 		int minZ = para->press_motion_min_z;
 		int maxZ = para->press_motion_max_z;
 		double minFctr = para->press_motion_min_factor;
@@ -1347,6 +1469,14 @@
     priv->scroll_packet_count = 0;
 }
 
+static void
+stop_coasting(SynapticsPrivate *priv)
+{
+    priv->autoscroll_xspd = 0;
+    priv->autoscroll_yspd = 0;
+    priv->scroll_packet_count = 0;
+}
+
 static int
 HandleScrolling(SynapticsPrivate *priv, struct SynapticsHwState *hw,
 		edge_type edge, Bool finger, struct ScrollData *sd)
@@ -1357,8 +1487,7 @@
     sd->left = sd->right = sd->up = sd->down = 0;
 
     if (priv->synpara->touchpad_off == 2) {
-	priv->autoscroll_xspd = 0;
-	priv->autoscroll_yspd = 0;
+	stop_coasting(priv);
 	priv->circ_scroll_on = FALSE;
 	priv->vert_scroll_edge_on = FALSE;
 	priv->horiz_scroll_edge_on = FALSE;
@@ -1368,10 +1497,8 @@
     }
 
     /* scroll detection */
-    if (finger && !priv->finger_flag) {
-	priv->autoscroll_xspd = 0;
-	priv->autoscroll_yspd = 0;
-	priv->scroll_packet_count = 0;
+    if (finger && !priv->finger_state) {
+	stop_coasting(priv);
 	if (para->circular_scrolling) {
 	    if ((para->circular_trigger == 0 && edge) ||
 		(para->circular_trigger == 1 && edge & TOP_EDGE) ||
@@ -1388,19 +1515,27 @@
 		DBG(7, ErrorF("circular scroll detected on edge\n"));
 	    }
 	}
-	if (!priv->circ_scroll_on) {
+    }
+    if (!priv->circ_scroll_on) {
+	if (finger) {
 	    if (hw->numFingers == 2) {
-		if ((para->scroll_twofinger_vert) && (para->scroll_dist_vert != 0)) {
+		if (!priv->vert_scroll_twofinger_on &&
+		    (para->scroll_twofinger_vert) && (para->scroll_dist_vert != 0)) {
 		    priv->vert_scroll_twofinger_on = TRUE;
+		    priv->vert_scroll_edge_on = FALSE;
 		    priv->scroll_y = hw->y;
 		    DBG(7, ErrorF("vert two-finger scroll detected\n"));
 		}
-		if ((para->scroll_twofinger_horiz) && (para->scroll_dist_horiz != 0)) {
+		if (!priv->horiz_scroll_twofinger_on &&
+		    (para->scroll_twofinger_horiz) && (para->scroll_dist_horiz != 0)) {
 		    priv->horiz_scroll_twofinger_on = TRUE;
+		    priv->horiz_scroll_edge_on = FALSE;
 		    priv->scroll_x = hw->x;
 		    DBG(7, ErrorF("horiz two-finger scroll detected\n"));
 		}
 	    }
+	}
+	if (finger && !priv->finger_state) {
 	    if (!priv->vert_scroll_twofinger_on && !priv->horiz_scroll_twofinger_on) {
 		if ((para->scroll_edge_vert) && (para->scroll_dist_vert != 0) &&
 		    (edge & RIGHT_EDGE)) {
@@ -1445,18 +1580,40 @@
 	    DBG(7, ErrorF("horiz edge scroll off\n"));
 	    priv->horiz_scroll_edge_on = FALSE;
 	}
-	if ((oldv || oldh) &&
+	/* If we were corner edge scrolling (coasting),
+	 * but no longer in corner or raised a finger, then stop coasting. */
+	if (para->scroll_edge_corner && (priv->autoscroll_xspd || priv->autoscroll_yspd)) {
+	    Bool is_in_corner =
+		((edge & RIGHT_EDGE)  && (edge & (TOP_EDGE | BOTTOM_EDGE))) ||
+		((edge & BOTTOM_EDGE) && (edge & (LEFT_EDGE | RIGHT_EDGE))) ;
+	    if (!is_in_corner || !finger) {
+		DBG(7, ErrorF("corner edge scroll off\n"));
+		stop_coasting(priv);
+	    }
+	}
+	/* if we were scrolling, but couldn't corner edge scroll,
+	 * and are no longer scrolling, then start coasting */
+	if ((oldv || oldh) && !para->scroll_edge_corner &&
 	    !(priv->circ_scroll_on || priv->vert_scroll_edge_on ||
 	      priv->horiz_scroll_edge_on)) {
 	    start_coasting(priv, hw, edge, oldv);
 	}
     }
 
-    /* if hitting a corner (top right or bottom right) while vertical scrolling
-       is active, switch over to circular scrolling smoothly */
+    /* if hitting a corner (top right or bottom right) while vertical
+     * scrolling is active, consider starting corner edge scrolling or
+     * switching over to circular scrolling smoothly */
     if (priv->vert_scroll_edge_on && !priv->horiz_scroll_edge_on &&
-	para->circular_scrolling) {
-	if ((edge & RIGHT_EDGE) && (edge & (TOP_EDGE | BOTTOM_EDGE))) {
+	(edge & RIGHT_EDGE) && (edge & (TOP_EDGE | BOTTOM_EDGE))) {
+	if (para->scroll_edge_corner) {
+	    if (priv->autoscroll_yspd == 0) {
+		/* FYI: We can generate multiple start_coasting requests if
+		 * we're in the corner, but we were moving so slowly when we
+		 * got here that we didn't actually start coasting. */
+		DBG(7, ErrorF("corner edge scroll on\n"));
+		start_coasting(priv, hw, edge, TRUE);
+	    }
+	} else if (para->circular_scrolling) {
 	    priv->vert_scroll_edge_on = FALSE;
 	    priv->circ_scroll_on = TRUE;
 	    priv->circ_scroll_vert = TRUE;
@@ -1466,8 +1623,16 @@
     }
     /* Same treatment for horizontal scrolling */
     if (priv->horiz_scroll_edge_on && !priv->vert_scroll_edge_on &&
-	para->circular_scrolling) {
-	if ((edge & BOTTOM_EDGE) && (edge & (LEFT_EDGE | RIGHT_EDGE))) {
+	(edge & BOTTOM_EDGE) && (edge & (LEFT_EDGE | RIGHT_EDGE))) {
+	if (para->scroll_edge_corner) {
+	    if (priv->autoscroll_xspd == 0) {
+		/* FYI: We can generate multiple start_coasting requests if
+		 * we're in the corner, but we were moving so slowly when we
+		 * got here that we didn't actually start coasting. */
+		DBG(7, ErrorF("corner edge scroll on\n"));
+		start_coasting(priv, hw, edge, FALSE);
+	    }
+	} else if (para->circular_scrolling) {
 	    priv->horiz_scroll_edge_on = FALSE;
 	    priv->circ_scroll_on = TRUE;
 	    priv->circ_scroll_vert = FALSE;
@@ -1576,7 +1741,7 @@
 {
     SynapticsPrivate *priv = (SynapticsPrivate *) (local->private);
     SynapticsSHM *para = priv->synpara;
-    Bool finger;
+    int finger;
     int dx, dy, buttons, rep_buttons, id;
     edge_type edge;
     int change;
@@ -1622,6 +1787,11 @@
     /* 3rd button emulation */
     hw->middle |= HandleMidButtonEmulation(priv, hw, &delay);
 
+    /* Two finger emulation */
+    if (hw->z >= para->emulate_twofinger_z && hw->numFingers == 1) {
+	hw->numFingers = 2;
+    }
+
     /* Up/Down button scrolling or middle/double click */
     double_click = FALSE;
     if (!para->updown_button_scrolling) {
@@ -1770,7 +1940,7 @@
     }
 
     /* Save old values of some state variables */
-    priv->finger_flag = finger;
+    priv->finger_state = finger;
     priv->lastButtons = buttons;
 
     return delay;
diff -urN synaptics-0.14.6/synaptics.h synaptics-git/synaptics.h
--- synaptics-0.14.6/synaptics.h	2006-07-15 17:54:29.000000000 +0200
+++ synaptics-git/synaptics.h	2008-05-28 14:56:57.000000000 +0200
@@ -50,7 +50,7 @@
 
     /* Parameter data */
     int left_edge, right_edge, top_edge, bottom_edge; /* edge coordinates absolute */
-    int finger_low, finger_high;	    /* finger detection values in Z-values */
+    int finger_low, finger_high, finger_press;	      /* finger detection values in Z-values */
     int tap_time;
     int tap_move;			    /* max. tapping time and movement in packets and coord. */
     int single_tap_timeout;		    /* timeout to recognize a single tap */
@@ -59,13 +59,16 @@
     Bool fast_taps;			    /* Faster reaction to single taps */
     int emulate_mid_button_time;	    /* Max time between left and right button presses to
 					       emulate a middle button press. */
+    int emulate_twofinger_z;		    /* pressure threshold to emulate two finger touch (for Alps) */
     int scroll_dist_vert;		    /* Scrolling distance in absolute coordinates */
     int scroll_dist_horiz;		    /* Scrolling distance in absolute coordinates */
     Bool scroll_edge_vert;		    /* Enable/disable vertical scrolling on right edge */
     Bool scroll_edge_horiz;		    /* Enable/disable horizontal scrolling on left edge */
+    Bool scroll_edge_corner;		    /* Enable/disable continuous edge scrolling when in the corner */
     Bool scroll_twofinger_vert;		    /* Enable/disable vertical two-finger scrolling */
     Bool scroll_twofinger_horiz;	    /* Enable/disable horizontal two-finger scrolling */
     double min_speed, max_speed, accl;	    /* movement parameters */
+    double trackstick_speed;		    /* trackstick mode speed */
     int edge_motion_min_z;		    /* finger pressure at which minimum edge motion speed is set */
     int edge_motion_max_z;		    /* finger pressure at which maximum edge motion speed is set */
     int edge_motion_min_speed;		    /* slowest setting for edge motion speed */
@@ -85,6 +88,7 @@
 					     */
     Bool guestmouse_off;		    /* Switches the guest mouse off */
     Bool locked_drags;			    /* Enable locked drags */
+    int locked_drag_time;		    /* timeout for locked drags */
     int tap_action[MAX_TAP];		    /* Button to report on tap events */
     Bool circular_scrolling;		    /* Enable circular scrolling */
     double scroll_dist_circ;		    /* Scrolling angle radians */
@@ -98,6 +102,7 @@
     int press_motion_max_z;		    /* finger pressure at which maximum pressure motion factor is applied */
     double press_motion_min_factor;	    /* factor applied on speed when finger pressure is at minimum */
     double press_motion_max_factor; 	    /* factor applied on speed when finger pressure is at minimum */
+    Bool grab_event_device;		    /* grab event device for exclusive use? */
 } SynapticsSHM;
 
 /*
@@ -135,6 +140,18 @@
     int millis;
 } SynapticsMoveHistRec;
 
+enum FingerState {		/* Note! The order matters. Compared with < operator. */
+    FS_UNTOUCHED,
+    FS_TOUCHED,
+    FS_PRESSED
+};
+
+enum MovingState {
+    MS_FALSE,
+    MS_TOUCHPAD_RELATIVE,
+    MS_TRACKSTICK		/* trackstick is always relative */
+};
+
 enum MidButtonEmulation {
     MBE_OFF,			/* No button pressed */
     MBE_LEFT,			/* Left button pressed, waiting for right button or timeout */
@@ -191,7 +208,7 @@
     int count_packet_finger;		/* packet counter with finger on the touchpad */
     int button_delay_millis;		/* button delay for 3rd button emulation */
     Bool prev_up;			/* Previous up button value, for double click emulation */
-    Bool finger_flag;			/* previous finger */
+    enum FingerState finger_state;	/* previous finger state */
 
     enum TapState tap_state;		/* State of tap processing */
     int tap_max_fingers;		/* Max number of fingers seen since entering start state */
@@ -199,6 +216,7 @@
     enum TapButtonState tap_button_state; /* Current tap action */
     SynapticsMoveHistRec touch_on;	/* data when the touchpad is touched/released */
 
+    enum MovingState moving_state;	/* previous moving state */
     Bool vert_scroll_edge_on;		/* Keeps track of currently active scroll modes */
     Bool horiz_scroll_edge_on;		/* Keeps track of currently active scroll modes */
     Bool vert_scroll_twofinger_on;	/* Keeps track of currently active scroll modes */
@@ -206,6 +224,8 @@
     Bool circ_scroll_on;		/* Keeps track of currently active scroll modes */
     Bool circ_scroll_vert;		/* True: Generate vertical scroll events
 					   False: Generate horizontal events */
+    int trackstick_neutral_x;		/* neutral x position for trackstick mode */
+    int trackstick_neutral_y;		/* neutral y position for trackstick mode */
     double autoscroll_xspd;		/* Horizontal coasting speed */
     double autoscroll_yspd;		/* Vertical coasting speed */
     double autoscroll_x;		/* Accumulated horizontal coasting scroll */
@@ -220,7 +240,10 @@
 					   palm/finger contact disappears */
     int prev_z;				/* previous z value, for palm detection */
     int avg_width;			/* weighted average of previous fingerWidth values */
-
+    int minx;
+    int maxx;
+    int miny;
+    int maxy;
 } SynapticsPrivate;
 
 
diff -urN synaptics-0.14.6/synclient.c synaptics-git/synclient.c
--- synaptics-0.14.6/synclient.c	2006-07-15 17:54:29.000000000 +0200
+++ synaptics-git/synclient.c	2008-05-28 14:56:57.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- *   Copyright 2002-2004 Peter Osterlund <petero2@telia.com>
+ *   Copyright 2002-2005,2007 Peter Osterlund <petero2@telia.com>
  *
  *   This program is free software; you can redistribute it and/or
  *   modify it under the terms of the GNU General Public License
@@ -55,6 +55,7 @@
     DEFINE_PAR("BottomEdge",           bottom_edge,             PT_INT,    0, 10000),
     DEFINE_PAR("FingerLow",            finger_low,              PT_INT,    0, 255),
     DEFINE_PAR("FingerHigh",           finger_high,             PT_INT,    0, 255),
+    DEFINE_PAR("FingerPress",          finger_press,            PT_INT,    0, 256),
     DEFINE_PAR("MaxTapTime",           tap_time,                PT_INT,    0, 1000),
     DEFINE_PAR("MaxTapMove",           tap_move,                PT_INT,    0, 2000),
     DEFINE_PAR("MaxDoubleTapTime",     tap_time_2,              PT_INT,    0, 1000),
@@ -62,15 +63,18 @@
     DEFINE_PAR("ClickTime",            click_time,              PT_INT,    0, 1000),
     DEFINE_PAR("FastTaps",             fast_taps,               PT_BOOL,   0, 1),
     DEFINE_PAR("EmulateMidButtonTime", emulate_mid_button_time, PT_INT,    0, 1000),
+    DEFINE_PAR("EmulateTwoFingerMinZ", emulate_twofinger_z,     PT_INT,    0, 1000),
     DEFINE_PAR("VertScrollDelta",      scroll_dist_vert,        PT_INT,    0, 1000),
     DEFINE_PAR("HorizScrollDelta",     scroll_dist_horiz,       PT_INT,    0, 1000),
     DEFINE_PAR("VertEdgeScroll",       scroll_edge_vert,        PT_BOOL,   0, 1),
     DEFINE_PAR("HorizEdgeScroll",      scroll_edge_horiz,       PT_BOOL,   0, 1),
+    DEFINE_PAR("CornerCoasting",       scroll_edge_corner,      PT_BOOL,   0, 1),
     DEFINE_PAR("VertTwoFingerScroll",  scroll_twofinger_vert,   PT_BOOL,   0, 1),
     DEFINE_PAR("HorizTwoFingerScroll", scroll_twofinger_horiz,  PT_BOOL,   0, 1),
     DEFINE_PAR("MinSpeed",             min_speed,               PT_DOUBLE, 0, 1.0),
     DEFINE_PAR("MaxSpeed",             max_speed,               PT_DOUBLE, 0, 1.0),
     DEFINE_PAR("AccelFactor",          accl,                    PT_DOUBLE, 0, 0.2),
+    DEFINE_PAR("TrackstickSpeed",      trackstick_speed,        PT_DOUBLE, 0, 200.0),
     DEFINE_PAR("EdgeMotionMinZ",       edge_motion_min_z,       PT_INT,    1, 255),
     DEFINE_PAR("EdgeMotionMaxZ",       edge_motion_max_z,       PT_INT,    1, 255),
     DEFINE_PAR("EdgeMotionMinSpeed",   edge_motion_min_speed,   PT_INT,    0, 1000),
@@ -78,12 +82,13 @@
     DEFINE_PAR("EdgeMotionUseAlways",  edge_motion_use_always,  PT_BOOL,   0, 1),
     DEFINE_PAR("UpDownScrolling",      updown_button_scrolling, PT_BOOL,   0, 1),
     DEFINE_PAR("LeftRightScrolling",   leftright_button_scrolling, PT_BOOL,   0, 1),
-    DEFINE_PAR("UpDownRepeat",         updown_button_repeat,    PT_BOOL,   0, 1),
-    DEFINE_PAR("LeftRightRepeat",      leftright_button_repeat, PT_BOOL,   0, 1),
+    DEFINE_PAR("UpDownScrollRepeat",   updown_button_repeat,    PT_BOOL,   0, 1),
+    DEFINE_PAR("LeftRightScrollRepeat",leftright_button_repeat, PT_BOOL,   0, 1),
     DEFINE_PAR("ScrollButtonRepeat",   scroll_button_repeat,    PT_INT,    SBR_MIN , SBR_MAX),
     DEFINE_PAR("TouchpadOff",          touchpad_off,            PT_INT,    0, 2),
     DEFINE_PAR("GuestMouseOff",        guestmouse_off,          PT_BOOL,   0, 1),
     DEFINE_PAR("LockedDrags",          locked_drags,            PT_BOOL,   0, 1),
+    DEFINE_PAR("LockedDragTimeout",    locked_drag_time,        PT_INT,    0, 30000),
     DEFINE_PAR("RTCornerButton",       tap_action[RT_TAP],      PT_INT,    0, SYN_MAX_BUTTONS),
     DEFINE_PAR("RBCornerButton",       tap_action[RB_TAP],      PT_INT,    0, SYN_MAX_BUTTONS),
     DEFINE_PAR("LTCornerButton",       tap_action[LT_TAP],      PT_INT,    0, SYN_MAX_BUTTONS),
@@ -102,7 +107,8 @@
     DEFINE_PAR("PressureMotionMinZ",   press_motion_min_z,      PT_INT,    1, 255),
     DEFINE_PAR("PressureMotionMaxZ",   press_motion_max_z,      PT_INT,    1, 255),
     DEFINE_PAR("PressureMotionMinFactor", press_motion_min_factor, PT_DOUBLE, 0, 10.0),
-    DEFINE_PAR("PressureMotionMaxFactor", press_motion_max_factor, PT_DOUBLE, 0, 10.0), 
+    DEFINE_PAR("PressureMotionMaxFactor", press_motion_max_factor, PT_DOUBLE, 0, 10.0),
+    DEFINE_PAR("GrabEventDevice",      grab_event_device,       PT_BOOL,   0, 1),
     { 0, 0, 0, 0, 0 }
 };
 
@@ -132,13 +138,13 @@
 	struct Parameter* par = &params[i];
 	switch (par->type) {
 	case PT_INT:
-	    printf("    %-20s = %d\n", par->name, *(int*)((char*)synshm + par->offset));
+	    printf("    %-23s = %d\n", par->name, *(int*)((char*)synshm + par->offset));
 	    break;
 	case PT_BOOL:
-	    printf("    %-20s = %d\n", par->name, *(Bool*)((char*)synshm + par->offset));
+	    printf("    %-23s = %d\n", par->name, *(Bool*)((char*)synshm + par->offset));
 	    break;
 	case PT_DOUBLE:
-	    printf("    %-20s = %g\n", par->name, *(double*)((char*)synshm + par->offset));
+	    printf("    %-23s = %g\n", par->name, *(double*)((char*)synshm + par->offset));
 	    break;
 	}
     }
diff -urN synaptics-0.14.6/synproto.h synaptics-git/synproto.h
--- synaptics-0.14.6/synproto.h	2006-07-09 18:53:02.000000000 +0200
+++ synaptics-git/synproto.h	2008-05-28 14:56:57.000000000 +0200
@@ -72,11 +72,12 @@
     SYN_PROTO_ALPS		/* ALPS touchpad protocol */
 };
 
+struct _SynapticsSHM;
 struct SynapticsHwInfo;
 struct CommData;
 
 struct SynapticsProtocolOperations {
-    void (*DeviceOnHook)(LocalDevicePtr local);
+    void (*DeviceOnHook)(LocalDevicePtr local, struct _SynapticsSHM *para);
     void (*DeviceOffHook)(LocalDevicePtr local);
     Bool (*QueryHardware)(LocalDevicePtr local, struct SynapticsHwInfo *synhw);
     Bool (*ReadHwState)(LocalDevicePtr local, struct SynapticsHwInfo *synhw,
