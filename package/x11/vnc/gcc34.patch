# --- ROCK-COPYRIGHT-NOTE-BEGIN ---
# 
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# Please add additional copyright information _after_ the line containing
# the ROCK-COPYRIGHT-NOTE-END tag. Otherwise it might get removed by
# the ./scripts/Create-CopyPatch script. Do not edit this copyright text!
# 
# ROCK Linux: rock-src/package/rene/vnc/gcc34.patch
# ROCK Linux is Copyright (C) 1998 - 2004 Clifford Wolf
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# 
# --- ROCK-COPYRIGHT-NOTE-END ---

Imported from ROCK Linux - whereever it comes from ...

  - Rene Rebe <rene@exactcode.de>

--- ./rfb/Rect.h.old	2003-06-30 21:50:25.000000000 +0100
+++ ./rfb/Rect.h	2004-05-20 14:43:56.299371046 +0100
@@ -21,13 +21,7 @@
 #ifndef __RFB_RECT_INCLUDED__
 #define __RFB_RECT_INCLUDED__
 
-#ifndef max
-#define max(a,b)            (((a) > (b)) ? (a) : (b))
-#endif
-
-#ifndef min
-#define min(a,b)            (((a) < (b)) ? (a) : (b))
-#endif
+#include <algorithm>
 
 namespace rfb {
 
@@ -70,20 +64,20 @@
     }
     inline Rect intersect(const Rect &r) const {
       Rect result;
-      result.tl.x = max(tl.x, r.tl.x);
-      result.tl.y = max(tl.y, r.tl.y);
-      result.br.x = max(min(br.x, r.br.x), result.tl.x);
-      result.br.y = max(min(br.y, r.br.y), result.tl.y);
+      result.tl.x = std::max(tl.x, r.tl.x);
+      result.tl.y = std::max(tl.y, r.tl.y);
+      result.br.x = std::max(std::min(br.x, r.br.x), result.tl.x);
+      result.br.y = std::max(std::min(br.y, r.br.y), result.tl.y);
       return result;
     }
     inline Rect union_boundary(const Rect &r) const {
       if (r.is_empty()) return *this;
       if (is_empty()) return r;
       Rect result;
-      result.tl.x = min(tl.x, r.tl.x);
-      result.tl.y = min(tl.y, r.tl.y);
-      result.br.x = max(br.x, r.br.x);
-      result.br.y = max(br.y, r.br.y);
+      result.tl.x = std::min(tl.x, r.tl.x);
+      result.tl.y = std::min(tl.y, r.tl.y);
+      result.br.x = std::max(br.x, r.br.x);
+      result.br.y = std::max(br.y, r.br.y);
       return result;
     }
     inline Rect translate(const Point &p) const {
--- ./rfb/ComparingUpdateTracker.cxx.orig	2004-05-18 17:16:51.000000000 +0100
+++ ./rfb/ComparingUpdateTracker.cxx	2004-05-20 14:44:48.225445585 +0100
@@ -60,7 +60,7 @@
     // since in effect the entire framebuffer has changed.
     oldFb.setSize(fb->width(), fb->height());
     for (int y=0; y<fb->height(); y+=BLOCK_SIZE) {
-      Rect pos(0, y, fb->width(), min(fb->height(), y+BLOCK_SIZE));
+      Rect pos(0, y, fb->width(), std::min(fb->height(), y+BLOCK_SIZE));
       int srcStride;
       const rdr::U8* srcData = fb->getPixelsR(pos, &srcStride);
       oldFb.imageRect(pos, srcData, srcStride);
@@ -100,20 +100,20 @@
   for (int blockTop = r.tl.y; blockTop < r.br.y; blockTop += BLOCK_SIZE)
   {
     // Get a strip of the source buffer
-    Rect pos(r.tl.x, blockTop, r.br.x, min(r.br.y, blockTop+BLOCK_SIZE));
+    Rect pos(r.tl.x, blockTop, r.br.x, std::min(r.br.y, blockTop+BLOCK_SIZE));
     int fbStride;
     const rdr::U8* newBlockPtr = fb->getPixelsR(pos, &fbStride);
     int newStrideBytes = fbStride * bytesPerPixel;
 
     rdr::U8* oldBlockPtr = oldData;
-    int blockBottom = min(blockTop+BLOCK_SIZE, r.br.y);
+    int blockBottom = std::min(blockTop+BLOCK_SIZE, r.br.y);
 
     for (int blockLeft = r.tl.x; blockLeft < r.br.x; blockLeft += BLOCK_SIZE)
     {
       const rdr::U8* newPtr = newBlockPtr;
       rdr::U8* oldPtr = oldBlockPtr;
 
-      int blockRight = min(blockLeft+BLOCK_SIZE, r.br.x);
+      int blockRight = std::min(blockLeft+BLOCK_SIZE, r.br.x);
       int blockWidthInBytes = (blockRight-blockLeft) * bytesPerPixel;
 
       for (int y = blockTop; y < blockBottom; y++)
--- ./rfb/hextileDecode.h.old	2003-07-31 19:03:38.000000000 +0100
+++ ./rfb/hextileDecode.h	2004-05-20 14:43:56.337363784 +0100
@@ -52,11 +52,11 @@
 
   for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 16) {
 
-    t.br.y = min(r.br.y, t.tl.y + 16);
+    t.br.y = std::min(r.br.y, t.tl.y + 16);
 
     for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 16) {
 
-      t.br.x = min(r.br.x, t.tl.x + 16);
+      t.br.x = std::min(r.br.x, t.tl.x + 16);
 
       int tileType = is->readU8();
 
--- ./rfb/hextileEncode.h.old	2003-07-31 19:03:38.000000000 +0100
+++ ./rfb/hextileEncode.h	2004-05-20 14:43:56.340363210 +0100
@@ -60,11 +60,11 @@
 
   for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 16) {
 
-    t.br.y = min(r.br.y, t.tl.y + 16);
+    t.br.y = std::min(r.br.y, t.tl.y + 16);
 
     for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 16) {
 
-      t.br.x = min(r.br.x, t.tl.x + 16);
+      t.br.x = std::min(r.br.x, t.tl.x + 16);
 
       GET_IMAGE_INTO_BUF(t,buf);
 
--- ./rfb/zrleEncode.h.orig	2004-05-18 17:16:52.000000000 +0100
+++ ./rfb/zrleEncode.h	2004-05-20 14:46:54.105384909 +0100
@@ -130,7 +130,7 @@
 
   for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {
 
-    t.br.y = min(r.br.y, t.tl.y + 64);
+    t.br.y = std::min(r.br.y, t.tl.y + 64);
 
     if (os->length() + worstCaseLine > maxLen) {
       if (t.tl.y == r.tl.y)
@@ -143,7 +143,7 @@
 
     for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {
 
-      t.br.x = min(r.br.x, t.tl.x + 64);
+      t.br.x = std::min(r.br.x, t.tl.x + 64);
 
       GET_IMAGE_INTO_BUF(t,buf);
 
--- ./rfb/zrleDecode.h.orig	2003-07-31 19:03:38.000000000 +0100
+++ ./rfb/zrleDecode.h	2004-05-20 14:43:56.352360917 +0100
@@ -61,11 +61,11 @@
 
   for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {
 
-    t.br.y = min(r.br.y, t.tl.y + 64);
+    t.br.y = std::min(r.br.y, t.tl.y + 64);
 
     for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {
 
-      t.br.x = min(r.br.x, t.tl.x + 64);
+      t.br.x = std::min(r.br.x, t.tl.x + 64);
 
       int mode = zis->readU8();
       bool rle = mode & 128;
--- ./tx/TXImage.cxx.orig	2004-03-18 17:37:37.000000000 +0000
+++ ./tx/TXImage.cxx	2004-05-20 14:43:56.355360344 +0100
@@ -71,8 +71,8 @@
   if (w == width() && h == height()) return;
 
   int oldStrideBytes = getStride() * (format.bpp/8);
-  int rowsToCopy = min(h, height());
-  int bytesPerRow = min(w, width()) * (format.bpp/8);
+  int rowsToCopy = std::min(h, height());
+  int bytesPerRow = std::min(w, width()) * (format.bpp/8);
   rdr::U8* oldData = 0;
   bool allocData = false;
 
