# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../blackbox/argb-visuals.patch
# Copyright (C) 2008 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

This patch adds ARGB visual support to the Blackbox Window Manager.
This is needed as top-level windows must have a matching ARGB visual
for ARGB visual utilizing applications to be composited by the
Composition Manager with the alpha channel taken into account.

  - Rene Rebe <rene@exactcode.de>

--- blackbox-0.70.1/src/Window.hh	2005-04-18 15:25:16.000000000 +0200
+++ blackbox/src/Window.hh	2008-07-13 22:10:13.000000000 +0200
@@ -202,6 +202,13 @@
       close_button, iconify_button, maximize_button,
       right_grip, left_grip;
 
+    // the visual
+    Visual* visual;
+    // depth
+    int depth;
+    // and colormap
+    Colormap colormap;
+
     // frame geometry
     bt::Rect rect;
 
@@ -221,7 +228,7 @@
 
   Window createToplevelWindow();
   Window createChildWindow(Window parent, unsigned long event_mask,
-                           Cursor = None);
+                           Cursor = None, Visual* = 0);
 
   void associateClientWindow(void);
 
--- blackbox-0.70.1/src/Window.cc	2005-10-18 10:01:41.000000000 +0200
+++ blackbox/src/Window.cc	2008-07-13 22:45:07.000000000 +0200
@@ -1006,6 +1007,19 @@
     return;
   }
 
+  if (wattrib.depth == 32) {
+    frame.depth = 32;
+    frame.visual = wattrib.visual;
+    frame.colormap = XCreateColormap(blackbox->XDisplay(),
+                                     _screen->screenInfo().rootWindow(),
+                                     frame.visual, AllocNone);
+  }
+  else {
+    frame.depth = _screen->screenInfo().depth();
+    frame.colormap = _screen->screenInfo().colormap();
+    frame.visual = _screen->screenInfo().visual();
+  }
+
   // set the eventmask early in the game so that we make sure we get
   // all the events we are interested in
   XSetWindowAttributes attrib_set;
@@ -1143,12 +1157,16 @@
     }
   }
 
+  // non visible decor container windows
+
   frame.window = createToplevelWindow();
   blackbox->insertEventHandler(frame.window, this);
 
-  frame.plate = createChildWindow(frame.window, NoEventMask);
+  frame.plate = createChildWindow(frame.window, NoEventMask, None, frame.visual);
   blackbox->insertEventHandler(frame.plate, this);
 
+  // create visible decor windows
+
   if (client.decorations & WindowDecorationTitlebar)
     createTitlebar();
 
@@ -1273,6 +1292,9 @@
 
   blackbox->removeEventHandler(frame.window);
   XDestroyWindow(blackbox->XDisplay(), frame.window);
+
+  if (frame.colormap)
+    XFreeColormap(blackbox->XDisplay(), frame.colormap);
 }
 
 
@@ -1281,15 +1303,19 @@
 Window BlackboxWindow::createToplevelWindow(void) {
   XSetWindowAttributes attrib_create;
   unsigned long create_mask = CWColormap | CWOverrideRedirect | CWEventMask;
+  if (frame.depth == 32) {
+    create_mask |= CWBorderPixel;
+  }
 
-  attrib_create.colormap = _screen->screenInfo().colormap();
   attrib_create.override_redirect = True;
   attrib_create.event_mask = EnterWindowMask | LeaveWindowMask;
 
+  attrib_create.colormap = frame.colormap;
+
   return XCreateWindow(blackbox->XDisplay(),
                        _screen->screenInfo().rootWindow(), 0, 0, 1, 1, 0,
-                       _screen->screenInfo().depth(), InputOutput,
-                       _screen->screenInfo().visual(),
+                       frame.depth, InputOutput,
+                       frame.visual,
                        create_mask, &attrib_create);
 }
 
@@ -1303,9 +1331,16 @@
  */
 Window BlackboxWindow::createChildWindow(Window parent,
                                          unsigned long event_mask,
-                                         Cursor cursor) {
+                                         Cursor cursor, Visual* visual) {
   XSetWindowAttributes attrib_create;
   unsigned long create_mask = CWEventMask;
+  if (visual && frame.depth == 32) {
+    create_mask |= CWColormap | CWBorderPixel;
+    attrib_create.colormap = frame.colormap;
+  } else if (frame.depth == 32) {
+    create_mask |= CWColormap | CWBorderPixel;
+    attrib_create.colormap = _screen->screenInfo().colormap();
+  }
 
   attrib_create.event_mask = event_mask;
 
@@ -1315,8 +1354,8 @@
   }
 
   return XCreateWindow(blackbox->XDisplay(), parent, 0, 0, 1, 1, 0,
-                       _screen->screenInfo().depth(), InputOutput,
-                       _screen->screenInfo().visual(),
+                       visual ? frame.depth : _screen->screenInfo().depth(), InputOutput,
+                       visual ? frame.visual : _screen->screenInfo().visual(),
                        create_mask, &attrib_create);
 }
 
@@ -2600,8 +2636,24 @@
     const bt::Color &c = (isFocused()
                           ? style.focus.frame_border
                           : style.unfocus.frame_border);
-    XSetWindowBorder(blackbox->XDisplay(), frame.plate,
-                     c.pixel(_screen->screenNumber()));
+    // If we have a ARGB visual, the ColorCache assumption about a single
+    // colormaps per screen is no longer valid. Just quickly custom alloc.
+    if (frame.depth < 32) {
+      XSetWindowBorder(blackbox->XDisplay(), frame.plate,
+                       c.pixel(_screen->screenNumber()));
+    }
+    else {
+      XColor xcol;
+      xcol.red   = c.red() | c.red() << 8;
+      xcol.green = c.green() | c.green() << 8;
+      xcol.blue  = c.blue() | c.blue() << 8;
+      xcol.pixel = 0;
+      xcol.flags = DoRed | DoGreen | DoBlue;
+      XAllocColor(blackbox->XDisplay(), frame.colormap, &xcol);
+      XSetWindowBorder(blackbox->XDisplay(), frame.plate,
+                       xcol.pixel);
+      XFreeColors(blackbox->XDisplay(), frame.colormap, &xcol.pixel, 1, 0);
+    }
   }
 
   if (client.decorations & WindowDecorationHandle) {
