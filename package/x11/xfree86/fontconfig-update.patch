diff -urN xc/extras/fontconfig/fc-cache/fc-cache.c xc-fontconfig/extras/fontconfig/fc-cache/fc-cache.c
--- xc/extras/fontconfig/fc-cache/fc-cache.c	2003-09-25 13:01:15.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/fc-cache/fc-cache.c	2003-11-19 21:35:04.000000000 +0100
@@ -1,7 +1,7 @@
 /*
- * $XFree86: xc/extras/fontconfig/fc-cache/fc-cache.c,v 1.2 2003/09/13 21:33:00 dawes Exp $
+ * $RCSId: xc/lib/fontconfig/fc-cache/fc-cache.c,v 1.8tsi Exp $
  *
- * Copyright © 2002 Keith Packard, member of The XFree86 Project, Inc.
+ * Copyright © 2002 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -36,9 +36,6 @@
 #define HAVE_GETOPT_LONG 1
 #endif
 #define HAVE_GETOPT 1
-#if defined(ISC) || defined(Lynx)
-#define HAVE_OPTARG_IN_UNISTD 0
-#endif
 #endif
 
 #ifndef HAVE_GETOPT
@@ -47,9 +44,6 @@
 #ifndef HAVE_GETOPT_LONG
 #define HAVE_GETOPT_LONG 0
 #endif
-#ifndef HAVE_OPTARG_IN_UNISTD
-#define HAVE_OPTARG_IN_UNISTD HAVE_GETOPT
-#endif
 
 #if HAVE_GETOPT_LONG
 #undef  _GNU_SOURCE
@@ -57,13 +51,14 @@
 #include <getopt.h>
 const struct option longopts[] = {
     {"force", 0, 0, 'f'},
+    {"system-only", 0, 0, 's'},
     {"version", 0, 0, 'V'},
     {"verbose", 0, 0, 'v'},
     {"help", 0, 0, '?'},
     {NULL,0,0,0},
 };
 #else
-#if HAVE_GETOPT && !HAVE_OPTARG_IN_UNISTD
+#if HAVE_GETOPT
 extern char *optarg;
 extern int optind, opterr, optopt;
 #endif
@@ -78,6 +73,7 @@
 	     "(all directories in font configuration by default).\n");
     fprintf (stderr, "\n");
     fprintf (stderr, "  -f, --force          scan directories with apparently valid caches\n");
+    fprintf (stderr, "  -s, --system-only    scan system-wide directories only\n");
     fprintf (stderr, "  -v, --verbose        display status information while busy\n");
     fprintf (stderr, "  -V, --version        display font config version and exit\n");
     fprintf (stderr, "  -?, --help           display this help and exit\n");
@@ -135,21 +131,33 @@
 	    continue;
 	}
 	
-	if (stat ((char *) dir, &statb) == -1)
+	if (access ((char *) dir, W_OK) < 0)
 	{
-	    if (errno == ENOENT || errno == ENOTDIR)
-	    {
+	    switch (errno) {
+	    case ENOENT:
+	    case ENOTDIR:
 		if (verbose)
-		    printf ("no such directory, skipping\n");
-	    }
-	    else
-	    {
+		    printf ("skipping, no such directory\n");
+		break;
+	    case EACCES:
+	    case EROFS:
+		if (verbose)
+		    printf ("skipping, no write access\n");
+		break;
+	    default:
 		fprintf (stderr, "\"%s\": ", dir);
 		perror ("");
 		ret++;
 	    }
 	    continue;
 	}
+	if (stat ((char *) dir, &statb) == -1)
+	{
+	    fprintf (stderr, "\"%s\": ", dir);
+	    perror ("");
+	    ret++;
+	    continue;
+	}
 	if (!S_ISDIR (statb.st_mode))
 	{
 	    fprintf (stderr, "\"%s\": not a directory, skipping\n", dir);
@@ -200,6 +208,7 @@
     FcStrList	*list;
     FcBool    	verbose = FcFalse;
     FcBool	force = FcFalse;
+    FcBool	systemOnly = FcFalse;
     FcConfig	*config;
     int		i;
     int		ret;
@@ -216,6 +225,9 @@
 	case 'f':
 	    force = FcTrue;
 	    break;
+	case 's':
+	    systemOnly = FcTrue;
+	    break;
 	case 'V':
 	    fprintf (stderr, "fontconfig version %d.%d.%d\n", 
 		     FC_MAJOR, FC_MINOR, FC_REVISION);
@@ -232,6 +244,8 @@
     i = 1;
 #endif
 
+    if (systemOnly)
+	FcConfigEnableHome (FcFalse);
     config = FcInitLoadConfig ();
     if (!config)
     {
diff -urN xc/extras/fontconfig/fc-list/fc-list.c xc-fontconfig/extras/fontconfig/fc-list/fc-list.c
--- xc/extras/fontconfig/fc-list/fc-list.c	2003-09-25 13:01:21.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/fc-list/fc-list.c	2003-11-19 21:35:22.000000000 +0100
@@ -1,5 +1,7 @@
 /*
- * Copyright © 2002 Keith Packard, member of The XFree86 Project, Inc.
+ * $RCSId: xc/lib/fontconfig/fc-list/fc-list.c,v 1.5 2002/06/30 23:45:40 keithp Exp $
+ *
+ * Copyright © 2002 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -19,7 +21,6 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-/* $XFree86: xc/extras/fontconfig/fc-list/fc-list.c,v 1.3 2003/09/13 21:33:00 dawes Exp $ */
 
 #include <fontconfig/fontconfig.h>
 #include <stdio.h>
@@ -32,9 +33,6 @@
 #define HAVE_GETOPT_LONG 1
 #endif
 #define HAVE_GETOPT 1
-#if defined(ISC) || defined(Lynx)
-#define HAVE_OPTARG_IN_UNISTD 0
-#endif
 #endif
 
 #ifndef HAVE_GETOPT
@@ -43,9 +41,6 @@
 #ifndef HAVE_GETOPT_LONG
 #define HAVE_GETOPT_LONG 0
 #endif
-#ifndef HAVE_OPTARG_IN_UNISTD
-#define HAVE_OPTARG_IN_UNISTD HAVE_GETOPT
-#endif
 
 #if HAVE_GETOPT_LONG
 #undef  _GNU_SOURCE
@@ -58,7 +53,7 @@
     {NULL,0,0,0},
 };
 #else
-#if HAVE_GETOPT && !HAVE_OPTARG_IN_UNISTD
+#if HAVE_GETOPT
 extern char *optarg;
 extern int optind, opterr, optopt;
 #endif
@@ -66,25 +61,20 @@
 
 static void usage (char *program)
 {
-#if HAVE_GETOPT_LONG || HAVE_GETOPT
-    fprintf (stderr,
-	     "usage: %s [-V?] [--version] [--help] [pattern] {element ...} \n",
+    fprintf (stderr, "usage: %s [-vV?] [--verbose] [--version] [--help] [pattern] {element ...} \n",
 	     program);
     fprintf (stderr, "List fonts matching [pattern]\n");
     fprintf (stderr, "\n");
-    fprintf (stderr,
-	     "  -V, --version        display font config version and exit\n");
+    fprintf (stderr, "  -v, --verbose        display status information while busy\n");
+    fprintf (stderr, "  -V, --version        display font config version and exit\n");
     fprintf (stderr, "  -?, --help           display this help and exit\n");
-#else
-    fprintf (stderr, "usage: %s [pattern] {element ...} \n", program);
-    fprintf (stderr, "List fonts matching [pattern]\n");
-#endif
     exit (1);
 }
 
 int
 main (int argc, char **argv)
 {
+    int		verbose = 0;
     int		i;
     FcObjectSet *os = 0;
     FcFontSet	*fs;
@@ -104,7 +94,7 @@
 		     FC_MAJOR, FC_MINOR, FC_REVISION);
 	    exit (0);
 	case 'v':
-	    /* Ignore */
+	    verbose = 1;
 	    break;
 	default:
 	    usage (argv[0]);
diff -urN xc/extras/fontconfig/fontconfig/fcfreetype.h xc-fontconfig/extras/fontconfig/fontconfig/fcfreetype.h
--- xc/extras/fontconfig/fontconfig/fcfreetype.h	2003-09-25 13:01:21.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/fontconfig/fcfreetype.h	2003-11-19 21:35:42.000000000 +0100
@@ -1,7 +1,7 @@
 /*
- * $XFree86: xc/extras/fontconfig/fontconfig/fcfreetype.h,v 1.1.1.1 2003/06/04 02:57:42 dawes Exp $
+ * $RCSId: xc/lib/fontconfig/fontconfig/fcfreetype.h,v 1.2 2002/02/15 06:01:27 keithp Exp $
  *
- * Copyright © 2001 Keith Packard, member of The XFree86 Project, Inc.
+ * Copyright © 2001 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -30,6 +30,9 @@
 FcFreeTypeCharIndex (FT_Face face, FcChar32 ucs4);
 
 FcCharSet *
+FcFreeTypeCharSetAndSpacing (FT_Face face, FcBlanks *blanks, int *spacing);
+    
+FcCharSet *
 FcFreeTypeCharSet (FT_Face face, FcBlanks *blanks);
 
 FcResult
diff -urN xc/extras/fontconfig/fontconfig/fcprivate.h xc-fontconfig/extras/fontconfig/fontconfig/fcprivate.h
--- xc/extras/fontconfig/fontconfig/fcprivate.h	2003-06-04 18:29:39.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/fontconfig/fcprivate.h	2003-11-19 21:35:42.000000000 +0100
@@ -1,5 +1,7 @@
 /*
- * Copyright © 2001 Keith Packard, member of The XFree86 Project, Inc.
+ * $RCSId: xc/lib/fontconfig/fontconfig/fcprivate.h,v 1.5 2002/08/19 19:32:04 keithp Exp $
+ *
+ * Copyright © 2001 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -19,7 +21,6 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-/* $XFree86: xc/extras/fontconfig/fontconfig/fcprivate.h,v 1.2 2003/06/04 16:29:39 dawes Exp $ */
 
 #ifndef _FCPRIVATE_H_
 #define _FCPRIVATE_H_
diff -urN xc/extras/fontconfig/fontconfig/fontconfig.h xc-fontconfig/extras/fontconfig/fontconfig/fontconfig.h
--- xc/extras/fontconfig/fontconfig/fontconfig.h	2003-09-25 13:01:21.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/fontconfig/fontconfig.h	2003-11-19 21:35:42.000000000 +0100
@@ -1,7 +1,7 @@
 /*
- * $XFree86: xc/extras/fontconfig/fontconfig/fontconfig.h,v 1.1.1.1 2003/06/04 02:57:42 dawes Exp $
+ * $RCSId: xc/lib/fontconfig/fontconfig/fontconfig.h,v 1.30 2002/09/26 00:17:27 keithp Exp $
  *
- * Copyright © 2001 Keith Packard, member of The XFree86 Project, Inc.
+ * Copyright © 2001 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -33,11 +33,14 @@
 typedef int		FcBool;
 
 /*
- * Current Fontconfig version number
+ * Current Fontconfig version number.  This same number
+ * must appear in the fontconfig configure.in file. Yes,
+ * it'a a pain to synchronize version numbers like this.
  */
-#define FC_MAJOR	1
-#define FC_MINOR	0
-#define FC_REVISION	2
+
+#define FC_MAJOR	2
+#define FC_MINOR	2
+#define FC_REVISION	1
 
 #define FC_VERSION	((FC_MAJOR * 10000) + (FC_MINOR * 100) + (FC_REVISION))
 
@@ -70,6 +73,7 @@
 #define FC_VERTICAL_LAYOUT  "verticallayout"	/* Bool (false) */
 #define FC_AUTOHINT	    "autohint"		/* Bool (false) */
 #define FC_GLOBAL_ADVANCE   "globaladvance"	/* Bool (true) */
+#define FC_WIDTH	    "width"		/* Int */
 #define FC_FILE		    "file"		/* String */
 #define FC_INDEX	    "index"		/* Int */
 #define FC_FT_FACE	    "ftface"		/* FT_Face */
@@ -93,19 +97,38 @@
 #define FC_CHAR_HEIGHT	    "charheight"/* Int */
 #define FC_MATRIX	    "matrix"    /* FcMatrix */
 
-#define FC_WEIGHT_LIGHT	    0
-#define FC_WEIGHT_MEDIUM    100
-#define FC_WEIGHT_DEMIBOLD  180
-#define FC_WEIGHT_BOLD	    200
-#define FC_WEIGHT_BLACK	    210
-
-#define FC_SLANT_ROMAN	    0
-#define FC_SLANT_ITALIC	    100
-#define FC_SLANT_OBLIQUE    110
-
-#define FC_PROPORTIONAL	    0
-#define FC_MONO		    100
-#define FC_CHARCELL	    110
+#define FC_WEIGHT_THIN		    0
+#define FC_WEIGHT_EXTRALIGHT	    40
+#define FC_WEIGHT_ULTRALIGHT	    FC_WEIGHT_EXTRALIGHT
+#define FC_WEIGHT_LIGHT		    50
+#define FC_WEIGHT_REGULAR	    80
+#define FC_WEIGHT_NORMAL	    FC_WEIGHT_REGULAR
+#define FC_WEIGHT_MEDIUM	    100
+#define FC_WEIGHT_DEMIBOLD	    180
+#define FC_WEIGHT_SEMIBOLD	    FC_WEIGHT_DEMIBOLD
+#define FC_WEIGHT_BOLD		    200
+#define FC_WEIGHT_EXTRABOLD	    205
+#define FC_WEIGHT_ULTRABOLD	    FC_WEIGHT_EXTRABOLD
+#define FC_WEIGHT_BLACK		    210
+#define FC_WEIGHT_HEAVY		    FC_WEIGHT_BLACK
+
+#define FC_SLANT_ROMAN		    0
+#define FC_SLANT_ITALIC		    100
+#define FC_SLANT_OBLIQUE	    110
+
+#define FC_WIDTH_ULTRACONDENSED	    50
+#define FC_WIDTH_EXTRACONDENSED	    63
+#define FC_WIDTH_CONDENSED	    75
+#define FC_WIDTH_SEMICONDENSED	    87
+#define FC_WIDTH_NORMAL		    100
+#define FC_WIDTH_SEMIEXPANDED	    113
+#define FC_WIDTH_EXPANDED	    125
+#define FC_WIDTH_EXTRAEXPANDED	    150
+#define FC_WIDTH_ULTRAEXPANDED	    200
+
+#define FC_PROPORTIONAL		    0
+#define FC_MONO			    100
+#define FC_CHARCELL		    110
 
 /* sub-pixel order */
 #define FC_RGBA_UNKNOWN	    0
@@ -242,6 +265,12 @@
 
 /* fccfg.c */
 FcChar8 *
+FcConfigHome (void);
+
+FcBool
+FcConfigEnableHome (FcBool enable);
+
+FcChar8 *
 FcConfigFilename (const FcChar8 *url);
     
 FcConfig *
@@ -451,6 +480,9 @@
 FcLangSetCompare (const FcLangSet *lsa, const FcLangSet *lsb);
 
 FcBool
+FcLangSetContains (const FcLangSet *lsa, const FcLangSet *lsb);
+
+FcBool
 FcLangSetEqual (const FcLangSet *lsa, const FcLangSet *lsb);
 
 FcChar32
@@ -694,7 +726,9 @@
 FcChar8 *
 FcStrCopyFilename (const FcChar8 *s);
     
-#define FcToLower(c)	(('A' <= (c) && (c) <= 'Z') ? (c) - 'A' + 'a' : (c))
+#define FcIsUpper(c)	(('A' <= (c) && (c) <= 'Z'))
+#define FcIsLower(c)	(('a' <= (c) && (c) <= 'z'))
+#define FcToLower(c)	(FcIsUpper(c) ? (c) - 'A' + 'a' : (c))
 
 int
 FcStrCmpIgnoreCase (const FcChar8 *s1, const FcChar8 *s2);
diff -urN xc/extras/fontconfig/src/Imakefile xc-fontconfig/extras/fontconfig/src/Imakefile
--- xc/extras/fontconfig/src/Imakefile	2003-09-25 13:01:22.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/src/Imakefile	2003-11-19 21:32:40.000000000 +0100
@@ -16,7 +16,7 @@
 #define DoProfileLib ProfileLibFontconfig
 #define HasSharedData YES
 #define LibName fontconfig
-SOFONTCONFIGREV=1.0
+SOFONTCONFIGREV=2.2
 #define SoRev SOFONTCONFIGREV
 
 #include <Threads.tmpl>
diff -urN xc/extras/fontconfig/src/fcatomic.c xc-fontconfig/extras/fontconfig/src/fcatomic.c
--- xc/extras/fontconfig/src/fcatomic.c	2003-09-25 13:01:22.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/src/fcatomic.c	2003-11-19 21:34:42.000000000 +0100
@@ -1,7 +1,7 @@
 /*
- * $XFree86: xc/extras/fontconfig/src/fcatomic.c,v 1.1.1.1 2003/06/04 02:57:42 dawes Exp $
+ * $RCSId: xc/lib/fontconfig/src/fcatomic.c,v 1.2 2002/03/04 21:15:28 tsi Exp $
  *
- * Copyright © 2002 Keith Packard, member of The XFree86 Project, Inc.
+ * Copyright © 2002 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -30,7 +30,7 @@
  * Uses only regular filesystem calls so it should
  * work even in the absense of functioning file locking
  *
- *  Four files:
+ * On Unix, four files are used:
  *	file	    - the data file accessed by other apps.
  *	new	    - a new version of the data file while it's being written
  *	lck	    - the lock file
@@ -41,6 +41,10 @@
  *	Attempt to link it to 'lck'
  *	Unlink 'tmp'
  *	If the link succeeded, the lock is held
+ *
+ * On Windows, where there are no links, no tmp file is used, and lck
+ * is a directory that's mkdir'ed. If the mkdir succeeds, the lock is
+ * held.
  */
 
 #include "fcint.h"
@@ -51,6 +55,10 @@
 #include <stdlib.h>
 #include <time.h>
 
+#ifdef _WIN32
+#define mkdir(path,mode) _mkdir(path)
+#endif
+
 #define NEW_NAME	".NEW"
 #define LCK_NAME	".LCK"
 #define TMP_NAME	".TMP-XXXXXX"
@@ -96,6 +104,7 @@
     int		ret;
     struct stat	lck_stat;
 
+#ifdef HAVE_LINK
     strcpy ((char *) atomic->tmp, (char *) atomic->file);
     strcat ((char *) atomic->tmp, TMP_NAME);
     fd = mkstemp ((char *) atomic->tmp);
@@ -122,6 +131,9 @@
     }
     ret = link ((char *) atomic->tmp, (char *) atomic->lck);
     (void) unlink ((char *) atomic->tmp);
+#else
+    ret = mkdir ((char *) atomic->lck, 0600);
+#endif
     if (ret < 0)
     {
 	/*
@@ -135,8 +147,13 @@
 	    time_t  now = time (0);
 	    if ((long int) (now - lck_stat.st_mtime) > 10 * 60)
 	    {
+#ifdef HAVE_LINK
 		if (unlink ((char *) atomic->lck) == 0)
 		    return FcAtomicLock (atomic);
+#else
+		if (rmdir ((char *) atomic->lck) == 0)
+		    return FcAtomicLock (atomic);
+#endif
 	    }
 	}
 	return FcFalse;
@@ -174,7 +191,11 @@
 void
 FcAtomicUnlock (FcAtomic *atomic)
 {
+#ifdef HAVE_LINK
     unlink ((char *) atomic->lck);
+#else
+    rmdir ((char *) atomic->lck);
+#endif
 }
 
 void
diff -urN xc/extras/fontconfig/src/fcblanks.c xc-fontconfig/extras/fontconfig/src/fcblanks.c
--- xc/extras/fontconfig/src/fcblanks.c	2003-09-25 13:01:22.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/src/fcblanks.c	2003-11-19 21:34:42.000000000 +0100
@@ -1,7 +1,7 @@
 /*
- * $XFree86: xc/extras/fontconfig/src/fcblanks.c,v 1.1.1.1 2003/06/04 02:57:42 dawes Exp $
+ * $RCSId:$
  *
- * Copyright © 2002 Keith Packard, member of The XFree86 Project, Inc.
+ * Copyright © 2002 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
diff -urN xc/extras/fontconfig/src/fccache.c xc-fontconfig/extras/fontconfig/src/fccache.c
--- xc/extras/fontconfig/src/fccache.c	2003-11-02 05:40:29.000000000 +0100
+++ xc-fontconfig/extras/fontconfig/src/fccache.c	2003-11-19 21:34:42.000000000 +0100
@@ -1,5 +1,7 @@
 /*
- * Copyright © 2000 Keith Packard, member of The XFree86 Project, Inc.
+ * $RCSId: xc/lib/fontconfig/src/fccache.c,v 1.12 2002/08/22 07:36:44 keithp Exp $
+ *
+ * Copyright © 2000 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -19,7 +21,6 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-/* $XFree86: xc/extras/fontconfig/src/fccache.c,v 1.3 2003/10/28 18:01:48 tsi Exp $ */
 
 #include "fcint.h"
 
@@ -187,9 +188,19 @@
     if (dir)
 	if (!FcCacheWriteChars (f, dir))
 	    return FcFalse;
+#ifdef _WIN32
+    if (dir &&
+	dir[strlen((const char *) dir) - 1] != '/' &&
+	dir[strlen((const char *) dir) - 1] != '\\')
+    {
+	if (!FcCacheWriteChars (f, "\\"))
+	    return FcFalse;
+    }
+#else
     if (dir && dir[strlen((const char *) dir) - 1] != '/')
 	if (PUTC ('/', f) == EOF)
 	    return FcFalse;
+#endif
     if (!FcCacheWriteChars (f, file))
 	return FcFalse;
     if (PUTC ('"', f) == EOF)
@@ -257,8 +268,13 @@
 	    return FcFalse;
     }
     strncpy ((char *) path, (const char *) dir, dir_len);
+#ifdef _WIN32
+    if (dir[dir_len - 1] != '/' && dir[dir_len - 1] != '\\' )
+	path[dir_len++] = '\\';
+#else
     if (dir[dir_len - 1] != '/')
 	path[dir_len++] = '/';
+#endif
     strcpy ((char *) path + dir_len, (const char *) file);
     if (!FcStrCmp (name, FC_FONT_FILE_DIR))
     {
@@ -294,28 +310,28 @@
 }
 
 static unsigned int
-FcCacheHash (const FcChar8 *string)
+FcCacheHash (const FcChar8 *string, int len)
 {
     unsigned int    h = 0;
     FcChar8	    c;
 
-    while ((c = *string++))
+    while (len-- && (c = *string++))
 	h = (h << 1) ^ c;
-    return 0;
+    return h;
 }
 
 /*
  * Verify the saved timestamp for a file
  */
 FcBool
-FcGlobalCacheCheckTime (FcGlobalCacheInfo *info)
+FcGlobalCacheCheckTime (const FcChar8 *file, FcGlobalCacheInfo *info)
 {
     struct stat	    statb;
 
-    if (stat ((char *) info->file, &statb) < 0)
+    if (stat ((char *) file, &statb) < 0)
     {
 	if (FcDebug () & FC_DBG_CACHE)
-	    printf (" file missing\n");
+	    printf (" file %s missing\n", file);
 	return FcFalse;
     }
     if (statb.st_mtime != info->time)
@@ -360,7 +376,7 @@
     FcFilePathInfo  i;
     FcChar8	    *slash;
 
-    slash = (FcChar8 *) strrchr ((const char *) path, '/');
+    slash = FcStrLastSlash (path);
     if (slash)
     {
         i.dir = path;
@@ -375,7 +391,7 @@
 	i.dir_len = 1;
 	i.base = path;
     }
-    i.base_hash = FcCacheHash (i.base);
+    i.base_hash = FcCacheHash (i.base, -1);
     return i;
 }
 
@@ -385,7 +401,7 @@
 		     int	    len,
 		     FcBool	    create_missing)
 {
-    unsigned int	hash = FcCacheHash (dir);
+    unsigned int	hash = FcCacheHash (dir, len);
     FcGlobalCacheDir	*d, **prev;
 
     for (prev = &cache->ents[hash % FC_GLOBAL_CACHE_DIR_HASH_SIZE];
@@ -426,13 +442,29 @@
 FcGlobalCacheDirAdd (FcGlobalCache  *cache,
 		     const FcChar8  *dir,
 		     time_t	    time,
-		     FcBool	    replace)
+		     FcBool	    replace,
+		     FcBool	    create_missing)
 {
     FcGlobalCacheDir	*d;
     FcFilePathInfo	i;
     FcGlobalCacheSubdir	*subdir;
     FcGlobalCacheDir	*parent;
 
+    i = FcFilePathInfoGet (dir);
+    parent = FcGlobalCacheDirGet (cache, i.dir, i.dir_len, create_missing);
+    /*
+     * Tricky here -- directories containing fonts.cache-1 files
+     * need entries only when the parent doesn't have a cache file.
+     * That is, when the parent already exists in the cache, is
+     * referenced and has a "real" timestamp.  The time of 0 is
+     * special and marks directories which got stuck in the
+     * global cache for this very reason.  Yes, it could
+     * use a separate boolean field, and probably should.
+     */
+    if (!parent || (!create_missing && 
+		    (!parent->info.referenced ||
+		    (parent->info.time == 0))))
+	return 0;
     /*
      * Add this directory to the cache
      */
@@ -440,13 +472,9 @@
     if (!d)
 	return 0;
     d->info.time = time;
-    i = FcFilePathInfoGet (dir);
     /*
      * Add this directory to the subdirectory list of the parent
      */
-    parent = FcGlobalCacheDirGet (cache, i.dir, i.dir_len, FcTrue);
-    if (!parent)
-	return 0;
     subdir = malloc (sizeof (FcGlobalCacheSubdir));
     if (!subdir)
 	return 0;
@@ -483,6 +511,30 @@
     free (d);
 }
 
+/*
+ * If the parent is in the global cache and referenced, add
+ * an entry for 'dir' to the global cache.  This is used
+ * for directories with fonts.cache files
+ */
+
+void
+FcGlobalCacheReferenceSubdir (FcGlobalCache *cache,
+			      const FcChar8 *dir)
+{
+    FcGlobalCacheInfo	*info;
+    info = FcGlobalCacheDirAdd (cache, dir, 0, FcFalse, FcFalse);
+    if (info && !info->referenced)
+    {
+	info->referenced = FcTrue;
+	cache->referenced++;
+    }
+}
+
+/*
+ * Check to see if the global cache contains valid data for 'dir'.
+ * If so, scan the global cache for files and directories in 'dir'.
+ * else, return False.
+ */
 FcBool
 FcGlobalCacheScanDir (FcFontSet		*set,
 		      FcStrSet		*dirs,
@@ -496,6 +548,7 @@
     int			h;
     int			dir_len;
     FcGlobalCacheSubdir	*subdir;
+    FcBool		any_in_cache = FcFalse;
 
     if (FcDebug() & FC_DBG_CACHE)
 	printf ("FcGlobalCacheScanDir %s\n", dir);
@@ -507,19 +560,27 @@
 	return FcFalse;
     }
 
-    if (!FcGlobalCacheCheckTime (&d->info))
+    /*
+     * See if the timestamp recorded in the global cache
+     * matches the directory time, if not, return False
+     */
+    if (!FcGlobalCacheCheckTime (d->info.file, &d->info))
     {
 	if (FcDebug () & FC_DBG_CACHE)
 	    printf ("\tdir cache entry time mismatch\n");
 	return FcFalse;
     }
 
+    /*
+     * Add files from 'dir' to the fontset
+     */
     dir_len = strlen ((const char *) dir);
     for (h = 0; h < FC_GLOBAL_CACHE_FILE_HASH_SIZE; h++)
 	for (f = d->ents[h]; f; f = f->next)
 	{
 	    if (FcDebug() & FC_DBG_CACHEV)
 		printf ("FcGlobalCacheScanDir add file %s\n", f->info.file);
+	    any_in_cache = FcTrue;
 	    if (!FcCacheFontSetAdd (set, dirs, dir, dir_len,
 				    f->info.file, f->name))
 	    {
@@ -528,11 +589,14 @@
 	    }
 	    FcGlobalCacheReferenced (cache, &f->info);
 	}
+    /*
+     * Add directories in 'dir' to 'dirs'
+     */
     for (subdir = d->subdirs; subdir; subdir = subdir->next)
     {
-	FcFilePathInfo info;
+	FcFilePathInfo	info = FcFilePathInfoGet (subdir->ent->info.file);
 	
-	info = FcFilePathInfoGet (subdir->ent->info.file);
+        any_in_cache = FcTrue;
 	if (!FcCacheFontSetAdd (set, dirs, dir, dir_len,
 				info.base, FC_FONT_FILE_DIR))
 	{
@@ -544,7 +608,15 @@
     
     FcGlobalCacheReferenced (cache, &d->info);
 
-    return FcTrue;
+    /*
+     * To recover from a bug in previous versions of fontconfig,
+     * return FcFalse if no entries in the cache were found
+     * for this directory.  This will cause any empty directories
+     * to get rescanned every time fontconfig is initialized.  This
+     * might get removed at some point when the older cache files are
+     * presumably fixed.
+     */
+    return any_in_cache;
 }
 
 /*
@@ -576,7 +648,7 @@
 	}
     }
     if (count)
-	*count = max;
+	*count = max + 1;
     return match;
 }
     
@@ -713,7 +785,7 @@
 	if (FcDebug () & FC_DBG_CACHEV)
 	    printf ("FcGlobalCacheLoad \"%s\" \"%20.20s\"\n", file, name);
 	if (!FcStrCmp (name, FC_FONT_FILE_DIR))
-	    info = FcGlobalCacheDirAdd (cache, file, time, FcFalse);
+	    info = FcGlobalCacheDirAdd (cache, file, time, FcFalse, FcTrue);
 	else
 	    info = FcGlobalCacheFileAdd (cache, file, id, time, name, FcFalse);
 	if (!info)
@@ -743,14 +815,17 @@
 		     int	    id,
 		     const FcChar8  *name)
 {
+    const FcChar8	*match;
     struct stat		statb;
     FcGlobalCacheInfo	*info;
 
+    match = file;
+
     if (stat ((char *) file, &statb) < 0)
 	return FcFalse;
     if (S_ISDIR (statb.st_mode))
 	info = FcGlobalCacheDirAdd (cache, file, statb.st_mtime, 
-				   FcTrue);
+				    FcTrue, FcTrue);
     else
 	info = FcGlobalCacheFileAdd (cache, file, id, statb.st_mtime, 
 				    name, FcTrue);
@@ -780,9 +855,11 @@
     if (cache->broken)
 	return FcFalse;
 
+#if defined (HAVE_GETUID) && defined (HAVE_GETEUID)
     /* Set-UID programs can't safely update the cache */
     if (getuid () != geteuid ())
 	return FcFalse;
+#endif
     
     atomic = FcAtomicCreate (cache_file);
     if (!atomic)
@@ -973,7 +1050,7 @@
 {
     const FcChar8   *cache_slash;
 
-    cache_slash = (const FcChar8 *) strrchr ((const char *) cache, '/');
+    cache_slash = FcStrLastSlash (cache);
     if (cache_slash && !strncmp ((const char *) cache, (const char *) file,
 				 (cache_slash + 1) - cache))
 	return file + ((cache_slash + 1) - cache);
diff -urN xc/extras/fontconfig/src/fccfg.c xc-fontconfig/extras/fontconfig/src/fccfg.c
--- xc/extras/fontconfig/src/fccfg.c	2003-06-04 18:29:39.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/src/fccfg.c	2003-11-19 21:34:42.000000000 +0100
@@ -1,5 +1,7 @@
 /*
- * Copyright © 2000 Keith Packard, member of The XFree86 Project, Inc.
+ * $RCSId: xc/lib/fontconfig/src/fccfg.c,v 1.23 2002/08/31 22:17:32 keithp Exp $
+ *
+ * Copyright © 2000 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -19,10 +21,15 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-/* $XFree86: xc/extras/fontconfig/src/fccfg.c,v 1.2 2003/06/04 16:29:39 dawes Exp $ */
 
 #include "fcint.h"
 
+#if defined (_WIN32) && defined (PIC)
+#define STRICT
+#include <windows.h>
+#undef STRICT
+#endif
+
 FcConfig    *_fcConfig;
 
 FcConfig *
@@ -49,8 +56,9 @@
 	goto bail3;
     
     config->cache = 0;
-    if (!FcConfigSetCache (config, (FcChar8 *) ("~/" FC_USER_CACHE_FILE)))
-	goto bail4;
+    if (FcConfigHome())
+	if (!FcConfigSetCache (config, (FcChar8 *) ("~/" FC_USER_CACHE_FILE)))
+	    goto bail4;
 
     config->blanks = 0;
 
@@ -132,8 +140,10 @@
     while (s)
     {
 	n = s->next;
-	FcTestDestroy (s->test);
-	FcEditDestroy (s->edit);
+	if (s->test)
+	    FcTestDestroy (s->test);
+	if (s->edit)
+	    FcEditDestroy (s->edit);
 	s = n;
     }
 }
@@ -482,11 +492,13 @@
 }
 
 FcBool
-FcConfigCompareValue (FcValue	m,
-		      FcOp	op,
-		      FcValue	v)
-{
-    FcBool    ret = FcFalse;
+FcConfigCompareValue (const FcValue	m_o,
+		      FcOp		op,
+		      const FcValue	v_o)
+{
+    FcValue	m = m_o;
+    FcValue	v = v_o;
+    FcBool	ret = FcFalse;
     
     m = FcConfigPromote (m, v);
     v = FcConfigPromote (v, m);
@@ -586,10 +598,10 @@
 	case FcTypeLangSet:
 	    switch (op) {
 	    case FcOpContains:
-		ret = FcLangSetCompare (v.u.l, m.u.l) != FcLangDifferentLang;
+		ret = FcLangSetContains (v.u.l, m.u.l);
 		break;
 	    case FcOpNotContains:
-		ret = FcLangSetCompare (v.u.l, m.u.l) == FcLangDifferentLang;
+		ret = FcLangSetContains (v.u.l, m.u.l);
 		break;
 	    case FcOpEqual:
 		ret = FcLangSetEqual (v.u.l, m.u.l);
@@ -636,6 +648,13 @@
 }
 
 
+#define _FcDoubleFloor(d)	((int) (d))
+#define _FcDoubleCeil(d)	((double) (int) (d) == (d) ? (int) (d) : (int) ((d) + 1))
+#define FcDoubleFloor(d)	((d) >= 0 ? _FcDoubleFloor(d) : -_FcDoubleCeil(-(d)))
+#define FcDoubleCeil(d)		((d) >= 0 ? _FcDoubleCeil(d) : -_FcDoubleFloor(-(d)))
+#define FcDoubleRound(d)	FcDoubleFloor ((d) + 0.5)
+#define FcDoubleTrunc(d)	((d) >= 0 ? _FcDoubleFloor (d) : -_FcDoubleFloor (-(d)))
+
 static FcValue
 FcConfigEvaluate (FcPattern *p, FcExpr *e)
 {
@@ -824,6 +843,70 @@
 	}
 	FcValueDestroy (vl);
 	break;
+    case FcOpFloor:
+	vl = FcConfigEvaluate (p, e->u.tree.left);
+	switch (vl.type) {
+	case FcTypeInteger:
+	    v = vl;
+	    break;
+	case FcTypeDouble:
+	    v.type = FcTypeInteger;
+	    v.u.i = FcDoubleFloor (vl.u.d);
+	    break;
+	default:
+	    v.type = FcTypeVoid;
+	    break;
+	}
+	FcValueDestroy (vl);
+	break;
+    case FcOpCeil:
+	vl = FcConfigEvaluate (p, e->u.tree.left);
+	switch (vl.type) {
+	case FcTypeInteger:
+	    v = vl;
+	    break;
+	case FcTypeDouble:
+	    v.type = FcTypeInteger;
+	    v.u.i = FcDoubleCeil (vl.u.d);
+	    break;
+	default:
+	    v.type = FcTypeVoid;
+	    break;
+	}
+	FcValueDestroy (vl);
+	break;
+    case FcOpRound:
+	vl = FcConfigEvaluate (p, e->u.tree.left);
+	switch (vl.type) {
+	case FcTypeInteger:
+	    v = vl;
+	    break;
+	case FcTypeDouble:
+	    v.type = FcTypeInteger;
+	    v.u.i = FcDoubleRound (vl.u.d);
+	    break;
+	default:
+	    v.type = FcTypeVoid;
+	    break;
+	}
+	FcValueDestroy (vl);
+	break;
+    case FcOpTrunc:
+	vl = FcConfigEvaluate (p, e->u.tree.left);
+	switch (vl.type) {
+	case FcTypeInteger:
+	    v = vl;
+	    break;
+	case FcTypeDouble:
+	    v.type = FcTypeInteger;
+	    v.u.i = FcDoubleTrunc (vl.u.d);
+	    break;
+	default:
+	    v.type = FcTypeVoid;
+	    break;
+	}
+	FcValueDestroy (vl);
+	break;
     default:
 	v.type = FcTypeVoid;
 	break;
@@ -914,8 +997,16 @@
 	     FcBool	    append,
 	     FcValueList    *new)
 {
-    FcValueList    **prev, *last;
+    FcValueList	    **prev, *last, *v;
+    FcValueBinding  sameBinding;
     
+    if (position)
+	sameBinding = position->binding;
+    else
+	sameBinding = FcValueBindingWeak;
+    for (v = new; v; v = v->next)
+	if (v->binding == FcValueBindingSame)
+	    v->binding = sameBinding;
     if (append)
     {
 	if (position)
@@ -1141,6 +1232,14 @@
 		    !FcStrCmpIgnoreCase ((FcChar8 *) t->field, 
 					 (FcChar8 *) e->field))
 		{
+		    /* 
+		     * KLUDGE - the pattern may have been reallocated or
+		     * things may have been inserted or deleted above
+		     * this element by other edits.  Go back and find
+		     * the element again
+		     */
+		    if (e != s->edit && st[i].elt)
+			st[i].elt = FcPatternFindElt (p, t->field);
 		    if (!st[i].elt)
 			t = 0;
 		    break;
@@ -1253,9 +1352,53 @@
     return FcConfigSubstituteWithPat (config, p, 0, kind);
 }
 
-#ifndef FONTCONFIG_PATH
-#define FONTCONFIG_PATH	"/etc/fonts"
-#endif
+#if defined (_WIN32) && defined (PIC)
+
+static FcChar8 fontconfig_path[1000] = "";
+
+BOOL WINAPI
+DllMain (HINSTANCE hinstDLL,
+	 DWORD     fdwReason,
+	 LPVOID    lpvReserved)
+{
+  FcChar8 *p;
+
+  switch (fdwReason) {
+  case DLL_PROCESS_ATTACH:
+      if (!GetModuleFileName ((HMODULE) hinstDLL, fontconfig_path,
+			      sizeof (fontconfig_path)))
+	  break;
+
+      /* If the fontconfig DLL is in a "bin" or "lib" subfolder,
+       * assume it's a Unix-style installation tree, and use
+       * "etc/fonts" in there as FONTCONFIG_PATH. Otherwise use the
+       * folder where the DLL is as FONTCONFIG_PATH.
+       */
+      p = strrchr (fontconfig_path, '\\');
+      if (p)
+      {
+	  *p = '\0';
+	  p = strrchr (fontconfig_path, '\\');
+	  if (p && (FcStrCmpIgnoreCase (p + 1, "bin") == 0 ||
+		    FcStrCmpIgnoreCase (p + 1, "lib") == 0))
+	      *p = '\0';
+	  strcat (fontconfig_path, "\\etc\\fonts");
+      }
+      else
+          fontconfig_path[0] = '\0';
+      
+      break;
+  }
+
+  return TRUE;
+}
+
+#undef FONTCONFIG_PATH
+#define FONTCONFIG_PATH fontconfig_path
+
+#else /* !(_WIN32 && PIC) */
+
+#endif /* !(_WIN32 && PIC) */
 
 #ifndef FONTCONFIG_FILE
 #define FONTCONFIG_FILE	"fonts.conf"
@@ -1273,9 +1416,16 @@
 	return 0;
 
     strcpy ((char *) path, (const char *) dir);
-    /* make sure there's a single separating / */
+    /* make sure there's a single separator */
+#ifdef _WIN32
+    if ((!path[0] || (path[strlen((char *) path)-1] != '/' &&
+		      path[strlen((char *) path)-1] != '\\')) &&
+	 (file[0] != '/' && file[0] != '\\'))
+	strcat ((char *) path, "\\");
+#else
     if ((!path[0] || path[strlen((char *) path)-1] != '/') && file[0] != '/')
 	strcat ((char *) path, "/");
+#endif
     strcat ((char *) path, (char *) file);
 
     FcMemAlloc (FC_MEM_STRING, strlen ((char *) path) + 1);
@@ -1302,11 +1452,7 @@
 	e = env;
 	npath++;
 	while (*e)
-#ifndef __UNIXOS2__
-	    if (*e++ == ':')
-#else
-	    if (*e++ == ';')
-#endif
+	    if (*e++ == FC_SEARCH_PATH_SEPARATOR)
 		npath++;
     }
     path = calloc (npath, sizeof (FcChar8 *));
@@ -1319,11 +1465,7 @@
 	e = env;
 	while (*e) 
 	{
-#ifndef __UNIXOS2__
-	    colon = (FcChar8 *) strchr ((char *) e, ':');
-#else
-	    colon = (FcChar8 *) strchr ((char *) e, ';');
-#endif
+	    colon = (FcChar8 *) strchr ((char *) e, FC_SEARCH_PATH_SEPARATOR);
 	    if (!colon)
 		colon = e + strlen ((char *) e);
 	    path[i] = malloc (colon - e + 1);
@@ -1339,11 +1481,7 @@
 	}
     }
     
-#ifndef __UNIXOS2__
     dir = (FcChar8 *) FONTCONFIG_PATH;
-#else
-    dir = (FcChar8 *) __XOS2RedirRoot(FONTCONFIG_PATH);
-#endif
     path[i] = malloc (strlen ((char *) dir) + 1);
     if (!path[i])
 	goto bail1;
@@ -1368,6 +1506,33 @@
     free (path);
 }
 
+static FcBool	_FcConfigHomeEnabled = FcTrue;
+
+FcChar8 *
+FcConfigHome (void)
+{
+    if (_FcConfigHomeEnabled)
+    {
+        char *home = getenv ("HOME");
+
+#ifdef _WIN32
+	if (home == NULL)
+	    home = getenv ("USERPROFILE");
+#endif
+
+	return home;
+    }
+    return 0;
+}
+
+FcBool
+FcConfigEnableHome (FcBool enable)
+{
+    FcBool  prev = _FcConfigHomeEnabled;
+    _FcConfigHomeEnabled = enable;
+    return prev;
+}
+
 FcChar8 *
 FcConfigFilename (const FcChar8 *url)
 {
@@ -1380,14 +1545,26 @@
 	    url = (FcChar8 *) FONTCONFIG_FILE;
     }
     file = 0;
+
+#ifdef _WIN32
+    if (isalpha (*url) &&
+	url[1] == ':' &&
+	(url[2] == '/' || url[2] == '\\'))
+	goto absolute_path;
+#endif
+
     switch (*url) {
     case '~':
-	dir = (FcChar8 *) getenv ("HOME");
+	dir = FcConfigHome ();
 	if (dir)
 	    file = FcConfigFileExists (dir, url + 1);
 	else
 	    file = 0;
 	break;
+#ifdef _WIN32
+    case '\\':
+    absolute_path:
+#endif
     case '/':
 	file = FcConfigFileExists (0, url);
 	break;
diff -urN xc/extras/fontconfig/src/fccharset.c xc-fontconfig/extras/fontconfig/src/fccharset.c
--- xc/extras/fontconfig/src/fccharset.c	2003-06-04 18:29:39.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/src/fccharset.c	2003-11-19 21:34:42.000000000 +0100
@@ -1,5 +1,7 @@
 /*
- * Copyright © 2001 Keith Packard, member of The XFree86 Project, Inc.
+ * $RCSId: xc/lib/fontconfig/src/fccharset.c,v 1.18 2002/08/22 07:36:44 keithp Exp $
+ *
+ * Copyright © 2001 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -19,7 +21,6 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-/* $XFree86: xc/extras/fontconfig/src/fccharset.c,v 1.2 2003/06/04 16:29:39 dawes Exp $ */
 
 #include <stdlib.h>
 #include "fcint.h"
@@ -171,7 +172,7 @@
  * if desired
  */
 
-static FcCharLeaf *
+FcCharLeaf *
 FcCharSetFindLeafCreate (FcCharSet *fcs, FcChar32 ucs4)
 {
     int			pos;
@@ -636,7 +637,7 @@
 		bi++;
 	}
     }
-    return FcTrue;
+    return ai >= a->num;
 }
 
 /*
@@ -1159,769 +1160,3 @@
     
     return FcTrue;
 }
-
-/*
- * Figure out whether the available freetype has FT_Get_Next_Char
- */
-
-#if FREETYPE_MAJOR > 2
-# define HAS_NEXT_CHAR
-#else
-# if FREETYPE_MAJOR == 2
-#  if FREETYPE_MINOR > 0
-#   define HAS_NEXT_CHAR
-#  else
-#   if FREETYPE_MINOR == 0
-#    if FREETYPE_PATCH >= 9
-#     define HAS_NEXT_CHAR
-#    endif
-#   endif
-#  endif
-# endif
-#endif
-
-/*
- * For our purposes, this approximation is sufficient
- */
-#ifndef HAS_NEXT_CHAR
-#define FT_Get_First_Char(face, gi) ((*(gi) = 1), 1)
-#define FT_Get_Next_Char(face, ucs4, gi) ((ucs4) >= 0xffffff ? \
-					  (*(gi) = 0), 0 : \
-					  (*(gi) = 1), (ucs4) + 1)
-#warning "No FT_Get_Next_Char"
-#endif
-
-typedef struct _FcCharEnt {
-    FcChar16	    bmp;
-    unsigned char   encode;
-} FcCharEnt;
-
-struct _FcCharMap {
-    const FcCharEnt *ent;
-    int		    nent;
-};
-
-typedef struct _FcFontDecode {
-    FT_Encoding	    encoding;
-    const FcCharMap *map;
-    FcChar32	    max;
-} FcFontDecode;
-
-static const FcCharEnt AppleRomanEnt[] = {
-    { 0x0020, 0x20 }, /* SPACE */
-    { 0x0021, 0x21 }, /* EXCLAMATION MARK */
-    { 0x0022, 0x22 }, /* QUOTATION MARK */
-    { 0x0023, 0x23 }, /* NUMBER SIGN */
-    { 0x0024, 0x24 }, /* DOLLAR SIGN */
-    { 0x0025, 0x25 }, /* PERCENT SIGN */
-    { 0x0026, 0x26 }, /* AMPERSAND */
-    { 0x0027, 0x27 }, /* APOSTROPHE */
-    { 0x0028, 0x28 }, /* LEFT PARENTHESIS */
-    { 0x0029, 0x29 }, /* RIGHT PARENTHESIS */
-    { 0x002A, 0x2A }, /* ASTERISK */
-    { 0x002B, 0x2B }, /* PLUS SIGN */
-    { 0x002C, 0x2C }, /* COMMA */
-    { 0x002D, 0x2D }, /* HYPHEN-MINUS */
-    { 0x002E, 0x2E }, /* FULL STOP */
-    { 0x002F, 0x2F }, /* SOLIDUS */
-    { 0x0030, 0x30 }, /* DIGIT ZERO */
-    { 0x0031, 0x31 }, /* DIGIT ONE */
-    { 0x0032, 0x32 }, /* DIGIT TWO */
-    { 0x0033, 0x33 }, /* DIGIT THREE */
-    { 0x0034, 0x34 }, /* DIGIT FOUR */
-    { 0x0035, 0x35 }, /* DIGIT FIVE */
-    { 0x0036, 0x36 }, /* DIGIT SIX */
-    { 0x0037, 0x37 }, /* DIGIT SEVEN */
-    { 0x0038, 0x38 }, /* DIGIT EIGHT */
-    { 0x0039, 0x39 }, /* DIGIT NINE */
-    { 0x003A, 0x3A }, /* COLON */
-    { 0x003B, 0x3B }, /* SEMICOLON */
-    { 0x003C, 0x3C }, /* LESS-THAN SIGN */
-    { 0x003D, 0x3D }, /* EQUALS SIGN */
-    { 0x003E, 0x3E }, /* GREATER-THAN SIGN */
-    { 0x003F, 0x3F }, /* QUESTION MARK */
-    { 0x0040, 0x40 }, /* COMMERCIAL AT */
-    { 0x0041, 0x41 }, /* LATIN CAPITAL LETTER A */
-    { 0x0042, 0x42 }, /* LATIN CAPITAL LETTER B */
-    { 0x0043, 0x43 }, /* LATIN CAPITAL LETTER C */
-    { 0x0044, 0x44 }, /* LATIN CAPITAL LETTER D */
-    { 0x0045, 0x45 }, /* LATIN CAPITAL LETTER E */
-    { 0x0046, 0x46 }, /* LATIN CAPITAL LETTER F */
-    { 0x0047, 0x47 }, /* LATIN CAPITAL LETTER G */
-    { 0x0048, 0x48 }, /* LATIN CAPITAL LETTER H */
-    { 0x0049, 0x49 }, /* LATIN CAPITAL LETTER I */
-    { 0x004A, 0x4A }, /* LATIN CAPITAL LETTER J */
-    { 0x004B, 0x4B }, /* LATIN CAPITAL LETTER K */
-    { 0x004C, 0x4C }, /* LATIN CAPITAL LETTER L */
-    { 0x004D, 0x4D }, /* LATIN CAPITAL LETTER M */
-    { 0x004E, 0x4E }, /* LATIN CAPITAL LETTER N */
-    { 0x004F, 0x4F }, /* LATIN CAPITAL LETTER O */
-    { 0x0050, 0x50 }, /* LATIN CAPITAL LETTER P */
-    { 0x0051, 0x51 }, /* LATIN CAPITAL LETTER Q */
-    { 0x0052, 0x52 }, /* LATIN CAPITAL LETTER R */
-    { 0x0053, 0x53 }, /* LATIN CAPITAL LETTER S */
-    { 0x0054, 0x54 }, /* LATIN CAPITAL LETTER T */
-    { 0x0055, 0x55 }, /* LATIN CAPITAL LETTER U */
-    { 0x0056, 0x56 }, /* LATIN CAPITAL LETTER V */
-    { 0x0057, 0x57 }, /* LATIN CAPITAL LETTER W */
-    { 0x0058, 0x58 }, /* LATIN CAPITAL LETTER X */
-    { 0x0059, 0x59 }, /* LATIN CAPITAL LETTER Y */
-    { 0x005A, 0x5A }, /* LATIN CAPITAL LETTER Z */
-    { 0x005B, 0x5B }, /* LEFT SQUARE BRACKET */
-    { 0x005C, 0x5C }, /* REVERSE SOLIDUS */
-    { 0x005D, 0x5D }, /* RIGHT SQUARE BRACKET */
-    { 0x005E, 0x5E }, /* CIRCUMFLEX ACCENT */
-    { 0x005F, 0x5F }, /* LOW LINE */
-    { 0x0060, 0x60 }, /* GRAVE ACCENT */
-    { 0x0061, 0x61 }, /* LATIN SMALL LETTER A */
-    { 0x0062, 0x62 }, /* LATIN SMALL LETTER B */
-    { 0x0063, 0x63 }, /* LATIN SMALL LETTER C */
-    { 0x0064, 0x64 }, /* LATIN SMALL LETTER D */
-    { 0x0065, 0x65 }, /* LATIN SMALL LETTER E */
-    { 0x0066, 0x66 }, /* LATIN SMALL LETTER F */
-    { 0x0067, 0x67 }, /* LATIN SMALL LETTER G */
-    { 0x0068, 0x68 }, /* LATIN SMALL LETTER H */
-    { 0x0069, 0x69 }, /* LATIN SMALL LETTER I */
-    { 0x006A, 0x6A }, /* LATIN SMALL LETTER J */
-    { 0x006B, 0x6B }, /* LATIN SMALL LETTER K */
-    { 0x006C, 0x6C }, /* LATIN SMALL LETTER L */
-    { 0x006D, 0x6D }, /* LATIN SMALL LETTER M */
-    { 0x006E, 0x6E }, /* LATIN SMALL LETTER N */
-    { 0x006F, 0x6F }, /* LATIN SMALL LETTER O */
-    { 0x0070, 0x70 }, /* LATIN SMALL LETTER P */
-    { 0x0071, 0x71 }, /* LATIN SMALL LETTER Q */
-    { 0x0072, 0x72 }, /* LATIN SMALL LETTER R */
-    { 0x0073, 0x73 }, /* LATIN SMALL LETTER S */
-    { 0x0074, 0x74 }, /* LATIN SMALL LETTER T */
-    { 0x0075, 0x75 }, /* LATIN SMALL LETTER U */
-    { 0x0076, 0x76 }, /* LATIN SMALL LETTER V */
-    { 0x0077, 0x77 }, /* LATIN SMALL LETTER W */
-    { 0x0078, 0x78 }, /* LATIN SMALL LETTER X */
-    { 0x0079, 0x79 }, /* LATIN SMALL LETTER Y */
-    { 0x007A, 0x7A }, /* LATIN SMALL LETTER Z */
-    { 0x007B, 0x7B }, /* LEFT CURLY BRACKET */
-    { 0x007C, 0x7C }, /* VERTICAL LINE */
-    { 0x007D, 0x7D }, /* RIGHT CURLY BRACKET */
-    { 0x007E, 0x7E }, /* TILDE */
-    { 0x00A0, 0xCA }, /* NO-BREAK SPACE */
-    { 0x00A1, 0xC1 }, /* INVERTED EXCLAMATION MARK */
-    { 0x00A2, 0xA2 }, /* CENT SIGN */
-    { 0x00A3, 0xA3 }, /* POUND SIGN */
-    { 0x00A5, 0xB4 }, /* YEN SIGN */
-    { 0x00A7, 0xA4 }, /* SECTION SIGN */
-    { 0x00A8, 0xAC }, /* DIAERESIS */
-    { 0x00A9, 0xA9 }, /* COPYRIGHT SIGN */
-    { 0x00AA, 0xBB }, /* FEMININE ORDINAL INDICATOR */
-    { 0x00AB, 0xC7 }, /* LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */
-    { 0x00AC, 0xC2 }, /* NOT SIGN */
-    { 0x00AE, 0xA8 }, /* REGISTERED SIGN */
-    { 0x00AF, 0xF8 }, /* MACRON */
-    { 0x00B0, 0xA1 }, /* DEGREE SIGN */
-    { 0x00B1, 0xB1 }, /* PLUS-MINUS SIGN */
-    { 0x00B4, 0xAB }, /* ACUTE ACCENT */
-    { 0x00B5, 0xB5 }, /* MICRO SIGN */
-    { 0x00B6, 0xA6 }, /* PILCROW SIGN */
-    { 0x00B7, 0xE1 }, /* MIDDLE DOT */
-    { 0x00B8, 0xFC }, /* CEDILLA */
-    { 0x00BA, 0xBC }, /* MASCULINE ORDINAL INDICATOR */
-    { 0x00BB, 0xC8 }, /* RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */
-    { 0x00BF, 0xC0 }, /* INVERTED QUESTION MARK */
-    { 0x00C0, 0xCB }, /* LATIN CAPITAL LETTER A WITH GRAVE */
-    { 0x00C1, 0xE7 }, /* LATIN CAPITAL LETTER A WITH ACUTE */
-    { 0x00C2, 0xE5 }, /* LATIN CAPITAL LETTER A WITH CIRCUMFLEX */
-    { 0x00C3, 0xCC }, /* LATIN CAPITAL LETTER A WITH TILDE */
-    { 0x00C4, 0x80 }, /* LATIN CAPITAL LETTER A WITH DIAERESIS */
-    { 0x00C5, 0x81 }, /* LATIN CAPITAL LETTER A WITH RING ABOVE */
-    { 0x00C6, 0xAE }, /* LATIN CAPITAL LETTER AE */
-    { 0x00C7, 0x82 }, /* LATIN CAPITAL LETTER C WITH CEDILLA */
-    { 0x00C8, 0xE9 }, /* LATIN CAPITAL LETTER E WITH GRAVE */
-    { 0x00C9, 0x83 }, /* LATIN CAPITAL LETTER E WITH ACUTE */
-    { 0x00CA, 0xE6 }, /* LATIN CAPITAL LETTER E WITH CIRCUMFLEX */
-    { 0x00CB, 0xE8 }, /* LATIN CAPITAL LETTER E WITH DIAERESIS */
-    { 0x00CC, 0xED }, /* LATIN CAPITAL LETTER I WITH GRAVE */
-    { 0x00CD, 0xEA }, /* LATIN CAPITAL LETTER I WITH ACUTE */
-    { 0x00CE, 0xEB }, /* LATIN CAPITAL LETTER I WITH CIRCUMFLEX */
-    { 0x00CF, 0xEC }, /* LATIN CAPITAL LETTER I WITH DIAERESIS */
-    { 0x00D1, 0x84 }, /* LATIN CAPITAL LETTER N WITH TILDE */
-    { 0x00D2, 0xF1 }, /* LATIN CAPITAL LETTER O WITH GRAVE */
-    { 0x00D3, 0xEE }, /* LATIN CAPITAL LETTER O WITH ACUTE */
-    { 0x00D4, 0xEF }, /* LATIN CAPITAL LETTER O WITH CIRCUMFLEX */
-    { 0x00D5, 0xCD }, /* LATIN CAPITAL LETTER O WITH TILDE */
-    { 0x00D6, 0x85 }, /* LATIN CAPITAL LETTER O WITH DIAERESIS */
-    { 0x00D8, 0xAF }, /* LATIN CAPITAL LETTER O WITH STROKE */
-    { 0x00D9, 0xF4 }, /* LATIN CAPITAL LETTER U WITH GRAVE */
-    { 0x00DA, 0xF2 }, /* LATIN CAPITAL LETTER U WITH ACUTE */
-    { 0x00DB, 0xF3 }, /* LATIN CAPITAL LETTER U WITH CIRCUMFLEX */
-    { 0x00DC, 0x86 }, /* LATIN CAPITAL LETTER U WITH DIAERESIS */
-    { 0x00DF, 0xA7 }, /* LATIN SMALL LETTER SHARP S */
-    { 0x00E0, 0x88 }, /* LATIN SMALL LETTER A WITH GRAVE */
-    { 0x00E1, 0x87 }, /* LATIN SMALL LETTER A WITH ACUTE */
-    { 0x00E2, 0x89 }, /* LATIN SMALL LETTER A WITH CIRCUMFLEX */
-    { 0x00E3, 0x8B }, /* LATIN SMALL LETTER A WITH TILDE */
-    { 0x00E4, 0x8A }, /* LATIN SMALL LETTER A WITH DIAERESIS */
-    { 0x00E5, 0x8C }, /* LATIN SMALL LETTER A WITH RING ABOVE */
-    { 0x00E6, 0xBE }, /* LATIN SMALL LETTER AE */
-    { 0x00E7, 0x8D }, /* LATIN SMALL LETTER C WITH CEDILLA */
-    { 0x00E8, 0x8F }, /* LATIN SMALL LETTER E WITH GRAVE */
-    { 0x00E9, 0x8E }, /* LATIN SMALL LETTER E WITH ACUTE */
-    { 0x00EA, 0x90 }, /* LATIN SMALL LETTER E WITH CIRCUMFLEX */
-    { 0x00EB, 0x91 }, /* LATIN SMALL LETTER E WITH DIAERESIS */
-    { 0x00EC, 0x93 }, /* LATIN SMALL LETTER I WITH GRAVE */
-    { 0x00ED, 0x92 }, /* LATIN SMALL LETTER I WITH ACUTE */
-    { 0x00EE, 0x94 }, /* LATIN SMALL LETTER I WITH CIRCUMFLEX */
-    { 0x00EF, 0x95 }, /* LATIN SMALL LETTER I WITH DIAERESIS */
-    { 0x00F1, 0x96 }, /* LATIN SMALL LETTER N WITH TILDE */
-    { 0x00F2, 0x98 }, /* LATIN SMALL LETTER O WITH GRAVE */
-    { 0x00F3, 0x97 }, /* LATIN SMALL LETTER O WITH ACUTE */
-    { 0x00F4, 0x99 }, /* LATIN SMALL LETTER O WITH CIRCUMFLEX */
-    { 0x00F5, 0x9B }, /* LATIN SMALL LETTER O WITH TILDE */
-    { 0x00F6, 0x9A }, /* LATIN SMALL LETTER O WITH DIAERESIS */
-    { 0x00F7, 0xD6 }, /* DIVISION SIGN */
-    { 0x00F8, 0xBF }, /* LATIN SMALL LETTER O WITH STROKE */
-    { 0x00F9, 0x9D }, /* LATIN SMALL LETTER U WITH GRAVE */
-    { 0x00FA, 0x9C }, /* LATIN SMALL LETTER U WITH ACUTE */
-    { 0x00FB, 0x9E }, /* LATIN SMALL LETTER U WITH CIRCUMFLEX */
-    { 0x00FC, 0x9F }, /* LATIN SMALL LETTER U WITH DIAERESIS */
-    { 0x00FF, 0xD8 }, /* LATIN SMALL LETTER Y WITH DIAERESIS */
-    { 0x0131, 0xF5 }, /* LATIN SMALL LETTER DOTLESS I */
-    { 0x0152, 0xCE }, /* LATIN CAPITAL LIGATURE OE */
-    { 0x0153, 0xCF }, /* LATIN SMALL LIGATURE OE */
-    { 0x0178, 0xD9 }, /* LATIN CAPITAL LETTER Y WITH DIAERESIS */
-    { 0x0192, 0xC4 }, /* LATIN SMALL LETTER F WITH HOOK */
-    { 0x02C6, 0xF6 }, /* MODIFIER LETTER CIRCUMFLEX ACCENT */
-    { 0x02C7, 0xFF }, /* CARON */
-    { 0x02D8, 0xF9 }, /* BREVE */
-    { 0x02D9, 0xFA }, /* DOT ABOVE */
-    { 0x02DA, 0xFB }, /* RING ABOVE */
-    { 0x02DB, 0xFE }, /* OGONEK */
-    { 0x02DC, 0xF7 }, /* SMALL TILDE */
-    { 0x02DD, 0xFD }, /* DOUBLE ACUTE ACCENT */
-    { 0x03A9, 0xBD }, /* GREEK CAPITAL LETTER OMEGA */
-    { 0x03C0, 0xB9 }, /* GREEK SMALL LETTER PI */
-    { 0x2013, 0xD0 }, /* EN DASH */
-    { 0x2014, 0xD1 }, /* EM DASH */
-    { 0x2018, 0xD4 }, /* LEFT SINGLE QUOTATION MARK */
-    { 0x2019, 0xD5 }, /* RIGHT SINGLE QUOTATION MARK */
-    { 0x201A, 0xE2 }, /* SINGLE LOW-9 QUOTATION MARK */
-    { 0x201C, 0xD2 }, /* LEFT DOUBLE QUOTATION MARK */
-    { 0x201D, 0xD3 }, /* RIGHT DOUBLE QUOTATION MARK */
-    { 0x201E, 0xE3 }, /* DOUBLE LOW-9 QUOTATION MARK */
-    { 0x2020, 0xA0 }, /* DAGGER */
-    { 0x2021, 0xE0 }, /* DOUBLE DAGGER */
-    { 0x2022, 0xA5 }, /* BULLET */
-    { 0x2026, 0xC9 }, /* HORIZONTAL ELLIPSIS */
-    { 0x2030, 0xE4 }, /* PER MILLE SIGN */
-    { 0x2039, 0xDC }, /* SINGLE LEFT-POINTING ANGLE QUOTATION MARK */
-    { 0x203A, 0xDD }, /* SINGLE RIGHT-POINTING ANGLE QUOTATION MARK */
-    { 0x2044, 0xDA }, /* FRACTION SLASH */
-    { 0x20AC, 0xDB }, /* EURO SIGN */
-    { 0x2122, 0xAA }, /* TRADE MARK SIGN */
-    { 0x2202, 0xB6 }, /* PARTIAL DIFFERENTIAL */
-    { 0x2206, 0xC6 }, /* INCREMENT */
-    { 0x220F, 0xB8 }, /* N-ARY PRODUCT */
-    { 0x2211, 0xB7 }, /* N-ARY SUMMATION */
-    { 0x221A, 0xC3 }, /* SQUARE ROOT */
-    { 0x221E, 0xB0 }, /* INFINITY */
-    { 0x222B, 0xBA }, /* INTEGRAL */
-    { 0x2248, 0xC5 }, /* ALMOST EQUAL TO */
-    { 0x2260, 0xAD }, /* NOT EQUAL TO */
-    { 0x2264, 0xB2 }, /* LESS-THAN OR EQUAL TO */
-    { 0x2265, 0xB3 }, /* GREATER-THAN OR EQUAL TO */
-    { 0x25CA, 0xD7 }, /* LOZENGE */
-    { 0xF8FF, 0xF0 }, /* Apple logo */
-    { 0xFB01, 0xDE }, /* LATIN SMALL LIGATURE FI */
-    { 0xFB02, 0xDF }, /* LATIN SMALL LIGATURE FL */
-};
-
-static const FcCharMap AppleRoman = {
-    AppleRomanEnt,
-    sizeof (AppleRomanEnt) / sizeof (AppleRomanEnt[0])
-};
-
-static const FcCharEnt AdobeSymbolEnt[] = {
-    { 0x0020, 0x20 }, /* SPACE	# space */
-    { 0x0021, 0x21 }, /* EXCLAMATION MARK	# exclam */
-    { 0x0023, 0x23 }, /* NUMBER SIGN	# numbersign */
-    { 0x0025, 0x25 }, /* PERCENT SIGN	# percent */
-    { 0x0026, 0x26 }, /* AMPERSAND	# ampersand */
-    { 0x0028, 0x28 }, /* LEFT PARENTHESIS	# parenleft */
-    { 0x0029, 0x29 }, /* RIGHT PARENTHESIS	# parenright */
-    { 0x002B, 0x2B }, /* PLUS SIGN	# plus */
-    { 0x002C, 0x2C }, /* COMMA	# comma */
-    { 0x002E, 0x2E }, /* FULL STOP	# period */
-    { 0x002F, 0x2F }, /* SOLIDUS	# slash */
-    { 0x0030, 0x30 }, /* DIGIT ZERO	# zero */
-    { 0x0031, 0x31 }, /* DIGIT ONE	# one */
-    { 0x0032, 0x32 }, /* DIGIT TWO	# two */
-    { 0x0033, 0x33 }, /* DIGIT THREE	# three */
-    { 0x0034, 0x34 }, /* DIGIT FOUR	# four */
-    { 0x0035, 0x35 }, /* DIGIT FIVE	# five */
-    { 0x0036, 0x36 }, /* DIGIT SIX	# six */
-    { 0x0037, 0x37 }, /* DIGIT SEVEN	# seven */
-    { 0x0038, 0x38 }, /* DIGIT EIGHT	# eight */
-    { 0x0039, 0x39 }, /* DIGIT NINE	# nine */
-    { 0x003A, 0x3A }, /* COLON	# colon */
-    { 0x003B, 0x3B }, /* SEMICOLON	# semicolon */
-    { 0x003C, 0x3C }, /* LESS-THAN SIGN	# less */
-    { 0x003D, 0x3D }, /* EQUALS SIGN	# equal */
-    { 0x003E, 0x3E }, /* GREATER-THAN SIGN	# greater */
-    { 0x003F, 0x3F }, /* QUESTION MARK	# question */
-    { 0x005B, 0x5B }, /* LEFT SQUARE BRACKET	# bracketleft */
-    { 0x005D, 0x5D }, /* RIGHT SQUARE BRACKET	# bracketright */
-    { 0x005F, 0x5F }, /* LOW LINE	# underscore */
-    { 0x007B, 0x7B }, /* LEFT CURLY BRACKET	# braceleft */
-    { 0x007C, 0x7C }, /* VERTICAL LINE	# bar */
-    { 0x007D, 0x7D }, /* RIGHT CURLY BRACKET	# braceright */
-    { 0x00A0, 0x20 }, /* NO-BREAK SPACE	# space */
-    { 0x00AC, 0xD8 }, /* NOT SIGN	# logicalnot */
-    { 0x00B0, 0xB0 }, /* DEGREE SIGN	# degree */
-    { 0x00B1, 0xB1 }, /* PLUS-MINUS SIGN	# plusminus */
-    { 0x00B5, 0x6D }, /* MICRO SIGN	# mu */
-    { 0x00D7, 0xB4 }, /* MULTIPLICATION SIGN	# multiply */
-    { 0x00F7, 0xB8 }, /* DIVISION SIGN	# divide */
-    { 0x0192, 0xA6 }, /* LATIN SMALL LETTER F WITH HOOK	# florin */
-    { 0x0391, 0x41 }, /* GREEK CAPITAL LETTER ALPHA	# Alpha */
-    { 0x0392, 0x42 }, /* GREEK CAPITAL LETTER BETA	# Beta */
-    { 0x0393, 0x47 }, /* GREEK CAPITAL LETTER GAMMA	# Gamma */
-    { 0x0394, 0x44 }, /* GREEK CAPITAL LETTER DELTA	# Delta */
-    { 0x0395, 0x45 }, /* GREEK CAPITAL LETTER EPSILON	# Epsilon */
-    { 0x0396, 0x5A }, /* GREEK CAPITAL LETTER ZETA	# Zeta */
-    { 0x0397, 0x48 }, /* GREEK CAPITAL LETTER ETA	# Eta */
-    { 0x0398, 0x51 }, /* GREEK CAPITAL LETTER THETA	# Theta */
-    { 0x0399, 0x49 }, /* GREEK CAPITAL LETTER IOTA	# Iota */
-    { 0x039A, 0x4B }, /* GREEK CAPITAL LETTER KAPPA	# Kappa */
-    { 0x039B, 0x4C }, /* GREEK CAPITAL LETTER LAMDA	# Lambda */
-    { 0x039C, 0x4D }, /* GREEK CAPITAL LETTER MU	# Mu */
-    { 0x039D, 0x4E }, /* GREEK CAPITAL LETTER NU	# Nu */
-    { 0x039E, 0x58 }, /* GREEK CAPITAL LETTER XI	# Xi */
-    { 0x039F, 0x4F }, /* GREEK CAPITAL LETTER OMICRON	# Omicron */
-    { 0x03A0, 0x50 }, /* GREEK CAPITAL LETTER PI	# Pi */
-    { 0x03A1, 0x52 }, /* GREEK CAPITAL LETTER RHO	# Rho */
-    { 0x03A3, 0x53 }, /* GREEK CAPITAL LETTER SIGMA	# Sigma */
-    { 0x03A4, 0x54 }, /* GREEK CAPITAL LETTER TAU	# Tau */
-    { 0x03A5, 0x55 }, /* GREEK CAPITAL LETTER UPSILON	# Upsilon */
-    { 0x03A6, 0x46 }, /* GREEK CAPITAL LETTER PHI	# Phi */
-    { 0x03A7, 0x43 }, /* GREEK CAPITAL LETTER CHI	# Chi */
-    { 0x03A8, 0x59 }, /* GREEK CAPITAL LETTER PSI	# Psi */
-    { 0x03A9, 0x57 }, /* GREEK CAPITAL LETTER OMEGA	# Omega */
-    { 0x03B1, 0x61 }, /* GREEK SMALL LETTER ALPHA	# alpha */
-    { 0x03B2, 0x62 }, /* GREEK SMALL LETTER BETA	# beta */
-    { 0x03B3, 0x67 }, /* GREEK SMALL LETTER GAMMA	# gamma */
-    { 0x03B4, 0x64 }, /* GREEK SMALL LETTER DELTA	# delta */
-    { 0x03B5, 0x65 }, /* GREEK SMALL LETTER EPSILON	# epsilon */
-    { 0x03B6, 0x7A }, /* GREEK SMALL LETTER ZETA	# zeta */
-    { 0x03B7, 0x68 }, /* GREEK SMALL LETTER ETA	# eta */
-    { 0x03B8, 0x71 }, /* GREEK SMALL LETTER THETA	# theta */
-    { 0x03B9, 0x69 }, /* GREEK SMALL LETTER IOTA	# iota */
-    { 0x03BA, 0x6B }, /* GREEK SMALL LETTER KAPPA	# kappa */
-    { 0x03BB, 0x6C }, /* GREEK SMALL LETTER LAMDA	# lambda */
-    { 0x03BC, 0x6D }, /* GREEK SMALL LETTER MU	# mu */
-    { 0x03BD, 0x6E }, /* GREEK SMALL LETTER NU	# nu */
-    { 0x03BE, 0x78 }, /* GREEK SMALL LETTER XI	# xi */
-    { 0x03BF, 0x6F }, /* GREEK SMALL LETTER OMICRON	# omicron */
-    { 0x03C0, 0x70 }, /* GREEK SMALL LETTER PI	# pi */
-    { 0x03C1, 0x72 }, /* GREEK SMALL LETTER RHO	# rho */
-    { 0x03C2, 0x56 }, /* GREEK SMALL LETTER FINAL SIGMA	# sigma1 */
-    { 0x03C3, 0x73 }, /* GREEK SMALL LETTER SIGMA	# sigma */
-    { 0x03C4, 0x74 }, /* GREEK SMALL LETTER TAU	# tau */
-    { 0x03C5, 0x75 }, /* GREEK SMALL LETTER UPSILON	# upsilon */
-    { 0x03C6, 0x66 }, /* GREEK SMALL LETTER PHI	# phi */
-    { 0x03C7, 0x63 }, /* GREEK SMALL LETTER CHI	# chi */
-    { 0x03C8, 0x79 }, /* GREEK SMALL LETTER PSI	# psi */
-    { 0x03C9, 0x77 }, /* GREEK SMALL LETTER OMEGA	# omega */
-    { 0x03D1, 0x4A }, /* GREEK THETA SYMBOL	# theta1 */
-    { 0x03D2, 0xA1 }, /* GREEK UPSILON WITH HOOK SYMBOL	# Upsilon1 */
-    { 0x03D5, 0x6A }, /* GREEK PHI SYMBOL	# phi1 */
-    { 0x03D6, 0x76 }, /* GREEK PI SYMBOL	# omega1 */
-    { 0x2022, 0xB7 }, /* BULLET	# bullet */
-    { 0x2026, 0xBC }, /* HORIZONTAL ELLIPSIS	# ellipsis */
-    { 0x2032, 0xA2 }, /* PRIME	# minute */
-    { 0x2033, 0xB2 }, /* DOUBLE PRIME	# second */
-    { 0x2044, 0xA4 }, /* FRACTION SLASH	# fraction */
-    { 0x20AC, 0xA0 }, /* EURO SIGN	# Euro */
-    { 0x2111, 0xC1 }, /* BLACK-LETTER CAPITAL I	# Ifraktur */
-    { 0x2118, 0xC3 }, /* SCRIPT CAPITAL P	# weierstrass */
-    { 0x211C, 0xC2 }, /* BLACK-LETTER CAPITAL R	# Rfraktur */
-    { 0x2126, 0x57 }, /* OHM SIGN	# Omega */
-    { 0x2135, 0xC0 }, /* ALEF SYMBOL	# aleph */
-    { 0x2190, 0xAC }, /* LEFTWARDS ARROW	# arrowleft */
-    { 0x2191, 0xAD }, /* UPWARDS ARROW	# arrowup */
-    { 0x2192, 0xAE }, /* RIGHTWARDS ARROW	# arrowright */
-    { 0x2193, 0xAF }, /* DOWNWARDS ARROW	# arrowdown */
-    { 0x2194, 0xAB }, /* LEFT RIGHT ARROW	# arrowboth */
-    { 0x21B5, 0xBF }, /* DOWNWARDS ARROW WITH CORNER LEFTWARDS	# carriagereturn */
-    { 0x21D0, 0xDC }, /* LEFTWARDS DOUBLE ARROW	# arrowdblleft */
-    { 0x21D1, 0xDD }, /* UPWARDS DOUBLE ARROW	# arrowdblup */
-    { 0x21D2, 0xDE }, /* RIGHTWARDS DOUBLE ARROW	# arrowdblright */
-    { 0x21D3, 0xDF }, /* DOWNWARDS DOUBLE ARROW	# arrowdbldown */
-    { 0x21D4, 0xDB }, /* LEFT RIGHT DOUBLE ARROW	# arrowdblboth */
-    { 0x2200, 0x22 }, /* FOR ALL	# universal */
-    { 0x2202, 0xB6 }, /* PARTIAL DIFFERENTIAL	# partialdiff */
-    { 0x2203, 0x24 }, /* THERE EXISTS	# existential */
-    { 0x2205, 0xC6 }, /* EMPTY SET	# emptyset */
-    { 0x2206, 0x44 }, /* INCREMENT	# Delta */
-    { 0x2207, 0xD1 }, /* NABLA	# gradient */
-    { 0x2208, 0xCE }, /* ELEMENT OF	# element */
-    { 0x2209, 0xCF }, /* NOT AN ELEMENT OF	# notelement */
-    { 0x220B, 0x27 }, /* CONTAINS AS MEMBER	# suchthat */
-    { 0x220F, 0xD5 }, /* N-ARY PRODUCT	# product */
-    { 0x2211, 0xE5 }, /* N-ARY SUMMATION	# summation */
-    { 0x2212, 0x2D }, /* MINUS SIGN	# minus */
-    { 0x2215, 0xA4 }, /* DIVISION SLASH	# fraction */
-    { 0x2217, 0x2A }, /* ASTERISK OPERATOR	# asteriskmath */
-    { 0x221A, 0xD6 }, /* SQUARE ROOT	# radical */
-    { 0x221D, 0xB5 }, /* PROPORTIONAL TO	# proportional */
-    { 0x221E, 0xA5 }, /* INFINITY	# infinity */
-    { 0x2220, 0xD0 }, /* ANGLE	# angle */
-    { 0x2227, 0xD9 }, /* LOGICAL AND	# logicaland */
-    { 0x2228, 0xDA }, /* LOGICAL OR	# logicalor */
-    { 0x2229, 0xC7 }, /* INTERSECTION	# intersection */
-    { 0x222A, 0xC8 }, /* UNION	# union */
-    { 0x222B, 0xF2 }, /* INTEGRAL	# integral */
-    { 0x2234, 0x5C }, /* THEREFORE	# therefore */
-    { 0x223C, 0x7E }, /* TILDE OPERATOR	# similar */
-    { 0x2245, 0x40 }, /* APPROXIMATELY EQUAL TO	# congruent */
-    { 0x2248, 0xBB }, /* ALMOST EQUAL TO	# approxequal */
-    { 0x2260, 0xB9 }, /* NOT EQUAL TO	# notequal */
-    { 0x2261, 0xBA }, /* IDENTICAL TO	# equivalence */
-    { 0x2264, 0xA3 }, /* LESS-THAN OR EQUAL TO	# lessequal */
-    { 0x2265, 0xB3 }, /* GREATER-THAN OR EQUAL TO	# greaterequal */
-    { 0x2282, 0xCC }, /* SUBSET OF	# propersubset */
-    { 0x2283, 0xC9 }, /* SUPERSET OF	# propersuperset */
-    { 0x2284, 0xCB }, /* NOT A SUBSET OF	# notsubset */
-    { 0x2286, 0xCD }, /* SUBSET OF OR EQUAL TO	# reflexsubset */
-    { 0x2287, 0xCA }, /* SUPERSET OF OR EQUAL TO	# reflexsuperset */
-    { 0x2295, 0xC5 }, /* CIRCLED PLUS	# circleplus */
-    { 0x2297, 0xC4 }, /* CIRCLED TIMES	# circlemultiply */
-    { 0x22A5, 0x5E }, /* UP TACK	# perpendicular */
-    { 0x22C5, 0xD7 }, /* DOT OPERATOR	# dotmath */
-    { 0x2320, 0xF3 }, /* TOP HALF INTEGRAL	# integraltp */
-    { 0x2321, 0xF5 }, /* BOTTOM HALF INTEGRAL	# integralbt */
-    { 0x2329, 0xE1 }, /* LEFT-POINTING ANGLE BRACKET	# angleleft */
-    { 0x232A, 0xF1 }, /* RIGHT-POINTING ANGLE BRACKET	# angleright */
-    { 0x25CA, 0xE0 }, /* LOZENGE	# lozenge */
-    { 0x2660, 0xAA }, /* BLACK SPADE SUIT	# spade */
-    { 0x2663, 0xA7 }, /* BLACK CLUB SUIT	# club */
-    { 0x2665, 0xA9 }, /* BLACK HEART SUIT	# heart */
-    { 0x2666, 0xA8 }, /* BLACK DIAMOND SUIT	# diamond */
-    { 0xF6D9, 0xD3 }, /* COPYRIGHT SIGN SERIF	# copyrightserif (CUS) */
-    { 0xF6DA, 0xD2 }, /* REGISTERED SIGN SERIF	# registerserif (CUS) */
-    { 0xF6DB, 0xD4 }, /* TRADE MARK SIGN SERIF	# trademarkserif (CUS) */
-    { 0xF8E5, 0x60 }, /* RADICAL EXTENDER	# radicalex (CUS) */
-    { 0xF8E6, 0xBD }, /* VERTICAL ARROW EXTENDER	# arrowvertex (CUS) */
-    { 0xF8E7, 0xBE }, /* HORIZONTAL ARROW EXTENDER	# arrowhorizex (CUS) */
-    { 0xF8E8, 0xE2 }, /* REGISTERED SIGN SANS SERIF	# registersans (CUS) */
-    { 0xF8E9, 0xE3 }, /* COPYRIGHT SIGN SANS SERIF	# copyrightsans (CUS) */
-    { 0xF8EA, 0xE4 }, /* TRADE MARK SIGN SANS SERIF	# trademarksans (CUS) */
-    { 0xF8EB, 0xE6 }, /* LEFT PAREN TOP	# parenlefttp (CUS) */
-    { 0xF8EC, 0xE7 }, /* LEFT PAREN EXTENDER	# parenleftex (CUS) */
-    { 0xF8ED, 0xE8 }, /* LEFT PAREN BOTTOM	# parenleftbt (CUS) */
-    { 0xF8EE, 0xE9 }, /* LEFT SQUARE BRACKET TOP	# bracketlefttp (CUS) */
-    { 0xF8EF, 0xEA }, /* LEFT SQUARE BRACKET EXTENDER	# bracketleftex (CUS) */
-    { 0xF8F0, 0xEB }, /* LEFT SQUARE BRACKET BOTTOM	# bracketleftbt (CUS) */
-    { 0xF8F1, 0xEC }, /* LEFT CURLY BRACKET TOP	# bracelefttp (CUS) */
-    { 0xF8F2, 0xED }, /* LEFT CURLY BRACKET MID	# braceleftmid (CUS) */
-    { 0xF8F3, 0xEE }, /* LEFT CURLY BRACKET BOTTOM	# braceleftbt (CUS) */
-    { 0xF8F4, 0xEF }, /* CURLY BRACKET EXTENDER	# braceex (CUS) */
-    { 0xF8F5, 0xF4 }, /* INTEGRAL EXTENDER	# integralex (CUS) */
-    { 0xF8F6, 0xF6 }, /* RIGHT PAREN TOP	# parenrighttp (CUS) */
-    { 0xF8F7, 0xF7 }, /* RIGHT PAREN EXTENDER	# parenrightex (CUS) */
-    { 0xF8F8, 0xF8 }, /* RIGHT PAREN BOTTOM	# parenrightbt (CUS) */
-    { 0xF8F9, 0xF9 }, /* RIGHT SQUARE BRACKET TOP	# bracketrighttp (CUS) */
-    { 0xF8FA, 0xFA }, /* RIGHT SQUARE BRACKET EXTENDER	# bracketrightex (CUS) */
-    { 0xF8FB, 0xFB }, /* RIGHT SQUARE BRACKET BOTTOM	# bracketrightbt (CUS) */
-    { 0xF8FC, 0xFC }, /* RIGHT CURLY BRACKET TOP	# bracerighttp (CUS) */
-    { 0xF8FD, 0xFD }, /* RIGHT CURLY BRACKET MID	# bracerightmid (CUS) */
-    { 0xF8FE, 0xFE }, /* RIGHT CURLY BRACKET BOTTOM	# bracerightbt (CUS) */
-};
-
-static const FcCharMap AdobeSymbol = {
-    AdobeSymbolEnt,
-    sizeof (AdobeSymbolEnt) / sizeof (AdobeSymbolEnt[0]),
-};
-    
-static const FcFontDecode fcFontDecoders[] = {
-    { ft_encoding_unicode,	0,		(1 << 21) - 1 },
-    { ft_encoding_symbol,	&AdobeSymbol,	(1 << 16) - 1 },
-    { ft_encoding_apple_roman,	&AppleRoman,	(1 << 16) - 1 },
-};
-
-#define NUM_DECODE  (sizeof (fcFontDecoders) / sizeof (fcFontDecoders[0]))
-
-FcChar32
-FcFreeTypeUcs4ToPrivate (FcChar32 ucs4, const FcCharMap *map)
-{
-    int		low, high, mid;
-    FcChar16	bmp;
-
-    low = 0;
-    high = map->nent - 1;
-    if (ucs4 < map->ent[low].bmp || map->ent[high].bmp < ucs4)
-	return ~0;
-    while (low <= high)
-    {
-	mid = (high + low) >> 1;
-	bmp = map->ent[mid].bmp;
-	if (ucs4 == bmp)
-	    return (FT_ULong) map->ent[mid].encode;
-	if (ucs4 < bmp)
-	    high = mid - 1;
-	else
-	    low = mid + 1;
-    }
-    return ~0;
-}
-
-FcChar32
-FcFreeTypePrivateToUcs4 (FcChar32 private, const FcCharMap *map)
-{
-    int	    i;
-
-    for (i = 0; i < map->nent; i++)
-	if (map->ent[i].encode == private)
-	    return (FcChar32) map->ent[i].bmp;
-    return ~0;
-}
-
-const FcCharMap *
-FcFreeTypeGetPrivateMap (FT_Encoding encoding)
-{
-    int	i;
-
-    for (i = 0; i < NUM_DECODE; i++)
-	if (fcFontDecoders[i].encoding == encoding)
-	    return fcFontDecoders[i].map;
-    return 0;
-}
-
-/*
- * Map a UCS4 glyph to a glyph index.  Use all available encoding
- * tables to try and find one that works.  This information is expected
- * to be cached by higher levels, so performance isn't critical
- */
-
-FT_UInt
-FcFreeTypeCharIndex (FT_Face face, FcChar32 ucs4)
-{
-    int		    initial, offset, decode;
-    FT_UInt	    glyphindex;
-    FcChar32	    charcode;
-
-    initial = 0;
-    /*
-     * Find the current encoding
-     */
-    if (face->charmap)
-    {
-	for (; initial < NUM_DECODE; initial++)
-	    if (fcFontDecoders[initial].encoding == face->charmap->encoding)
-		break;
-	if (initial == NUM_DECODE)
-	    initial = 0;
-    }
-    /*
-     * Check each encoding for the glyph, starting with the current one
-     */
-    for (offset = 0; offset < NUM_DECODE; offset++)
-    {
-	decode = (initial + offset) % NUM_DECODE;
-	if (!face->charmap || face->charmap->encoding != fcFontDecoders[decode].encoding)
-	    if (FT_Select_Charmap (face, fcFontDecoders[decode].encoding) != 0)
-		continue;
-	if (fcFontDecoders[decode].map)
-	{
-	    charcode = FcFreeTypeUcs4ToPrivate (ucs4, fcFontDecoders[decode].map);
-	    if (charcode == ~0)
-		continue;
-	}
-	else
-	    charcode = ucs4;
-	glyphindex = FT_Get_Char_Index (face, (FT_ULong) charcode);
-	if (glyphindex)
-	    return glyphindex;
-    }
-    return 0;
-}
-
-static FcBool
-FcFreeTypeCheckGlyph (FT_Face face, FcChar32 ucs4, 
-		      FT_UInt glyph, FcBlanks *blanks)
-{
-    FT_Int	    load_flags = FT_LOAD_NO_SCALE | FT_LOAD_NO_HINTING;
-    FT_GlyphSlot    slot;
-    
-    /*
-     * When using scalable fonts, only report those glyphs
-     * which can be scaled; otherwise those fonts will
-     * only be available at some sizes, and never when
-     * transformed.  Avoid this by simply reporting bitmap-only
-     * glyphs as missing
-     */
-    if (face->face_flags & FT_FACE_FLAG_SCALABLE)
-	load_flags |= FT_LOAD_NO_BITMAP;
-    
-    if (FT_Load_Glyph (face, glyph, load_flags))
-	return FcFalse;
-    
-    slot = face->glyph;
-    if (!glyph)
-	return FcFalse;
-    
-    switch (slot->format) {
-    case ft_glyph_format_bitmap:
-	/*
-	 * Bitmaps are assumed to be reasonable; if
-	 * this proves to be a rash assumption, this
-	 * code can be easily modified
-	 */
-	return FcTrue;
-    case ft_glyph_format_outline:
-	/*
-	 * Glyphs with contours are always OK
-	 */
-	if (slot->outline.n_contours != 0)
-	    return FcTrue;
-	/*
-	 * Glyphs with no contours are only OK if
-	 * they're members of the Blanks set specified
-	 * in the configuration.  If blanks isn't set,
-	 * then allow any glyph to be blank
-	 */
-	if (!blanks || FcBlanksIsMember (blanks, ucs4))
-	    return FcTrue;
-	/* fall through ... */
-    default:
-	break;
-    }
-    return FcFalse;
-}
-
-FcCharSet *
-FcFreeTypeCharSet (FT_Face face, FcBlanks *blanks)
-{
-    FcChar32	    page, off, ucs4;
-#ifdef CHECK
-    FcChar32	    font_max = 0;
-#endif
-    FcCharSet	    *fcs;
-    FcCharLeaf	    *leaf;
-    const FcCharMap *map;
-    int		    o;
-    int		    i;
-    FT_UInt	    glyph;
-
-    fcs = FcCharSetCreate ();
-    if (!fcs)
-	goto bail0;
-    
-    for (o = 0; o < NUM_DECODE; o++)
-    {
-	if (FT_Select_Charmap (face, fcFontDecoders[o].encoding) != 0)
-	    continue;
-	map = fcFontDecoders[o].map;
-	if (map)
-	{
-	    /*
-	     * Non-Unicode tables are easy; there's a list of all possible
-	     * characters
-	     */
-	    for (i = 0; i < map->nent; i++)
-	    {
-		ucs4 = map->ent[i].bmp;
-		glyph = FT_Get_Char_Index (face, map->ent[i].encode);
-		if (glyph && FcFreeTypeCheckGlyph (face, ucs4, glyph, blanks))
-		{
-		    leaf = FcCharSetFindLeafCreate (fcs, ucs4);
-		    if (!leaf)
-			goto bail1;
-		    leaf->map[(ucs4 & 0xff) >> 5] |= (1 << (ucs4 & 0x1f));
-#ifdef CHECK
-		    if (ucs4 > font_max)
-			font_max = ucs4;
-#endif
-		}
-	    }
-	}
-	else
-	{
-	    FT_UInt gindex;
-	  
-	    /*
-	     * Find the first encoded character in the font
-	     */
-	    if (FT_Get_Char_Index (face, 0))
-	    {
-		ucs4 = 0;
-		gindex = 1;
-	    }
-	    else
-	    {
-		ucs4 = FT_Get_Next_Char (face, 0, &gindex);
-		if (!ucs4)
-		    gindex = 0;
-	    }
-
-	    while (gindex)
-	    {
-		page = ucs4 >> 8;
-		leaf = 0;
-		while ((ucs4 >> 8) == page)
-		{
-		    glyph = FT_Get_Char_Index (face, ucs4);
-		    if (glyph && FcFreeTypeCheckGlyph (face, ucs4, 
-						       glyph, blanks))
-		    {
-			if (!leaf)
-			{
-			    leaf = FcCharSetFindLeafCreate (fcs, ucs4);
-			    if (!leaf)
-				goto bail1;
-			}
-			off = ucs4 & 0xff;
-			leaf->map[off >> 5] |= (1 << (off & 0x1f));
-#ifdef CHECK
-			if (ucs4 > font_max)
-			    font_max = ucs4;
-#endif
-		    }
-		    ucs4++;
-		}
-		ucs4 = FT_Get_Next_Char (face, ucs4 - 1, &gindex);
-		if (!ucs4)
-		    gindex = 0;
-	    }
-#ifdef CHECK
-	    for (ucs4 = 0; ucs4 < 0x10000; ucs4++)
-	    {
-		FcBool	    FT_Has, FC_Has;
-
-		FT_Has = FT_Get_Char_Index (face, ucs4) != 0;
-		FC_Has = FcCharSetHasChar (fcs, ucs4);
-		if (FT_Has != FC_Has)
-		{
-		    printf ("0x%08x FT says %d FC says %d\n", ucs4, FT_Has, FC_Has);
-		}
-	    }
-#endif
-	}
-    }
-#ifdef CHECK
-    printf ("%d glyphs %d encoded\n", (int) face->num_glyphs, FcCharSetCount (fcs));
-    for (ucs4 = 0; ucs4 <= font_max; ucs4++)
-    {
-	FcBool	has_char = FcFreeTypeCharIndex (face, ucs4) != 0;
-	FcBool	has_bit = FcCharSetHasChar (fcs, ucs4);
-
-	if (has_char && !has_bit)
-	    printf ("Bitmap missing char 0x%x\n", ucs4);
-	else if (!has_char && has_bit)
-	    printf ("Bitmap extra char 0x%x\n", ucs4);
-    }
-#endif
-    return fcs;
-bail1:
-    FcCharSetDestroy (fcs);
-bail0:
-    return 0;
-}
-
diff -urN xc/extras/fontconfig/src/fcdbg.c xc-fontconfig/extras/fontconfig/src/fcdbg.c
--- xc/extras/fontconfig/src/fcdbg.c	2003-09-25 13:01:22.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/src/fcdbg.c	2003-11-19 21:34:42.000000000 +0100
@@ -1,7 +1,7 @@
 /*
- * $XFree86: xc/extras/fontconfig/src/fcdbg.c,v 1.1.1.1 2003/06/04 02:57:52 dawes Exp $
+ * $RCSId: xc/lib/fontconfig/src/fcdbg.c,v 1.10 2002/08/22 18:53:22 keithp Exp $
  *
- * Copyright © 2000 Keith Packard, member of The XFree86 Project, Inc.
+ * Copyright © 2000 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -34,10 +34,10 @@
 	printf (" <void>");
 	break;
     case FcTypeInteger:
-	printf (" %d", v.u.i);
+	printf (" %d(i)", v.u.i);
 	break;
     case FcTypeDouble:
-	printf (" %g", v.u.d);
+	printf (" %g(f)", v.u.d);
 	break;
     case FcTypeString:
 	printf (" \"%s\"", v.u.s);
@@ -52,7 +52,8 @@
 	printf (" set");
 	break;
     case FcTypeLangSet:
-	printf (" langset");
+	printf (" ");
+	FcLangSetPrint (v.u.l);
 	break;
     case FcTypeFTFace:
 	printf (" face");
@@ -66,12 +67,35 @@
     for (; l; l = l->next)
     {
 	FcValuePrint (l->value);
-	if (l->binding == FcValueBindingWeak)
+	switch (l->binding) {
+	case FcValueBindingWeak:
 	    printf ("(w)");
+	    break;
+	case FcValueBindingStrong:
+	    printf ("(s)");
+	    break;
+	case FcValueBindingSame:
+	    printf ("(=)");
+	    break;
+	}
     }
 }
 
 void
+FcLangSetPrint (const FcLangSet *ls)
+{
+    FcStrBuf	buf;
+    FcChar8	init_buf[1024];
+    
+    FcStrBufInit (&buf, init_buf, sizeof (init_buf));
+    if (FcNameUnparseLangSet (&buf, ls) && FcStrBufChar (&buf,'\0'))
+	printf ("%s", buf.buf);
+    else
+	printf ("langset (alloc error)");
+    FcStrBufDestroy (&buf);
+}
+
+void
 FcPatternPrint (const FcPattern *p)
 {
     int		    i;
@@ -129,6 +153,10 @@
     case FcOpNot: printf ("Not"); break;
     case FcOpNil: printf ("Nil"); break;
     case FcOpComma: printf ("Comma"); break;
+    case FcOpFloor: printf ("Floor"); break;
+    case FcOpCeil: printf ("Ceil"); break;
+    case FcOpRound: printf ("Round"); break;
+    case FcOpTrunc: printf ("Trunc"); break;
     case FcOpInvalid: printf ("Invalid"); break;
     }
 }
@@ -136,7 +164,8 @@
 void
 FcExprPrint (const FcExpr *expr)
 {
-    switch (expr->op) {
+    if (!expr) printf ("none");
+    else switch (expr->op) {
     case FcOpInteger: printf ("%d", expr->u.ival); break;
     case FcOpDouble: printf ("%g", expr->u.dval); break;
     case FcOpString: printf ("\"%s\"", expr->u.sval); break;
@@ -211,6 +240,22 @@
 	printf ("Not ");
 	FcExprPrint (expr->u.tree.left);
 	break;
+    case FcOpFloor:
+	printf ("Floor ");
+	FcExprPrint (expr->u.tree.left);
+	break;
+    case FcOpCeil:
+	printf ("Ceil ");
+	FcExprPrint (expr->u.tree.left);
+	break;
+    case FcOpRound:
+	printf ("Round ");
+	FcExprPrint (expr->u.tree.left);
+	break;
+    case FcOpTrunc:
+	printf ("Trunc ");
+	FcExprPrint (expr->u.tree.left);
+	break;
     case FcOpInvalid: printf ("Invalid"); break;
     }
 }
diff -urN xc/extras/fontconfig/src/fcdefault.c xc-fontconfig/extras/fontconfig/src/fcdefault.c
--- xc/extras/fontconfig/src/fcdefault.c	2003-09-25 13:01:22.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/src/fcdefault.c	2003-11-19 21:34:42.000000000 +0100
@@ -1,7 +1,7 @@
 /*
- * $XFree86: xc/extras/fontconfig/src/fcdefault.c,v 1.1.1.1 2003/06/04 02:57:52 dawes Exp $
+ * $RCSId: xc/lib/fontconfig/src/fcdefault.c,v 1.2 2002/07/09 22:08:14 keithp Exp $
  *
- * Copyright © 2001 Keith Packard, member of The XFree86 Project, Inc.
+ * Copyright © 2001 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -55,6 +55,9 @@
 	}
     }
 
+    if (FcPatternGet (pattern, FC_WIDTH, 0, &v) == FcResultNoMatch)
+	FcPatternAddInteger (pattern, FC_WIDTH, FC_WIDTH_NORMAL);
+
     for (i = 0; i < NUM_FC_BOOL_DEFAULTS; i++)
 	if (FcPatternGet (pattern, FcBoolDefaults[i].field, 0, &v) == FcResultNoMatch)
 	    FcPatternAddBool (pattern, FcBoolDefaults[i].field, FcBoolDefaults[i].value);
diff -urN xc/extras/fontconfig/src/fcdir.c xc-fontconfig/extras/fontconfig/src/fcdir.c
--- xc/extras/fontconfig/src/fcdir.c	2003-06-04 18:29:39.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/src/fcdir.c	2003-11-19 21:34:42.000000000 +0100
@@ -1,5 +1,7 @@
 /*
- * Copyright © 2000 Keith Packard, member of The XFree86 Project, Inc.
+ * $RCSId: xc/lib/fontconfig/src/fcdir.c,v 1.9 2002/08/31 22:17:32 keithp Exp $
+ *
+ * Copyright © 2000 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -19,7 +21,6 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-/* $XFree86: xc/extras/fontconfig/src/fcdir.c,v 1.2 2003/06/04 16:29:39 dawes Exp $ */
 
 #include "fcint.h"
 #include <dirent.h>
@@ -46,6 +47,7 @@
     FcChar8		*name;
     FcPattern		*font;
     FcBool		ret = FcTrue;
+    FcBool		isDir;
     int			count = 0;
     FcGlobalCacheFile	*cache_file;
     FcGlobalCacheDir	*cache_dir;
@@ -68,7 +70,7 @@
 		/*
 		 * Found a cache entry for the file
 		 */
-		if (FcGlobalCacheCheckTime (&cache_file->info))
+		if (FcGlobalCacheCheckTime (file, &cache_file->info))
 		{
 		    name = cache_file->name;
 		    need_scan = FcFalse;
@@ -87,7 +89,8 @@
 						       strlen ((const char *) file),
 						       FcFalse)))
 	    {
-		if (FcGlobalCacheCheckTime (&cache_dir->info))
+		if (FcGlobalCacheCheckTime (cache_dir->info.file, 
+					    &cache_dir->info))
 		{
 		    font = 0;
 		    need_scan = FcFalse;
@@ -110,11 +113,11 @@
 	    font = FcFreeTypeQuery (file, id, blanks, &count);
 	    if (FcDebug () & FC_DBG_SCAN)
 		printf ("done\n");
+	    isDir = FcFalse;
 	    if (!font && FcFileIsDir (file))
 	    {
+		isDir = FcTrue;
 		ret = FcStrSetAdd (dirs, file);
-		if (cache && ret)
-		    FcGlobalCacheUpdate (cache, file, 0, FC_FONT_FILE_DIR);
 	    }
 	    /*
 	     * Update the cache
@@ -150,6 +153,11 @@
 
 #define FC_MAX_FILE_LEN	    4096
 
+/*
+ * Scan 'dir', adding font files to 'set' and
+ * subdirectories to 'dirs'
+ */
+
 FcBool
 FcDirScan (FcFontSet	    *set,
 	   FcStrSet	    *dirs,
@@ -170,7 +178,11 @@
 	 * Check fonts.cache-<version> file
 	 */
 	if (FcDirCacheReadDir (set, dirs, dir))
+	{
+	    if (cache)
+		FcGlobalCacheReferenceSubdir (cache, dir);
 	    return FcTrue;
+	}
     
 	/*
 	 * Check ~/.fonts.cache-<version> file
@@ -188,6 +200,9 @@
     strcat ((char *) file, "/");
     base = file + strlen ((char *) file);
     
+    if (FcDebug () & FC_DBG_SCAN)
+	printf ("\tScanning dir %s\n", dir);
+	
     d = opendir ((char *) dir);
     
     if (!d)
@@ -208,6 +223,10 @@
     }
     free (file);
     closedir (d);
+    /*
+     * Now that the directory has been scanned,
+     * add the cache entry 
+     */
     if (ret && cache)
 	FcGlobalCacheUpdate (cache, dir, 0, 0);
 	
diff -urN xc/extras/fontconfig/src/fcfreetype.c xc-fontconfig/extras/fontconfig/src/fcfreetype.c
--- xc/extras/fontconfig/src/fcfreetype.c	2003-09-25 13:01:22.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/src/fcfreetype.c	2003-11-19 21:34:42.000000000 +0100
@@ -1,7 +1,7 @@
 /*
- * $XFree86: xc/extras/fontconfig/src/fcfreetype.c,v 1.1.1.1 2003/06/04 02:57:52 dawes Exp $
+ * $RCSId: xc/lib/fontconfig/src/fcfreetype.c,v 1.11 2002/08/31 22:17:32 keithp Exp $
  *
- * Copyright © 2001 Keith Packard, member of The XFree86 Project, Inc.
+ * Copyright © 2001 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -22,6 +22,28 @@
  * PERFORMANCE OF THIS SOFTWARE.
  */
 
+/*
+  Copyright © 2002-2003 by Juliusz Chroboczek
+
+  Permission is hereby granted, free of charge, to any person obtaining a copy
+  of this software and associated documentation files (the "Software"), to deal
+  in the Software without restriction, including without limitation the rights
+  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+  THE SOFTWARE.
+*/
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
@@ -31,6 +53,19 @@
 #include <freetype/tttables.h>
 #include <freetype/ftsnames.h>
 #include <freetype/ttnameid.h>
+#include <freetype/t1tables.h>
+
+#if (FREETYPE_MINOR > 1 || (FREETYPE_MINOR == 1 && FREETYPE_PATCH >= 4))
+#include <freetype/ftbdf.h>
+#include <freetype/ftmodule.h>
+#define USE_FTBDF
+#define HAS_BDF_PROPERTY(f) ((f) && (f)->driver && \
+			     (f)->driver->root.clazz->get_interface)
+#define MY_Get_BDF_Property(f,n,p) (HAS_BDF_PROPERTY(f) ? \
+				    FT_Get_BDF_Property(f,n,p) : \
+				    FT_Err_Invalid_Argument)
+#endif
+
 
 /*
  * Keep Han languages separated by eliminating languages
@@ -89,7 +124,8 @@
 	return FcTrue;
     if (page == 0xfb)
 	return FcTrue;
-    if (page == 0xff)
+    /* halfwidth forms, don't include kana or white parens */
+    if (0xff01 <= ucs4 && ucs4 <= 0xff5e)
 	return FcTrue;
     return FcFalse;
 }
@@ -111,6 +147,115 @@
     return FcTrue;
 }
 
+/* Order is significant.  For example, some B&H fonts are hinted by
+   URW++, and both strings appear in the notice. */
+
+static const struct {
+    const FcChar8   *notice;
+    const FcChar8   *foundry;
+} FcNoticeFoundries[] = {
+    { (const FcChar8*) "Bigelow",	(const FcChar8 *) "b&h" },
+    { (const FcChar8*) "Adobe",		(const FcChar8 *) "adobe" },
+    { (const FcChar8*) "Bitstream",	(const FcChar8 *) "bitstream" },
+    { (const FcChar8*) "Monotype",	(const FcChar8 *) "monotype" },
+    { (const FcChar8*) "Linotype",	(const FcChar8 *) "linotype" },
+    { (const FcChar8*) "LINOTYPE-HELL", (const FcChar8 *) "linotype" },
+    { (const FcChar8*) "IBM",		(const FcChar8 *) "ibm" },
+    { (const FcChar8*) "URW",		(const FcChar8 *) "urw" },
+    { (const FcChar8*) "International Typeface Corporation", 
+					(const FcChar8 *) "itc" },
+    { (const FcChar8*) "Tiro Typeworks",(const FcChar8 *) "tiro" },
+    { (const FcChar8*) "XFree86",	(const FcChar8 *) "xfree86" },
+    { (const FcChar8*) "Microsoft",	(const FcChar8 *) "microsoft" },
+    { (const FcChar8*) "Omega",		(const FcChar8 *) "omega" },
+    { (const FcChar8*) "Font21",	(const FcChar8 *) "hwan" },
+    { (const FcChar8*) "HanYang System",(const FcChar8 *) "hanyang" }
+};
+
+#define NUM_NOTICE_FOUNDRIES	(sizeof (FcNoticeFoundries) / sizeof (FcNoticeFoundries[0]))
+
+static const FcChar8 *
+FcNoticeFoundry(const char *notice)
+{
+    int i;
+
+    if (notice)
+	for(i = 0; i < NUM_NOTICE_FOUNDRIES; i++)
+	    if (strstr ((const char *) notice, (const char *) FcNoticeFoundries[i].notice))
+		return FcNoticeFoundries[i].foundry;
+    return 0;
+}
+
+static FcBool
+FcVendorMatch(const char *vendor, const char *vendor_string)
+{
+    /* vendor is not necessarily NUL-terminated. */
+    int i, len;
+    
+    len = strlen(vendor_string);
+    if (memcmp(vendor, vendor_string, len) != 0)
+        return FcFalse;
+    for (i = len; i < 4; i++)
+        if (vendor[i] != ' ' && vendor[i] != '\0')
+            return FcFalse;
+    return FcTrue;
+}
+
+/* This table is partly taken from ttmkfdir by Joerg Pommnitz. */
+
+/* It should not contain useless entries (such as UNKN) nor duplicate
+   entries for padding both with spaces and NULs. */
+
+static const struct {
+    const FcChar8   *vendor;
+    const FcChar8   *foundry;
+} FcVendorFoundries[] = {
+    { (const FcChar8*) "ADBE", (const FcChar8 *) "adobe"},
+    { (const FcChar8*) "AGFA", (const FcChar8 *) "agfa"},
+    { (const FcChar8*) "ALTS", (const FcChar8 *) "altsys"},
+    { (const FcChar8*) "APPL", (const FcChar8 *) "apple"},
+    { (const FcChar8*) "ARPH", (const FcChar8 *) "arphic"},
+    { (const FcChar8*) "ATEC", (const FcChar8 *) "alltype"},
+    { (const FcChar8*) "B&H",  (const FcChar8 *) "b&h"},
+    { (const FcChar8*) "BITS", (const FcChar8 *) "bitstream"},
+    { (const FcChar8*) "CANO", (const FcChar8 *) "cannon"},
+    { (const FcChar8*) "DYNA", (const FcChar8 *) "dynalab"},
+    { (const FcChar8*) "EPSN", (const FcChar8 *) "epson"},
+    { (const FcChar8*) "FJ",   (const FcChar8 *) "fujitsu"},
+    { (const FcChar8*) "IBM",  (const FcChar8 *) "ibm"},
+    { (const FcChar8*) "ITC",  (const FcChar8 *) "itc"},
+    { (const FcChar8*) "IMPR", (const FcChar8 *) "impress"},
+    { (const FcChar8*) "LARA", (const FcChar8 *) "larabiefonts"},
+    { (const FcChar8*) "LEAF", (const FcChar8 *) "interleaf"},
+    { (const FcChar8*) "LETR", (const FcChar8 *) "letraset"},
+    { (const FcChar8*) "LINO", (const FcChar8 *) "linotype"},
+    { (const FcChar8*) "MACR", (const FcChar8 *) "macromedia"},
+    { (const FcChar8*) "MONO", (const FcChar8 *) "monotype"},
+    { (const FcChar8*) "MS",   (const FcChar8 *) "microsoft"},
+    { (const FcChar8*) "MT",   (const FcChar8 *) "monotype"},
+    { (const FcChar8*) "NEC",  (const FcChar8 *) "nec"},
+    { (const FcChar8*) "PARA", (const FcChar8 *) "paratype"},
+    { (const FcChar8*) "QMSI", (const FcChar8 *) "qms"},
+    { (const FcChar8*) "RICO", (const FcChar8 *) "ricoh"},
+    { (const FcChar8*) "URW",  (const FcChar8 *) "urw"},
+    { (const FcChar8*) "Y&Y",  (const FcChar8 *) "y&y"}
+};
+
+#define NUM_VENDOR_FOUNDRIES	(sizeof (FcVendorFoundries) / sizeof (FcVendorFoundries[0]))
+
+static const FcChar8 *
+FcVendorFoundry(const char *vendor)
+{
+    int i;
+    
+    if (vendor)
+	for(i = 0; i < NUM_VENDOR_FOUNDRIES; i++)
+	    if (FcVendorMatch (vendor, FcVendorFoundries[i].vendor))
+		return FcVendorFoundries[i].foundry;
+    return 0;
+}
+
+
 FcPattern *
 FcFreeTypeQuery (const FcChar8	*file,
 		 int		id,
@@ -121,13 +266,17 @@
     FcPattern	    *pat;
     int		    slant;
     int		    weight;
+    int		    width = -1;
     int		    i;
     FcCharSet	    *cs;
     FcLangSet	    *ls;
     FT_Library	    ftLibrary;
-    FcChar8	    *family;
-    FcChar8	    *style;
+    FcChar8	    *family = 0;
+    FcChar8	    *style = 0;
+    const FcChar8   *foundry = 0;
+    int		    spacing;
     TT_OS2	    *os2;
+    PS_FontInfoRec  psfontinfo;
     TT_Header	    *head;
     const FcChar8   *exclusiveLang = 0;
     FT_SfntName	    sname;
@@ -162,23 +311,32 @@
     if (face->style_flags & FT_STYLE_FLAG_ITALIC)
 	slant = FC_SLANT_ITALIC;
 
-    if (!FcPatternAddInteger (pat, FC_SLANT, slant))
-	goto bail1;
 
     weight = FC_WEIGHT_MEDIUM;
     if (face->style_flags & FT_STYLE_FLAG_BOLD)
 	weight = FC_WEIGHT_BOLD;
 
-    if (!FcPatternAddInteger (pat, FC_WEIGHT, weight))
-	goto bail1;
+    /*
+     * Get the OS/2 table
+     */
+    os2 = (TT_OS2 *) FT_Get_Sfnt_Table (face, ft_sfnt_os2);
+
+    /*
+     * Look first in the OS/2 table for the foundry, if
+     * not found here, the various notices will be searched for
+     * that information, either from the sfnt name tables or
+     * the Postscript FontInfo dictionary.  Finally, the
+     * BDF properties will queried.
+     */
+    
+    if (os2 && os2->version >= 0x0001 && os2->version != 0xffff)
+        foundry = FcVendorFoundry(os2->achVendID);
 
     /*
      * Grub through the name table looking for family
      * and style names.  FreeType makes quite a hash
      * of them
      */
-    family = 0;
-    style = 0;
     snamec = FT_Get_Sfnt_Name_Count (face);
     for (snamei = 0; snamei < snamec; snamei++)
     {
@@ -288,7 +446,9 @@
 	    prio |= FC_NAME_PRIO_NAME_PS;
 	    break;
 	case TT_NAME_ID_FONT_SUBFAMILY:
-	    break;
+        case TT_NAME_ID_TRADEMARK:
+        case TT_NAME_ID_MANUFACTURER:
+            break;
 	default:
 	    continue;
 	}
@@ -401,6 +561,12 @@
 		style_prio = prio;
 	    }
 	    break;
+        case TT_NAME_ID_TRADEMARK:
+        case TT_NAME_ID_MANUFACTURER:
+	    /* If the foundry wasn't found in the OS/2 table, look here */
+            if(!foundry)
+                foundry = FcNoticeFoundry(utf8);
+            break;
 	}
 	if (utf8)
 	    free (utf8);
@@ -467,7 +633,12 @@
     if (!FcPatternAddString (pat, FC_SOURCE, (FcChar8 *) "FreeType"))
 	goto bail1;
 
-#if 1
+#if 0
+    /*
+     * don't even try this -- CJK 'monospace' fonts are really
+     * dual width, and most other fonts don't bother to set
+     * the attribute.  Sigh.
+     */
     if ((face->face_flags & FT_FACE_FLAG_FIXED_WIDTH) != 0)
 	if (!FcPatternAddInteger (pat, FC_SPACING, FC_MONO))
 	    goto bail1;
@@ -488,10 +659,6 @@
 	    goto bail1;
     }
 
-    /*
-     * Get the OS/2 table and poke about
-     */
-    os2 = (TT_OS2 *) FT_Get_Sfnt_Table (face, ft_sfnt_os2);
     if (os2 && os2->version >= 0x0001 && os2->version != 0xffff)
     {
 	for (i = 0; i < NUM_CODE_PAGE_RANGE; i++)
@@ -525,10 +692,185 @@
 	}
     }
 
+    if (os2 && os2->version != 0xffff)
+    {
+	if (os2->usWeightClass == 0)
+	    weight = -1;
+	else if (os2->usWeightClass < 150)
+	    weight = FC_WEIGHT_THIN;
+	else if (os2->usWeightClass < 250)
+	    weight = FC_WEIGHT_EXTRALIGHT;
+	else if (os2->usWeightClass < 350)
+	    weight = FC_WEIGHT_LIGHT;
+	else if (os2->usWeightClass < 450)
+	    weight = FC_WEIGHT_REGULAR;
+	else if (os2->usWeightClass < 550)
+	    weight = FC_WEIGHT_MEDIUM;
+	else if (os2->usWeightClass < 650)
+	    weight = FC_WEIGHT_SEMIBOLD;
+	else if (os2->usWeightClass < 750)
+	    weight = FC_WEIGHT_BOLD;
+	else if (os2->usWeightClass < 850)
+	    weight = FC_WEIGHT_EXTRABOLD;
+	else if (os2->usWeightClass < 950)
+	    weight = FC_WEIGHT_BLACK;
+	else
+	    weight = FC_WEIGHT_MEDIUM;
+
+	switch (os2->usWidthClass) {
+	case 1:	width = FC_WIDTH_ULTRACONDENSED; break;
+	case 2:	width = FC_WIDTH_EXTRACONDENSED; break;
+	case 3:	width = FC_WIDTH_CONDENSED; break;
+	case 4:	width = FC_WIDTH_SEMICONDENSED; break;
+	case 5:	width = FC_WIDTH_NORMAL; break;
+	case 6:	width = FC_WIDTH_SEMIEXPANDED; break;
+	case 7:	width = FC_WIDTH_EXPANDED; break;
+	case 8:	width = FC_WIDTH_EXTRAEXPANDED; break;
+	case 9:	width = FC_WIDTH_ULTRAEXPANDED; break;
+	}
+    }
+
+    /*
+     * Type 1: Check for FontInfo dictionary information
+     * Code from g2@magestudios.net (Gerard Escalante)
+     */
+    
+    if (FT_Get_PS_Font_Info(face, &psfontinfo) == 0)
+    {
+	if (psfontinfo.weight)
+	{
+	    static struct {
+		char    *name;
+		int	value;
+	    } ps_weights[] = {
+		{ "thin",		FC_WEIGHT_THIN },
+		{ "extralight",		FC_WEIGHT_EXTRALIGHT },
+		{ "ultralight",		FC_WEIGHT_ULTRALIGHT },
+		{ "light",		FC_WEIGHT_LIGHT },
+		{ "regular",		FC_WEIGHT_REGULAR },
+		{ "normal",		FC_WEIGHT_NORMAL },
+		{ "medium",		FC_WEIGHT_MEDIUM },
+		{ "demibold",		FC_WEIGHT_DEMIBOLD },
+		{ "semibold",		FC_WEIGHT_SEMIBOLD },
+		{ "bold",		FC_WEIGHT_BOLD },
+		{ "extrabold",		FC_WEIGHT_EXTRABOLD },
+		{ "ultrabold",		FC_WEIGHT_ULTRABOLD },
+		{ "black",		FC_WEIGHT_BLACK },
+		{ "heavy",		FC_WEIGHT_HEAVY },
+	    };
+#define NUM_PS_WEIGHTS	(sizeof (ps_weights) / sizeof (ps_weights[0]))
+	    int	w;
+	    for (w = 0; w < NUM_PS_WEIGHTS; w++)
+		if (!FcStrCmpIgnoreCase ((FcChar8 *) ps_weights[w].name,
+					 (FcChar8 *) psfontinfo.weight))
+		{
+		    weight = ps_weights[w].value;
+		    break;
+		}
+	}
+     
+#if 0
+	/* 
+	 * Don't bother with italic_angle; FreeType already extracts that
+	 * information for us and sticks it into style_flags
+	 */
+        if (psfontinfo.italic_angle < 0) 
+            slant = FC_SLANT_ITALIC; 
+        else if (psfontinfo.italic_angle >= 0) 
+            slant = FC_SLANT_ROMAN; 
+#endif
+
+        if(!foundry)
+            foundry = FcNoticeFoundry(psfontinfo.notice);
+    }
+    
+#ifdef USE_FTBDF
+    /*
+     * Finally, look for a FOUNDRY BDF property if no other
+     * mechanism has managed to locate a foundry
+     */
+
+    if (!foundry)
+    {
+	int             rc;
+	BDF_PropertyRec prop;
+	rc = MY_Get_BDF_Property(face, "FOUNDRY", &prop);
+	if(rc == 0 && prop.type == BDF_PROPERTY_TYPE_ATOM)
+	    foundry = prop.u.atom;
+    }
+
+    if (width == -1)
+    {
+	BDF_PropertyRec prop;
+	if (MY_Get_BDF_Property(face, "RELATIVE_SETWIDTH", &prop) == 0 &&
+	    (prop.type == BDF_PROPERTY_TYPE_INTEGER ||
+	     prop.type == BDF_PROPERTY_TYPE_CARDINAL))
+	{
+	    FT_Int32	value;
+	    
+	    if (prop.type == BDF_PROPERTY_TYPE_INTEGER)
+		value = prop.u.integer;
+	    else
+		value = (FT_Int32) prop.u.cardinal;
+	    switch ((value + 5) / 10) {
+	    case 1: width = FC_WIDTH_ULTRACONDENSED; break;
+	    case 2: width = FC_WIDTH_EXTRACONDENSED; break;
+	    case 3: width = FC_WIDTH_CONDENSED; break;
+	    case 4: width = FC_WIDTH_SEMICONDENSED; break;
+	    case 5: width = FC_WIDTH_NORMAL; break;
+	    case 6: width = FC_WIDTH_SEMIEXPANDED; break;
+	    case 7: width = FC_WIDTH_EXPANDED; break;
+	    case 8: width = FC_WIDTH_EXTRAEXPANDED; break;
+	    case 9: width = FC_WIDTH_ULTRAEXPANDED; break;
+	    }
+	}
+	else if (MY_Get_BDF_Property (face, "SETWIDTH_NAME", &prop) == 0 &&
+		 prop.type == BDF_PROPERTY_TYPE_ATOM)
+	{
+	    static struct {
+		FcChar8	    *width_name;
+		int	    width;
+	    } FcSetWidths[] = {
+		{ "Condensed",	    FC_WIDTH_CONDENSED },
+		{ "SemiCondensed",  FC_WIDTH_SEMICONDENSED },
+		{ "Normal",	    FC_WIDTH_NORMAL },
+	    };
+	    int	i;
+
+	    if (FcDebug () & FC_DBG_SCANV)
+		printf ("\nsetwidth: %s\n", prop.u.atom);
+	    for (i = 0; i < sizeof (FcSetWidths) / sizeof (FcSetWidths[0]); i++)
+		if (!FcStrCmpIgnoreCase ((FcChar8 *) prop.u.atom,
+					 FcSetWidths[i].width_name))
+		{
+		    width = FcSetWidths[i].width;
+		    break;
+		}
+	}
+    }
+
+#endif
+
+    if (!FcPatternAddInteger (pat, FC_SLANT, slant))
+	goto bail1;
+
+    if (!FcPatternAddInteger (pat, FC_WEIGHT, weight))
+	goto bail1;
+
+    if (width != -1)
+	if (!FcPatternAddInteger (pat, FC_WIDTH, width))
+	    goto bail1;
+
+    if(foundry) 
+    {
+        if(!FcPatternAddString (pat, FC_FOUNDRY, foundry))
+            goto bail1;
+    }
+
     /*
      * Compute the unicode coverage for the font
      */
-    cs = FcFreeTypeCharSet (face, blanks);
+    cs = FcFreeTypeCharSetAndSpacing (face, blanks, &spacing);
     if (!cs)
 	goto bail1;
 
@@ -552,6 +894,10 @@
     if (!FcPatternAddLangSet (pat, FC_LANG, ls))
 	goto bail2;
 
+    if (spacing != FC_PROPORTIONAL)
+	if (!FcPatternAddInteger (pat, FC_SPACING, spacing))
+	    goto bail2;
+
     /*
      * Drop our reference to the charset
      */
@@ -581,3 +927,802 @@
     FT_Done_FreeType (ftLibrary);
     return 0;
 }
+
+
+/*
+ * Figure out whether the available freetype has FT_Get_Next_Char
+ */
+
+#if FREETYPE_MAJOR > 2
+# define HAS_NEXT_CHAR
+#else
+# if FREETYPE_MAJOR == 2
+#  if FREETYPE_MINOR > 0
+#   define HAS_NEXT_CHAR
+#  else
+#   if FREETYPE_MINOR == 0
+#    if FREETYPE_PATCH >= 9
+#     define HAS_NEXT_CHAR
+#    endif
+#   endif
+#  endif
+# endif
+#endif
+
+/*
+ * For our purposes, this approximation is sufficient
+ */
+#ifndef HAS_NEXT_CHAR
+#define FT_Get_First_Char(face, gi) ((*(gi) = 1), 1)
+#define FT_Get_Next_Char(face, ucs4, gi) ((ucs4) >= 0xffffff ? \
+					  (*(gi) = 0), 0 : \
+					  (*(gi) = 1), (ucs4) + 1)
+#warning "No FT_Get_Next_Char"
+#endif
+
+typedef struct _FcCharEnt {
+    FcChar16	    bmp;
+    unsigned char   encode;
+} FcCharEnt;
+
+struct _FcCharMap {
+    const FcCharEnt *ent;
+    int		    nent;
+};
+
+typedef struct _FcFontDecode {
+    FT_Encoding	    encoding;
+    const FcCharMap *map;
+    FcChar32	    max;
+} FcFontDecode;
+
+static const FcCharEnt AppleRomanEnt[] = {
+    { 0x0020, 0x20 }, /* SPACE */
+    { 0x0021, 0x21 }, /* EXCLAMATION MARK */
+    { 0x0022, 0x22 }, /* QUOTATION MARK */
+    { 0x0023, 0x23 }, /* NUMBER SIGN */
+    { 0x0024, 0x24 }, /* DOLLAR SIGN */
+    { 0x0025, 0x25 }, /* PERCENT SIGN */
+    { 0x0026, 0x26 }, /* AMPERSAND */
+    { 0x0027, 0x27 }, /* APOSTROPHE */
+    { 0x0028, 0x28 }, /* LEFT PARENTHESIS */
+    { 0x0029, 0x29 }, /* RIGHT PARENTHESIS */
+    { 0x002A, 0x2A }, /* ASTERISK */
+    { 0x002B, 0x2B }, /* PLUS SIGN */
+    { 0x002C, 0x2C }, /* COMMA */
+    { 0x002D, 0x2D }, /* HYPHEN-MINUS */
+    { 0x002E, 0x2E }, /* FULL STOP */
+    { 0x002F, 0x2F }, /* SOLIDUS */
+    { 0x0030, 0x30 }, /* DIGIT ZERO */
+    { 0x0031, 0x31 }, /* DIGIT ONE */
+    { 0x0032, 0x32 }, /* DIGIT TWO */
+    { 0x0033, 0x33 }, /* DIGIT THREE */
+    { 0x0034, 0x34 }, /* DIGIT FOUR */
+    { 0x0035, 0x35 }, /* DIGIT FIVE */
+    { 0x0036, 0x36 }, /* DIGIT SIX */
+    { 0x0037, 0x37 }, /* DIGIT SEVEN */
+    { 0x0038, 0x38 }, /* DIGIT EIGHT */
+    { 0x0039, 0x39 }, /* DIGIT NINE */
+    { 0x003A, 0x3A }, /* COLON */
+    { 0x003B, 0x3B }, /* SEMICOLON */
+    { 0x003C, 0x3C }, /* LESS-THAN SIGN */
+    { 0x003D, 0x3D }, /* EQUALS SIGN */
+    { 0x003E, 0x3E }, /* GREATER-THAN SIGN */
+    { 0x003F, 0x3F }, /* QUESTION MARK */
+    { 0x0040, 0x40 }, /* COMMERCIAL AT */
+    { 0x0041, 0x41 }, /* LATIN CAPITAL LETTER A */
+    { 0x0042, 0x42 }, /* LATIN CAPITAL LETTER B */
+    { 0x0043, 0x43 }, /* LATIN CAPITAL LETTER C */
+    { 0x0044, 0x44 }, /* LATIN CAPITAL LETTER D */
+    { 0x0045, 0x45 }, /* LATIN CAPITAL LETTER E */
+    { 0x0046, 0x46 }, /* LATIN CAPITAL LETTER F */
+    { 0x0047, 0x47 }, /* LATIN CAPITAL LETTER G */
+    { 0x0048, 0x48 }, /* LATIN CAPITAL LETTER H */
+    { 0x0049, 0x49 }, /* LATIN CAPITAL LETTER I */
+    { 0x004A, 0x4A }, /* LATIN CAPITAL LETTER J */
+    { 0x004B, 0x4B }, /* LATIN CAPITAL LETTER K */
+    { 0x004C, 0x4C }, /* LATIN CAPITAL LETTER L */
+    { 0x004D, 0x4D }, /* LATIN CAPITAL LETTER M */
+    { 0x004E, 0x4E }, /* LATIN CAPITAL LETTER N */
+    { 0x004F, 0x4F }, /* LATIN CAPITAL LETTER O */
+    { 0x0050, 0x50 }, /* LATIN CAPITAL LETTER P */
+    { 0x0051, 0x51 }, /* LATIN CAPITAL LETTER Q */
+    { 0x0052, 0x52 }, /* LATIN CAPITAL LETTER R */
+    { 0x0053, 0x53 }, /* LATIN CAPITAL LETTER S */
+    { 0x0054, 0x54 }, /* LATIN CAPITAL LETTER T */
+    { 0x0055, 0x55 }, /* LATIN CAPITAL LETTER U */
+    { 0x0056, 0x56 }, /* LATIN CAPITAL LETTER V */
+    { 0x0057, 0x57 }, /* LATIN CAPITAL LETTER W */
+    { 0x0058, 0x58 }, /* LATIN CAPITAL LETTER X */
+    { 0x0059, 0x59 }, /* LATIN CAPITAL LETTER Y */
+    { 0x005A, 0x5A }, /* LATIN CAPITAL LETTER Z */
+    { 0x005B, 0x5B }, /* LEFT SQUARE BRACKET */
+    { 0x005C, 0x5C }, /* REVERSE SOLIDUS */
+    { 0x005D, 0x5D }, /* RIGHT SQUARE BRACKET */
+    { 0x005E, 0x5E }, /* CIRCUMFLEX ACCENT */
+    { 0x005F, 0x5F }, /* LOW LINE */
+    { 0x0060, 0x60 }, /* GRAVE ACCENT */
+    { 0x0061, 0x61 }, /* LATIN SMALL LETTER A */
+    { 0x0062, 0x62 }, /* LATIN SMALL LETTER B */
+    { 0x0063, 0x63 }, /* LATIN SMALL LETTER C */
+    { 0x0064, 0x64 }, /* LATIN SMALL LETTER D */
+    { 0x0065, 0x65 }, /* LATIN SMALL LETTER E */
+    { 0x0066, 0x66 }, /* LATIN SMALL LETTER F */
+    { 0x0067, 0x67 }, /* LATIN SMALL LETTER G */
+    { 0x0068, 0x68 }, /* LATIN SMALL LETTER H */
+    { 0x0069, 0x69 }, /* LATIN SMALL LETTER I */
+    { 0x006A, 0x6A }, /* LATIN SMALL LETTER J */
+    { 0x006B, 0x6B }, /* LATIN SMALL LETTER K */
+    { 0x006C, 0x6C }, /* LATIN SMALL LETTER L */
+    { 0x006D, 0x6D }, /* LATIN SMALL LETTER M */
+    { 0x006E, 0x6E }, /* LATIN SMALL LETTER N */
+    { 0x006F, 0x6F }, /* LATIN SMALL LETTER O */
+    { 0x0070, 0x70 }, /* LATIN SMALL LETTER P */
+    { 0x0071, 0x71 }, /* LATIN SMALL LETTER Q */
+    { 0x0072, 0x72 }, /* LATIN SMALL LETTER R */
+    { 0x0073, 0x73 }, /* LATIN SMALL LETTER S */
+    { 0x0074, 0x74 }, /* LATIN SMALL LETTER T */
+    { 0x0075, 0x75 }, /* LATIN SMALL LETTER U */
+    { 0x0076, 0x76 }, /* LATIN SMALL LETTER V */
+    { 0x0077, 0x77 }, /* LATIN SMALL LETTER W */
+    { 0x0078, 0x78 }, /* LATIN SMALL LETTER X */
+    { 0x0079, 0x79 }, /* LATIN SMALL LETTER Y */
+    { 0x007A, 0x7A }, /* LATIN SMALL LETTER Z */
+    { 0x007B, 0x7B }, /* LEFT CURLY BRACKET */
+    { 0x007C, 0x7C }, /* VERTICAL LINE */
+    { 0x007D, 0x7D }, /* RIGHT CURLY BRACKET */
+    { 0x007E, 0x7E }, /* TILDE */
+    { 0x00A0, 0xCA }, /* NO-BREAK SPACE */
+    { 0x00A1, 0xC1 }, /* INVERTED EXCLAMATION MARK */
+    { 0x00A2, 0xA2 }, /* CENT SIGN */
+    { 0x00A3, 0xA3 }, /* POUND SIGN */
+    { 0x00A5, 0xB4 }, /* YEN SIGN */
+    { 0x00A7, 0xA4 }, /* SECTION SIGN */
+    { 0x00A8, 0xAC }, /* DIAERESIS */
+    { 0x00A9, 0xA9 }, /* COPYRIGHT SIGN */
+    { 0x00AA, 0xBB }, /* FEMININE ORDINAL INDICATOR */
+    { 0x00AB, 0xC7 }, /* LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */
+    { 0x00AC, 0xC2 }, /* NOT SIGN */
+    { 0x00AE, 0xA8 }, /* REGISTERED SIGN */
+    { 0x00AF, 0xF8 }, /* MACRON */
+    { 0x00B0, 0xA1 }, /* DEGREE SIGN */
+    { 0x00B1, 0xB1 }, /* PLUS-MINUS SIGN */
+    { 0x00B4, 0xAB }, /* ACUTE ACCENT */
+    { 0x00B5, 0xB5 }, /* MICRO SIGN */
+    { 0x00B6, 0xA6 }, /* PILCROW SIGN */
+    { 0x00B7, 0xE1 }, /* MIDDLE DOT */
+    { 0x00B8, 0xFC }, /* CEDILLA */
+    { 0x00BA, 0xBC }, /* MASCULINE ORDINAL INDICATOR */
+    { 0x00BB, 0xC8 }, /* RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */
+    { 0x00BF, 0xC0 }, /* INVERTED QUESTION MARK */
+    { 0x00C0, 0xCB }, /* LATIN CAPITAL LETTER A WITH GRAVE */
+    { 0x00C1, 0xE7 }, /* LATIN CAPITAL LETTER A WITH ACUTE */
+    { 0x00C2, 0xE5 }, /* LATIN CAPITAL LETTER A WITH CIRCUMFLEX */
+    { 0x00C3, 0xCC }, /* LATIN CAPITAL LETTER A WITH TILDE */
+    { 0x00C4, 0x80 }, /* LATIN CAPITAL LETTER A WITH DIAERESIS */
+    { 0x00C5, 0x81 }, /* LATIN CAPITAL LETTER A WITH RING ABOVE */
+    { 0x00C6, 0xAE }, /* LATIN CAPITAL LETTER AE */
+    { 0x00C7, 0x82 }, /* LATIN CAPITAL LETTER C WITH CEDILLA */
+    { 0x00C8, 0xE9 }, /* LATIN CAPITAL LETTER E WITH GRAVE */
+    { 0x00C9, 0x83 }, /* LATIN CAPITAL LETTER E WITH ACUTE */
+    { 0x00CA, 0xE6 }, /* LATIN CAPITAL LETTER E WITH CIRCUMFLEX */
+    { 0x00CB, 0xE8 }, /* LATIN CAPITAL LETTER E WITH DIAERESIS */
+    { 0x00CC, 0xED }, /* LATIN CAPITAL LETTER I WITH GRAVE */
+    { 0x00CD, 0xEA }, /* LATIN CAPITAL LETTER I WITH ACUTE */
+    { 0x00CE, 0xEB }, /* LATIN CAPITAL LETTER I WITH CIRCUMFLEX */
+    { 0x00CF, 0xEC }, /* LATIN CAPITAL LETTER I WITH DIAERESIS */
+    { 0x00D1, 0x84 }, /* LATIN CAPITAL LETTER N WITH TILDE */
+    { 0x00D2, 0xF1 }, /* LATIN CAPITAL LETTER O WITH GRAVE */
+    { 0x00D3, 0xEE }, /* LATIN CAPITAL LETTER O WITH ACUTE */
+    { 0x00D4, 0xEF }, /* LATIN CAPITAL LETTER O WITH CIRCUMFLEX */
+    { 0x00D5, 0xCD }, /* LATIN CAPITAL LETTER O WITH TILDE */
+    { 0x00D6, 0x85 }, /* LATIN CAPITAL LETTER O WITH DIAERESIS */
+    { 0x00D8, 0xAF }, /* LATIN CAPITAL LETTER O WITH STROKE */
+    { 0x00D9, 0xF4 }, /* LATIN CAPITAL LETTER U WITH GRAVE */
+    { 0x00DA, 0xF2 }, /* LATIN CAPITAL LETTER U WITH ACUTE */
+    { 0x00DB, 0xF3 }, /* LATIN CAPITAL LETTER U WITH CIRCUMFLEX */
+    { 0x00DC, 0x86 }, /* LATIN CAPITAL LETTER U WITH DIAERESIS */
+    { 0x00DF, 0xA7 }, /* LATIN SMALL LETTER SHARP S */
+    { 0x00E0, 0x88 }, /* LATIN SMALL LETTER A WITH GRAVE */
+    { 0x00E1, 0x87 }, /* LATIN SMALL LETTER A WITH ACUTE */
+    { 0x00E2, 0x89 }, /* LATIN SMALL LETTER A WITH CIRCUMFLEX */
+    { 0x00E3, 0x8B }, /* LATIN SMALL LETTER A WITH TILDE */
+    { 0x00E4, 0x8A }, /* LATIN SMALL LETTER A WITH DIAERESIS */
+    { 0x00E5, 0x8C }, /* LATIN SMALL LETTER A WITH RING ABOVE */
+    { 0x00E6, 0xBE }, /* LATIN SMALL LETTER AE */
+    { 0x00E7, 0x8D }, /* LATIN SMALL LETTER C WITH CEDILLA */
+    { 0x00E8, 0x8F }, /* LATIN SMALL LETTER E WITH GRAVE */
+    { 0x00E9, 0x8E }, /* LATIN SMALL LETTER E WITH ACUTE */
+    { 0x00EA, 0x90 }, /* LATIN SMALL LETTER E WITH CIRCUMFLEX */
+    { 0x00EB, 0x91 }, /* LATIN SMALL LETTER E WITH DIAERESIS */
+    { 0x00EC, 0x93 }, /* LATIN SMALL LETTER I WITH GRAVE */
+    { 0x00ED, 0x92 }, /* LATIN SMALL LETTER I WITH ACUTE */
+    { 0x00EE, 0x94 }, /* LATIN SMALL LETTER I WITH CIRCUMFLEX */
+    { 0x00EF, 0x95 }, /* LATIN SMALL LETTER I WITH DIAERESIS */
+    { 0x00F1, 0x96 }, /* LATIN SMALL LETTER N WITH TILDE */
+    { 0x00F2, 0x98 }, /* LATIN SMALL LETTER O WITH GRAVE */
+    { 0x00F3, 0x97 }, /* LATIN SMALL LETTER O WITH ACUTE */
+    { 0x00F4, 0x99 }, /* LATIN SMALL LETTER O WITH CIRCUMFLEX */
+    { 0x00F5, 0x9B }, /* LATIN SMALL LETTER O WITH TILDE */
+    { 0x00F6, 0x9A }, /* LATIN SMALL LETTER O WITH DIAERESIS */
+    { 0x00F7, 0xD6 }, /* DIVISION SIGN */
+    { 0x00F8, 0xBF }, /* LATIN SMALL LETTER O WITH STROKE */
+    { 0x00F9, 0x9D }, /* LATIN SMALL LETTER U WITH GRAVE */
+    { 0x00FA, 0x9C }, /* LATIN SMALL LETTER U WITH ACUTE */
+    { 0x00FB, 0x9E }, /* LATIN SMALL LETTER U WITH CIRCUMFLEX */
+    { 0x00FC, 0x9F }, /* LATIN SMALL LETTER U WITH DIAERESIS */
+    { 0x00FF, 0xD8 }, /* LATIN SMALL LETTER Y WITH DIAERESIS */
+    { 0x0131, 0xF5 }, /* LATIN SMALL LETTER DOTLESS I */
+    { 0x0152, 0xCE }, /* LATIN CAPITAL LIGATURE OE */
+    { 0x0153, 0xCF }, /* LATIN SMALL LIGATURE OE */
+    { 0x0178, 0xD9 }, /* LATIN CAPITAL LETTER Y WITH DIAERESIS */
+    { 0x0192, 0xC4 }, /* LATIN SMALL LETTER F WITH HOOK */
+    { 0x02C6, 0xF6 }, /* MODIFIER LETTER CIRCUMFLEX ACCENT */
+    { 0x02C7, 0xFF }, /* CARON */
+    { 0x02D8, 0xF9 }, /* BREVE */
+    { 0x02D9, 0xFA }, /* DOT ABOVE */
+    { 0x02DA, 0xFB }, /* RING ABOVE */
+    { 0x02DB, 0xFE }, /* OGONEK */
+    { 0x02DC, 0xF7 }, /* SMALL TILDE */
+    { 0x02DD, 0xFD }, /* DOUBLE ACUTE ACCENT */
+    { 0x03A9, 0xBD }, /* GREEK CAPITAL LETTER OMEGA */
+    { 0x03C0, 0xB9 }, /* GREEK SMALL LETTER PI */
+    { 0x2013, 0xD0 }, /* EN DASH */
+    { 0x2014, 0xD1 }, /* EM DASH */
+    { 0x2018, 0xD4 }, /* LEFT SINGLE QUOTATION MARK */
+    { 0x2019, 0xD5 }, /* RIGHT SINGLE QUOTATION MARK */
+    { 0x201A, 0xE2 }, /* SINGLE LOW-9 QUOTATION MARK */
+    { 0x201C, 0xD2 }, /* LEFT DOUBLE QUOTATION MARK */
+    { 0x201D, 0xD3 }, /* RIGHT DOUBLE QUOTATION MARK */
+    { 0x201E, 0xE3 }, /* DOUBLE LOW-9 QUOTATION MARK */
+    { 0x2020, 0xA0 }, /* DAGGER */
+    { 0x2021, 0xE0 }, /* DOUBLE DAGGER */
+    { 0x2022, 0xA5 }, /* BULLET */
+    { 0x2026, 0xC9 }, /* HORIZONTAL ELLIPSIS */
+    { 0x2030, 0xE4 }, /* PER MILLE SIGN */
+    { 0x2039, 0xDC }, /* SINGLE LEFT-POINTING ANGLE QUOTATION MARK */
+    { 0x203A, 0xDD }, /* SINGLE RIGHT-POINTING ANGLE QUOTATION MARK */
+    { 0x2044, 0xDA }, /* FRACTION SLASH */
+    { 0x20AC, 0xDB }, /* EURO SIGN */
+    { 0x2122, 0xAA }, /* TRADE MARK SIGN */
+    { 0x2202, 0xB6 }, /* PARTIAL DIFFERENTIAL */
+    { 0x2206, 0xC6 }, /* INCREMENT */
+    { 0x220F, 0xB8 }, /* N-ARY PRODUCT */
+    { 0x2211, 0xB7 }, /* N-ARY SUMMATION */
+    { 0x221A, 0xC3 }, /* SQUARE ROOT */
+    { 0x221E, 0xB0 }, /* INFINITY */
+    { 0x222B, 0xBA }, /* INTEGRAL */
+    { 0x2248, 0xC5 }, /* ALMOST EQUAL TO */
+    { 0x2260, 0xAD }, /* NOT EQUAL TO */
+    { 0x2264, 0xB2 }, /* LESS-THAN OR EQUAL TO */
+    { 0x2265, 0xB3 }, /* GREATER-THAN OR EQUAL TO */
+    { 0x25CA, 0xD7 }, /* LOZENGE */
+    { 0xF8FF, 0xF0 }, /* Apple logo */
+    { 0xFB01, 0xDE }, /* LATIN SMALL LIGATURE FI */
+    { 0xFB02, 0xDF }, /* LATIN SMALL LIGATURE FL */
+};
+
+static const FcCharMap AppleRoman = {
+    AppleRomanEnt,
+    sizeof (AppleRomanEnt) / sizeof (AppleRomanEnt[0])
+};
+
+static const FcCharEnt AdobeSymbolEnt[] = {
+    { 0x0020, 0x20 }, /* SPACE	# space */
+    { 0x0021, 0x21 }, /* EXCLAMATION MARK	# exclam */
+    { 0x0023, 0x23 }, /* NUMBER SIGN	# numbersign */
+    { 0x0025, 0x25 }, /* PERCENT SIGN	# percent */
+    { 0x0026, 0x26 }, /* AMPERSAND	# ampersand */
+    { 0x0028, 0x28 }, /* LEFT PARENTHESIS	# parenleft */
+    { 0x0029, 0x29 }, /* RIGHT PARENTHESIS	# parenright */
+    { 0x002B, 0x2B }, /* PLUS SIGN	# plus */
+    { 0x002C, 0x2C }, /* COMMA	# comma */
+    { 0x002E, 0x2E }, /* FULL STOP	# period */
+    { 0x002F, 0x2F }, /* SOLIDUS	# slash */
+    { 0x0030, 0x30 }, /* DIGIT ZERO	# zero */
+    { 0x0031, 0x31 }, /* DIGIT ONE	# one */
+    { 0x0032, 0x32 }, /* DIGIT TWO	# two */
+    { 0x0033, 0x33 }, /* DIGIT THREE	# three */
+    { 0x0034, 0x34 }, /* DIGIT FOUR	# four */
+    { 0x0035, 0x35 }, /* DIGIT FIVE	# five */
+    { 0x0036, 0x36 }, /* DIGIT SIX	# six */
+    { 0x0037, 0x37 }, /* DIGIT SEVEN	# seven */
+    { 0x0038, 0x38 }, /* DIGIT EIGHT	# eight */
+    { 0x0039, 0x39 }, /* DIGIT NINE	# nine */
+    { 0x003A, 0x3A }, /* COLON	# colon */
+    { 0x003B, 0x3B }, /* SEMICOLON	# semicolon */
+    { 0x003C, 0x3C }, /* LESS-THAN SIGN	# less */
+    { 0x003D, 0x3D }, /* EQUALS SIGN	# equal */
+    { 0x003E, 0x3E }, /* GREATER-THAN SIGN	# greater */
+    { 0x003F, 0x3F }, /* QUESTION MARK	# question */
+    { 0x005B, 0x5B }, /* LEFT SQUARE BRACKET	# bracketleft */
+    { 0x005D, 0x5D }, /* RIGHT SQUARE BRACKET	# bracketright */
+    { 0x005F, 0x5F }, /* LOW LINE	# underscore */
+    { 0x007B, 0x7B }, /* LEFT CURLY BRACKET	# braceleft */
+    { 0x007C, 0x7C }, /* VERTICAL LINE	# bar */
+    { 0x007D, 0x7D }, /* RIGHT CURLY BRACKET	# braceright */
+    { 0x00A0, 0x20 }, /* NO-BREAK SPACE	# space */
+    { 0x00AC, 0xD8 }, /* NOT SIGN	# logicalnot */
+    { 0x00B0, 0xB0 }, /* DEGREE SIGN	# degree */
+    { 0x00B1, 0xB1 }, /* PLUS-MINUS SIGN	# plusminus */
+    { 0x00B5, 0x6D }, /* MICRO SIGN	# mu */
+    { 0x00D7, 0xB4 }, /* MULTIPLICATION SIGN	# multiply */
+    { 0x00F7, 0xB8 }, /* DIVISION SIGN	# divide */
+    { 0x0192, 0xA6 }, /* LATIN SMALL LETTER F WITH HOOK	# florin */
+    { 0x0391, 0x41 }, /* GREEK CAPITAL LETTER ALPHA	# Alpha */
+    { 0x0392, 0x42 }, /* GREEK CAPITAL LETTER BETA	# Beta */
+    { 0x0393, 0x47 }, /* GREEK CAPITAL LETTER GAMMA	# Gamma */
+    { 0x0394, 0x44 }, /* GREEK CAPITAL LETTER DELTA	# Delta */
+    { 0x0395, 0x45 }, /* GREEK CAPITAL LETTER EPSILON	# Epsilon */
+    { 0x0396, 0x5A }, /* GREEK CAPITAL LETTER ZETA	# Zeta */
+    { 0x0397, 0x48 }, /* GREEK CAPITAL LETTER ETA	# Eta */
+    { 0x0398, 0x51 }, /* GREEK CAPITAL LETTER THETA	# Theta */
+    { 0x0399, 0x49 }, /* GREEK CAPITAL LETTER IOTA	# Iota */
+    { 0x039A, 0x4B }, /* GREEK CAPITAL LETTER KAPPA	# Kappa */
+    { 0x039B, 0x4C }, /* GREEK CAPITAL LETTER LAMDA	# Lambda */
+    { 0x039C, 0x4D }, /* GREEK CAPITAL LETTER MU	# Mu */
+    { 0x039D, 0x4E }, /* GREEK CAPITAL LETTER NU	# Nu */
+    { 0x039E, 0x58 }, /* GREEK CAPITAL LETTER XI	# Xi */
+    { 0x039F, 0x4F }, /* GREEK CAPITAL LETTER OMICRON	# Omicron */
+    { 0x03A0, 0x50 }, /* GREEK CAPITAL LETTER PI	# Pi */
+    { 0x03A1, 0x52 }, /* GREEK CAPITAL LETTER RHO	# Rho */
+    { 0x03A3, 0x53 }, /* GREEK CAPITAL LETTER SIGMA	# Sigma */
+    { 0x03A4, 0x54 }, /* GREEK CAPITAL LETTER TAU	# Tau */
+    { 0x03A5, 0x55 }, /* GREEK CAPITAL LETTER UPSILON	# Upsilon */
+    { 0x03A6, 0x46 }, /* GREEK CAPITAL LETTER PHI	# Phi */
+    { 0x03A7, 0x43 }, /* GREEK CAPITAL LETTER CHI	# Chi */
+    { 0x03A8, 0x59 }, /* GREEK CAPITAL LETTER PSI	# Psi */
+    { 0x03A9, 0x57 }, /* GREEK CAPITAL LETTER OMEGA	# Omega */
+    { 0x03B1, 0x61 }, /* GREEK SMALL LETTER ALPHA	# alpha */
+    { 0x03B2, 0x62 }, /* GREEK SMALL LETTER BETA	# beta */
+    { 0x03B3, 0x67 }, /* GREEK SMALL LETTER GAMMA	# gamma */
+    { 0x03B4, 0x64 }, /* GREEK SMALL LETTER DELTA	# delta */
+    { 0x03B5, 0x65 }, /* GREEK SMALL LETTER EPSILON	# epsilon */
+    { 0x03B6, 0x7A }, /* GREEK SMALL LETTER ZETA	# zeta */
+    { 0x03B7, 0x68 }, /* GREEK SMALL LETTER ETA	# eta */
+    { 0x03B8, 0x71 }, /* GREEK SMALL LETTER THETA	# theta */
+    { 0x03B9, 0x69 }, /* GREEK SMALL LETTER IOTA	# iota */
+    { 0x03BA, 0x6B }, /* GREEK SMALL LETTER KAPPA	# kappa */
+    { 0x03BB, 0x6C }, /* GREEK SMALL LETTER LAMDA	# lambda */
+    { 0x03BC, 0x6D }, /* GREEK SMALL LETTER MU	# mu */
+    { 0x03BD, 0x6E }, /* GREEK SMALL LETTER NU	# nu */
+    { 0x03BE, 0x78 }, /* GREEK SMALL LETTER XI	# xi */
+    { 0x03BF, 0x6F }, /* GREEK SMALL LETTER OMICRON	# omicron */
+    { 0x03C0, 0x70 }, /* GREEK SMALL LETTER PI	# pi */
+    { 0x03C1, 0x72 }, /* GREEK SMALL LETTER RHO	# rho */
+    { 0x03C2, 0x56 }, /* GREEK SMALL LETTER FINAL SIGMA	# sigma1 */
+    { 0x03C3, 0x73 }, /* GREEK SMALL LETTER SIGMA	# sigma */
+    { 0x03C4, 0x74 }, /* GREEK SMALL LETTER TAU	# tau */
+    { 0x03C5, 0x75 }, /* GREEK SMALL LETTER UPSILON	# upsilon */
+    { 0x03C6, 0x66 }, /* GREEK SMALL LETTER PHI	# phi */
+    { 0x03C7, 0x63 }, /* GREEK SMALL LETTER CHI	# chi */
+    { 0x03C8, 0x79 }, /* GREEK SMALL LETTER PSI	# psi */
+    { 0x03C9, 0x77 }, /* GREEK SMALL LETTER OMEGA	# omega */
+    { 0x03D1, 0x4A }, /* GREEK THETA SYMBOL	# theta1 */
+    { 0x03D2, 0xA1 }, /* GREEK UPSILON WITH HOOK SYMBOL	# Upsilon1 */
+    { 0x03D5, 0x6A }, /* GREEK PHI SYMBOL	# phi1 */
+    { 0x03D6, 0x76 }, /* GREEK PI SYMBOL	# omega1 */
+    { 0x2022, 0xB7 }, /* BULLET	# bullet */
+    { 0x2026, 0xBC }, /* HORIZONTAL ELLIPSIS	# ellipsis */
+    { 0x2032, 0xA2 }, /* PRIME	# minute */
+    { 0x2033, 0xB2 }, /* DOUBLE PRIME	# second */
+    { 0x2044, 0xA4 }, /* FRACTION SLASH	# fraction */
+    { 0x20AC, 0xA0 }, /* EURO SIGN	# Euro */
+    { 0x2111, 0xC1 }, /* BLACK-LETTER CAPITAL I	# Ifraktur */
+    { 0x2118, 0xC3 }, /* SCRIPT CAPITAL P	# weierstrass */
+    { 0x211C, 0xC2 }, /* BLACK-LETTER CAPITAL R	# Rfraktur */
+    { 0x2126, 0x57 }, /* OHM SIGN	# Omega */
+    { 0x2135, 0xC0 }, /* ALEF SYMBOL	# aleph */
+    { 0x2190, 0xAC }, /* LEFTWARDS ARROW	# arrowleft */
+    { 0x2191, 0xAD }, /* UPWARDS ARROW	# arrowup */
+    { 0x2192, 0xAE }, /* RIGHTWARDS ARROW	# arrowright */
+    { 0x2193, 0xAF }, /* DOWNWARDS ARROW	# arrowdown */
+    { 0x2194, 0xAB }, /* LEFT RIGHT ARROW	# arrowboth */
+    { 0x21B5, 0xBF }, /* DOWNWARDS ARROW WITH CORNER LEFTWARDS	# carriagereturn */
+    { 0x21D0, 0xDC }, /* LEFTWARDS DOUBLE ARROW	# arrowdblleft */
+    { 0x21D1, 0xDD }, /* UPWARDS DOUBLE ARROW	# arrowdblup */
+    { 0x21D2, 0xDE }, /* RIGHTWARDS DOUBLE ARROW	# arrowdblright */
+    { 0x21D3, 0xDF }, /* DOWNWARDS DOUBLE ARROW	# arrowdbldown */
+    { 0x21D4, 0xDB }, /* LEFT RIGHT DOUBLE ARROW	# arrowdblboth */
+    { 0x2200, 0x22 }, /* FOR ALL	# universal */
+    { 0x2202, 0xB6 }, /* PARTIAL DIFFERENTIAL	# partialdiff */
+    { 0x2203, 0x24 }, /* THERE EXISTS	# existential */
+    { 0x2205, 0xC6 }, /* EMPTY SET	# emptyset */
+    { 0x2206, 0x44 }, /* INCREMENT	# Delta */
+    { 0x2207, 0xD1 }, /* NABLA	# gradient */
+    { 0x2208, 0xCE }, /* ELEMENT OF	# element */
+    { 0x2209, 0xCF }, /* NOT AN ELEMENT OF	# notelement */
+    { 0x220B, 0x27 }, /* CONTAINS AS MEMBER	# suchthat */
+    { 0x220F, 0xD5 }, /* N-ARY PRODUCT	# product */
+    { 0x2211, 0xE5 }, /* N-ARY SUMMATION	# summation */
+    { 0x2212, 0x2D }, /* MINUS SIGN	# minus */
+    { 0x2215, 0xA4 }, /* DIVISION SLASH	# fraction */
+    { 0x2217, 0x2A }, /* ASTERISK OPERATOR	# asteriskmath */
+    { 0x221A, 0xD6 }, /* SQUARE ROOT	# radical */
+    { 0x221D, 0xB5 }, /* PROPORTIONAL TO	# proportional */
+    { 0x221E, 0xA5 }, /* INFINITY	# infinity */
+    { 0x2220, 0xD0 }, /* ANGLE	# angle */
+    { 0x2227, 0xD9 }, /* LOGICAL AND	# logicaland */
+    { 0x2228, 0xDA }, /* LOGICAL OR	# logicalor */
+    { 0x2229, 0xC7 }, /* INTERSECTION	# intersection */
+    { 0x222A, 0xC8 }, /* UNION	# union */
+    { 0x222B, 0xF2 }, /* INTEGRAL	# integral */
+    { 0x2234, 0x5C }, /* THEREFORE	# therefore */
+    { 0x223C, 0x7E }, /* TILDE OPERATOR	# similar */
+    { 0x2245, 0x40 }, /* APPROXIMATELY EQUAL TO	# congruent */
+    { 0x2248, 0xBB }, /* ALMOST EQUAL TO	# approxequal */
+    { 0x2260, 0xB9 }, /* NOT EQUAL TO	# notequal */
+    { 0x2261, 0xBA }, /* IDENTICAL TO	# equivalence */
+    { 0x2264, 0xA3 }, /* LESS-THAN OR EQUAL TO	# lessequal */
+    { 0x2265, 0xB3 }, /* GREATER-THAN OR EQUAL TO	# greaterequal */
+    { 0x2282, 0xCC }, /* SUBSET OF	# propersubset */
+    { 0x2283, 0xC9 }, /* SUPERSET OF	# propersuperset */
+    { 0x2284, 0xCB }, /* NOT A SUBSET OF	# notsubset */
+    { 0x2286, 0xCD }, /* SUBSET OF OR EQUAL TO	# reflexsubset */
+    { 0x2287, 0xCA }, /* SUPERSET OF OR EQUAL TO	# reflexsuperset */
+    { 0x2295, 0xC5 }, /* CIRCLED PLUS	# circleplus */
+    { 0x2297, 0xC4 }, /* CIRCLED TIMES	# circlemultiply */
+    { 0x22A5, 0x5E }, /* UP TACK	# perpendicular */
+    { 0x22C5, 0xD7 }, /* DOT OPERATOR	# dotmath */
+    { 0x2320, 0xF3 }, /* TOP HALF INTEGRAL	# integraltp */
+    { 0x2321, 0xF5 }, /* BOTTOM HALF INTEGRAL	# integralbt */
+    { 0x2329, 0xE1 }, /* LEFT-POINTING ANGLE BRACKET	# angleleft */
+    { 0x232A, 0xF1 }, /* RIGHT-POINTING ANGLE BRACKET	# angleright */
+    { 0x25CA, 0xE0 }, /* LOZENGE	# lozenge */
+    { 0x2660, 0xAA }, /* BLACK SPADE SUIT	# spade */
+    { 0x2663, 0xA7 }, /* BLACK CLUB SUIT	# club */
+    { 0x2665, 0xA9 }, /* BLACK HEART SUIT	# heart */
+    { 0x2666, 0xA8 }, /* BLACK DIAMOND SUIT	# diamond */
+    { 0xF6D9, 0xD3 }, /* COPYRIGHT SIGN SERIF	# copyrightserif (CUS) */
+    { 0xF6DA, 0xD2 }, /* REGISTERED SIGN SERIF	# registerserif (CUS) */
+    { 0xF6DB, 0xD4 }, /* TRADE MARK SIGN SERIF	# trademarkserif (CUS) */
+    { 0xF8E5, 0x60 }, /* RADICAL EXTENDER	# radicalex (CUS) */
+    { 0xF8E6, 0xBD }, /* VERTICAL ARROW EXTENDER	# arrowvertex (CUS) */
+    { 0xF8E7, 0xBE }, /* HORIZONTAL ARROW EXTENDER	# arrowhorizex (CUS) */
+    { 0xF8E8, 0xE2 }, /* REGISTERED SIGN SANS SERIF	# registersans (CUS) */
+    { 0xF8E9, 0xE3 }, /* COPYRIGHT SIGN SANS SERIF	# copyrightsans (CUS) */
+    { 0xF8EA, 0xE4 }, /* TRADE MARK SIGN SANS SERIF	# trademarksans (CUS) */
+    { 0xF8EB, 0xE6 }, /* LEFT PAREN TOP	# parenlefttp (CUS) */
+    { 0xF8EC, 0xE7 }, /* LEFT PAREN EXTENDER	# parenleftex (CUS) */
+    { 0xF8ED, 0xE8 }, /* LEFT PAREN BOTTOM	# parenleftbt (CUS) */
+    { 0xF8EE, 0xE9 }, /* LEFT SQUARE BRACKET TOP	# bracketlefttp (CUS) */
+    { 0xF8EF, 0xEA }, /* LEFT SQUARE BRACKET EXTENDER	# bracketleftex (CUS) */
+    { 0xF8F0, 0xEB }, /* LEFT SQUARE BRACKET BOTTOM	# bracketleftbt (CUS) */
+    { 0xF8F1, 0xEC }, /* LEFT CURLY BRACKET TOP	# bracelefttp (CUS) */
+    { 0xF8F2, 0xED }, /* LEFT CURLY BRACKET MID	# braceleftmid (CUS) */
+    { 0xF8F3, 0xEE }, /* LEFT CURLY BRACKET BOTTOM	# braceleftbt (CUS) */
+    { 0xF8F4, 0xEF }, /* CURLY BRACKET EXTENDER	# braceex (CUS) */
+    { 0xF8F5, 0xF4 }, /* INTEGRAL EXTENDER	# integralex (CUS) */
+    { 0xF8F6, 0xF6 }, /* RIGHT PAREN TOP	# parenrighttp (CUS) */
+    { 0xF8F7, 0xF7 }, /* RIGHT PAREN EXTENDER	# parenrightex (CUS) */
+    { 0xF8F8, 0xF8 }, /* RIGHT PAREN BOTTOM	# parenrightbt (CUS) */
+    { 0xF8F9, 0xF9 }, /* RIGHT SQUARE BRACKET TOP	# bracketrighttp (CUS) */
+    { 0xF8FA, 0xFA }, /* RIGHT SQUARE BRACKET EXTENDER	# bracketrightex (CUS) */
+    { 0xF8FB, 0xFB }, /* RIGHT SQUARE BRACKET BOTTOM	# bracketrightbt (CUS) */
+    { 0xF8FC, 0xFC }, /* RIGHT CURLY BRACKET TOP	# bracerighttp (CUS) */
+    { 0xF8FD, 0xFD }, /* RIGHT CURLY BRACKET MID	# bracerightmid (CUS) */
+    { 0xF8FE, 0xFE }, /* RIGHT CURLY BRACKET BOTTOM	# bracerightbt (CUS) */
+};
+
+static const FcCharMap AdobeSymbol = {
+    AdobeSymbolEnt,
+    sizeof (AdobeSymbolEnt) / sizeof (AdobeSymbolEnt[0]),
+};
+    
+static const FcFontDecode fcFontDecoders[] = {
+    { ft_encoding_unicode,	0,		(1 << 21) - 1 },
+    { ft_encoding_symbol,	&AdobeSymbol,	(1 << 16) - 1 },
+    { ft_encoding_apple_roman,	&AppleRoman,	(1 << 16) - 1 },
+};
+
+#define NUM_DECODE  (sizeof (fcFontDecoders) / sizeof (fcFontDecoders[0]))
+
+FcChar32
+FcFreeTypeUcs4ToPrivate (FcChar32 ucs4, const FcCharMap *map)
+{
+    int		low, high, mid;
+    FcChar16	bmp;
+
+    low = 0;
+    high = map->nent - 1;
+    if (ucs4 < map->ent[low].bmp || map->ent[high].bmp < ucs4)
+	return ~0;
+    while (low <= high)
+    {
+	mid = (high + low) >> 1;
+	bmp = map->ent[mid].bmp;
+	if (ucs4 == bmp)
+	    return (FT_ULong) map->ent[mid].encode;
+	if (ucs4 < bmp)
+	    high = mid - 1;
+	else
+	    low = mid + 1;
+    }
+    return ~0;
+}
+
+FcChar32
+FcFreeTypePrivateToUcs4 (FcChar32 private, const FcCharMap *map)
+{
+    int	    i;
+
+    for (i = 0; i < map->nent; i++)
+	if (map->ent[i].encode == private)
+	    return (FcChar32) map->ent[i].bmp;
+    return ~0;
+}
+
+const FcCharMap *
+FcFreeTypeGetPrivateMap (FT_Encoding encoding)
+{
+    int	i;
+
+    for (i = 0; i < NUM_DECODE; i++)
+	if (fcFontDecoders[i].encoding == encoding)
+	    return fcFontDecoders[i].map;
+    return 0;
+}
+
+/*
+ * Map a UCS4 glyph to a glyph index.  Use all available encoding
+ * tables to try and find one that works.  This information is expected
+ * to be cached by higher levels, so performance isn't critical
+ */
+
+FT_UInt
+FcFreeTypeCharIndex (FT_Face face, FcChar32 ucs4)
+{
+    int		    initial, offset, decode;
+    FT_UInt	    glyphindex;
+    FcChar32	    charcode;
+
+    initial = 0;
+    /*
+     * Find the current encoding
+     */
+    if (face->charmap)
+    {
+	for (; initial < NUM_DECODE; initial++)
+	    if (fcFontDecoders[initial].encoding == face->charmap->encoding)
+		break;
+	if (initial == NUM_DECODE)
+	    initial = 0;
+    }
+    /*
+     * Check each encoding for the glyph, starting with the current one
+     */
+    for (offset = 0; offset < NUM_DECODE; offset++)
+    {
+	decode = (initial + offset) % NUM_DECODE;
+	if (!face->charmap || face->charmap->encoding != fcFontDecoders[decode].encoding)
+	    if (FT_Select_Charmap (face, fcFontDecoders[decode].encoding) != 0)
+		continue;
+	if (fcFontDecoders[decode].map)
+	{
+	    charcode = FcFreeTypeUcs4ToPrivate (ucs4, fcFontDecoders[decode].map);
+	    if (charcode == ~0)
+		continue;
+	}
+	else
+	    charcode = ucs4;
+	glyphindex = FT_Get_Char_Index (face, (FT_ULong) charcode);
+	if (glyphindex)
+	    return glyphindex;
+    }
+    return 0;
+}
+
+static FcBool
+FcFreeTypeCheckGlyph (FT_Face face, FcChar32 ucs4, 
+		      FT_UInt glyph, FcBlanks *blanks,
+		      FT_Pos *advance)
+{
+    FT_Int	    load_flags = FT_LOAD_NO_SCALE | FT_LOAD_NO_HINTING;
+    FT_GlyphSlot    slot;
+    
+    /*
+     * When using scalable fonts, only report those glyphs
+     * which can be scaled; otherwise those fonts will
+     * only be available at some sizes, and never when
+     * transformed.  Avoid this by simply reporting bitmap-only
+     * glyphs as missing
+     */
+    if (face->face_flags & FT_FACE_FLAG_SCALABLE)
+	load_flags |= FT_LOAD_NO_BITMAP;
+    
+    if (FT_Load_Glyph (face, glyph, load_flags))
+	return FcFalse;
+    
+    slot = face->glyph;
+    if (!glyph)
+	return FcFalse;
+    
+    *advance = slot->metrics.horiAdvance;
+
+    switch (slot->format) {
+    case ft_glyph_format_bitmap:
+	/*
+	 * Bitmaps are assumed to be reasonable; if
+	 * this proves to be a rash assumption, this
+	 * code can be easily modified
+	 */
+	return FcTrue;
+    case ft_glyph_format_outline:
+	/*
+	 * Glyphs with contours are always OK
+	 */
+	if (slot->outline.n_contours != 0)
+	    return FcTrue;
+	/*
+	 * Glyphs with no contours are only OK if
+	 * they're members of the Blanks set specified
+	 * in the configuration.  If blanks isn't set,
+	 * then allow any glyph to be blank
+	 */
+	if (!blanks || FcBlanksIsMember (blanks, ucs4))
+	    return FcTrue;
+	/* fall through ... */
+    default:
+	break;
+    }
+    return FcFalse;
+}
+
+FcCharSet *
+FcFreeTypeCharSetAndSpacing (FT_Face face, FcBlanks *blanks, int *spacing)
+{
+    FcChar32	    page, off, max, ucs4;
+#ifdef CHECK
+    FcChar32	    font_max = 0;
+#endif
+    FcCharSet	    *fcs;
+    FcCharLeaf	    *leaf;
+    const FcCharMap *map;
+    int		    o;
+    int		    i;
+    FT_UInt	    glyph;
+    FT_Pos	    advance, all_advance = 0;
+    FcBool	    has_advance = FcFalse, fixed_advance = FcTrue;
+
+    fcs = FcCharSetCreate ();
+    if (!fcs)
+	goto bail0;
+    
+    for (o = 0; o < NUM_DECODE; o++)
+    {
+	if (FT_Select_Charmap (face, fcFontDecoders[o].encoding) != 0)
+	    continue;
+	map = fcFontDecoders[o].map;
+	if (map)
+	{
+	    /*
+	     * Non-Unicode tables are easy; there's a list of all possible
+	     * characters
+	     */
+	    for (i = 0; i < map->nent; i++)
+	    {
+		ucs4 = map->ent[i].bmp;
+		glyph = FT_Get_Char_Index (face, map->ent[i].encode);
+		if (glyph && 
+		    FcFreeTypeCheckGlyph (face, ucs4, glyph, blanks, &advance))
+		{
+		    if (!has_advance)
+		    {
+			has_advance = FcTrue;
+			all_advance = advance;
+		    }
+		    else if (advance != all_advance)
+			fixed_advance = FcFalse;
+		    leaf = FcCharSetFindLeafCreate (fcs, ucs4);
+		    if (!leaf)
+			goto bail1;
+		    leaf->map[(ucs4 & 0xff) >> 5] |= (1 << (ucs4 & 0x1f));
+#ifdef CHECK
+		    if (ucs4 > font_max)
+			font_max = ucs4;
+#endif
+		}
+	    }
+	}
+	else
+	{
+	    FT_UInt gindex;
+	  
+	    max = fcFontDecoders[o].max;
+	    /*
+	     * Find the first encoded character in the font
+	     */
+	    if (FT_Get_Char_Index (face, 0))
+	    {
+		ucs4 = 0;
+		gindex = 1;
+	    }
+	    else
+	    {
+		ucs4 = FT_Get_Next_Char (face, 0, &gindex);
+		if (!ucs4)
+		    gindex = 0;
+	    }
+
+	    while (gindex)
+	    {
+		page = ucs4 >> 8;
+		leaf = 0;
+		while ((ucs4 >> 8) == page)
+		{
+		    glyph = FT_Get_Char_Index (face, ucs4);
+		    if (glyph && FcFreeTypeCheckGlyph (face, ucs4, 
+						       glyph, blanks, &advance))
+		    {
+			if (!has_advance)
+			{
+			    has_advance = FcTrue;
+			    all_advance = advance;
+			}
+			else if (advance != all_advance)
+			    fixed_advance = FcFalse;
+			if (!leaf)
+			{
+			    leaf = FcCharSetFindLeafCreate (fcs, ucs4);
+			    if (!leaf)
+				goto bail1;
+			}
+			off = ucs4 & 0xff;
+			leaf->map[off >> 5] |= (1 << (off & 0x1f));
+#ifdef CHECK
+			if (ucs4 > font_max)
+			    font_max = ucs4;
+#endif
+		    }
+		    ucs4++;
+		}
+		ucs4 = FT_Get_Next_Char (face, ucs4 - 1, &gindex);
+		if (!ucs4)
+		    gindex = 0;
+	    }
+#ifdef CHECK
+	    for (ucs4 = 0; ucs4 < 0x10000; ucs4++)
+	    {
+		FcBool	    FT_Has, FC_Has;
+
+		FT_Has = FT_Get_Char_Index (face, ucs4) != 0;
+		FC_Has = FcCharSetHasChar (fcs, ucs4);
+		if (FT_Has != FC_Has)
+		{
+		    printf ("0x%08x FT says %d FC says %d\n", ucs4, FT_Has, FC_Has);
+		}
+	    }
+#endif
+	}
+    }
+#ifdef CHECK
+    printf ("%d glyphs %d encoded\n", (int) face->num_glyphs, FcCharSetCount (fcs));
+    for (ucs4 = 0; ucs4 <= font_max; ucs4++)
+    {
+	FcBool	has_char = FcFreeTypeCharIndex (face, ucs4) != 0;
+	FcBool	has_bit = FcCharSetHasChar (fcs, ucs4);
+
+	if (has_char && !has_bit)
+	    printf ("Bitmap missing char 0x%x\n", ucs4);
+	else if (!has_char && has_bit)
+	    printf ("Bitmap extra char 0x%x\n", ucs4);
+    }
+#endif
+    if (fixed_advance)
+	*spacing = FC_MONO;
+    else
+	*spacing = FC_PROPORTIONAL;
+    return fcs;
+bail1:
+    FcCharSetDestroy (fcs);
+bail0:
+    return 0;
+}
+
+FcCharSet *
+FcFreeTypeCharSet (FT_Face face, FcBlanks *blanks)
+{
+    int spacing;
+
+    return FcFreeTypeCharSetAndSpacing (face, blanks, &spacing);
+}
diff -urN xc/extras/fontconfig/src/fcfs.c xc-fontconfig/extras/fontconfig/src/fcfs.c
--- xc/extras/fontconfig/src/fcfs.c	2003-09-25 13:01:22.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/src/fcfs.c	2003-11-19 21:34:42.000000000 +0100
@@ -1,7 +1,7 @@
 /*
- * $XFree86: xc/extras/fontconfig/src/fcfs.c,v 1.1.1.1 2003/06/04 02:57:52 dawes Exp $
+ * $RCSId: $
  *
- * Copyright © 2000 Keith Packard, member of The XFree86 Project, Inc.
+ * Copyright © 2000 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
diff -urN xc/extras/fontconfig/src/fcinit.c xc-fontconfig/extras/fontconfig/src/fcinit.c
--- xc/extras/fontconfig/src/fcinit.c	2003-09-25 13:01:22.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/src/fcinit.c	2003-11-19 21:34:42.000000000 +0100
@@ -1,7 +1,7 @@
 /*
- * $XFree86: xc/extras/fontconfig/src/fcinit.c,v 1.1.1.1 2003/06/04 02:57:52 dawes Exp $
+ * $RCSId: xc/lib/fontconfig/src/fcinit.c,v 1.7 2002/08/22 07:36:44 keithp Exp $
  *
- * Copyright © 2001 Keith Packard, member of The XFree86 Project, Inc.
+ * Copyright © 2001 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
diff -urN xc/extras/fontconfig/src/fcint.h xc-fontconfig/extras/fontconfig/src/fcint.h
--- xc/extras/fontconfig/src/fcint.h	2003-11-02 05:40:29.000000000 +0100
+++ xc-fontconfig/extras/fontconfig/src/fcint.h	2003-11-19 21:34:45.000000000 +0100
@@ -1,7 +1,7 @@
 /*
- * $XFree86: xc/extras/fontconfig/src/fcint.h,v 1.2 2003/10/22 17:15:22 tsi Exp $
+ * $RCSId: xc/lib/fontconfig/src/fcint.h,v 1.27 2002/08/31 22:17:32 keithp Exp $
  *
- * Copyright © 2000 Keith Packard, member of The XFree86 Project, Inc.
+ * Copyright © 2000 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -53,6 +53,12 @@
 #define FC_FONT_FILE_INVALID	((FcChar8 *) ".")
 #define FC_FONT_FILE_DIR	((FcChar8 *) ".dir")
 
+#ifdef _WIN32
+#define FC_SEARCH_PATH_SEPARATOR ';'
+#else
+#define FC_SEARCH_PATH_SEPARATOR ':'
+#endif
+
 #define FC_DBG_MATCH	1
 #define FC_DBG_MATCHV	2
 #define FC_DBG_EDIT	4
@@ -97,7 +103,7 @@
 #define FC_MEM_NUM	    29
 
 typedef enum _FcValueBinding {
-    FcValueBindingWeak, FcValueBindingStrong
+    FcValueBindingWeak, FcValueBindingStrong, FcValueBindingSame
 } FcValueBinding;
 
 typedef struct _FcValueList {
@@ -129,7 +135,8 @@
     FcOpOr, FcOpAnd, FcOpEqual, FcOpNotEqual, FcOpContains, FcOpNotContains,
     FcOpLess, FcOpLessEqual, FcOpMore, FcOpMoreEqual,
     FcOpPlus, FcOpMinus, FcOpTimes, FcOpDivide,
-    FcOpNot, FcOpComma, FcOpInvalid
+    FcOpNot, FcOpComma, FcOpFloor, FcOpCeil, FcOpRound, FcOpTrunc,
+    FcOpInvalid
 } FcOp;
 
 typedef struct _FcExpr {
@@ -338,12 +345,16 @@
 FcGlobalCacheDestroy (FcGlobalCache *cache);
 
 FcBool
-FcGlobalCacheCheckTime (FcGlobalCacheInfo *info);
+FcGlobalCacheCheckTime (const FcChar8*file, FcGlobalCacheInfo *info);
 
 void
 FcGlobalCacheReferenced (FcGlobalCache	    *cache,
 			 FcGlobalCacheInfo  *info);
 
+void
+FcGlobalCacheReferenceSubdir (FcGlobalCache *cache,
+			      const FcChar8 *dir);
+
 FcGlobalCacheDir *
 FcGlobalCacheDirGet (FcGlobalCache  *cache,
 		     const FcChar8  *dir,
@@ -421,9 +432,9 @@
 		  FcSetName	set);
 
 FcBool
-FcConfigCompareValue (FcValue m,
-		      FcOp    op,
-		      FcValue v);
+FcConfigCompareValue (const FcValue m,
+		      FcOp	    op,
+		      const FcValue v);
 
 /* fccharset.c */
 FcCharSet *
@@ -435,20 +446,17 @@
 FcCharSet *
 FcNameParseCharSet (FcChar8 *string);
 
-FcChar32
-FcFreeTypeUcs4ToPrivate (FcChar32 ucs4, const FcCharMap *map);
-
-FcChar32
-FcFreeTypePrivateToUcs4 (FcChar32 private, const FcCharMap *map);
+FcCharLeaf *
+FcCharSetFindLeafCreate (FcCharSet *fcs, FcChar32 ucs4);
 
-const FcCharMap *
-FcFreeTypeGetPrivateMap (FT_Encoding encoding);
-    
 /* fcdbg.c */
 void
 FcValueListPrint (const FcValueList *l);
 
 void
+FcLangSetPrint (const FcLangSet *ls);
+
+void
 FcOpPrint (FcOp op);
 
 void
@@ -479,6 +487,15 @@
 FcBool
 FcFreeTypeHasLang (FcPattern *pattern, const FcChar8 *lang);
 
+FcChar32
+FcFreeTypeUcs4ToPrivate (FcChar32 ucs4, const FcCharMap *map);
+
+FcChar32
+FcFreeTypePrivateToUcs4 (FcChar32 private, const FcCharMap *map);
+
+const FcCharMap *
+FcFreeTypeGetPrivateMap (FT_Encoding encoding);
+    
 /* fcfs.c */
 /* fcgram.y */
 int
@@ -636,4 +653,10 @@
 int
 FcStrCmpIgnoreBlanksAndCase (const FcChar8 *s1, const FcChar8 *s2);
 
+FcBool
+FcStrUsesHome (const FcChar8 *s);
+
+FcChar8 *
+FcStrLastSlash (const FcChar8  *path);
+
 #endif /* _FC_INT_H_ */
diff -urN xc/extras/fontconfig/src/fclang.c xc-fontconfig/extras/fontconfig/src/fclang.c
--- xc/extras/fontconfig/src/fclang.c	2003-06-04 18:29:39.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/src/fclang.c	2003-11-19 21:34:42.000000000 +0100
@@ -1,5 +1,7 @@
 /*
- * Copyright © 2002 Keith Packard, member of The XFree86 Project, Inc.
+ * $RCSId: xc/lib/fontconfig/src/fclang.c,v 1.7 2002/08/26 23:34:31 keithp Exp $
+ *
+ * Copyright © 2002 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -19,7 +21,6 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-/* $XFree86: xc/extras/fontconfig/src/fclang.c,v 1.2 2003/06/04 16:29:39 dawes Exp $ */
 
 #include "fcint.h"
 
@@ -28,6 +29,11 @@
     FcCharSet	charset;
 } FcLangCharSet;
 
+typedef struct {
+    int begin;
+    int end;
+} FcLangCharSetRange;
+
 #include "../fc-lang/fclang.h"
 
 struct _FcLangSet {
@@ -137,6 +143,37 @@
     }
 }
 
+/*
+ * Return FcTrue when s1 contains s2. 
+ *
+ * s1 contains s2 if s1 equals s2 or if s1 is a
+ * language with a country and s2 is just a language
+ */
+
+static FcBool
+FcLangContains (const FcChar8 *s1, const FcChar8 *s2)
+{
+    FcChar8	    c1, c2;
+
+    for (;;)
+    {
+	c1 = *s1++;
+	c2 = *s2++;
+	
+	c1 = FcToLower (c1);
+	c2 = FcToLower (c2);
+	if (c1 != c2)
+	{
+	    /* see if s1 has a country while s2 is mising one */
+	    if (c1 == '-' && c2 == '\0')
+		return FcTrue;
+	    return FcFalse;
+	}
+	else if (!c1)
+	    return FcTrue;
+    }
+}
+
 const FcCharSet *
 FcCharSetForLang (const FcChar8 *lang)
 {
@@ -222,16 +259,48 @@
 static int
 FcLangSetIndex (const FcChar8 *lang)
 {
-    int	    low, high, mid;
-    int	    cmp;
+    int	    low, high, mid = 0;
+    int	    cmp = 0;
+    FcChar8 firstChar = FcToLower(lang[0]); 
+    FcChar8 secondChar = firstChar ? FcToLower(lang[1]) : '\0';
+    
+    if (firstChar < 'a')
+    {
+	low = 0;
+	high = fcLangCharSetRanges[0].begin;
+    }
+    else if(firstChar > 'z')
+    {
+	low = fcLangCharSetRanges[25].begin;
+	high = NUM_LANG_CHAR_SET - 1;
+    }
+    else
+    {
+	low = fcLangCharSetRanges[firstChar - 'a'].begin;
+	high = fcLangCharSetRanges[firstChar - 'a'].end;
+	/* no matches */
+	if (low > high)
+	    return -low; /* next entry after where it would be */
+    }
 
-    low = 0;
-    high = NUM_LANG_CHAR_SET - 1;
     while (low <= high)
     {
 	mid = (high + low) >> 1;
-	cmp = FcStrCmpIgnoreCase (fcLangCharSets[mid].lang, lang);
-	if (cmp == 0) 
+	if(fcLangCharSets[mid].lang[0] != firstChar)
+	    cmp = FcStrCmpIgnoreCase(fcLangCharSets[mid].lang, lang);
+	else
+	{   /* fast path for resolving 2-letter languages (by far the most common) after
+	     * finding the first char (probably already true because of the hash table) */
+	    cmp = fcLangCharSets[mid].lang[1] - secondChar;
+	    if (cmp == 0 && 
+		(fcLangCharSets[mid].lang[2] != '\0' || 
+		 lang[2] != '\0'))
+	    {
+		cmp = FcStrCmpIgnoreCase(fcLangCharSets[mid].lang+2, 
+					 lang+2);
+	    }
+	}
+	if (cmp == 0)
 	    return mid;
 	if (cmp < 0)
 	    low = mid + 1;
@@ -411,32 +480,28 @@
 FcLangSet *
 FcNameParseLangSet (const FcChar8 *string)
 {
-    FcChar8	    lang[32];
-    const FcChar8   *end, *next;
+    FcChar8	    lang[32],c;
+    int i;
     FcLangSet	    *ls;
 
     ls = FcLangSetCreate ();
     if (!ls)
 	goto bail0;
 
-    while (string && *string) 
+    for(;;)
     {
-	end = (FcChar8 *) strchr ((char *) string, '|');
-	if (!end)
+	for(i = 0; i < 31;i++)
 	{
-	    end = string + strlen ((char *) string);
-	    next = end;
+	    c = *string++;
+	    if(c == '\0' || c == '|')
+		break; /* end of this code */
+	    lang[i] = c;
 	}
-	else
-	    next = end + 1;
-	if (end - string < sizeof (lang) - 1)
-	{
-	    strncpy ((char *) lang, (char *) string, end - string);
-	    lang[end-string] = '\0';
-	    if (!FcLangSetAdd (ls, lang))
-		goto bail1;
-	}
-	string = next;
+	lang[i] = '\0';
+	if (!FcLangSetAdd (ls, lang))
+	    goto bail1;
+	if(c == '\0')
+	    break;
     }
     return ls;
 bail1:
@@ -481,7 +546,7 @@
 	    if (!first)
 		if (!FcStrBufChar (buf, '|'))
 		    return FcFalse;
-	    if (!FcStrBufString (buf, extra));
+	    if (!FcStrBufString (buf, extra))
 		return FcFalse;
 	    first = FcFalse;
 	}
@@ -505,3 +570,113 @@
 	return FcStrSetEqual (lsa->extra, lsb->extra);
     return FcFalse;
 }
+
+static FcBool
+FcLangSetContainsLang (const FcLangSet *ls, const FcChar8 *lang)
+{
+    int		    id;
+    int		    i;
+
+    id = FcLangSetIndex (lang);
+    if (id < 0)
+	id = -id - 1;
+    else if (FcLangSetBitGet (ls, id))
+	return FcTrue;
+    /*
+     * search up and down among equal languages for a match
+     */
+    for (i = id - 1; i >= 0; i--)
+    {
+	if (FcLangCompare (fcLangCharSets[i].lang, lang) == FcLangDifferentLang)
+	    break;
+	if (FcLangSetBitGet (ls, i) &&
+	    FcLangContains (fcLangCharSets[i].lang, lang))
+	    return FcTrue;
+    }
+    for (i = id; i < NUM_LANG_CHAR_SET; i++)
+    {
+	if (FcLangCompare (fcLangCharSets[i].lang, lang) == FcLangDifferentLang)
+	    break;
+	if (FcLangSetBitGet (ls, i) &&
+	    FcLangContains (fcLangCharSets[i].lang, lang))
+	    return FcTrue;
+    }
+    if (ls->extra)
+    {
+	FcStrList	*list = FcStrListCreate (ls->extra);
+	FcChar8		*extra;
+	
+	if (list)
+	{
+	    while ((extra = FcStrListNext (list)))
+	    {
+		if (FcLangContains (extra, lang))
+		    break;
+	    }
+	    FcStrListDone (list);
+    	    if (extra)
+		return FcTrue;
+	}
+    }
+    return FcFalse;
+}
+
+/*
+ * return FcTrue if lsa contains every language in lsb
+ */
+FcBool
+FcLangSetContains (const FcLangSet *lsa, const FcLangSet *lsb)
+{
+    int		    i, j;
+    FcChar32	    missing;
+
+    if (FcDebug() & FC_DBG_MATCHV)
+    {
+	printf ("FcLangSet "); FcLangSetPrint (lsa);
+	printf (" contains "); FcLangSetPrint (lsb);
+	printf ("\n");
+    }
+    /*
+     * check bitmaps for missing language support
+     */
+    for (i = 0; i < NUM_LANG_SET_MAP; i++)
+    {
+	missing = lsb->map[i] & ~lsa->map[i];
+	if (missing)
+	{
+	    for (j = 0; j < 32; j++)
+		if (missing & (1 << j)) 
+		{
+		    if (!FcLangSetContainsLang (lsa,
+						fcLangCharSets[i*32 + j].lang))
+		    {
+			if (FcDebug() & FC_DBG_MATCHV)
+			    printf ("\tMissing bitmap %s\n", fcLangCharSets[i*32+j].lang);
+			return FcFalse;
+		    }
+		}
+	}
+    }
+    if (lsb->extra)
+    {
+	FcStrList   *list = FcStrListCreate (lsb->extra);
+	FcChar8	    *extra;
+
+	if (list)
+	{
+	    while ((extra = FcStrListNext (list)))
+	    {
+		if (!FcLangSetContainsLang (lsa, extra))
+		{
+		    if (FcDebug() & FC_DBG_MATCHV)
+			printf ("\tMissing string %s\n", extra);
+		    break;
+		}
+	    }
+	    FcStrListDone (list);
+	    if (extra)
+		return FcFalse;
+	}
+    }
+    return FcTrue;
+}
diff -urN xc/extras/fontconfig/src/fclist.c xc-fontconfig/extras/fontconfig/src/fclist.c
--- xc/extras/fontconfig/src/fclist.c	2003-09-25 13:01:22.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/src/fclist.c	2003-11-19 21:34:42.000000000 +0100
@@ -1,7 +1,7 @@
 /*
- * $XFree86: xc/extras/fontconfig/src/fclist.c,v 1.1.1.1 2003/06/04 02:58:01 dawes Exp $
+ * $RCSId: xc/lib/fontconfig/src/fclist.c,v 1.11tsi Exp $
  *
- * Copyright © 2000 Keith Packard, member of The XFree86 Project, Inc.
+ * Copyright © 2000 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -128,7 +128,7 @@
 
     for (v1 = v1orig; v1; v1 = v1->next)
 	for (v2 = v2orig; v2; v2 = v2->next)
-	    if (FcConfigCompareValue (v2->value, FcOpContains, v1->value))
+	    if (FcConfigCompareValue (v1->value, FcOpContains, v2->value))
 		return FcTrue;
     return FcFalse;
 }
diff -urN xc/extras/fontconfig/src/fcmatch.c xc-fontconfig/extras/fontconfig/src/fcmatch.c
--- xc/extras/fontconfig/src/fcmatch.c	2003-09-25 13:01:22.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/src/fcmatch.c	2003-11-19 21:34:42.000000000 +0100
@@ -1,7 +1,7 @@
 /*
- * $XFree86: xc/extras/fontconfig/src/fcmatch.c,v 1.1.1.1 2003/06/04 02:58:01 dawes Exp $
+ * $RCSId: xc/lib/fontconfig/src/fcmatch.c,v 1.20 2002/08/31 22:17:32 keithp Exp $
  *
- * Copyright © 2000 Keith Packard, member of The XFree86 Project, Inc.
+ * Copyright © 2000 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -28,13 +28,31 @@
 #include <stdio.h>
 
 static double
-FcCompareInteger (char *object, FcValue value1, FcValue value2)
+FcCompareNumber (char *object, FcValue value1, FcValue value2)
 {
-    int	v;
+    double  v1, v2, v;
     
-    if (value2.type != FcTypeInteger || value1.type != FcTypeInteger)
+    switch (value1.type) {
+    case FcTypeInteger:
+	v1 = (double) value1.u.i;
+	break;
+    case FcTypeDouble:
+	v1 = value1.u.d;
+	break;
+    default:
 	return -1.0;
-    v = value2.u.i - value1.u.i;
+    }
+    switch (value2.type) {
+    case FcTypeInteger:
+	v2 = (double) value2.u.i;
+	break;
+    case FcTypeDouble:
+	v2 = value2.u.d;
+	break;
+    default:
+	return -1.0;
+    }
+    v = v2 - v1;
     if (v < 0)
 	v = -v;
     return (double) v;
@@ -173,7 +191,7 @@
     { FC_LANG,		FcCompareLang,		3, 3 },
 #define MATCH_LANG	    3
     
-    { FC_SPACING,	FcCompareInteger,	5, 5 },
+    { FC_SPACING,	FcCompareNumber,	5, 5 },
 #define MATCH_SPACING	    4
     
     { FC_PIXEL_SIZE,	FcCompareSize,		6, 6 },
@@ -182,26 +200,29 @@
     { FC_STYLE,		FcCompareString,	7, 7 },
 #define MATCH_STYLE	    6
     
-    { FC_SLANT,		FcCompareInteger,	8, 8 },
+    { FC_SLANT,		FcCompareNumber,	8, 8 },
 #define MATCH_SLANT	    7
     
-    { FC_WEIGHT,	FcCompareInteger,	9, 9 },
+    { FC_WEIGHT,	FcCompareNumber,	9, 9 },
 #define MATCH_WEIGHT	    8
     
-    { FC_ANTIALIAS,	FcCompareBool,		10, 10 },
-#define MATCH_ANTIALIAS	    9
+    { FC_WIDTH,		FcCompareNumber,	10, 10 },
+#define MATCH_WIDTH	    9
+    
+    { FC_ANTIALIAS,	FcCompareBool,		11, 11 },
+#define MATCH_ANTIALIAS	    10
     
-    { FC_RASTERIZER,	FcCompareString,	11, 11 },
-#define MATCH_RASTERIZER    10
+    { FC_RASTERIZER,	FcCompareString,	12, 12 },
+#define MATCH_RASTERIZER    11
     
-    { FC_OUTLINE,	FcCompareBool,		12, 12 },
-#define MATCH_OUTLINE	    11
+    { FC_OUTLINE,	FcCompareBool,		13, 13 },
+#define MATCH_OUTLINE	    12
 
-    { FC_FONTVERSION,	FcCompareInteger,	13, 13 },
-#define MATCH_FONTVERSION   12
+    { FC_FONTVERSION,	FcCompareNumber,	14, 14 },
+#define MATCH_FONTVERSION   13
 };
 
-#define NUM_MATCH_VALUES    14
+#define NUM_MATCH_VALUES    15
 
 static FcBool
 FcCompareValueList (const char  *object,
@@ -255,7 +276,13 @@
     case 'p':
 	i = MATCH_PIXEL_SIZE; break;
     case 'w':
-	i = MATCH_WEIGHT; break;
+	switch (FcToLower (object[1])) {
+	case 'i':
+	    i = MATCH_WIDTH; break;
+	case 'e':
+	    i = MATCH_WEIGHT; break;
+	}
+	break;
     case 'r':
 	i = MATCH_RASTERIZER; break;
     case 'o':
diff -urN xc/extras/fontconfig/src/fcmatrix.c xc-fontconfig/extras/fontconfig/src/fcmatrix.c
--- xc/extras/fontconfig/src/fcmatrix.c	2003-09-25 13:01:22.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/src/fcmatrix.c	2003-11-19 21:34:42.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * $XFree86: xc/extras/fontconfig/src/fcmatrix.c,v 1.1.1.1 2003/06/04 02:58:01 dawes Exp $
+ * $RCSId: $
  *
  * Copyright © 2000 Tuomas J. Lukka
  *
diff -urN xc/extras/fontconfig/src/fcname.c xc-fontconfig/extras/fontconfig/src/fcname.c
--- xc/extras/fontconfig/src/fcname.c	2003-09-25 13:01:22.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/src/fcname.c	2003-11-19 21:34:42.000000000 +0100
@@ -1,7 +1,7 @@
 /*
- * $XFree86: xc/extras/fontconfig/src/fcname.c,v 1.1.1.1 2003/06/04 02:58:01 dawes Exp $
+ * $RCSId: xc/lib/fontconfig/src/fcname.c,v 1.15 2002/09/26 00:17:28 keithp Exp $
  *
- * Copyright © 2000 Keith Packard, member of The XFree86 Project, Inc.
+ * Copyright © 2000 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -33,6 +33,7 @@
     { FC_STYLE,		FcTypeString, },
     { FC_SLANT,		FcTypeInteger, },
     { FC_WEIGHT,	FcTypeInteger, },
+    { FC_WIDTH,		FcTypeInteger, },
     { FC_SIZE,		FcTypeDouble, },
     { FC_ASPECT,	FcTypeDouble, },
     { FC_PIXEL_SIZE,	FcTypeDouble, },
@@ -137,16 +138,33 @@
 }
 
 static const FcConstant _FcBaseConstants[] = {
+    { (FcChar8 *) "thin",	    "weight",   FC_WEIGHT_THIN, },
+    { (FcChar8 *) "extralight",	    "weight",   FC_WEIGHT_EXTRALIGHT, },
+    { (FcChar8 *) "ultralight",	    "weight",   FC_WEIGHT_EXTRALIGHT, },
     { (FcChar8 *) "light",	    "weight",   FC_WEIGHT_LIGHT, },
+    { (FcChar8 *) "regular",	    "weight",   FC_WEIGHT_REGULAR, },
     { (FcChar8 *) "medium",	    "weight",   FC_WEIGHT_MEDIUM, },
     { (FcChar8 *) "demibold",	    "weight",   FC_WEIGHT_DEMIBOLD, },
+    { (FcChar8 *) "semibold",	    "weight",   FC_WEIGHT_DEMIBOLD, },
     { (FcChar8 *) "bold",	    "weight",   FC_WEIGHT_BOLD, },
+    { (FcChar8 *) "extrabold",	    "weight",   FC_WEIGHT_EXTRABOLD, },
+    { (FcChar8 *) "ultrabold",	    "weight",   FC_WEIGHT_EXTRABOLD, },
     { (FcChar8 *) "black",	    "weight",   FC_WEIGHT_BLACK, },
 
     { (FcChar8 *) "roman",	    "slant",    FC_SLANT_ROMAN, },
     { (FcChar8 *) "italic",	    "slant",    FC_SLANT_ITALIC, },
     { (FcChar8 *) "oblique",	    "slant",    FC_SLANT_OBLIQUE, },
 
+    { (FcChar8 *) "ultracondensed", "width",	FC_WIDTH_ULTRACONDENSED },
+    { (FcChar8 *) "extracondensed", "width",	FC_WIDTH_EXTRACONDENSED },
+    { (FcChar8 *) "condensed",	    "width",	FC_WIDTH_CONDENSED },
+    { (FcChar8 *) "semicondensed", "width",	FC_WIDTH_SEMICONDENSED },
+    { (FcChar8 *) "normal",	    "width",	FC_WIDTH_NORMAL },
+    { (FcChar8 *) "semiexpanded",   "width",	FC_WIDTH_SEMIEXPANDED },
+    { (FcChar8 *) "expanded",	    "width",	FC_WIDTH_EXPANDED },
+    { (FcChar8 *) "extraexpanded",  "width",	FC_WIDTH_EXTRAEXPANDED },
+    { (FcChar8 *) "ultraexpanded",  "width",	FC_WIDTH_ULTRAEXPANDED },
+    
     { (FcChar8 *) "proportional",   "spacing",  FC_PROPORTIONAL, },
     { (FcChar8 *) "mono",	    "spacing",  FC_MONO, },
     { (FcChar8 *) "charcell",	    "spacing",  FC_CHARCELL, },
@@ -218,7 +236,7 @@
 {
     const FcConstantList    *l;
     int			    i;
-    
+
     for (l = _FcConstants; l; l = l->next)
     {
 	for (i = 0; i < l->nconsts; i++)
@@ -247,8 +265,7 @@
     char    c0, c1;
 
     c0 = *v;
-    if (isupper (c0))
-	c0 = tolower (c0);
+    c0 = FcToLower (c0);
     if (c0 == 't' || c0 == 'y' || c0 == '1')
     {
 	*result = FcTrue;
@@ -262,8 +279,7 @@
     if (c0 == 'o')
     {
 	c1 = v[1];
-	if (isupper (c1))
-	    c1 = tolower (c1);
+	c1 = FcToLower (c1);
 	if (c1 == 'n')
 	{
 	    *result = FcTrue;
diff -urN xc/extras/fontconfig/src/fcpat.c xc-fontconfig/extras/fontconfig/src/fcpat.c
--- xc/extras/fontconfig/src/fcpat.c	2003-06-04 18:29:39.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/src/fcpat.c	2003-11-19 21:34:42.000000000 +0100
@@ -1,5 +1,7 @@
 /*
- * Copyright © 2000 Keith Packard, member of The XFree86 Project, Inc.
+ * $RCSId: xc/lib/fontconfig/src/fcpat.c,v 1.18 2002/09/18 17:11:46 tsi Exp $
+ *
+ * Copyright © 2000 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -19,7 +21,6 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-/* $XFree86: xc/extras/fontconfig/src/fcpat.c,v 1.2 2003/06/04 16:29:39 dawes Exp $ */
 
 #include <stdlib.h>
 #include <string.h>
@@ -753,11 +754,14 @@
 FcPatternDel (FcPattern *p, const char *object)
 {
     FcPatternElt   *e;
+    int		    i;
 
     e = FcPatternFindElt (p, object);
     if (!e)
 	return FcFalse;
 
+    i = e - p->elts;
+    
     /* destroy value */
     FcValueListDestroy (e->values);
     
diff -urN xc/extras/fontconfig/src/fcstr.c xc-fontconfig/extras/fontconfig/src/fcstr.c
--- xc/extras/fontconfig/src/fcstr.c	2003-06-04 18:29:39.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/src/fcstr.c	2003-11-19 21:34:42.000000000 +0100
@@ -1,5 +1,7 @@
 /*
- * Copyright © 2000 Keith Packard, member of The XFree86 Project, Inc.
+ * $RCSId: xc/lib/fontconfig/src/fcstr.c,v 1.10 2002/08/31 22:17:32 keithp Exp $
+ *
+ * Copyright © 2000 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -19,7 +21,6 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-/* $XFree86: xc/extras/fontconfig/src/fcstr.c,v 1.2 2003/06/04 16:29:39 dawes Exp $ */
 
 #include <stdlib.h>
 #include <ctype.h>
@@ -71,11 +72,7 @@
     {
 	c1 = *s1++;
 	c2 = *s2++;
-	if (!c1 || !c2)
-	    break;
-	c1 = FcToLower (c1);
-	c2 = FcToLower (c2);
-	if (c1 != c2)
+	if (!c1 || (c1 != c2 && (c1 = FcToLower(c1)) != (c2 = FcToLower(c2))))
 	    break;
     }
     return (int) c1 - (int) c2;
@@ -94,11 +91,7 @@
 	do
 	    c2 = *s2++;
 	while (c2 == ' ');
-	if (!c1 || !c2)
-	    break;
-	c1 = FcToLower (c1);
-	c2 = FcToLower (c2);
-	if (c1 != c2)
+	if (!c1 || (c1 != c2 && (c1 = FcToLower(c1)) != (c2 = FcToLower(c2))))
 	    break;
     }
     return (int) c1 - (int) c2;
@@ -115,9 +108,7 @@
     {
 	c1 = *s1++;
 	c2 = *s2++;
-	if (!c1 || !c2)
-	    break;
-	if (c1 != c2)
+	if (!c1 || c1 != c2)
 	    break;
     }
     return (int) c1 - (int) c2;
@@ -419,6 +410,12 @@
     return FcTrue;
 }
 
+FcBool
+FcStrUsesHome (const FcChar8 *s)
+{
+    return *s == '~';
+}
+
 FcChar8 *
 FcStrCopyFilename (const FcChar8 *s)
 {
@@ -426,10 +423,11 @@
     
     if (*s == '~')
     {
-	FcChar8	*home = (FcChar8 *) getenv ("HOME");
-	int	size = strlen ((char *) home) + strlen ((char *) s);
+	FcChar8	*home = FcConfigHome ();
+	int	size;
 	if (!home)
 	    return 0;
+	size = strlen ((char *) home) + strlen ((char *) s);
 	new = (FcChar8 *) malloc (size);
 	if (!new)
 	    return 0;
@@ -450,12 +448,31 @@
 }
 
 FcChar8 *
+FcStrLastSlash (const FcChar8  *path)
+{
+    FcChar8	    *slash;
+
+    slash = (FcChar8 *) strrchr ((const char *) path, '/');
+#ifdef _WIN32
+    {
+        FcChar8     *backslash;
+
+	backslash = (FcChar8 *) strrchr ((const char *) path, '\\');
+	if (!slash || (backslash && backslash > slash))
+	    slash = backslash;
+    }
+#endif
+
+    return slash;
+}
+  
+FcChar8 *
 FcStrDirname (const FcChar8 *file)
 {
     FcChar8 *slash;
     FcChar8 *dir;
 
-    slash = (FcChar8 *) strrchr ((char *) file, '/');
+    slash = FcStrLastSlash (file);
     if (!slash)
 	return FcStrCopy ((FcChar8 *) ".");
     dir = malloc ((slash - file) + 1);
@@ -472,7 +489,7 @@
 {
     FcChar8 *slash;
 
-    slash = (FcChar8 *) strrchr ((char *) file, '/');
+    slash = FcStrLastSlash (file);
     if (!slash)
 	return FcStrCopy (file);
     return FcStrCopy (slash + 1);
diff -urN xc/extras/fontconfig/src/fcxml.c xc-fontconfig/extras/fontconfig/src/fcxml.c
--- xc/extras/fontconfig/src/fcxml.c	2003-06-04 18:29:39.000000000 +0200
+++ xc-fontconfig/extras/fontconfig/src/fcxml.c	2003-11-19 21:34:42.000000000 +0100
@@ -1,5 +1,7 @@
 /*
- * Copyright © 2002 Keith Packard, member of The XFree86 Project, Inc.
+ * $RCSId: xc/lib/fontconfig/src/fcxml.c,v 1.21 2002/08/22 18:53:22 keithp Exp $
+ *
+ * Copyright © 2002 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
  * documentation for any purpose is hereby granted without fee, provided that
@@ -19,7 +21,6 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-/* $XFree86: xc/extras/fontconfig/src/fcxml.c,v 1.2 2003/06/04 16:29:39 dawes Exp $ */
 
 #include <stdarg.h>
 #include "fcint.h"
@@ -34,6 +35,12 @@
 #include <expat.h>
 #endif
 
+#ifdef _WIN32
+#define STRICT
+#include <windows.h>
+#undef STRICT
+#endif
+
 FcTest *
 FcTestCreate (FcMatchKind   kind, 
 	      FcQual	    qual,
@@ -196,6 +203,8 @@
 void
 FcExprDestroy (FcExpr *e)
 {
+    if (!e)
+	return;
     switch (e->op) {
     case FcOpInteger:
 	break;
@@ -244,6 +253,10 @@
 	FcExprDestroy (e->u.tree.right);
 	/* fall through */
     case FcOpNot:
+    case FcOpFloor:
+    case FcOpCeil:
+    case FcOpRound:
+    case FcOpTrunc:
 	FcExprDestroy (e->u.tree.left);
 	break;
     case FcOpNil:
@@ -330,6 +343,10 @@
     FcElementDivide,
     FcElementNot,
     FcElementIf,
+    FcElementFloor,
+    FcElementCeil,
+    FcElementRound,
+    FcElementTrunc,
     FcElementUnknown
 } FcElement;
 
@@ -382,8 +399,12 @@
 	{ "divide",	FcElementDivide },
 	{ "not",	FcElementNot },
 	{ "if",		FcElementIf },
+	{ "floor",	FcElementFloor },
+	{ "ceil",	FcElementCeil },
+	{ "round",	FcElementRound },
+	{ "trunc",	FcElementTrunc },
 	
-	{ 0,		FcElementUnknown }
+	{ 0,		0 }
     };
 
     int	    i;
@@ -702,6 +723,7 @@
 static FcChar8 **
 FcConfigSaveAttr (const XML_Char **attr)
 {
+    int		n;
     int		slen;
     int		i;
     FcChar8	**new;
@@ -712,6 +734,7 @@
     slen = 0;
     for (i = 0; attr[i]; i++)
 	slen += strlen (attr[i]) + 1;
+    n = i;
     new = malloc ((i + 1) * sizeof (FcChar8 *) + slen);
     if (!new)
 	return 0;
@@ -1283,8 +1306,17 @@
     return expr;
 }
 
+/*
+ * This builds a tree of binary operations.  Note
+ * that every operator is defined so that if only
+ * a single operand is contained, the value of the
+ * whole expression is the value of the operand.
+ *
+ * This code reduces in that case to returning that
+ * operand.
+ */
 static FcExpr *
-FcPopExprs (FcConfigParse *parse, FcOp op)
+FcPopBinary (FcConfigParse *parse, FcOp op)
 {
     FcExpr  *left, *expr = 0, *new;
 
@@ -1309,9 +1341,39 @@
 }
 
 static void
-FcParseExpr (FcConfigParse *parse, FcOp op)
+FcParseBinary (FcConfigParse *parse, FcOp op)
 {
-    FcExpr  *expr = FcPopExprs (parse, op);
+    FcExpr  *expr = FcPopBinary (parse, op);
+    if (expr)
+	FcVStackPushExpr (parse, FcVStackExpr, expr);
+}
+
+/*
+ * This builds a a unary operator, it consumes only
+ * a single operand
+ */
+
+static FcExpr *
+FcPopUnary (FcConfigParse *parse, FcOp op)
+{
+    FcExpr  *operand, *new = 0;
+
+    if ((operand = FcPopExpr (parse)))
+    {
+	new = FcExprCreateOp (operand, op, 0);
+	if (!new)
+	{
+	    FcExprDestroy (operand);
+	    FcConfigMessage (parse, FcSevereError, "out of memory");
+	}
+    }
+    return new;
+}
+
+static void
+FcParseUnary (FcConfigParse *parse, FcOp op)
+{
+    FcExpr  *expr = FcPopUnary (parse, op);
     if (expr)
 	FcVStackPushExpr (parse, FcVStackExpr, expr);
 }
@@ -1440,7 +1502,7 @@
 	    return;
 	}
     }
-    expr = FcPopExprs (parse, FcOpComma);
+    expr = FcPopBinary (parse, FcOpComma);
     if (!expr)
     {
 	FcConfigMessage (parse, FcSevereWarning, "missing test expression");
@@ -1510,13 +1572,15 @@
 	    binding = FcValueBindingWeak;
 	else if (!strcmp ((char *) binding_string, "strong"))
 	    binding = FcValueBindingStrong;
+	else if (!strcmp ((char *) binding_string, "same"))
+	    binding = FcValueBindingSame;
 	else
 	{
 	    FcConfigMessage (parse, FcSevereWarning, "invalid edit binding \"%s\"", binding_string);
 	    return;
 	}
     }
-    expr = FcPopExprs (parse, FcOpComma);
+    expr = FcPopBinary (parse, FcOpComma);
     edit = FcEditCreate ((char *) FcStrCopy (name), mode, expr, binding);
     if (!edit)
     {
@@ -1595,8 +1659,35 @@
 	    FcConfigMessage (parse, FcSevereError, "out of memory");
 	    break;
 	}
-	if (!FcConfigAddDir (parse->config, data))
-	    FcConfigMessage (parse, FcSevereError, "out of memory");
+#ifdef _WIN32
+	if (strcmp (data, "WINDOWSFONTDIR") == 0)
+	{
+	    int rc;
+	    FcStrFree (data);
+	    data = malloc (1000);
+	    if (!data)
+	    {
+		FcConfigMessage (parse, FcSevereError, "out of memory");
+		break;
+	    }
+	    FcMemAlloc (FC_MEM_STRING, 1000);
+	    rc = GetWindowsDirectory (data, 800);
+	    if (rc == 0 || rc > 800)
+	    {
+		FcConfigMessage (parse, FcSevereError, "GetWindowsDirectory failed");
+		FcStrFree (data);
+		break;
+	    }
+	    if (data [strlen (data) - 1] != '\\')
+		strcat (data, "\\");
+	    strcat (data, "fonts");
+	}
+#endif
+	if (!FcStrUsesHome (data) || FcConfigHome ())
+	{
+	    if (!FcConfigAddDir (parse->config, data))
+		FcConfigMessage (parse, FcSevereError, "out of memory");
+	}
 	FcStrFree (data);
 	break;
     case FcElementCache:
@@ -1606,8 +1697,11 @@
 	    FcConfigMessage (parse, FcSevereError, "out of memory");
 	    break;
 	}
-	if (!FcConfigSetCache (parse->config, data))
-	    FcConfigMessage (parse, FcSevereError, "out of memory");
+	if (!FcStrUsesHome (data) || FcConfigHome ())
+	{
+	    if (!FcConfigSetCache (parse->config, data))
+		FcConfigMessage (parse, FcSevereError, "out of memory");
+	}
 	FcStrFree (data);
 	break;
     case FcElementInclude:
@@ -1675,52 +1769,64 @@
 	FcParseString (parse, FcVStackConstant);
 	break;
     case FcElementOr:
-	FcParseExpr (parse, FcOpOr);
+	FcParseBinary (parse, FcOpOr);
 	break;
     case FcElementAnd:
-	FcParseExpr (parse, FcOpAnd);
+	FcParseBinary (parse, FcOpAnd);
 	break;
     case FcElementEq:
-	FcParseExpr (parse, FcOpEqual);
+	FcParseBinary (parse, FcOpEqual);
 	break;
     case FcElementNotEq:
-	FcParseExpr (parse, FcOpNotEqual);
+	FcParseBinary (parse, FcOpNotEqual);
 	break;
     case FcElementLess:
-	FcParseExpr (parse, FcOpLess);
+	FcParseBinary (parse, FcOpLess);
 	break;
     case FcElementLessEq:
-	FcParseExpr (parse, FcOpLessEqual);
+	FcParseBinary (parse, FcOpLessEqual);
 	break;
     case FcElementMore:
-	FcParseExpr (parse, FcOpMore);
+	FcParseBinary (parse, FcOpMore);
 	break;
     case FcElementMoreEq:
-	FcParseExpr (parse, FcOpMoreEqual);
+	FcParseBinary (parse, FcOpMoreEqual);
 	break;
     case FcElementContains:
-	FcParseExpr (parse, FcOpContains);
+	FcParseBinary (parse, FcOpContains);
 	break;
     case FcElementNotContains:
-	FcParseExpr (parse, FcOpNotContains);
+	FcParseBinary (parse, FcOpNotContains);
 	break;
     case FcElementPlus:
-	FcParseExpr (parse, FcOpPlus);
+	FcParseBinary (parse, FcOpPlus);
 	break;
     case FcElementMinus:
-	FcParseExpr (parse, FcOpMinus);
+	FcParseBinary (parse, FcOpMinus);
 	break;
     case FcElementTimes:
-	FcParseExpr (parse, FcOpTimes);
+	FcParseBinary (parse, FcOpTimes);
 	break;
     case FcElementDivide:
-	FcParseExpr (parse, FcOpDivide);
+	FcParseBinary (parse, FcOpDivide);
 	break;
     case FcElementNot:
-	FcParseExpr (parse, FcOpNot);
+	FcParseUnary (parse, FcOpNot);
 	break;
     case FcElementIf:
-	FcParseExpr (parse, FcOpQuest);
+	FcParseBinary (parse, FcOpQuest);
+	break;
+    case FcElementFloor:
+	FcParseUnary (parse, FcOpFloor);
+	break;
+    case FcElementCeil:
+	FcParseUnary (parse, FcOpCeil);
+	break;
+    case FcElementRound:
+	FcParseUnary (parse, FcOpRound);
+	break;
+    case FcElementTrunc:
+	FcParseUnary (parse, FcOpTrunc);
 	break;
     case FcElementUnknown:
 	break;
