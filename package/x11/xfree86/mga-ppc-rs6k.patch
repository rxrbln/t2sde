# --- ROCK-COPYRIGHT-NOTE-BEGIN ---
# 
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# Please add additional copyright information _after_ the line containing
# the ROCK-COPYRIGHT-NOTE-END tag. Otherwise it might get removed by
# the ./scripts/Create-CopyPatch script. Do not edit this copyright text!
# 
# ROCK Linux: rock-src/package/x11/xfree86/mga-ppc-rs6k.patch
# ROCK Linux is Copyright (C) 1998 - 2004 Clifford Wolf
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# 
# --- ROCK-COPYRIGHT-NOTE-END ---

diff -ur xc/programs/Xserver/hw/xfree86/drivers/mga/mga.h xc-working/programs/Xserver/hw/xfree86/drivers/mga/mga.h
--- xc/programs/Xserver/hw/xfree86/drivers/mga/mga.h	2003-10-10 13:06:02.000000000 +0200
+++ xc-working/programs/Xserver/hw/xfree86/drivers/mga/mga.h	2004-02-15 00:51:40.000000000 +0100
@@ -91,7 +91,7 @@
 } MGAOpts;
 
 
-#if !defined(EXTRADEBUG)
+#if EXTRADEBUG != 1
 #define INREG8(addr) MMIO_IN8(pMga->IOBase, addr)
 #define INREG16(addr) MMIO_IN16(pMga->IOBase, addr)
 #define INREG(addr) MMIO_IN32(pMga->IOBase, addr)
@@ -99,18 +99,18 @@
 #define OUTREG16(addr, val) MMIO_OUT16(pMga->IOBase, addr, val)
 #define OUTREG(addr, val) MMIO_OUT32(pMga->IOBase, addr, val)
 #else /* !EXTRADEBUG */
-CARD8 dbg_inreg8(ScrnInfoPtr,int,int);
-CARD16 dbg_inreg16(ScrnInfoPtr,int,int);
-CARD32 dbg_inreg32(ScrnInfoPtr,int,int);
-void dbg_outreg8(ScrnInfoPtr,int,int);
-void dbg_outreg16(ScrnInfoPtr,int,int);
-void dbg_outreg32(ScrnInfoPtr,int,int);
-#define INREG8(addr) dbg_inreg8(pScrn,addr,1)
-#define INREG16(addr) dbg_inreg16(pScrn,addr,1)
-#define INREG(addr) dbg_inreg32(pScrn,addr,1)
-#define OUTREG8(addr,val) dbg_outreg8(pScrn,addr,val)
-#define OUTREG16(addr,val) dbg_outreg16(pScrn,addr,val)
-#define OUTREG(addr,val) dbg_outreg32(pScrn,addr,val)
+CARD8 dbg_inreg8(ScrnInfoPtr,int,int,char*);
+CARD16 dbg_inreg16(ScrnInfoPtr,int,int,char*);
+CARD32 dbg_inreg32(ScrnInfoPtr,int,int,char*);
+void dbg_outreg8(ScrnInfoPtr,int,int,char*);
+void dbg_outreg16(ScrnInfoPtr,int,int,char*);
+void dbg_outreg32(ScrnInfoPtr,int,int,char*);
+#define INREG8(addr) dbg_inreg8(pScrn,addr,1,__FUNCTION__)
+#define INREG16(addr) dbg_inreg16(pScrn,addr,1,__FUNCTION__)
+#define INREG(addr) dbg_inreg32(pScrn,addr,1,__FUNCTION__)
+#define OUTREG8(addr,val) dbg_outreg8(pScrn,addr,val,__FUNCTION__)
+#define OUTREG16(addr,val) dbg_outreg16(pScrn,addr,val,__FUNCTION__)
+#define OUTREG(addr,val) dbg_outreg32(pScrn,addr,val,__FUNCTION__)
 #endif /* EXTRADEBUG */
 
 /*
diff -ur xc/programs/Xserver/hw/xfree86/drivers/mga/mga_arc.c xc-working/programs/Xserver/hw/xfree86/drivers/mga/mga_arc.c
--- xc/programs/Xserver/hw/xfree86/drivers/mga/mga_arc.c	2003-07-25 13:04:46.000000000 +0200
+++ xc-working/programs/Xserver/hw/xfree86/drivers/mga/mga_arc.c	2004-02-13 01:18:07.000000000 +0100
@@ -70,6 +70,7 @@
 ){
     int yoffset, dyoffset, x, y, a, b, d, mask, k1, k3, dx, dy, tmp;
     XAAInfoRecPtr infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
+    ScrnInfoPtr pScrn = xf86Screens[pGC->pScreen->myNum];
     MGAPtr pMga = MGAPTR(infoRec->pScrn);
     miZeroArcRec info;
     Bool do360;
diff -ur xc/programs/Xserver/hw/xfree86/drivers/mga/mga_dacG.c xc-working/programs/Xserver/hw/xfree86/drivers/mga/mga_dacG.c
--- xc/programs/Xserver/hw/xfree86/drivers/mga/mga_dacG.c	2003-11-21 06:59:14.000000000 +0100
+++ xc-working/programs/Xserver/hw/xfree86/drivers/mga/mga_dacG.c	2004-02-15 01:06:51.000000000 +0100
@@ -24,6 +24,8 @@
 
 #include "mga_bios.h"
 #include "mga_reg.h"
+
+#define EXTRADEBUG 0
 #include "mga.h"
 #include "mga_macros.h"
 
@@ -548,6 +550,14 @@
             MGACRTC2GetPitch(pScrn, &ModeInfo); 
             MGACRTC2GetDisplayStart(pScrn, &ModeInfo,0,0,0);
         }
+
+	/* Disable byte-swapping for big-endian architectures - the XFree
+	   driver seems to like a little-endian framebuffer -ReneR */
+#if X_BYTE_ORDER == X_BIG_ENDIAN
+	/* pReg->Option |= 0x80000000; */
+	pReg->Option &= ~0x80000000;
+#endif
+
 	return(TRUE);
 }
 
@@ -670,6 +680,14 @@
 	}
 
         if(!pMga->SecondCrtc) {
+           /* Do not set the memory config for primary cards as it
+              should be correct already. Only on little endian architectures
+              since we need to modify the byteswap bit. -ReneR */
+#if X_BYTE_ORDER == X_BIG_ENDIAN
+           optionMask = OPTION1_MASK;
+#else
+           optionMask = (pMga->Primary) ? OPTION1_MASK_PRIMARY : OPTION1_MASK;
+#endif
 
 MGA_NOT_HAL(
 	   /*
@@ -695,10 +713,6 @@
 	      outMGAdac(i, mgaReg->DacRegs[i]);
 	   }
 	   
-	   /* Do not set the memory config for primary cards as it
-	      should be correct already */
-	   optionMask = (pMga->Primary) ? OPTION1_MASK_PRIMARY : OPTION1_MASK; 
-	   
 	   if (!MGAISGx50(pMga)) {
 	      /* restore pci_option register */
 	      pciSetBitsLong(pMga->PciTag, PCI_OPTION_REG, optionMask,
@@ -939,6 +953,7 @@
     MGAPtr pMga = MGAPTR(pScrn);
     x += 64;
     y += 64;
+
 #ifdef USEMGAHAL
     MGA_HAL(
 	    x += pMga->HALGranularityOffX;
@@ -1033,7 +1048,8 @@
 static void
 MGAG_I2CGetBits(I2CBusPtr b, int *clock, int *data) 
 {
-  MGAPtr pMga = MGAPTR(xf86Screens[b->scrnIndex]);
+  ScrnInfoPtr pScrn = xf86Screens[b->scrnIndex];
+  MGAPtr pMga = MGAPTR(pScrn);
   unsigned char val;
   
    /* Get the result. */
@@ -1054,7 +1070,8 @@
 static void
 MGAG_I2CPutBits(I2CBusPtr b, int clock, int data)
 {
-  MGAPtr pMga = MGAPTR(xf86Screens[b->scrnIndex]);
+  ScrnInfoPtr pScrn = xf86Screens[b->scrnIndex]; 
+  MGAPtr pMga = MGAPTR(pScrn);
   unsigned char drv, val;
 
   val = (clock ? DDC_SCL_MASK : 0) | (data ? DDC_SDA_MASK : 0);
diff -ur xc/programs/Xserver/hw/xfree86/drivers/mga/mga_driver.c xc-working/programs/Xserver/hw/xfree86/drivers/mga/mga_driver.c
--- xc/programs/Xserver/hw/xfree86/drivers/mga/mga_driver.c	2003-11-21 06:59:15.000000000 +0100
+++ xc-working/programs/Xserver/hw/xfree86/drivers/mga/mga_driver.c	2004-02-15 01:08:02.000000000 +0100
@@ -926,7 +926,7 @@
 		return 16384;
 	    }
 	}
-	ProbeSize = 16384;
+        ProbeSize = 8192;
 	break;
     case PCI_CHIP_MGAG100:
     case PCI_CHIP_MGAG100_PCI:
@@ -954,11 +954,14 @@
 	tmp = INREG8(MGAREG_CRTCEXT_DATA);
 	OUTREG8(MGAREG_CRTCEXT_DATA, tmp | 0x80);
 
-	/* write, read and compare method */
+	/* write, read and compare method
+	   split into two loops to make it more reliable on RS/6k -ReneR */
 	for(i = ProbeSize; i > 2048; i -= 2048) {
 	    base[(i * 1024) - 1] = 0xAA;
-	    OUTREG8(MGAREG_CRTC_INDEX, 0);  /* flush the cache */
-	    usleep(1);  /* twart write combination */
+	}
+	OUTREG8(MGAREG_CRTC_INDEX, 0);  /* flush the cache */
+	usleep(4);  /* twart write combination */
+	for(i = ProbeSize; i > 2048; i -= 2048) {
 	    if(base[(i * 1024) - 1] == 0xAA) {
 		SizeFound = i;
 		break;
@@ -1266,8 +1269,8 @@
        is handled locally and not visible outside. If the VGA fb is
        handeled by the same function the third argument has to be set,
        too.*/
-    xf86SetAccessFuncs(pMga->pEnt, &pMga->Access, &pMga->Access,
-			&pMga->Access, NULL);
+    /* XXX: does not compile with recent XFree API changes -ReneR */
+    xf86SetAccessFuncs(pMga->pEnt, &pMga->Access, &pMga->Access);
 #endif
 
     /* Set pScrn->monitor */
@@ -1779,7 +1782,8 @@
 	}
     }
 #else
-    pMga->IOAddress = pMga->PciInfo->memBase[0];
+    /* changed to memBase[1] - tested on PowerPC RS/6k -ReneR */
+    pMga->IOAddress = pMga->PciInfo->memBase[1];
 #endif
     xf86DrvMsg(pScrn->scrnIndex, from, "MMIO registers at 0x%lX\n",
 	       (unsigned long)pMga->IOAddress);
@@ -2506,7 +2510,6 @@
 
     pMga->FbStart = pMga->FbBase + pMga->YDstOrg * (pScrn->bitsPerPixel / 8);
 
-
     /* Map the ILOAD transfer window if there is one.  We only make
 	DWORD access on DWORD boundaries to this window */
     if (pMga->ILOADAddress) {
@@ -4065,90 +4068,82 @@
  */
 
 CARD8
-dbg_inreg8(ScrnInfoPtr pScrn,int addr,int verbose)
+dbg_inreg8(ScrnInfoPtr pScrn,int addr,int verbose, char* func)
 {
-    MGAPtr pMga;
     CARD8 ret;
 
-    pMga = MGAPTR(pScrn);
-    ret = *(volatile CARD8 *)(pMga->IOBase + (addr));
+    ret = MMIO_IN8(MGAPTR(pScrn)->IOBase,addr);
     if(verbose)
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-			"inreg8 : 0x%8x = 0x%x\n",addr,ret);
+			"inreg8 : %s: 0x%8x = 0x%x\n",func, addr,ret);
     return ret;
 }
 
 CARD16
-dbg_inreg16(ScrnInfoPtr pScrn,int addr,int verbose)
+dbg_inreg16(ScrnInfoPtr pScrn,int addr,int verbose, char* func)
 {
-    MGAPtr pMga;
     CARD16 ret;
 
-    pMga = MGAPTR(pScrn);
-    ret = *(volatile CARD16 *)(pMga->IOBase + (addr));
+    ret = MMIO_IN16(MGAPTR(pScrn)->IOBase,addr);
     if(verbose)
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-			"inreg16: 0x%8x = 0x%x\n",addr,ret);
+			"inreg16: %s: 0x%8x = 0x%x\n",func, addr,ret);
     return ret;
 }
 
 CARD32
-dbg_inreg32(ScrnInfoPtr pScrn,int addr,int verbose)
+dbg_inreg32(ScrnInfoPtr pScrn,int addr,int verbose, char* func)
 {
-    MGAPtr pMga;
     CARD32 ret;
 
-    pMga = MGAPTR(pScrn);
-    ret = *(volatile CARD32 *)(pMga->IOBase + (addr));
+    ret = MMIO_IN32(MGAPTR(pScrn)->IOBase,addr);
     if(verbose)
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-			"inreg32: 0x%8x = 0x%x\n",addr,ret);
+			"inreg32: %s: 0x%8x = 0x%x\n",func, addr,ret);
     return ret;
 }
 
 void
-dbg_outreg8(ScrnInfoPtr pScrn,int addr,int val)
+dbg_outreg8(ScrnInfoPtr pScrn,int addr,int val, char* func)
 {
-    MGAPtr pMga;
     CARD8 ret;
 
-    pMga = MGAPTR(pScrn);
 #if 0
     if( addr = MGAREG_CRTCEXT_DATA )
     	return;
 #endif
     if( addr != 0x3c00 ) {
-	ret = dbg_inreg8(pScrn,addr,0);
+	ret = dbg_inreg8(pScrn,addr,0,func);
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-			"outreg8 : 0x%8x = 0x%x was 0x%x\n",addr,val,ret);
+			"outreg8 : %s: 0x%8x = 0x%x was 0x%x\n",
+			func,addr,val,ret);
     }
     else {
-	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "outreg8 : index 0x%x\n",val);
+	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "outreg8 : %s: index 0x%x\n",
+	func,val);
     }
-    *(volatile CARD8 *)(pMga->IOBase + (addr)) = (val);
+    MMIO_OUT8(MGAPTR(pScrn)->IOBase,addr,val);
 }
 
 void
-dbg_outreg16(ScrnInfoPtr pScrn,int addr,int val)
+dbg_outreg16(ScrnInfoPtr pScrn,int addr,int val, char* func)
 {
-    MGAPtr pMga;
     CARD16 ret;
 
 #if 0
     if (addr == MGAREG_CRTCEXT_INDEX)
     	return;
 #endif
-    pMga = MGAPTR(pScrn);
-    ret = dbg_inreg16(pScrn,addr,0);
+    ret = dbg_inreg16(pScrn,addr,0, func);
     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-			"outreg16 : 0x%8x = 0x%x was 0x%x\n",addr,val,ret);
-    *(volatile CARD16 *)(pMga->IOBase + (addr)) = (val);
+			"outreg16: %s: 0x%8x = 0x%x was 0x%x\n",
+			func,addr,val,ret);
+    MMIO_OUT16(MGAPTR(pScrn)->IOBase,addr,val);
 }
 
 void
-dbg_outreg32(ScrnInfoPtr pScrn,int addr,int val)
+dbg_outreg32(ScrnInfoPtr pScrn,int addr,int val, char* func)
 {
-    MGAPtr pMga;
     CARD32 ret;
 
     if (((addr & 0xff00) == 0x1c00)
@@ -4162,17 +4157,21 @@
     	&& (addr != 0x1c98)
     	&& (addr != 0x1c9c)
 	 ) {
-	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "refused address 0x%x\n",addr);
+	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%s: refused address 0x%x\n",
+			func,addr);
     	return;
     }
-    pMga = MGAPTR(pScrn);
-    ret = dbg_inreg32(pScrn,addr,0);
+    ret = dbg_inreg32(pScrn,addr,0, func);
     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-			"outreg32 : 0x%8x = 0x%x was 0x%x\n",addr,val,ret);
-    *(volatile CARD32 *)(pMga->IOBase + (addr)) = (val);
+			"outreg32: %s: 0x%8x = 0x%x was 0x%x\n",
+			func,addr,val,ret);
+    MMIO_OUT32(MGAPTR(pScrn)->IOBase,addr,val);
 }
 #endif /* DEBUG */
 
+/* Hack for the debug macro shortcomming -ReneR */
+#define OUTREG(addr, val) MMIO_OUT32(pMga->IOBase, addr, val)
+
 static void
 MGAG100BlackMagic(MGAPtr pMga)
 {
diff -ur xc/programs/Xserver/hw/xfree86/drivers/mga/mga_storm.c xc-working/programs/Xserver/hw/xfree86/drivers/mga/mga_storm.c
--- xc/programs/Xserver/hw/xfree86/drivers/mga/mga_storm.c	2003-01-16 17:09:10.000000000 +0100
+++ xc-working/programs/Xserver/hw/xfree86/drivers/mga/mga_storm.c	2004-02-13 01:16:52.000000000 +0100
@@ -2359,6 +2359,7 @@
     BoxPtr pbox;
     MGAPtr pMga;
     int xorg, yorg;
+    ScrnInfoPtr pScrn;
 
     if(!numRects) return;
 
@@ -2369,6 +2370,7 @@
 
     infoRec = GET_XAAINFORECPTR_FROM_GC(pGC);
     pMga = MGAPTR(infoRec->pScrn);
+    pScrn = xf86Screens[pGC->pScreen->myNum];
     xorg = pDraw->x;
     yorg = pDraw->y;
 
diff -ur xc/programs/Xserver/hw/xfree86/drivers/mga/mga_video.c xc-working/programs/Xserver/hw/xfree86/drivers/mga/mga_video.c
--- xc/programs/Xserver/hw/xfree86/drivers/mga/mga_video.c	2003-11-21 06:59:15.000000000 +0100
+++ xc-working/programs/Xserver/hw/xfree86/drivers/mga/mga_video.c	2004-02-15 01:07:28.000000000 +0100
@@ -458,8 +458,10 @@
   int h,
   int w
 ){
+
     w <<= 1;
     while(h--) {
+	/* XXX Maybe this one needs big-endian fixes, too? -ReneR */
 	memcpy(dst, src, w);
 	src += srcPitch;
 	dst += dstPitch;
@@ -489,16 +491,27 @@
         s1 = src1;  s2 = src2;  s3 = src3;
         i = w;
         while(i > 4) {
+#if X_BYTE_ORDER == X_LITTLE_ENDIAN
            dst[0] = s1[0] | (s1[1] << 16) | (s3[0] << 8) | (s2[0] << 24);
            dst[1] = s1[2] | (s1[3] << 16) | (s3[1] << 8) | (s2[1] << 24);
            dst[2] = s1[4] | (s1[5] << 16) | (s3[2] << 8) | (s2[2] << 24);
            dst[3] = s1[6] | (s1[7] << 16) | (s3[3] << 8) | (s2[3] << 24);
+#else
+           dst[0] = (s1[0] << 16) | s1[1] | (s3[0] << 24) | (s2[0] << 8);
+           dst[1] = (s1[2] << 16) | s1[3] | (s3[1] << 24) | (s2[1] << 8);
+           dst[2] = (s1[4] << 16) | s1[5] | (s3[2] << 24) | (s2[2] << 8);
+           dst[3] = (s1[6] << 16) | s1[7] | (s3[3] << 24) | (s2[3] << 8);
+#endif
            dst += 4; s2 += 4; s3 += 4; s1 += 8;
            i -= 4;
         }
 
         while(i--) {
+#if X_BYTE_ORDER == X_LITTLE_ENDIAN
            dst[0] = s1[0] | (s1[1] << 16) | (s3[0] << 8) | (s2[0] << 24);
+#else
+	   dst[0] = (s1[0] << 16) | s1[1] | (s3[0] << 24) | (s2[0] << 8);
+#endif
            dst++; s2++; s3++;
            s1 += 2;
         }
@@ -1006,6 +1019,7 @@
     XF86SurfacePtr surface
 ){
     OffscreenPrivPtr pPriv = (OffscreenPrivPtr)surface->devPrivate.ptr;
+    ScrnInfoPtr pScrn = surface->pScrn;
 
     if(pPriv->isOn) {
 	MGAPtr pMga = MGAPTR(surface->pScrn);
