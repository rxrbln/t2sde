# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: package/.../gzip/gzip.rsync.patch
# Copyright (C) 2006 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- T2-COPYRIGHT-NOTE-END ---

In the past from:
  http://ozlabs.org/~rusty/gzip.rsync.patch
but rediffed for 1.3.5 by:
  - Rene Rebe <rene@exactcode.de>

diff -r db58977bb81e -r 6759e961b519 deflate.c
--- a/deflate.c	Sun Dec 03 11:40:05 2006 +0100
+++ b/deflate.c	Sun Dec 03 11:48:30 2006 +0100
@@ -135,6 +135,14 @@ static char rcsid[] = "$Id: deflate.c,v 
 #endif
 /* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
 
+#ifndef RSYNC_WIN
+#  define RSYNC_WIN 8192
+#endif
+/* Size of rsync window, must be < MAX_DIST */
+
+#define RSYNC_SUM_MATCH(sum) (((sum) & (RSYNC_WIN - 1)) == 0)
+/* Whether window sum matches magic value */
+
 /* ===========================================================================
  * Local data used by the "longest match" routines.
  */
@@ -216,6 +224,8 @@ unsigned near good_match;
 unsigned near good_match;
 /* Use a faster search when the previous match is longer than this */
 
+local ulg rsync_sum;  /* rolling sum of rsync window */
+local ulg rsync_chunk_end; /* next rsync sequence point */
 
 /* Values for max_lazy_match, good_match and max_chain_length, depending on
  * the desired pack level (0..9). The values given below have been tuned to
@@ -314,6 +324,10 @@ void lm_init (pack_level, flags)
 #endif
     /* prev will be initialized on the fly */
 
+    /* rsync params */
+    rsync_chunk_end = 0xFFFFFFFFUL;
+    rsync_sum = 0;
+
     /* Set the default configuration parameters:
      */
     max_lazy_match   = configuration_table[pack_level].max_lazy;
@@ -331,6 +345,7 @@ void lm_init (pack_level, flags)
 
     strstart = 0;
     block_start = 0L;
+    rsync_chunk_end = 0xFFFFFFFFUL;
 #ifdef ASMV
     match_init(); /* initialize the asm code */
 #endif
@@ -550,6 +565,8 @@ local void fill_window()
         memcpy((char*)window, (char*)window+WSIZE, (unsigned)WSIZE);
         match_start -= WSIZE;
         strstart    -= WSIZE; /* we now have strstart >= MAX_DIST: */
+	if (rsync_chunk_end != 0xFFFFFFFFUL)
+	    rsync_chunk_end -= WSIZE;
 
         block_start -= (long) WSIZE;
 
@@ -576,6 +593,39 @@ local void fill_window()
         }
     }
 }
+
+local void rsync_roll(start, num)
+    unsigned start;
+    unsigned num;
+{
+    unsigned i;
+
+    if (start < RSYNC_WIN) {
+	/* before window fills. */
+	for (i = start; i < RSYNC_WIN; i++) {
+	    if (i == start + num) return;
+	    rsync_sum += (ulg)window[i];
+	}
+	num -= (RSYNC_WIN - start);
+	start = RSYNC_WIN;
+    }
+
+    /* buffer after window full */
+    for (i = start; i < start+num; i++) {
+	/* New character in */
+	rsync_sum += (ulg)window[i];
+	/* Old character out */
+	rsync_sum -= (ulg)window[i - RSYNC_WIN];
+	if (rsync_chunk_end == 0xFFFFFFFFUL && RSYNC_SUM_MATCH(rsync_sum))
+	    rsync_chunk_end = i;
+    }
+}
+
+/* ===========================================================================
+ * Set rsync_chunk_end if window sum matches magic value.
+ */
+#define RSYNC_ROLL(s, n) \
+   do { if (rsync) rsync_roll((s), (n)); } while(0)
 
 /* ===========================================================================
  * Flush the current block, with given end-of-file flag.
@@ -623,6 +673,7 @@ local off_t deflate_fast()
 
             lookahead -= match_length;
 
+	    RSYNC_ROLL(strstart, match_length);
 	    /* Insert new strings in the hash table only if the match length
              * is not too large. This saves time but degrades compression.
              */
@@ -651,8 +702,17 @@ local off_t deflate_fast()
             /* No match, output a literal byte */
             Tracevv((stderr,"%c",window[strstart]));
             flush = ct_tally (0, window[strstart]);
+            RSYNC_ROLL(strstart, 1);
             lookahead--;
 	    strstart++;
+        }
+        if (rsync && strstart > rsync_chunk_end) {
+           ush  attr = 0;          /* ascii/binary flag */
+
+           flush = 1;
+           /* Reset huffman tree */
+           ct_init(&attr, &method);
+           rsync_chunk_end = 0xFFFFFFFFUL;
         }
         if (flush) FLUSH_BLOCK(0), block_start = strstart;
 
@@ -726,6 +786,7 @@ off_t deflate()
              */
             lookahead -= prev_length-1;
             prev_length -= 2;
+	    RSYNC_ROLL(strstart, prev_length+1);
             do {
                 strstart++;
                 INSERT_STRING(strstart, hash_head);
@@ -738,24 +799,51 @@ off_t deflate()
             match_available = 0;
             match_length = MIN_MATCH-1;
             strstart++;
+
+	    if (rsync && strstart > rsync_chunk_end) {
+		ush  attr = 0;          /* ascii/binary flag */
+
+		/* Reset huffman tree */
+		ct_init(&attr, &method);
+		rsync_chunk_end = 0xFFFFFFFFUL;
+		flush = 1;
+	    }
             if (flush) FLUSH_BLOCK(0), block_start = strstart;
-
         } else if (match_available) {
             /* If there was no match at the previous position, output a
              * single literal. If there was a match but the current match
              * is longer, truncate the previous match to a single literal.
              */
             Tracevv((stderr,"%c",window[strstart-1]));
-            if (ct_tally (0, window[strstart-1])) {
-                FLUSH_BLOCK(0), block_start = strstart;
-            }
+	    flush = ct_tally (0, window[strstart-1]);
+	    if (rsync && strstart > rsync_chunk_end) {
+		ush  attr = 0;          /* ascii/binary flag */
+
+		/* Reset huffman tree */
+		ct_init(&attr, &method);
+		rsync_chunk_end = 0xFFFFFFFFUL;
+
+		flush = 1;
+	    }
+            if (flush) FLUSH_BLOCK(0), block_start = strstart;
+	    RSYNC_ROLL(strstart, 1);
             strstart++;
             lookahead--;
         } else {
             /* There is no previous match to compare with, wait for
              * the next step to decide.
              */
+	    if (rsync && strstart > rsync_chunk_end) {
+		ush  attr = 0;          /* ascii/binary flag */
+
+		/* Reset huffman tree */
+		ct_init(&attr, &method);
+		rsync_chunk_end = 0xFFFFFFFFUL;
+
+		FLUSH_BLOCK(0), block_start = strstart;
+	    }
             match_available = 1;
+	    RSYNC_ROLL(strstart, 1);
             strstart++;
             lookahead--;
         }
diff -r db58977bb81e -r 6759e961b519 doc/gzip.texi
--- a/doc/gzip.texi	Sun Dec 03 11:40:05 2006 +0100
+++ b/doc/gzip.texi	Sun Dec 03 11:48:30 2006 +0100
@@ -328,6 +328,14 @@ into the directory and compress all the 
 into the directory and compress all the files it finds there (or
 decompress them in the case of @code{gunzip}).
 
+@item --rsyncable
+While compressing, synchronize the output occasionally based on the
+input.  This can reduce the compression slightly in some cases, but
+means that the @code{rsync} program can take advantage of similarities
+in the uncompressed input when syncronizing two files compressed with
+this flag.  @code{gunzip} cannot tell the difference between a
+compressed file created with this option, and one created without it.
+
 @item --suffix @var{suf}
 @itemx -S @var{suf}
 Use suffix @samp{@var{suf}} instead of @samp{.gz}. Any suffix can be
diff -r db58977bb81e -r 6759e961b519 gzip.c
--- a/gzip.c	Sun Dec 03 11:40:05 2006 +0100
+++ b/gzip.c	Sun Dec 03 11:48:30 2006 +0100
@@ -167,7 +167,7 @@ DECLARE(uch, inbuf,  INBUFSIZ +INBUF_EXT
 DECLARE(uch, inbuf,  INBUFSIZ +INBUF_EXTRA);
 DECLARE(uch, outbuf, OUTBUFSIZ+OUTBUF_EXTRA);
 DECLARE(ush, d_buf,  DIST_BUFSIZE);
-DECLARE(uch, window, 2L*WSIZE);
+DECLARE(uch, window, 2L*WSIZE + 4096);
 #ifndef MAXSEG_64K
     DECLARE(ush, tab_prefix, 1L<<BITS);
 #else
@@ -218,6 +218,7 @@ unsigned insize;           /* valid byte
 unsigned insize;           /* valid bytes in inbuf */
 unsigned inptr;            /* index of next byte to be processed in inbuf */
 unsigned outcnt;           /* bytes in output buffer */
+int rsync = 0;             /* make ryncable chunks */
 
 struct option longopts[] =
 {
@@ -247,6 +248,7 @@ struct option longopts[] =
     {"best",       0, 0, '9'}, /* compress better */
     {"lzw",        0, 0, 'Z'}, /* make output compatible with old compress */
     {"bits",       1, 0, 'b'}, /* max number of bits per code (implies -Z) */
+    {"rsyncable",  0, 0, 'R'}, /* make rsync-friendly archive */
     { 0, 0, 0, 0 }
 };
 
@@ -329,6 +331,7 @@ local void help()
  "  -Z, --lzw         produce output compatible with old compress",
  "  -b, --bits=BITS   max number of bits per code (implies -Z)",
 #endif
+ "      --rsyncable   Make rsync-friendly archive",
  "",
  "With no FILE, or when FILE is -, read standard input.",
  "",
@@ -469,6 +472,8 @@ int main (argc, argv)
 	    recursive = 1;
 #endif
 	    break;
+	case 'R':
+	    rsync = 1; break;
 	case 'S':
 #ifdef NO_MULTIPLE_DOTS
             if (*optarg == '.') optarg++;
diff -r db58977bb81e -r 6759e961b519 gzip.h
--- a/gzip.h	Sun Dec 03 11:40:05 2006 +0100
+++ b/gzip.h	Sun Dec 03 11:48:30 2006 +0100
@@ -155,6 +155,7 @@ extern unsigned insize; /* valid bytes i
 extern unsigned insize; /* valid bytes in inbuf */
 extern unsigned inptr;  /* index of next byte to be processed in inbuf */
 extern unsigned outcnt; /* bytes in output buffer */
+extern int rsync;  /* deflate into rsyncable chunks */
 
 extern off_t bytes_in;   /* number of input bytes */
 extern off_t bytes_out;  /* number of output bytes */
