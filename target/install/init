#!/bin/sh

# partly based on linuxrc.c, Copyright (C) 2003, 2004 Cliford Wolf and Rene Rebe

echo "T2 early userspace ..."

PATH=/sbin:/bin

echo "Mounting /dev, /proc and /sys ..."
mount -t tmpfs none /dev
mount -t proc  none /proc
mount -t usbfs none /proc/bus/usb
mount -t sysfs none /sys
ln -s /proc/self/fd /dev/fd

# later on we might reverse these, that is run udevstart first,
# and let udev add new ones as hotplug agents ...

echo "Running hotplug++ hardware detection ..."
/sbin/hotplug++ -synth
echo "/sbin/hotplug++" > /proc/sys/kernel/hotplug

echo "Loading additional subsystem and filesystem driver ..."
# hack to be removed
modprobe sbp2

# well some hardcoded help for now ...
modprobe ide-generic
modprobe ide-disk
modprobe ide-cd
modprobe sd_mod
modprobe sr_mod
modprobe sg

# the modular filesystems ...
for x in /lib/modules/*/kernel/fs/{*/,}*.*o ; do
	x=${x##*/} ; x=${x%.*o}
	modprobe $x
done

echo "Populating /dev (udev) ..."
/sbin/udevstart

# Only print important stuff to console
# klogctl(8, NULL, 3);

echo "Searching for CD with Live file-system ..."
mkdir -p /media/cdrom /mnt/live
i=0
while [ $i -le 9 ]; do
  for x in /dev/cdrom* ; do
    [ -e $x ] || continue
    if mount -t iso9660 -o ro $x /media/cdrom; then
	if [ -f /media/cdrom/live.squash ]; then
	  echo "Found the Live file-system ($x) ..."

	  losetup /dev/loop0 /media/cdrom/live.squash
	  mount -t squashfs -o ro /dev/loop0 /mnt/live

	  # create symlinks to the live content
	  mv /bin /bin-static
	  for x in /mnt/live/* ; do
		x=${x#/mnt/live/}
		case $x in
		  dev|proc|sys|media|mnt|tmp) continue ;;
		esac
		if [ -e /$x ]; then
#			echo "Removing /$x ..."
			/bin-static/rm -rf /$x
		fi
#		echo "Linking /mnt/live/$x /$x"
		/bin-static/ln -s /mnt/live/$x /$x
	  done

#	  /bin-static/ls -l /
#	  echo "Removing /bin-static"
	  /bin-static/rm -rf /bin-static

	  exec /init2 $*
	else
	  echo "No Live file-system found - unmounting."
	  umount /cdrom
	fi
    fi
  done
  : $(( i++ ))
  sleep 1
done

echo "No Live CD found, giving up. Debug shell:"
exec /bin/sh

void doboot()
{
	mkdir /mnt_root/old_root || exit_linuxrc=0

	if [ ! -e /mnt_root/linuxrc ]; then
	 	echo "Can't find /mnt_root/linuxrc."
		exit_linuxrc=0
	fi

	if [ $exit_linuxrc = 1 ]; then
		pivot_root /mnt_root /mnt_root/old_root
		exit_linuxrc=0
		chdir("/");

		mount /old_root/dev /dev -o move
		mount /old_root/proc /proc -o move
	else
		rmdir /mnt_root/old_root

		umount /mnt_root
		rmdir /mnt_root
	fi
}

int trymount ()
{
	for fs in iso9660 ext3 ext2 minix vfat; do
		mount $1 $2 -t $fs -o ro && return
	done
}

void httpload() 
{
	baseurl=
	filename=
	url=

	echo "Enter base URL (e.g. http://1.2.3.4/rock): "

	read baseurl
	[ "$baseurl" ] || return

	echo "Select a stage 2 image file:
	            1. BIG_IMAGE   2. SMALL_IMAGE\n\n
	       Enter number or image file name (default=1): "

	read filename
	case $filename in
	  ""|1) filename=BIG_IMAGE ;;
	  2) filename=SMALL_IMAGE
	esax

	exit_init=1
	url=$baseurl/$filename

	echo -e "[ $url ]\n"
	export ROCK_INSTALL_SOURCE_URL=baseurl

	exit_linuxrc=1;
	mkdir /mnt_root || exit_linuxrc=0

	mount none /mnt_root -t tmpfs || exit_linuxrc=0

	curl $url | tar $STAGE_2_COMPRESS_ARG -C /mnt_root -x 
	
	echo "finished ... continuing execution of 2nd stage"
	doboot
}

/* this starts the module loading shell */
void load_modules(char* directory){
	struct dirent **namelist;
	int cnt = 0, n, len, needmodhdr = 1, needdirhdr = 1;
	int loader_res=0;
	char filename[256], input[256];
	char *execargs[100];

	printf("Module loading shell\n\n");
	printf("You can navigate through the filestem with 'cd'. For loading a module\n");
	printf("simply enter it's name, to exit press enter on a blank line.\n\n");

	while(1) {
		if (chdir(directory)) {
			perror("chdir");
		}

		n = scandir(".", &namelist, module_filter, dirs_first_sort);
		if (n < 0) {
			perror("scandir");
		}
		getcwd(directory, 255);

		while(n--) {
			strcpy(filename, namelist[n]->d_name);
			len = strlen(filename);
	
			if (is_dir(namelist[n])) {
				/* first visit to this function, show header */
				if (needdirhdr == 1) {
					printf("directories:\n	");
					needdirhdr = 0; cnt = 1;
				}
				printf("[%-15s]",filename);
				if (cnt % 4 == 0) printf("\n	");
				cnt++;
			} else { 
				/* finished directories, show module header */
				if (needmodhdr == 1) {
					if (needdirhdr == 0) printf("\n");
					printf("kernel modules:\n	");
					needmodhdr = 0; cnt = 1;
				}
				filename[len-mod_suffix_len] = 0;
				printf("%-15s",filename);
				if (cnt % 4 == 0) printf("\n	");
				cnt++;
			}
	
			free(namelist[n]);
		}
		free(namelist);
		needmodhdr = 1; needdirhdr = 1;
	
		printf("\n[%s]> ", directory);
		fflush(stdout);
	
		input[0]=0; fgets(input, 256, stdin); input[255]=0;
		if (strlen(input) > 0) input[strlen(input)-1]=0;
		if (input[0] == 0) return;
	
		if (!strncmp(input, "cd ", 3)) {
			/* absolute or relative pathname? */
			if (input[3] == '/') {
				strcpy(filename, input+3);
			} else {
				strcpy(filename, directory);
				strcat(filename, "/");
				strcat(filename, input+3);
			}
			free(directory);
			directory = (char*)malloc(strlen(filename)+1);
			strcpy(directory, filename);
		} else {
			snprintf(filename, 256, "%s%s", strtok(input, " "), mod_suffix);
			execargs[0] = mod_loader; execargs[1] = filename;
			for (n=2; (execargs[n] = strtok(NULL, " ")) != NULL; n++) ;

			if ( ! access(filename, R_OK) ) {
				if ( fork() == 0 ) {
					execvp(execargs[0], execargs);
					printf("Can't start %s!\n", execargs[0]);
					exit(1);
				}
				wait(&loader_res);
				if (WEXITSTATUS(loader_res) != 0)
					printf("error: module loader finished unsuccesfully!\n");
				else 
					printf("module loader finished succesfully.\n");
			} else {
				printf("%s: no such module found! try again... (enter=exit)\n", filename);
			}
		}

		fflush(stdout);
	}
	return;
}

int getdevice
{
	device=
	devicelist=`ls /dev/cdrom* /dev/floppy* 2>/dev/null`
	if [ -z "$devicelist" ]; then
		echo "No device found."
		return
	fi

	i=0
	for dev in $devicelist ; do
		case $dev in
		  floppy*)
			echo "     $i. $dev	Floppy Disk Drive" ;;
		  *)
			echo "     $i. $dev	ATAPI or SCSI CD-ROM" ;;
		esac
		: $(( i++ ))
	done

	echo -e "\nEnter number or device file name (default=0): "

	read in ; [ "$in" ] || in=0
	while [ -z "$device" ]; do
		[ -z "$in" ] && return
		if [ -e $in ]; then
			device=$in
		else
			i=0
			for x in $devicelist; do
				[ $in = $i ] && device=$x
				: $(( i++ ))
			done
		fi

		[ "$device" ] || echo "No such device found. Try again (enter=back): "
		read in
	done

	eval $1=$device
}

void load_ramdisk_file()
{
	devicefile=
	filename=

	echo -e "Select a device for loading the 2nd stage system from:\n"

	getdevice devicefile
	if [ "$devicefile" ]; then
		echo "No device detected.");
		return
	fi

	echo "Select a stage 2 image file:
	            1. BIG_IMAGE     2. SMALL_IMAGE
	       Enter number or image file name (default=1): "

	read in
	case $in in
	  ""|1) filename=BIG_IMAGE
	  2) filename=SMALL_IMAGE
	esac

	exit_linuxrc=1
	echo "Using $devicefile:$filename"

	mkdir /mnt_source || exit_linuxrc=0
	trymount devicefile /mnt_source || exit_linuxrc=0

	mkdir /mnt_root || exit_linuxrc=0
	mount none /mnt_root -t tmpfs || exit_linuxrc=0

	echo "Extracting 2nd stage filesystem to ram ..."
	tar $STAGE_2_COMPRESS_ARG -C /mnt_root -x  $filename ||
	echo "Can't run tar on $fielname."
	
	umount /mnt_source || exit_linuxrc=0
	rmdir /mnt_source || exit_linuxrc=0

	export ROCK_INSTALL_SOURCE_DEV=$devicefile
	export ROCK_INSTALL_SOURCE_FILE=$filename
	doboot
}	

activate_swap()
{
	echo -ne "\nEnter file name of swap device: "

	read in
	[ "$in" ] && swapon $in
}

void config_net()
{
	ip addr ; echo
	ip route ; echo

	echo "Enter interface name (eth0): "
	read dev ; [ "$dev" ] || dev="eth0"

	echo "Enter ip (192.168.0.254/24): "
	read ip ; [ "$ip" ] || ip="192.168.0.254/24"

	ip addr add $ip dev $dev
	ip link set $dev up

	echo "Enter default gateway (none): "
	read gw
	[ "$gw" ] && ip route add default via $gw
	echo

	ip addr ; echo
	ip route
}

exec_sh()
{
	echo "Exit the shell to return to the stage 1 loader."

#	if type -p kiss > /dev/null; then
#		kiss -E
#	else
		$0
#	fi
}

load_modules_disk () {
	mkdir /mnt_floppy

	trymount /dev/floppy/0 /mnt_floppy
	load_modules /mnt_floppy

	umount /mnt_floppy
	rmdir  /mnt_floppy
}

echo "
     =================================
     ===   1st stage boot system   ===
     =================================

The T2 install system boots up in two stages. You are now in the first stage
and if everything goes right, you will not spend much time here. Just load
your SATA, SCSI or networking drivers and configure the installation source
so the 2nd stage boot system can be loaded and you can start the installation.
"
exit_init=0
while [ $exit_init = 0 ]; do
	echo "
     0. Load 2nd stage system from local device
     1. Load 2nd stage system from network
     2. Configure network interfaces (IPv4 only)
     3. Load kernel modules from this disk
     4. Load kernel modules from another disk
     5. Activate already formatted swap device
     6. Execute a (kiss) shell if present (for experts!)

What do you want to do [0-8] (default=0)?"
	read in
	case $in in
	  0|"")	load_ramdisk_file ;;
	  1)	httpload ;;
	  2)	config_net ;;
	  3)	load_modules ;;
	  4)	load_modules_disk ;;
	  5)	activate_swap ;;
	  6)	exec_sh ;;
	  *)    echo "No such option." ;;
	esac
done
sleep 1
execl("/linuxrc", "/linuxrc", NULL);
printf("\nCan't start /linuxrc!! Life sucks.\n\n");

int load_one_module (const char *file, const struct stat *sb, int flag)
{
	if ( flag == FTW_F ) {
		printf("loading: %s\n", file);
		tryexeclp(mod_loader, mod_loader, file, NULL);
	}
	return 0;
}


	/* since only the unrecognized command line arguements are passed
	   to linuxrc/init, we need to re-generate a nice list out of /proc */
	{
	  cmdline[0] = 0;
	  int i = open ("/proc/cmdline", O_RDONLY);
	  if (i) {
		int ret = read (i, cmdline, 1024-2);
		if (ret > 0)
		  cmdline[ret+1] = 0;
	  } else
		perror("Can't open /proc/cmdline");
	  close (i);

	  /* seperate the options with 0, 00 terminated */
	  for (i = 0; i < 1023; ++i) {
		if (cmdline[i] == ' ')
			cmdline[i] = 0;
		else if (cmdline[i] == 0)
			break;
	  }
	  cmdline[i+1] = 0;
	}

	/* Extract the root= kernel argument. Run the stage1 shell when a
	   ramdisk or no argument is specified */
	root = cmdline;
	while (1) {
		printf("checking: %s\n", root);
		if ( *root == 0 ) {
			root = 0;
			break;
		}
		if ( !strncmp("root=", root, 5) ) {
			root += 5;
			break;
		}
		root += strlen (root) + 1;
	}

	/* if we later need to use /dev/ram for real systems, we need to
	   introduce some other magic commnd line arg to flag the stage2 */
	printf("root: %s\n", root);
	if ( root && !strncmp("/dev/ram", root, 8) )
		stage1(); /* never returns */

	printf("You should not yet get here - please report!\n");
	stage1(); /* never returns */

	/* later normal in-sytem linuxrc */

	printf("Loading all embedded modules ...\n");
	/* dietlibc implements nopenfd as depth :-( */
	ftw("/lib/modules/", *load_one_module, 16);

	printf("Mounting real-root device and continue to boot the system.\n");

	// TODO and reuse code above to check and mount the root device
	// and offer a nice fallback shell in the case s.th. is wrong

	return 0;
}

