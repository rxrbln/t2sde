#!/usr/bin/perl
# --- T2-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# T2 SDE: target/mnemosyne/mnemosyne.pl
# Copyright (C) 2004 - 2005 The T2 SDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License. A copy of the
# GNU General Public License can be found in the file COPYING.
# --- T2-COPYRIGHT-NOTE-END ---

use warnings;
use strict;

use constant {ALL => 0, ASK => 1, CHOICE => 2 };
%::FOLDER=();
%::MODULE=();

sub scandir {
	my ($pkgseldir,$prefix) = @_;
	my %current=('location', $pkgseldir, 'var', "CFGTEMP_$prefix");

	# $current{desc,var} for sub-pkgsel dirs
	if ($pkgseldir ne $::ROOT) {
		my ($relative,$dirvar,$dirname);
		$_ = $pkgseldir;
		$relative = (m/^$::ROOT\/(.*)/i)[0];

		$dirvar =  "CFGTEMP_$prefix\_$relative";
		$dirvar =~ tr,a-z\/,A-Z_,;

		$dirname=$relative;
		$dirname=~ s/.*\///g;

		$current{desc} = $dirname;
		$current{var}  = $dirvar;
	}

	# make this folder global
	$::FOLDER{$current{var}} = \%current;

	{
	# make scandir recursive
	my @subdirs;
	opendir(my $DIR, $pkgseldir);
	foreach( grep { ! /^\./ } sort readdir($DIR) ) {
		$_ = "$pkgseldir/$_";
		if ( -d $_ ) {
			my $subdir = scandir($_,$prefix);
			push @subdirs,$subdir;
		} else {
			scanmodule($_,$prefix);
		}
	}
        closedir $DIR;
	$current{subdirs} = \@subdirs;
	return $current{var};
	}

}

sub scanmodule {
	my ($file,$prefix)=@_;
	my (%current,$FILE);

	# this defines dir,key,option and kind acording to the following format.
	# $dir/[$prio-]$var[$option].$kind
	do {
		my ($dir,$key,$option,$kind);
		m/^(.*)\/(\d+-)?([^\.]*).?([^\.]*)?\.([^\/\.]*)/i;
		($dir,$key,$option,$kind) = ($1,$3,$4,$5);

		if ($kind eq 'choice') { $current{kind} = CHOICE; $current{option} = $option; }
		elsif ($kind eq 'all') { $current{kind} = ALL; }
		elsif ($kind eq 'ask') { $current{kind} = ASK; }
		else { return; }

		$current{location} = $dir;
		$current{key} = $key;
		$current{file} = $file;
	
	} for $file;

	open($FILE,'<',$file);
	while(<$FILE>) {
		if (/^#[^#: ]+: /) {
			my ($field,$value) = m/^#([^#: ]+): (.*)$/i;
			if ($field eq 'Description') {
				$current{desc} = $value;
			} elsif ($field eq 'Variable') {
				$current{var} = $value;
			} elsif ($field eq 'Default') {
				$current{default} = $value;
			} elsif ($field eq 'Forced') {
				$current{forced} = $value;
			} elsif ($field eq 'Imply') {
				$current{imply} = $value;
			} elsif ($field eq 'Dependencies') {
				$current{deps} = $value;
		#	} else {
		#		print "$file:$field:$value.\n";
				}
			}
		}
	close($FILE);

	# var name
	$current{var} = uc $current{key}
		unless exists $current{var};
	$current{var} = "SDECFG_$prefix\_" . $current{var}
		unless $current{var} =~ /^SDECFG_$prefix\_/;

	# for choices, we use $option instead of $key as description
	($current{desc} = $current{option}) =~ s/_/ /g
		if exists $current{option} && ! exists $current{desc};
	($current{desc} = $current{key}) =~ s/_/ /g
		unless exists $current{desc};

	# dependencies
	# NOTE: don't use spaces on the pkgsel file, only to delimite different dependencies
	if (exists $current{deps}) {
		my @deps;
		for ( split (/\s+/,$current{deps}) ) {
			$_="SDECFG_$prefix\_$_" unless /^SDECFG/;

			if (/=/) {
				m/(.*)(==|!=|=)(.*)/i;
				$_="\"\$$1\" $2 $3";
			} else {
				$_="\"\$$_\" == 1";
				}

			push @deps,$_;
			}
		$current{deps} = \@deps;
		}

	# forced modules
	if (exists $current{forced}) {
		my @forced;
		for ( split (/\s+/,$current{forced}) ) {
			$_="SDECFG_$prefix\_$_" unless /^SDECFG/;

			$_="$_=1" unless /=/;
			push @forced,$_;
			}
		$current{forced} = \@forced;
		}
	
	# implied options
	if (exists $current{imply}) {
		my @imply = split (/\s+/,$current{imply});
		$current{imply} = \@imply;
		}

	# make this module global
	if ( $current{kind} == CHOICE ) {

		# prepare the option for this choice
		my %option;
		for ('desc','forced','imply','deps','option','file') {
			$option{$_}=$current{$_} if exists $current{$_};
			}

		if ( exists $::MODULE{$current{var}} ) {
			push @{ $::MODULE{$current{var}}{options} },\%option;
		} else {
			# prepare and add this choice module
			my @options = (\%option);

			$::MODULE{$current{var}} = {
				'kind', CHOICE,
				'options', \@options,
				};

			for ('key','location','var') {
				$::MODULE{$current{var}}{$_}=$current{$_}
					if exists $current{$_};
				}
			}

	} else {
		$::MODULE{$current{var}} = {};
		for ('key','location','var','desc','forced','deps','file','kind') {
			$::MODULE{$current{var}}{$_}=$current{$_}
				if exists $current{$_};
			}
		}

	# default value
	$::MODULE{$current{var}}{default} = $current{default} 
		if exists $current{default};

	}
	
sub process_dependencies {
	my $module = $_[0];
	if (! exists $module->{lower}) {
		my @lower;
		if ($module->{kind} == CHOICE) {
			for my $option (@{ $module->{options} }) {
				if (exists $option->{deps}) {
					for (@{ $option->{deps} }) {
						my $dep = (m/"\$([^"]+)"/i)[0];
						my $sublower = process_dependencies($::MODULE{$dep});
						push @lower, $dep;
						push @lower, @{$sublower} if $#{$sublower} >= 0;
						}
					}
				}
		} elsif (exists $module->{deps}) {
			for (@{ $module->{deps} }) {
				my $dep = (m/"\$([^"]+)"/i)[0];
				my $sublower = process_dependencies($::MODULE{$dep});
				push @lower, $dep;
				push @lower, @{$sublower} if $#{$sublower} >= 0;
				}
			}
		$module->{lower}=\@lower;
		}
	return $module->{lower};
}

sub process_modules { 
	# populate {lower} list
	for (values %::MODULE) { process_dependencies( $_ ) unless $_->{lower}; }
}

sub trg_mnemosyne_filter {
=for comment
	echo "# generated for $SDECFG_TARGET target"
	pkgsel_init
	echo '{ $1="O"; }'
	for file; do
		pkgsel_parse < $file
	done
	pkgsel_finish
=cut
}

# print the content of a hash
sub printref {
	my ($name,$ref,$offset) = @_;
	my $typeof = ref($ref);

	print "$offset$name:";
	if ($typeof eq '') {
		print " '$ref'\n";
	} elsif ($typeof eq 'HASH') {
		print "\n";
		for (sort keys %{ $ref }) {
			printref($_,$ref->{$_},"$offset\t");
			}
	} elsif ($typeof eq 'ARRAY') {
		my $i=0;
		print "\n";
		for (@{ $ref }) {
			printref("[$i]",$_,"$offset\t");
			$i++;
		}
	} else {
		print " -> $typeof\n";
		}
}

if ($#ARGV != 3) {
	print "Usage mnemosyne.pl: <pkgseldir> <prefix> <configfile> <rulesfile>\n";
	exit (1);
	}

$::ROOT=$ARGV[0];
scandir($ARGV[0],$ARGV[1]);
process_modules();
printref('%::MODULE',\%::MODULE,'');
