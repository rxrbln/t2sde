From e36deb5b9b157f2fb3ee0e137ba947ef6e67407e Mon Sep 17 00:00:00 2001
From: Dom Cobley <dc4@broadcom.com>
Date: Wed, 1 Feb 2012 21:34:17 +0000
Subject: [PATCH 8/9] Fix some issues reported. Lower case module parameters
 for fb. Set board rev and serial. Requires updated
 start.elf.

Signed-off-by: Dom Cobley <dc4@broadcom.com>
---
 arch/arm/mach-bcm2708/bcm2708.c |  569 +++++++++++++++++++--------------------
 drivers/usb/gadget/Kconfig      |   14 -
 drivers/video/bcm2708_fb.c      |  425 ++++++++++++++++--------------
 3 files changed, 497 insertions(+), 511 deletions(-)

diff --git a/arch/arm/mach-bcm2708/bcm2708.c b/arch/arm/mach-bcm2708/bcm2708.c
index 5012f3f..d9dc628 100644
--- a/arch/arm/mach-bcm2708/bcm2708.c
+++ b/arch/arm/mach-bcm2708/bcm2708.c
@@ -30,6 +30,7 @@
 #include <linux/clockchips.h>
 #include <linux/cnt32_to_63.h>
 #include <linux/io.h>
+#include <linux/module.h>
 
 #include <linux/version.h>
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
@@ -69,6 +70,9 @@
  */
 #define DMA_MASK_BITS_COMMON 32
 
+/* command line parameters */
+static unsigned boardrev, serial;
+
 static void __init bcm2708_init_led(void);
 
 void __init bcm2708_init_irq(void)
@@ -78,58 +82,72 @@ void __init bcm2708_init_irq(void)
 
 static struct map_desc bcm2708_io_desc[] __initdata = {
 	{
-		.virtual	= IO_ADDRESS(ARMCTRL_BASE),
-		.pfn		= __phys_to_pfn(ARMCTRL_BASE),
-		.length		= SZ_4K,
-		.type		= MT_DEVICE
-	}, {
-		.virtual	= IO_ADDRESS(UART0_BASE),
-		.pfn		= __phys_to_pfn(UART0_BASE),
-		.length		= SZ_4K,
-		.type		= MT_DEVICE
-	}, {
-		.virtual	= IO_ADDRESS(UART1_BASE),
-		.pfn		= __phys_to_pfn(UART1_BASE),
-		.length		= SZ_4K,
-		.type		= MT_DEVICE
-	}, {
-#ifdef CONFIG_MMC_BCM2708 /* broadcom legacy SD */
-		.virtual	= IO_ADDRESS(MMCI0_BASE),
-		.pfn		= __phys_to_pfn(MMCI0_BASE),
-		.length		= SZ_4K,
-		.type		= MT_DEVICE
-	}, {
+	 .virtual = IO_ADDRESS(ARMCTRL_BASE),
+	 .pfn = __phys_to_pfn(ARMCTRL_BASE),
+	 .length = SZ_4K,
+	 .type = MT_DEVICE}, {
+			      .virtual = IO_ADDRESS(UART0_BASE),
+			      .pfn = __phys_to_pfn(UART0_BASE),
+			      .length = SZ_4K,
+			      .type = MT_DEVICE}, {
+						   .virtual =
+						   IO_ADDRESS(UART1_BASE),
+						   .pfn =
+						   __phys_to_pfn(UART1_BASE),
+						   .length = SZ_4K,
+						   .type = MT_DEVICE}, {
+#ifdef CONFIG_MMC_BCM2708	/* broadcom legacy SD */
+									.
+									virtual
+									=
+									IO_ADDRESS
+									(MMCI0_BASE),
+									.pfn =
+									__phys_to_pfn
+									(MMCI0_BASE),
+									.
+									length =
+									SZ_4K,
+									.type =
+									MT_DEVICE},
+	{
 #endif
-		.virtual	= IO_ADDRESS(DMA_BASE),
-		.pfn		= __phys_to_pfn(DMA_BASE),
-		.length		= SZ_4K,
-		.type		= MT_DEVICE
-	}, {
-		.virtual	= IO_ADDRESS(MCORE_BASE),
-		.pfn		= __phys_to_pfn(MCORE_BASE),
-		.length		= SZ_4K,
-		.type		= MT_DEVICE
-	}, {
-		.virtual	= IO_ADDRESS(ST_BASE),
-		.pfn		= __phys_to_pfn(ST_BASE),
-		.length		= SZ_4K,
-		.type		= MT_DEVICE
-	 }, {
-		.virtual	= IO_ADDRESS(USB_BASE),
-		.pfn		= __phys_to_pfn(USB_BASE),
-		.length		= SZ_128K,
-		.type		= MT_DEVICE
-	 }, {
-		.virtual        = IO_ADDRESS(PM_BASE),
-		.pfn	        = __phys_to_pfn(PM_BASE),
-		.length	        = SZ_4K,
-		.type	        = MT_DEVICE
-	}, {
-		.virtual	= IO_ADDRESS(GPIO_BASE),
-		.pfn		= __phys_to_pfn(GPIO_BASE),
-		.length		= SZ_4K,
-		.type		= MT_DEVICE
-	 }
+	 .virtual = IO_ADDRESS(DMA_BASE),
+	 .pfn = __phys_to_pfn(DMA_BASE),
+	 .length = SZ_4K,
+	 .type = MT_DEVICE}, {
+			      .virtual = IO_ADDRESS(MCORE_BASE),
+			      .pfn = __phys_to_pfn(MCORE_BASE),
+			      .length = SZ_4K,
+			      .type = MT_DEVICE}, {
+						   .virtual =
+						   IO_ADDRESS(ST_BASE),
+						   .pfn =
+						   __phys_to_pfn(ST_BASE),
+						   .length = SZ_4K,
+						   .type = MT_DEVICE}, {
+									.
+									virtual
+									=
+									IO_ADDRESS
+									(USB_BASE),
+									.pfn =
+									__phys_to_pfn
+									(USB_BASE),
+									.
+									length =
+									SZ_128K,
+									.type =
+									MT_DEVICE},
+	{
+	 .virtual = IO_ADDRESS(PM_BASE),
+	 .pfn = __phys_to_pfn(PM_BASE),
+	 .length = SZ_4K,
+	 .type = MT_DEVICE}, {
+			      .virtual = IO_ADDRESS(GPIO_BASE),
+			      .pfn = __phys_to_pfn(GPIO_BASE),
+			      .length = SZ_4K,
+			      .type = MT_DEVICE}
 };
 
 void __init bcm2708_map_io(void)
@@ -140,7 +158,7 @@ void __init bcm2708_map_io(void)
 unsigned long frc_clock_ticks32(void)
 {
 	/* STC: a free running counter that increments at the rate of 1MHz */
-	return readl(__io_address(ST_BASE+0x04));
+	return readl(__io_address(ST_BASE + 0x04));
 }
 
 unsigned long long frc_clock_ticks63(void)
@@ -162,49 +180,50 @@ unsigned long long sched_clock(void)
  * These are fixed clocks.
  */
 static struct clk ref24_clk = {
-	.rate	= 3000000,  /* The UART is clocked at 3MHz via APB_CLK */
+	.rate = 3000000,	/* The UART is clocked at 3MHz via APB_CLK */
 };
+
 static struct clk osc_clk = {
 #ifdef CONFIG_ARCH_BCM2708_CHIPIT
-	.rate	= 27000000,
+	.rate = 27000000,
 #else
-	.rate	= 500000000,  /* ARM clock is set from the VideoCore booter */
+	.rate = 500000000,	/* ARM clock is set from the VideoCore booter */
 #endif
 };
+
 /* warning - the USB needs a clock > 34MHz */
 
 #ifdef CONFIG_MMC_BCM2708
 static struct clk sdhost_clk = {
 #ifdef CONFIG_ARCH_BCM2708_CHIPIT
-	.rate	=   4000000, /* 4MHz */
+	.rate = 4000000,	/* 4MHz */
 #else
-	.rate	= 250000000, /* 250MHz */
+	.rate = 250000000,	/* 250MHz */
 #endif
 };
 #endif
 
 static struct clk_lookup lookups[] = {
-	{	/* UART0 */
-		.dev_id		= "dev:f1",
-		.clk		= &ref24_clk,
-	},
-	{	/* USB */
-		.dev_id		= "bcm2708_usb",
-		.clk		= &osc_clk,
+	{			/* UART0 */
+	 .dev_id = "dev:f1",
+	 .clk = &ref24_clk,
+	 },
+	{			/* USB */
+	 .dev_id = "bcm2708_usb",
+	 .clk = &osc_clk,
 #ifdef CONFIG_MMC_BCM2708
-	},
-	{	/* MCI */
-		.dev_id		= "bcm2708_mci.0",
-		.clk		= &sdhost_clk,
+	 },
+	{			/* MCI */
+	 .dev_id = "bcm2708_mci.0",
+	 .clk = &sdhost_clk,
 #endif
-	}
+	 }
 };
 
-
 #define UART0_IRQ	{ IRQ_UART, NO_IRQ }
 #define UART0_DMA	{ 15, 14 }
 
-AMBA_DEVICE(uart0, "dev:f1",  UART0,    NULL);
+AMBA_DEVICE(uart0, "dev:f1", UART0, NULL);
 
 static struct amba_device *amba_devs[] __initdata = {
 	&uart0_device,
@@ -212,262 +231,221 @@ static struct amba_device *amba_devs[] __initdata = {
 
 static struct resource bcm2708_dmaman_resources[] = {
 	{
-		.start			= DMA_BASE,
-		.end			= DMA_BASE + SZ_4K - 1,
-		.flags			= IORESOURCE_MEM,
-	}
+	 .start = DMA_BASE,
+	 .end = DMA_BASE + SZ_4K - 1,
+	 .flags = IORESOURCE_MEM,
+	 }
 };
 
 static struct platform_device bcm2708_dmaman_device = {
-   .name			= BCM_DMAMAN_DRIVER_NAME,
-	.id			= 0, /* first bcm2708_dma */
-	.resource		= bcm2708_dmaman_resources,
-	.num_resources		= ARRAY_SIZE(bcm2708_dmaman_resources),
+	.name = BCM_DMAMAN_DRIVER_NAME,
+	.id = 0,		/* first bcm2708_dma */
+	.resource = bcm2708_dmaman_resources,
+	.num_resources = ARRAY_SIZE(bcm2708_dmaman_resources),
 };
 
 #ifdef CONFIG_MMC_BCM2708
 static struct resource bcm2708_mci_resources[] = {
 	{
-		.start			= MMCI0_BASE,
-		.end			= MMCI0_BASE + SZ_4K - 1,
-		.flags			= IORESOURCE_MEM,
-	}, {
-		.start                  = IRQ_SDIO,
-		.end                    = IRQ_SDIO,
-		.flags                  = IORESOURCE_IRQ,
-	}
+	 .start = MMCI0_BASE,
+	 .end = MMCI0_BASE + SZ_4K - 1,
+	 .flags = IORESOURCE_MEM,
+	 }, {
+	     .start = IRQ_SDIO,
+	     .end = IRQ_SDIO,
+	     .flags = IORESOURCE_IRQ,
+	     }
 };
 
-
 static struct platform_device bcm2708_mci_device = {
-	.name			= "bcm2708_mci",
-	.id			= 0, /* first bcm2708_mci */
-	.resource		= bcm2708_mci_resources,
-	.num_resources		= ARRAY_SIZE(bcm2708_mci_resources),
-	.dev			= {
-	.coherent_dma_mask      = DMA_BIT_MASK(DMA_MASK_BITS_COMMON),
-	},
+	.name = "bcm2708_mci",
+	.id = 0,		/* first bcm2708_mci */
+	.resource = bcm2708_mci_resources,
+	.num_resources = ARRAY_SIZE(bcm2708_mci_resources),
+	.dev = {
+		.coherent_dma_mask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON),
+		},
 };
 #endif /* CONFIG_MMC_BCM2708 */
 
-
 static u64 fb_dmamask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON);
 
 static struct platform_device bcm2708_fb_device = {
-	.name			= "bcm2708_fb",
-	.id			= -1,  /* only one bcm2708_fb */
-	.resource               = NULL,
-	.num_resources          = 0,
-	.dev			= {
-		.dma_mask               = &fb_dmamask,
-		.coherent_dma_mask      = DMA_BIT_MASK(DMA_MASK_BITS_COMMON),
-	},
+	.name = "bcm2708_fb",
+	.id = -1,		/* only one bcm2708_fb */
+	.resource = NULL,
+	.num_resources = 0,
+	.dev = {
+		.dma_mask = &fb_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON),
+		},
 };
 
 static struct plat_serial8250_port bcm2708_uart1_platform_data[] = {
 	{
-		.mapbase	= UART1_BASE + 0x40,
-		.irq		= IRQ_AUX,
-		.uartclk	= 125000000,
-		.regshift	= 2,
-		.iotype		= UPIO_MEM,
-		.flags		= UPF_FIXED_TYPE | UPF_IOREMAP | UPF_SKIP_TEST,
-		.type		= PORT_8250,
-	},
-	{ },
+	 .mapbase = UART1_BASE + 0x40,
+	 .irq = IRQ_AUX,
+	 .uartclk = 125000000,
+	 .regshift = 2,
+	 .iotype = UPIO_MEM,
+	 .flags = UPF_FIXED_TYPE | UPF_IOREMAP | UPF_SKIP_TEST,
+	 .type = PORT_8250,
+	 },
+	{},
 };
 
 static struct platform_device bcm2708_uart1_device = {
-	.name			= "serial8250",
-	.id			= PLAT8250_DEV_PLATFORM,
-	.dev			= {
-		.platform_data	= bcm2708_uart1_platform_data,
-	},
+	.name = "serial8250",
+	.id = PLAT8250_DEV_PLATFORM,
+	.dev = {
+		.platform_data = bcm2708_uart1_platform_data,
+		},
 };
 
 static struct resource bcm2708_usb_resources[] = {
-	[0] =	{
-		.start			= USB_BASE,
-		.end			= USB_BASE + SZ_128K - 1,
-		.flags			= IORESOURCE_MEM,
-		},
-	[1] =	{
-		.start                  = IRQ_USB,
-		.end                    = IRQ_USB,
-		.flags                  = IORESOURCE_IRQ,
-		},
+	[0] = {
+	       .start = USB_BASE,
+	       .end = USB_BASE + SZ_128K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = IRQ_USB,
+	       .end = IRQ_USB,
+	       .flags = IORESOURCE_IRQ,
+	       },
 };
 
 static u64 usb_dmamask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON);
 
 static struct platform_device bcm2708_usb_device = {
-	.name			= "bcm2708_usb",
-	.id			= -1, /* only one bcm2708_usb */
-	.resource		= bcm2708_usb_resources,
-	.num_resources		= ARRAY_SIZE(bcm2708_usb_resources),
-	.dev			= {
-		.dma_mask               = &usb_dmamask,
-		.coherent_dma_mask      = DMA_BIT_MASK(DMA_MASK_BITS_COMMON),
-	},
+	.name = "bcm2708_usb",
+	.id = -1,		/* only one bcm2708_usb */
+	.resource = bcm2708_usb_resources,
+	.num_resources = ARRAY_SIZE(bcm2708_usb_resources),
+	.dev = {
+		.dma_mask = &usb_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON),
+		},
 };
 
 static struct resource bcm2708_vcio_resources[] = {
-	[0] =	{                       /* mailbox/semaphore/doorbell access */
-		.start			= MCORE_BASE,
-		.end			= MCORE_BASE + SZ_4K - 1,
-		.flags			= IORESOURCE_MEM,
-	},
+	[0] = {			/* mailbox/semaphore/doorbell access */
+	       .start = MCORE_BASE,
+	       .end = MCORE_BASE + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
 };
 
 static u64 vcio_dmamask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON);
 
 static struct platform_device bcm2708_vcio_device = {
-	.name                   = BCM_VCIO_DRIVER_NAME,
-	.id                     = -1, /* only one VideoCore I/O area */
-	.resource               = bcm2708_vcio_resources,
-	.num_resources          = ARRAY_SIZE(bcm2708_vcio_resources),
-	.dev			= {
-		.dma_mask               = &vcio_dmamask,
-		.coherent_dma_mask      = DMA_BIT_MASK(DMA_MASK_BITS_COMMON),
-	},
+	.name = BCM_VCIO_DRIVER_NAME,
+	.id = -1,		/* only one VideoCore I/O area */
+	.resource = bcm2708_vcio_resources,
+	.num_resources = ARRAY_SIZE(bcm2708_vcio_resources),
+	.dev = {
+		.dma_mask = &vcio_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON),
+		},
 };
 
 #ifdef CONFIG_BCM2708_GPIO
 #define BCM_GPIO_DRIVER_NAME "bcm2708_gpio"
 
 static struct resource bcm2708_gpio_resources[] = {
-	[0] =	{                       /* general purpose I/O */
-		.start			= GPIO_BASE,
-		.end			= GPIO_BASE + SZ_4K - 1,
-		.flags			= IORESOURCE_MEM,
-	},
+	[0] = {			/* general purpose I/O */
+	       .start = GPIO_BASE,
+	       .end = GPIO_BASE + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
 };
 
 static u64 gpio_dmamask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON);
 
 static struct platform_device bcm2708_gpio_device = {
-	.name                   = BCM_GPIO_DRIVER_NAME,
-	.id                     = -1, /* only one VideoCore I/O area */
-	.resource               = bcm2708_gpio_resources,
-	.num_resources          = ARRAY_SIZE(bcm2708_gpio_resources),
-	.dev			= {
-		.dma_mask               = &gpio_dmamask,
-		.coherent_dma_mask      = DMA_BIT_MASK(DMA_MASK_BITS_COMMON),
-	},
-};
-#endif
-
-#ifdef CONFIG_BCM2708_BUTTONS
-static struct resource bcm2708_vcbuttons_resources[] = {
-};
-
-static u64 vcbuttons_dmamask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON);
-
-static struct platform_device bcm2708_vcbuttons_device = {
-	.name                   = "bcm2708_vcbuttons",
-	.id                     = -1, /* only one VideoCore I/O area */
-	.resource               = bcm2708_vcbuttons_resources,
-	.num_resources          = ARRAY_SIZE(bcm2708_vcbuttons_resources),
-	.dev			= {
-		.dma_mask               = &vcbuttons_dmamask,
-		.coherent_dma_mask      = DMA_BIT_MASK(DMA_MASK_BITS_COMMON),
-	},
-};
-#endif
-
-#ifdef CONFIG_BCM2708_TOUCHSCREEN
-static struct resource bcm2708_vctouch_resources[] = {
-};
-
-static u64 vctouch_dmamask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON);
-
-static struct platform_device bcm2708_vctouch_device = {
-	.name                   = "bcm2708_vctouch",
-	.id                     = -1, /* only one VideoCore I/O area */
-	.resource               = bcm2708_vctouch_resources,
-	.num_resources          = ARRAY_SIZE(bcm2708_vctouch_resources),
-	.dev			= {
-		.dma_mask               = &vctouch_dmamask,
-		.coherent_dma_mask      = DMA_BIT_MASK(DMA_MASK_BITS_COMMON),
-	},
+	.name = BCM_GPIO_DRIVER_NAME,
+	.id = -1,		/* only one VideoCore I/O area */
+	.resource = bcm2708_gpio_resources,
+	.num_resources = ARRAY_SIZE(bcm2708_gpio_resources),
+	.dev = {
+		.dma_mask = &gpio_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON),
+		},
 };
 #endif
 
 static struct resource bcm2708_systemtimer_resources[] = {
-	[0] =	{                       /* system timer access */
-		.start			= ST_BASE,
-		.end			= ST_BASE + SZ_4K - 1,
-		.flags			= IORESOURCE_MEM,
-	}, {
-		.start                  = IRQ_TIMER3,
-		.end                    = IRQ_TIMER3,
-		.flags                  = IORESOURCE_IRQ,
-	}
-
+	[0] = {			/* system timer access */
+	       .start = ST_BASE,
+	       .end = ST_BASE + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       }, {
+		   .start = IRQ_TIMER3,
+		   .end = IRQ_TIMER3,
+		   .flags = IORESOURCE_IRQ,
+		   }
 
 };
 
 static u64 systemtimer_dmamask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON);
 
 static struct platform_device bcm2708_systemtimer_device = {
-	.name                   = "bcm2708_systemtimer",
-	.id                     = -1, /* only one VideoCore I/O area */
-	.resource               = bcm2708_systemtimer_resources,
-	.num_resources          = ARRAY_SIZE(bcm2708_systemtimer_resources),
-	.dev			= {
-		.dma_mask               = &systemtimer_dmamask,
-		.coherent_dma_mask      = DMA_BIT_MASK(DMA_MASK_BITS_COMMON),
-	},
+	.name = "bcm2708_systemtimer",
+	.id = -1,		/* only one VideoCore I/O area */
+	.resource = bcm2708_systemtimer_resources,
+	.num_resources = ARRAY_SIZE(bcm2708_systemtimer_resources),
+	.dev = {
+		.dma_mask = &systemtimer_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON),
+		},
 };
 
-#ifdef CONFIG_MMC_SDHCI_BCM2708 /* Arasan emmc SD */
+#ifdef CONFIG_MMC_SDHCI_BCM2708	/* Arasan emmc SD */
 static struct resource bcm2708_emmc_resources[] = {
 	[0] = {
-		.start = EMMC_BASE,
-		.end   = EMMC_BASE + SZ_256 - 1, /* we only need this area */
-		/* the memory map actually makes SZ_4K available  */
-		.flags = IORESOURCE_MEM,
-	},
+	       .start = EMMC_BASE,
+	       .end = EMMC_BASE + SZ_256 - 1,	/* we only need this area */
+	       /* the memory map actually makes SZ_4K available  */
+	       .flags = IORESOURCE_MEM,
+	       },
 	[1] = {
-		.start = IRQ_ARASANSDIO,
-		.end   = IRQ_ARASANSDIO,
-		.flags = IORESOURCE_IRQ,
-	},
+	       .start = IRQ_ARASANSDIO,
+	       .end = IRQ_ARASANSDIO,
+	       .flags = IORESOURCE_IRQ,
+	       },
 };
 
 static u64 bcm2708_emmc_dmamask = 0xffffffffUL;
 
 struct platform_device bcm2708_emmc_device = {
-	.name		= "bcm2708_sdhci",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(bcm2708_emmc_resources),
-	.resource	= bcm2708_emmc_resources,
-	.dev		= {
-		.dma_mask		= &bcm2708_emmc_dmamask,
-		.coherent_dma_mask	= 0xffffffffUL
-	},
+	.name = "bcm2708_sdhci",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(bcm2708_emmc_resources),
+	.resource = bcm2708_emmc_resources,
+	.dev = {
+		.dma_mask = &bcm2708_emmc_dmamask,
+		.coherent_dma_mask = 0xffffffffUL},
 };
 #endif /* CONFIG_MMC_SDHCI_BCM2708 */
 
 static struct resource bcm2708_powerman_resources[] = {
 	[0] = {
-		.start = PM_BASE,
-		.end   = PM_BASE + SZ_256 - 1,
-		.flags = IORESOURCE_MEM,
-	},
+	       .start = PM_BASE,
+	       .end = PM_BASE + SZ_256 - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
 };
 
 static u64 powerman_dmamask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON);
 
 struct platform_device bcm2708_powerman_device = {
-	.name		= "bcm2708_powerman",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(bcm2708_powerman_resources),
-	.resource	= bcm2708_powerman_resources,
-	.dev		= {
-		.dma_mask     = &powerman_dmamask,
-		.coherent_dma_mask = 0xffffffffUL
-	},
+	.name = "bcm2708_powerman",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(bcm2708_powerman_resources),
+	.resource = bcm2708_powerman_resources,
+	.dev = {
+		.dma_mask = &powerman_dmamask,
+		.coherent_dma_mask = 0xffffffffUL},
 };
 
 int __init bcm_register_device(struct platform_device *pdev)
@@ -501,30 +479,26 @@ void __init bcm2708_init(void)
 	bcm_register_device(&bcm2708_fb_device);
 	bcm_register_device(&bcm2708_usb_device);
 	bcm_register_device(&bcm2708_uart1_device);
-#ifdef CONFIG_BCM2708_BUTTONS
-	bcm_register_device(&bcm2708_vcbuttons_device);
-#endif
-#ifdef CONFIG_BCM2708_TOUCHSCREEN
-	bcm_register_device(&bcm2708_vctouch_device);
-#endif
 	bcm_register_device(&bcm2708_powerman_device);
 #ifdef CONFIG_MMC_SDHCI_BCM2708
 	bcm_register_device(&bcm2708_emmc_device);
 #endif
-        bcm2708_init_led();
+	bcm2708_init_led();
 #ifdef CONFIG_BCM2708_VCMEM
-{
-	extern void vc_mem_connected_init(void);
-        vc_mem_connected_init();
-}
+	{
+		extern void vc_mem_connected_init(void);
+		vc_mem_connected_init();
+	}
 #endif
 	for (i = 0; i < ARRAY_SIZE(amba_devs); i++) {
 		struct amba_device *d = amba_devs[i];
 		amba_device_register(d, &iomem_resource);
 	}
+	system_rev = boardrev;
+	system_serial_low = serial;
 }
 
-#define TIMER_PERIOD 10000 /* HZ in microsecs */
+#define TIMER_PERIOD 10000	/* HZ in microsecs */
 
 static void timer_set_mode(enum clock_event_mode mode,
 			   struct clock_event_device *clk)
@@ -533,16 +507,15 @@ static void timer_set_mode(enum clock_event_mode mode,
 
 	switch (mode) {
 	case CLOCK_EVT_MODE_PERIODIC:
-		stc = readl(__io_address(ST_BASE+0x04));
-		writel(stc + TIMER_PERIOD,
-			__io_address(ST_BASE+0x18));/* stc3 */
+		stc = readl(__io_address(ST_BASE + 0x04));
+		writel(stc + TIMER_PERIOD, __io_address(ST_BASE + 0x18));	/* stc3 */
 		break;
 	case CLOCK_EVT_MODE_ONESHOT:
 	case CLOCK_EVT_MODE_UNUSED:
 	case CLOCK_EVT_MODE_SHUTDOWN:
 	default:
 		printk(KERN_ERR "timer_set_mode: unhandled mode:%d\n",
-			(int)mode);
+		       (int)mode);
 		break;
 	}
 
@@ -553,17 +526,17 @@ static int timer_set_next_event(unsigned long evt,
 {
 	unsigned long stc;
 
-	 stc = readl(__io_address(ST_BASE + 0x04));
-	 writel(stc + TIMER_PERIOD, __io_address(ST_BASE+0x18)); /* stc3 */
+	stc = readl(__io_address(ST_BASE + 0x04));
+	writel(stc + TIMER_PERIOD, __io_address(ST_BASE + 0x18));	/* stc3 */
 	return 0;
 }
 
-static struct clock_event_device timer0_clockevent =	 {
-	.name		= "timer0",
-	.shift		= 32,
-	.features       = CLOCK_EVT_FEAT_ONESHOT,
-	.set_mode	= timer_set_mode,
-	.set_next_event	= timer_set_next_event,
+static struct clock_event_device timer0_clockevent = {
+	.name = "timer0",
+	.shift = 32,
+	.features = CLOCK_EVT_FEAT_ONESHOT,
+	.set_mode = timer_set_mode,
+	.set_next_event = timer_set_next_event,
 };
 
 /*
@@ -573,7 +546,7 @@ static irqreturn_t bcm2708_timer_interrupt(int irq, void *dev_id)
 {
 	struct clock_event_device *evt = &timer0_clockevent;
 
-	writel(1<<3, __io_address(ST_BASE+0x00)); /* stcs clear timer int */
+	writel(1 << 3, __io_address(ST_BASE + 0x00));	/* stcs clear timer int */
 
 	evt->event_handler(evt);
 
@@ -581,9 +554,9 @@ static irqreturn_t bcm2708_timer_interrupt(int irq, void *dev_id)
 }
 
 static struct irqaction bcm2708_timer_irq = {
-	.name		= "BCM2708 Timer Tick",
-	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
-	.handler	= bcm2708_timer_interrupt,
+	.name = "BCM2708 Timer Tick",
+	.flags = IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.handler = bcm2708_timer_interrupt,
 };
 
 /*
@@ -601,18 +574,18 @@ static void __init bcm2708_timer_init(void)
 	setup_irq(IRQ_TIMER3, &bcm2708_timer_irq);
 
 	timer0_clockevent.mult =
-		div_sc(1000000, NSEC_PER_SEC, timer0_clockevent.shift);
+	    div_sc(1000000, NSEC_PER_SEC, timer0_clockevent.shift);
 	timer0_clockevent.max_delta_ns =
-		clockevent_delta2ns(0xffffffff, &timer0_clockevent);
+	    clockevent_delta2ns(0xffffffff, &timer0_clockevent);
 	timer0_clockevent.min_delta_ns =
-		clockevent_delta2ns(0xf, &timer0_clockevent);
+	    clockevent_delta2ns(0xf, &timer0_clockevent);
 
 	timer0_clockevent.cpumask = cpumask_of(0);
 	clockevents_register_device(&timer0_clockevent);
 }
 
 struct sys_timer bcm2708_timer = {
-	.init		= bcm2708_timer_init,
+	.init = bcm2708_timer_init,
 };
 
 #if defined(CONFIG_LEDS_GPIO) || defined(CONFIG_LEDS_GPIO_MODULE)
@@ -620,24 +593,24 @@ struct sys_timer bcm2708_timer = {
 
 static struct gpio_led bcm2708_leds[] = {
 	[0] = {
-		.gpio			= 16,
-		.name			= "led0",
-		.default_trigger	= "mmc0",
-		.active_low		= 0,
-	},
+	       .gpio = 16,
+	       .name = "led0",
+	       .default_trigger = "mmc0",
+	       .active_low = 0,
+	       },
 };
 
 static struct gpio_led_platform_data bcm2708_led_pdata = {
-	.num_leds	= ARRAY_SIZE(bcm2708_leds),
-	.leds		= bcm2708_leds,
+	.num_leds = ARRAY_SIZE(bcm2708_leds),
+	.leds = bcm2708_leds,
 };
 
 static struct platform_device bcm2708_led_device = {
-	.name		= "leds-gpio",
-	.id		= -1,
-	.dev		= {
-		.platform_data	= &bcm2708_led_pdata,
-	},
+	.name = "leds-gpio",
+	.id = -1,
+	.dev = {
+		.platform_data = &bcm2708_led_pdata,
+		},
 };
 
 static void __init bcm2708_init_led(void)
@@ -645,14 +618,14 @@ static void __init bcm2708_init_led(void)
 	platform_device_register(&bcm2708_led_device);
 }
 #else
-static inline void bcm2708_init_led(void) {}
+static inline void bcm2708_init_led(void)
+{
+}
 #endif
 
-
 MACHINE_START(BCM2708, "BCM2708")
-	/* Maintainer: Broadcom Europe Ltd. */
-	.map_io		= bcm2708_map_io,
-	.init_irq	= bcm2708_init_irq,
-	.timer		= &bcm2708_timer,
-	.init_machine	= bcm2708_init,
-MACHINE_END
+    /* Maintainer: Broadcom Europe Ltd. */
+.map_io = bcm2708_map_io,.init_irq = bcm2708_init_irq,.timer =
+    &bcm2708_timer,.init_machine =
+    bcm2708_init, MACHINE_END module_param(boardrev, uint, 0644);
+module_param(serial, uint, 0644);
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 83de375..6690bdb 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -539,20 +539,6 @@ config USB_DWC_OTG_LPM
 	help
 	   Enables LPM support.
 
-config USB_GADGET_SNPS_DWC_OTG
-	boolean "Synopsys Driver for DWC_otg Controller"
-	depends on USB && EXPERIMENTAL
-	select USB_OTG
-	select USB_GADGET_DUALSPEED
-	help
-	   Selects the Synopsys Driver for the DWC_otg Controller.
-
-config USB_DWC_OTG_LPM
-	boolean "Enable LPM support"
-	depends on USB && EXPERIMENTAL
-	help
-	   Enables LPM support.
-
 #
 # USB Gadget Drivers
 #
diff --git a/drivers/video/bcm2708_fb.c b/drivers/video/bcm2708_fb.c
index 6bfdeef..8612266 100644
--- a/drivers/video/bcm2708_fb.c
+++ b/drivers/video/bcm2708_fb.c
@@ -7,7 +7,11 @@
  * License.  See the file COPYING in the main directory of this archive
  * for more details.
  *
- *  Broadcom simple framebuffer driver
+ * Broadcom simple framebuffer driver
+ *
+ * This file is derived from cirrusfb.c
+ * Copyright 1999-2001 Jeff Garzik <jgarzik@pobox.com>
+ *
  */
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -22,6 +26,7 @@
 #include <linux/list.h>
 #include <linux/platform_device.h>
 #include <linux/clk.h>
+#include <linux/printk.h>
 
 #include <mach/platform.h>
 #include <mach/vcio.h>
@@ -38,26 +43,24 @@ static const char *bcm2708_name = "BCM2708 FB";
 /* this data structure describes each frame buffer device we find */
 
 struct fbinfo_s {
-   int xres, yres, xres_virtual, yres_virtual;
-   int pitch, bpp;
-   int xoffset, yoffset;
-   int base;
-   int screen_size;
+	u32 xres, yres, xres_virtual, yres_virtual;
+	u32 pitch, bpp;
+	u32 xoffset, yoffset;
+	u32 base;
+	u32 screen_size;
 };
 
 struct bcm2708_fb {
-	struct fb_info		fb;
-	struct platform_device	*dev;
-	void __iomem		*regs;
-        volatile struct fbinfo_s         *info;
-        dma_addr_t              dma;
-	u32			cmap[16];
+	struct fb_info fb;
+	struct platform_device *dev;
+	struct fbinfo_s *info;
+	dma_addr_t dma;
+	u32 cmap[16];
 };
 
 #define to_bcm2708(info)	container_of(info, struct bcm2708_fb, fb)
 
-static int
-bcm2708_fb_set_bitfields(struct fb_var_screeninfo *var)
+static int bcm2708_fb_set_bitfields(struct fb_var_screeninfo *var)
 {
 	int ret = 0;
 
@@ -72,12 +75,12 @@ bcm2708_fb_set_bitfields(struct fb_var_screeninfo *var)
 	case 2:
 	case 4:
 	case 8:
-		var->red.length		= var->bits_per_pixel;
-		var->red.offset		= 0;
-		var->green.length	= var->bits_per_pixel;
-		var->green.offset	= 0;
-		var->blue.length	= var->bits_per_pixel;
-		var->blue.offset	= 0;
+		var->red.length = var->bits_per_pixel;
+		var->red.offset = 0;
+		var->green.length = var->bits_per_pixel;
+		var->green.offset = 0;
+		var->blue.length = var->bits_per_pixel;
+		var->blue.offset = 0;
 		break;
 	case 16:
 		var->red.length = 5;
@@ -90,9 +93,9 @@ bcm2708_fb_set_bitfields(struct fb_var_screeninfo *var)
 			var->green.length = 6;
 		break;
 	case 32:
-		var->red.length		= 8;
-		var->green.length	= 8;
-		var->blue.length	= 8;
+		var->red.length = 8;
+		var->green.length = 8;
+		var->blue.length = 8;
 		break;
 	default:
 		ret = -EINVAL;
@@ -113,110 +116,119 @@ bcm2708_fb_set_bitfields(struct fb_var_screeninfo *var)
 	return ret;
 }
 
-static int bcm2708_fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+static int bcm2708_fb_check_var(struct fb_var_screeninfo *var,
+				struct fb_info *info)
 {
 
-         // info input, var output
-         int yres;
-         /* memory size in pixels */
-         unsigned pixels = info->screen_size * 8 / var->bits_per_pixel;
-
-         // info input, var output
-	 printk(KERN_ERR "bcm2708_fb_check_var info(%p) %dx%d (%dx%d), %d, %d\n", info, info->var.xres, info->var.yres, info->var.xres_virtual, info->var.yres_virtual, (int)info->screen_size, info->var.bits_per_pixel );
-	 printk(KERN_ERR "bcm2708_fb_check_var var(%p) %dx%d (%dx%d), %d, %d\n", var, var->xres, var->yres, var->xres_virtual, var->yres_virtual, var->bits_per_pixel, pixels);
-
-         if (!var->bits_per_pixel) var->bits_per_pixel = 16;
-
-         if (0 && var->bits_per_pixel != 16 && var->bits_per_pixel != 32) {
-                 printk(KERN_ERR "bcm2708_fb_check_var: ERROR: bits_per_pixel=%d\n", var->bits_per_pixel);
-                 return -EINVAL;
-         }
-
-         bcm2708_fb_set_bitfields(var);
-
-         if (var->xres_virtual < var->xres)
-                 var->xres_virtual = var->xres;
-         /* use highest possible virtual resolution */
-         if (var->yres_virtual == -1) {
-                 var->yres_virtual = 480; //pixels / var->xres_virtual;
-
-                 printk(KERN_ERR
-                          "bcm2708_fb_check_var: virtual resolution set to maximum of %dx%d\n",
-                          var->xres_virtual, var->yres_virtual);
-         }
-         if (var->yres_virtual < var->yres)
-                 var->yres_virtual = var->yres;
-
-         #if 0
-         if (var->xres_virtual * var->yres_virtual > pixels) {
-                 printk(KERN_ERR "bcm2708_fb_check_var: mode %dx%dx%d rejected... "
-                       "virtual resolution too high to fit into video memory!\n",
-                         var->xres_virtual, var->yres_virtual,
-                         var->bits_per_pixel);
-                 return -EINVAL;
-         }
-         #endif
-         if (var->xoffset < 0)
-                 var->xoffset = 0;
-         if (var->yoffset < 0)
-                 var->yoffset = 0;
-
-         /* truncate xoffset and yoffset to maximum if too high */
-         if (var->xoffset > var->xres_virtual - var->xres)
-                 var->xoffset = var->xres_virtual - var->xres - 1;
-         if (var->yoffset > var->yres_virtual - var->yres)
-                 var->yoffset = var->yres_virtual - var->yres - 1;
-
-         var->red.msb_right =
-             var->green.msb_right =
-             var->blue.msb_right =
-             var->transp.offset =
-             var->transp.length =
-             var->transp.msb_right = 0;
-
-         yres = var->yres;
-         if (var->vmode & FB_VMODE_DOUBLE)
-                 yres *= 2;
-         else if (var->vmode & FB_VMODE_INTERLACED)
-                 yres = (yres + 1) / 2;
-
-         if (yres > 1200) {
-                 printk(KERN_ERR "bcm2708_fb_check_var: ERROR: VerticalTotal >= 1200; "
-                         "special treatment required! (TODO)\n");
-                 return -EINVAL;
-         }
-
-         //if (cirrusfb_check_pixclock(var, info))
-         //        return -EINVAL;
-
-         //if (!is_laguna(cinfo))
-         //        var->accel_flags = FB_ACCELF_TEXT;
-
-         return 0;
+	/* info input, var output */
+	int yres;
+	/* memory size in pixels */
+	unsigned pixels = info->screen_size * 8 / var->bits_per_pixel;
+
+	/* info input, var output */
+	pr_info("bcm2708_fb_check_var info(%p) %dx%d (%dx%d), %d, %d\n", info,
+		info->var.xres, info->var.yres, info->var.xres_virtual,
+		info->var.yres_virtual, (int)info->screen_size,
+		info->var.bits_per_pixel);
+	pr_info("bcm2708_fb_check_var var(%p) %dx%d (%dx%d), %d, %d\n", var,
+		var->xres, var->yres, var->xres_virtual, var->yres_virtual,
+		var->bits_per_pixel, pixels);
+
+	if (!var->bits_per_pixel)
+		var->bits_per_pixel = 16;
+
+	if (0 && var->bits_per_pixel != 16 && var->bits_per_pixel != 32) {
+		pr_err("bcm2708_fb_check_var: ERROR: bits_per_pixel=%d\n",
+		       var->bits_per_pixel);
+		return -EINVAL;
+	}
+
+	bcm2708_fb_set_bitfields(var);
+
+	if (var->xres_virtual < var->xres)
+		var->xres_virtual = var->xres;
+	/* use highest possible virtual resolution */
+	if (var->yres_virtual == -1) {
+		var->yres_virtual = 480;
+
+		pr_err
+		    ("bcm2708_fb_check_var: virtual resolution set to maximum of %dx%d\n",
+		     var->xres_virtual, var->yres_virtual);
+	}
+	if (var->yres_virtual < var->yres)
+		var->yres_virtual = var->yres;
+
+#if 0
+	if (var->xres_virtual * var->yres_virtual > pixels) {
+		pr_err("bcm2708_fb_check_var: mode %dx%dx%d rejected... "
+		       "virtual resolution too high to fit into video memory!\n",
+		       var->xres_virtual, var->yres_virtual,
+		       var->bits_per_pixel);
+		return -EINVAL;
+	}
+#endif
+	if (var->xoffset < 0)
+		var->xoffset = 0;
+	if (var->yoffset < 0)
+		var->yoffset = 0;
+
+	/* truncate xoffset and yoffset to maximum if too high */
+	if (var->xoffset > var->xres_virtual - var->xres)
+		var->xoffset = var->xres_virtual - var->xres - 1;
+	if (var->yoffset > var->yres_virtual - var->yres)
+		var->yoffset = var->yres_virtual - var->yres - 1;
+
+	var->red.msb_right =
+	    var->green.msb_right =
+	    var->blue.msb_right =
+	    var->transp.offset = var->transp.length = var->transp.msb_right = 0;
+
+	yres = var->yres;
+	if (var->vmode & FB_VMODE_DOUBLE)
+		yres *= 2;
+	else if (var->vmode & FB_VMODE_INTERLACED)
+		yres = (yres + 1) / 2;
+
+	if (yres > 1200) {
+		pr_err("bcm2708_fb_check_var: ERROR: VerticalTotal >= 1200; "
+		       "special treatment required! (TODO)\n");
+		return -EINVAL;
+	}
+
+	return 0;
 }
 
 static int bcm2708_fb_set_par(struct fb_info *info)
 {
-        unsigned val = 0;
+	unsigned val = 0;
 	struct bcm2708_fb *fb = to_bcm2708(info);
-        volatile struct fbinfo_s *fbinfo = fb->info;
-        fbinfo->xres = info->var.xres;
-        fbinfo->yres = info->var.yres;
-        fbinfo->xres_virtual = info->var.xres_virtual;
-        fbinfo->yres_virtual = info->var.yres_virtual;
-        fbinfo->bpp = info->var.bits_per_pixel;
-        fbinfo->xoffset = info->var.xoffset;
-        fbinfo->yoffset = info->var.yoffset;
-        fbinfo->base = 0; // filled in by VC
-        fbinfo->pitch = 0; // filled in by VC
-
-        printk(KERN_ERR "bcm2708_fb_set_par info(%p) %dx%d (%dx%d), %d, %d\n", info, info->var.xres, info->var.yres, info->var.xres_virtual, info->var.yres_virtual, (int)info->screen_size, info->var.bits_per_pixel );
-
-	// inform vc about new framebuffer
+	volatile struct fbinfo_s *fbinfo = fb->info;
+	fbinfo->xres = info->var.xres;
+	fbinfo->yres = info->var.yres;
+	fbinfo->xres_virtual = info->var.xres_virtual;
+	fbinfo->yres_virtual = info->var.yres_virtual;
+	fbinfo->bpp = info->var.bits_per_pixel;
+	fbinfo->xoffset = info->var.xoffset;
+	fbinfo->yoffset = info->var.yoffset;
+	fbinfo->base = 0;	/* filled in by VC */
+	fbinfo->pitch = 0;	/* filled in by VC */
+
+	pr_info("bcm2708_fb_set_par info(%p) %dx%d (%dx%d), %d, %d\n", info,
+		info->var.xres, info->var.yres, info->var.xres_virtual,
+		info->var.yres_virtual, (int)info->screen_size,
+		info->var.bits_per_pixel);
+
+	/* ensure last write to fbinfo is visible to GPU */
+	wmb();
+
+	/* inform vc about new framebuffer */
 	bcm_mailbox_write(MBOX_CHAN_FB, fb->dma);
 
-	// wait for response
-        bcm_mailbox_read(MBOX_CHAN_FB, &val);
+	/* wait for response */
+	bcm_mailbox_read(MBOX_CHAN_FB, &val);
+
+	/* ensure GPU writes are visible to us */
+	rmb();
 
 	fb->fb.fix.line_length = fbinfo->pitch;
 
@@ -225,13 +237,21 @@ static int bcm2708_fb_set_par(struct fb_info *info)
 	else
 		fb->fb.fix.visual = FB_VISUAL_TRUECOLOR;
 
-        fb->fb.fix.smem_start = fbinfo->base;
-        fb->fb.fix.smem_len = fbinfo->pitch * fbinfo->yres_virtual;
-        fb->fb.screen_size = fbinfo->screen_size;
-        fb->fb.screen_base = (void *)ioremap_nocache(fb->fb.fix.smem_start, fb->fb.screen_size);
-
-	printk(KERN_ERR "BCM2708FB: start = %p,%p,%p width=%d, height=%d, bpp=%d, pitch=%d\n",
-	       (void *)fb->fb.screen_base, (void *)fb->fb.fix.smem_start, (void *)val, fbinfo->xres, fbinfo->yres, fbinfo->bpp, fbinfo->pitch);
+	fb->fb.fix.smem_start = fbinfo->base;
+	fb->fb.fix.smem_len = fbinfo->pitch * fbinfo->yres_virtual;
+	fb->fb.screen_size = fbinfo->screen_size;
+	if (fb->fb.screen_base)
+		iounmap(fb->fb.screen_base);
+	fb->fb.screen_base =
+	    (void *)ioremap_nocache(fb->fb.fix.smem_start, fb->fb.screen_size);
+	if (!fb->fb.screen_base)
+		BUG();		/* what can we do here */
+
+	pr_info
+	    ("BCM2708FB: start = %p,%p,%p width=%d, height=%d, bpp=%d, pitch=%d\n",
+	     (void *)fb->fb.screen_base, (void *)fb->fb.fix.smem_start,
+	     (void *)val, fbinfo->xres, fbinfo->yres, fbinfo->bpp,
+	     fbinfo->pitch);
 
 	return val;
 }
@@ -243,58 +263,61 @@ static inline u32 convert_bitfield(int val, struct fb_bitfield *bf)
 	return (val >> (16 - bf->length) & mask) << bf->offset;
 }
 
-static int bcm2708_fb_setcolreg(unsigned int regno, unsigned int red, unsigned int green,
-		 unsigned int blue, unsigned int transp, struct fb_info *info)
+static int bcm2708_fb_setcolreg(unsigned int regno, unsigned int red,
+				unsigned int green, unsigned int blue,
+				unsigned int transp, struct fb_info *info)
 {
 	struct bcm2708_fb *fb = to_bcm2708(info);
 
 	if (regno < 16)
 		fb->cmap[regno] = convert_bitfield(transp, &fb->fb.var.transp) |
-				  convert_bitfield(blue, &fb->fb.var.blue) |
-				  convert_bitfield(green, &fb->fb.var.green) |
-				  convert_bitfield(red, &fb->fb.var.red);
+		    convert_bitfield(blue, &fb->fb.var.blue) |
+		    convert_bitfield(green, &fb->fb.var.green) |
+		    convert_bitfield(red, &fb->fb.var.red);
 
 	return regno > 255;
 }
 
 static int bcm2708_fb_blank(int blank_mode, struct fb_info *info)
 {
-//printk(KERN_ERR "bcm2708_fb_blank\n");
+	/*pr_info("bcm2708_fb_blank\n"); */
 	return -1;
 }
 
-static void bcm2708_fb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)
+static void bcm2708_fb_fillrect(struct fb_info *info,
+				const struct fb_fillrect *rect)
 {
-// (is called) printk(KERN_ERR "bcm2708_fb_fillrect\n");
+	/* (is called) pr_info("bcm2708_fb_fillrect\n"); */
 	cfb_fillrect(info, rect);
 }
 
-static void bcm2708_fb_copyarea(struct fb_info *info, const struct fb_copyarea *region)
+static void bcm2708_fb_copyarea(struct fb_info *info,
+				const struct fb_copyarea *region)
 {
-//printk(KERN_ERR "bcm2708_fb_copyarea\n");
+	/*pr_info("bcm2708_fb_copyarea\n"); */
 	cfb_copyarea(info, region);
 }
 
-static void bcm2708_fb_imageblit(struct fb_info *info, const struct fb_image *image)
+static void bcm2708_fb_imageblit(struct fb_info *info,
+				 const struct fb_image *image)
 {
-// (is called) printk(KERN_ERR "bcm2708_fb_imageblit\n");
+	/* (is called) pr_info("bcm2708_fb_imageblit\n"); */
 	cfb_imageblit(info, image);
 }
 
 static struct fb_ops bcm2708_fb_ops = {
-	.owner		= THIS_MODULE,
-	.fb_check_var	= bcm2708_fb_check_var,
-	.fb_set_par	= bcm2708_fb_set_par,
-	.fb_setcolreg	= bcm2708_fb_setcolreg,
-	.fb_blank	= bcm2708_fb_blank,
-	.fb_fillrect	= bcm2708_fb_fillrect,
-	.fb_copyarea	= bcm2708_fb_copyarea,
-	.fb_imageblit	= bcm2708_fb_imageblit,
+	.owner = THIS_MODULE,
+	.fb_check_var = bcm2708_fb_check_var,
+	.fb_set_par = bcm2708_fb_set_par,
+	.fb_setcolreg = bcm2708_fb_setcolreg,
+	.fb_blank = bcm2708_fb_blank,
+	.fb_fillrect = bcm2708_fb_fillrect,
+	.fb_copyarea = bcm2708_fb_copyarea,
+	.fb_imageblit = bcm2708_fb_imageblit,
 };
 
-static int FBWIDTH =800; /* module parameter */
-static int FBHEIGHT =480; /* module parameter */
-
+static int fbwidth = 800;	/* module parameter */
+static int fbheight = 480;	/* module parameter */
 
 static int bcm2708_fb_register(struct bcm2708_fb *fb)
 {
@@ -302,45 +325,47 @@ static int bcm2708_fb_register(struct bcm2708_fb *fb)
 	dma_addr_t dma;
 	void *mem;
 
-	mem = dma_alloc_coherent(NULL, PAGE_ALIGN(sizeof(*fb->info)), &dma, GFP_KERNEL);
+	mem =
+	    dma_alloc_coherent(NULL, PAGE_ALIGN(sizeof(*fb->info)), &dma,
+			       GFP_KERNEL);
 
 	if (NULL == mem) {
-		printk(KERN_ERR ": unable to allocate fbinfo buffer\n");
+		pr_err(": unable to allocate fbinfo buffer\n");
 		ret = -ENOMEM;
 	} else {
 		fb->info = (struct fbinfo_s *)mem;
-                fb->dma = dma;
-        }
-	fb->fb.fbops		= &bcm2708_fb_ops;
-	fb->fb.flags		= FBINFO_FLAG_DEFAULT | FBINFO_HWACCEL_COPYAREA | FBINFO_HWACCEL_FILLRECT |  FBINFO_HWACCEL_IMAGEBLIT;
-	fb->fb.pseudo_palette	= fb->cmap;
+		fb->dma = dma;
+	}
+	fb->fb.fbops = &bcm2708_fb_ops;
+	fb->fb.flags = FBINFO_FLAG_DEFAULT;
+	fb->fb.pseudo_palette = fb->cmap;
 
 	strncpy(fb->fb.fix.id, bcm2708_name, sizeof(fb->fb.fix.id));
-	fb->fb.fix.type		= FB_TYPE_PACKED_PIXELS;
-	fb->fb.fix.type_aux	= 0;
-	fb->fb.fix.xpanstep	= 0;
-	fb->fb.fix.ypanstep	= 0;
-	fb->fb.fix.ywrapstep	= 0;
-	fb->fb.fix.accel	= FB_ACCEL_NONE;
-
-	fb->fb.var.xres		= FBWIDTH;
-	fb->fb.var.yres		= FBHEIGHT;
-	fb->fb.var.xres_virtual	= FBWIDTH;
-	fb->fb.var.yres_virtual	= FBHEIGHT;
+	fb->fb.fix.type = FB_TYPE_PACKED_PIXELS;
+	fb->fb.fix.type_aux = 0;
+	fb->fb.fix.xpanstep = 0;
+	fb->fb.fix.ypanstep = 0;
+	fb->fb.fix.ywrapstep = 0;
+	fb->fb.fix.accel = FB_ACCEL_NONE;
+
+	fb->fb.var.xres = fbwidth;
+	fb->fb.var.yres = fbheight;
+	fb->fb.var.xres_virtual = fbwidth;
+	fb->fb.var.yres_virtual = fbheight;
 	fb->fb.var.bits_per_pixel = 16;
-	fb->fb.var.vmode	= FB_VMODE_NONINTERLACED;
-	fb->fb.var.activate	= FB_ACTIVATE_NOW;
-	fb->fb.var.nonstd	= 0;
-	fb->fb.var.height	= FBWIDTH;
-	fb->fb.var.width	= FBHEIGHT;
-	fb->fb.var.accel_flags	= 0;
-
-	fb->fb.monspecs.hfmin	= 0;
-	fb->fb.monspecs.hfmax   = 100000;
-	fb->fb.monspecs.vfmin	= 0;
-	fb->fb.monspecs.vfmax	= 400;
+	fb->fb.var.vmode = FB_VMODE_NONINTERLACED;
+	fb->fb.var.activate = FB_ACTIVATE_NOW;
+	fb->fb.var.nonstd = 0;
+	fb->fb.var.height = fbwidth;
+	fb->fb.var.width = fbheight;
+	fb->fb.var.accel_flags = 0;
+
+	fb->fb.monspecs.hfmin = 0;
+	fb->fb.monspecs.hfmax = 100000;
+	fb->fb.monspecs.vfmin = 0;
+	fb->fb.monspecs.vfmax = 400;
 	fb->fb.monspecs.dclkmin = 1000000;
-	fb->fb.monspecs.dclkmax	= 100000000;
+	fb->fb.monspecs.dclkmax = 100000000;
 
 	bcm2708_fb_set_bitfields(&fb->fb.var);
 
@@ -350,17 +375,16 @@ static int bcm2708_fb_register(struct bcm2708_fb *fb)
 
 	fb_set_var(&fb->fb, &fb->fb.var);
 
-	printk(KERN_INFO "BCM2708FB: registering framebuffer (%d, %d)\n", FBWIDTH, FBHEIGHT);
+	pr_info("BCM2708FB: registering framebuffer (%d, %d)\n", fbwidth,
+		fbheight);
 
 	ret = register_framebuffer(&fb->fb);
-	printk(KERN_ERR "BCM2708FB: register framebuffer (%d)\n", ret);
+	pr_info("BCM2708FB: register framebuffer (%d)\n", ret);
 	if (ret == 0)
 		goto out;
 
-	printk(KERN_ERR "BCM2708FB: cannot register framebuffer (%d)\n", ret);
-
-	iounmap(fb->regs);
- out:
+	pr_info("BCM2708FB: cannot register framebuffer (%d)\n", ret);
+out:
 	return ret;
 }
 
@@ -371,7 +395,8 @@ static int bcm2708_fb_probe(struct platform_device *dev)
 
 	fb = kmalloc(sizeof(struct bcm2708_fb), GFP_KERNEL);
 	if (!fb) {
-		dev_err(&dev->dev, "could not allocate new bcm2708_fb struct\n");
+		dev_err(&dev->dev,
+			"could not allocate new bcm2708_fb struct\n");
 		ret = -ENOMEM;
 		goto free_region;
 	}
@@ -386,9 +411,9 @@ static int bcm2708_fb_probe(struct platform_device *dev)
 	}
 
 	kfree(fb);
- free_region:
+free_region:
 	dev_err(&dev->dev, "probe failed, err %d\n", ret);
- out:
+out:
 	return ret;
 }
 
@@ -398,22 +423,24 @@ static int bcm2708_fb_remove(struct platform_device *dev)
 
 	platform_set_drvdata(dev, NULL);
 
+	if (fb->fb.screen_base)
+		iounmap(fb->fb.screen_base);
 	unregister_framebuffer(&fb->fb);
-	iounmap(fb->regs);
 
-        dma_free_coherent(NULL, PAGE_ALIGN(sizeof(*fb->info)), (void *)fb->info, fb->dma);
+	dma_free_coherent(NULL, PAGE_ALIGN(sizeof(*fb->info)), (void *)fb->info,
+			  fb->dma);
 	kfree(fb);
 
 	return 0;
 }
 
 static struct platform_driver bcm2708_fb_driver = {
-	.probe		= bcm2708_fb_probe,
-	.remove		= bcm2708_fb_remove,
-	.driver		= {
-		.name	= DRIVER_NAME,
-		.owner  = THIS_MODULE,
-	},
+	.probe = bcm2708_fb_probe,
+	.remove = bcm2708_fb_remove,
+	.driver = {
+		   .name = DRIVER_NAME,
+		   .owner = THIS_MODULE,
+		   },
 };
 
 static int __init bcm2708_fb_init(void)
@@ -430,11 +457,11 @@ static void __exit bcm2708_fb_exit(void)
 
 module_exit(bcm2708_fb_exit);
 
-module_param(FBWIDTH, int, 0644);
-module_param(FBHEIGHT, int, 0644);
+module_param(fbwidth, int, 0644);
+module_param(fbheight, int, 0644);
 
 MODULE_DESCRIPTION("BCM2708 framebuffer driver");
 MODULE_LICENSE("GPL");
 
-MODULE_PARM_DESC(FBWIDTH, "Width of ARM Framebuffer");
-MODULE_PARM_DESC(FBHEIGHT, "Height of ARM Framebuffer");
+MODULE_PARM_DESC(fbwidth, "Width of ARM Framebuffer");
+MODULE_PARM_DESC(fbheight, "Height of ARM Framebuffer");
-- 
1.7.8.1

