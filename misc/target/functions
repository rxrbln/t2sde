# -*- sh -*-

source misc/target/functions.iso

# root path where we do the iso,initrd,rootfs etc. generation
imagedir=$build_rock/$target
topdir=$PWD

# copy_from_pkg pkg-name destination [glob-match-1 [glob-match-2 [...]]]
# 
# Copy a file from the target into a specified destination.
# This should make unpacking/building e.g. syslinux in the
# target/*/build.sh file superfluous.
#
# Example: 
# $ copy_from_pkg grub dest '/stage*' -*/share/* -*/doc/*
# cp boot/grub/stage1 dest
# cp boot/grub/stage2 dest
# $ copy_from_pkg syslinux dest "isolinux.bin"
# cp usr/lib/syslinux/isolinux.bin dest
copy_from_pkg() {
    local flist=$build_root/var/adm/flists/$1 ; shift
    local dest=$1 ; shift
    local dummy file sedexp list p tmp
    local arg

    # addiditve matches
    for arg in "$@"; do
	case "$arg" in
	    -*) continue ;;
	    +*) arg="`echo $arg | sed 's,^+,,;'`" ;;
	esac
	arg="`echo "$arg" | sed 's,[*],[^ ]*,g; s,[?],.,g;'`"

	while read dummy file; do
	    var_append list ' ' "$file"
	done < <(egrep "$arg" $flist)
    done

    # subtractive matches
    for arg in $* -var/adm/*; do
	case "$arg" in
	    -*) arg="`echo $arg | sed 's,^-,,; s,[*],[^ ]*,g; s,[?],.,g;'`" ;;
	    *) continue ;;
	esac

	#FIXME does not work due to '/' in $arg...: var_remove_regex list ' ' "$arg"
	#HACK ALTER
	dummy="$list" ; list=
	for p in $dummy; do
	    tmp="`echo $p | sed "s,$arg,,"`"
	    [ -n "$tmp" ] && var_append list ' ' "$p"
	done
    done

    # do the copy
    for p in $list; do
	if [ -f $build_root/$p ]; then
	    mkdir -p $dest/`dirname $p`
	    cp -a $build_root/$p $dest/$p
#FIXME do I need this:
	elif [ -d $build_root/$p ];  then
	    mkdir -p $dest/$p
	else
	    echo_error "Unknown file type ($p)"
	fi
    done
}

# pkgsel_update_tmpl -- update the package selection from pkgsel.tmpl and rerun config
#                       this function is only usefule while developing 
#                       a target, so everything is updated correctly
pkgsel_update_tmpl() {
    if [ "$ROCKCFG_TARGET_DEBUG" = "yes" ]; then
	if test target/$target/pkgsel.tmpl -nt target/$target/pkgsel; then
	    echo_header "Updating package selection..."
	    grep -v -E "^(#.*)?([ \t].*)?$" target/$target/pkgsel.tmpl \
		| awk '{ print $1 " " $3; }' \
		> target/$target/pkgsel
	    
            # rerun config
	    scripts/Config -cfg $target -oldconfig
	    
	    target_essential_changes=1
	    echo_status "Done."
	fi
    fi
}

# initrd_parse_config -- create initrd tree's according to $target/initrd.cfg
# 
# Variables exported:
#   initrd_name
#   initrd_title
#   initrd_kernel
#   initrd_type initrd_type_args
#   initrd_create_func
initrd_parse_config() {
    local option args cmd each swallow
    local pkg_default_args pkg_name pkg_args

    if [ ! -f "target/$target/initrd.cfg" ]; then
	echo_error "No initrd.cfg in this target..."
	return
    fi

    while read option args; do
	case "$option" in
	    # currently we only support a default for "pkg" selection
	    default)		
		read cmd args < <(echo $args)
		case "$cmd" in
		    pkg)
			pkg_default_args="$pkg_default_args $args"
			;;
		    *)
			echo_error "Error in target/$target/initrd.cfg"
			exit -1
			;;
		esac
		;;
	    # the main line for creating an initrd
	    initrd)
		read initrd_name swallow < <(echo $args) ; export initrd_name
		echo_header "Creating $initrd_name initrd..."
		rm -rf $imagedir/$initrd_name
		rm -rf $imagedir/$initrd_name.cfg
		mkdir -p $imagedir/$initrd_name
		mkdir -p $imagedir/$initrd_name/{dev,udev,sys,boot}
		echo "initrd $initrd_name" >> $imagedir/$initrd_name.cfg
		;;
	    # unpacking and extra functions to call
	    pkg)
		read pkg_name pkg_args < <(echo $args)
		echo_status "Copying files from $pkg_name..."
		eval "copy_from_pkg $pkg_name $imagedir/$initrd_name $pkg_args $pkg_default_args"
		;;
	    func)
		for each in $args; do
		    eval "$each"
		done
		;;
	    # following is only needed while the initrd creation, so
	    # the info is only recorded in the respective .cfg file,
	    # one exception, some variables my be need by the "func" 
	    # function called
	    title)  
		export initrd_title="$args"
		echo "title $args" >> $imagedir/$initrd_name.cfg 
		;;
	    kernel) 
		export initrd_kernel="$args"
		echo "kernel $args" >> $imagedir/$initrd_name.cfg 
		;;
	    type)   
		read initrd_type initrd_type_args < <(echo $args) ; export initrd_type initrd_type_args
		echo "type $args" >> $imagedir/$initrd_name.cfg 
		;;
	    create) 
		export initrd_create_func="$args"
		echo "create $args" >> $imagedir/$initrd_name.cfg 
		;;
	esac
    done < <(egrep -v "^(#.*)?$" target/$target/initrd.cfg)
}

# initrd_get_configs -- list initrd configs
initrd_get_configs() {
    local option args

    if [ ! -f "target/$target/initrd.cfg" ]; then
	echo_error "No initrd.cfg in this target..."
	return
    fi

    while read option args; do
	case "$option" in
	    initrd) echo "$args" ;;
	esac
    done < <(egrep -v "^(#.*)?$" target/$target/initrd.cfg)
}

# initrd_create -- create the initrd images
#
# Variables exported:
#   initrd_name
#   initrd_title
#   initrd_kernel
#   initrd_type
#   initrd_type_args
#   initrd_create_func
initrd_create() {
    local each swallow
    local kver ktree

    # parse config
    for each in `initrd_get_configs`; do
	# read single initrd config
	while read option args; do
	    case "$option" in
		initrd) read initrd_name swallow < <(echo $args) ; export initrd_name ;;
		title)  export initrd_title="$args" ;;
		kernel) export initrd_kernel="$args" ;;
		type)   read initrd_type initrd_type_args < <(echo $args) ; export initrd_type initrd_type_args ;;
		create) export initrd_create_func="$args" ;;
	    esac
	done < <(egrep -v "^(#.*)?$" $imagedir/$each.cfg)
	
	echo_header "Creating initrd ($initrd_name)"

        # kernel version and tree
	kver="`grep lib/modules  $build_root/var/adm/flists/$initrd_kernel |
              cut -d ' ' -f 2 | cut -d / -f 3 | head -n 1`" # FIXME check

	case "$kver" in
	    2.4.*) ktree=24 ;;
	    2.6.*) ktree=26 ;;
	esac

	# check type of image to create
	case "$initrd_type" in
	    cramfs)
		if ! grep -q "CONFIG_CRAMFS=y" $build_root/boot/kconfig_$kver; then
		    echo_error "cramfs not supported by selected kernel"
		    exit -1
		fi
		;;
	    squashfs)
		if ! grep -q "CONFIG_SQUASHFS=y" $build_root/boot/kconfig_$kver; then
		    echo_error "squashfs not supported by selected kernel"
		    exit -1
		fi
		;;
	    *)
		echo_error "Creating initrd with \"$initrd_type\" file system (currently) not supported"
		exit -1
		;;
	esac

	# Create init
	echo_status "Creating init..."

	# default flags
	CFLAGS="-Os -s -I$topdir/misc/target/src -I$build_root/usr/include"

	# devfs flags
	grep -q "CONFIG_DEVFS_FS=y" $build_root/boot/kconfig_$kver && CFLAGS="$CFLAGS -DWITH_DEVFS"
	grep -q "CONFIG_DEVFS_FS=m" $build_root/boot/kconfig_$kver && CFLAGS="$CFLAGS -DWITH_DEVFS_MODULE"

	# FIXME should be configurable
	CFLAGS="$CFLAGS -DUSE_CDROM"
	CFLAGS="$CFLAGS -DUSE_HWDETECT"
	CFLAGS="$CFLAGS -DDEBUG"
	
	# compile init
	eval "$CC -static $CFLAGS -o $imagedir/$initrd_name/linuxrc $topdir/misc/target/src/linuxrc.c"

	# Create image
	if [ -n "$initrd_create_func" ]; then
	    eval "$initrd_create_func"
	else
	    case "$initrd_type" in
		cramfs)
		    eval "mkcramfs $initrd_type_args $imagedir/$initrd_name $imagedir/$initrd_name.img"
		    ;;
		*)	echo_error "Image type \"$type\" currently not supported" ;;
	    esac
	fi
    done
}
