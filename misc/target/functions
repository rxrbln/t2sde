# -*- sh -*-

source misc/target/functions.iso

# root path where we do the iso,initrd,rootfs etc. generation
imagedir=$build_rock/$target
topdir=$PWD

# copy_from_pkg [options] pkg-name destination [glob-match-1 [glob-match-2 [...]]]
# 
# Copy a file from the target into a specified destination.
# The source path is kept unless -f or -s options are set.
#
# This should make unpacking/building e.g. syslinux in the
# target/*/build.sh file superfluous.
#
# Options:
#   -f            Copy file only (without tree)
#   -s 'sed-expr' Sed expression for installation path
#
# Example: 
# $ copy_from_pkg grub dest '/stage*' -*/share/* -*/doc/*
# cp -a boot/grub/stage1 dest
# cp -a boot/grub/stage2 dest
# $ copy_from_pkg -f syslinux dest "isolinux.bin"
# cp usr/lib/syslinux/isolinux.bin dest
copy_from_pkg() {
    local arg flist dest sedexpr
    local match_del match_add
    local src srcorig

    # options
    for arg in "$@"; do
	case "$arg" in
	    -f) sedexpr='s,.*/,,' ; shift ;;
	    -s) sedexpr="$2" ; shift ; shift ;;
	    *) break ;;
	esac
    done

    flist=$build_root/var/adm/flists/$1 ; shift
    dest=$1 ; shift

    # addiditve matches
    for arg in "$@"; do
	arg="`echo "$arg" | sed 's,"\([^"]*\)",\1,'`"

	case "$arg" in
	    -*) continue ;;
	    +*) arg="`echo "$arg" | sed 's,^+,,;'`" ;;
	esac
	arg="`echo "$arg" | sed 's,[*],[^ ]*,g; s,[?],.,g;'`"

	var_append match_add '|' "(^$arg\$)"
    done

    # subtractive matches
    for arg in "$@"; do
	arg="`echo "$arg" | sed 's,"\([^"]*\)",\1,'`"

	case "$arg" in
	    -*) arg="`echo "$arg" | sed 's,^-,,; s,[*],[^ ]*,g; s,[?],.,g;'`" ;;
	    *) continue ;;
	esac

	var_append match_del '|' "(^$arg\$)"
    done

    # do the copy
    for src in `awk '{ print "/" $2; }' < $flist | egrep "$match_add" | egrep -v "$match_del"`; do
	srcorig="$src"
	[ -n "$sedexpr" ] && src="`echo "$src" | sed "$sedexpr"`"

	mkdir -p $dest/`dirname $src`
	cp -a $build_root/$srcorig $dest/$src
    done
}

# option_parser_skeleton config-file [option-definitions] -- see image_parse_cfg for usage
option_parser_skeleton() {
    local cfg=$1 ; shift
    local arg case_def
    local def fnc
    local option args

    # assemble switch statement
    for arg in "$@"; do
	def="${arg%%:*}"
	fnc="${arg#*:}"
	
	var_append case_def ';; ' "$def) $fnc"
    done

    while read option args; do
	eval "case "$option" in $case_def ;; esac"
    done < <(egrep -v "^(#.*)?$" $cfg)
}

# image_parse_cfg config-file -- creates an image out a config file, see README
image_parse_cfg() {
    local cmd kver ktree

    # parse options stage 1 (unpacking, adaption functions and per-image config)
    option_parser_skeleton $1 \
	'default: read cmd args < <(echo $args);
                  if [ "$cmd" = "pkg" ]; then
                      pkg_selection_defaults="$args";
                  else
                      echo_error "Error in config";
                  fi' \
        'initrd: image_name=$args ; var_append image_list " " "$args" ; echo "initrd $args" > $imagedir/$image_name.cfg' \
	'title:  image_title="$args" ; echo "title $args" >> $imagedir/$image_name.cfg' \
        'kernel: image_kernel=$args ; echo "kernel $args" >> $imagedir/$image_name.cfg' \
	'init-flags:  echo "init-flags $args" >> $imagedir/$image_name.cfg' \
	'init-srcs:  echo "init-srcs $args" >> $imagedir/$image_name.cfg' \
	'type:   read cmd args < <(echo $args);
                 image_type=$cmd;
                 image_type_args="$args";
                 echo "type $args" >> $imagedir/$image_name.cfg' \
	'func:   eval "$args"' \
	'pkg:    read cmd args < <(echo $args);
                 copy_from_pkg $cmd $imagedir/$image_name $args $pkg_selection_defaults'

    # parse options stage 2 (init and image creation)
    for each in $image_list; do
	# parse per image config
	image_kernel=
	image_init_flags=
	image_init_srcs=
	image_type=
	image_type_args=

	option_parser_skeleton $imagedir/$image_name.cfg \
            'initrd: image_name=$args' \
	    'title:  image_title="$args"' \
            'kernel: image_kernel=$args' \
            'init-flags: image_init_flags="$args"' \
            'init-srcs: image_init_srcs="$args"' \
	    'type:   read cmd args < <(echo $args);
                 image_type=$cmd;
                 image_type_args="$args"'

        # kernel version and tree
	kver="`grep lib/modules  $build_root/var/adm/flists/$image_kernel |
              cut -d ' ' -f 2 | cut -d / -f 3 | head -n 1`"

	case "$kver" in
	    2.4.*) ktree=24 ;;
	    2.6.*) ktree=26 ;;
	esac

	# Create init
	echo_status "Creating init..."

	# default flags
	CFLAGS="-Os -s -I$topdir/misc/target/src -I$build_root/usr/include $image_init_flags"

	# kernel related cflags
	grep -q "CONFIG_DEVFS_FS=y" $build_root/boot/kconfig_$kver && CFLAGS="$CFLAGS -DWITH_DEVFS"
	grep -q "CONFIG_DEVFS_FS=m" $build_root/boot/kconfig_$kver && CFLAGS="$CFLAGS -DWITH_DEVFS_MODULE"

	# compile init
	#FIXME handle init-srcs
	eval "$CC -static $CFLAGS -o $imagedir/$image_name/linuxrc $topdir/misc/target/src/linuxrc.c"
	
	# image creation
	if [ "$image_type" = "cramfs" ]; then mkcramfs $image_type_args $imagedir/$image_name $imagedir/$image_name.img; 
	elif [ "$image_type" = "squashfs" ]; then mkcramfs $image_type_args $imagedir/$image_name $imagedir/$image_name.img; 
	elif [ -n "$image_type" ]; then eval "$image_type $image_type_args"; fi
    done
}

# pkgsel_update_tmpl -- update the package selection from pkgsel.tmpl and rerun config
#                       this function is only usefule while developing 
#                       a target, so everything is updated correctly
pkgsel_update_tmpl() {
    if [ "$ROCKCFG_TARGET_DEBUG" = "yes" ]; then
	if test target/$target/pkgsel.tmpl -nt target/$target/pkgsel; then
	    echo_header "Updating package selection..."
	    grep -v -E "^(#.*)?([ \t].*)?$" target/$target/pkgsel.tmpl \
		| awk '{ print $1 " " $3; }' \
		> target/$target/pkgsel
	    
            # rerun config
	    scripts/Config -cfg $target -oldconfig
	    
	    target_essential_changes=1
	    echo_status "Done."
	fi
    fi
}
