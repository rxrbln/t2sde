/*
 * --- T2-COPYRIGHT-NOTE-BEGIN ---
 * This copyright note is auto-generated by ./scripts/Create-CopyPatch.
 * 
 * T2 SDE: misc/luabash/luabash.c
 * Copyright (C) 2006 The T2 SDE Project
 * 
 * More information can be found in the files COPYING and README.
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License. A copy of the
 * GNU General Public License can be found in the file COPYING.
 * --- T2-COPYRIGHT-NOTE-END ---
 */


// compile with:
// gcc -shared -fPIC -Wall -o luabash.so luabash.c -llua -lm -Wall -ldl

/* Some declarations copied from bash-3.1 headers */

#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>


#define EXECUTION_SUCCESS 0
#define EXECUTION_FAILURE 1

typedef struct word_desc {
  char *word;
  int flags;
} WORD_DESC;

typedef struct word_list {
  struct word_list *next;
  WORD_DESC *word;
} WORD_LIST;

typedef int sh_builtin_func_t(WORD_LIST *);

#define BUILTIN_ENABLED 0x1
#define STATIC_BUILTIN  0x4	/* This builtin is not dynamically loaded. */
#define SPECIAL_BUILTIN 0x8	/* This is a Posix `special' builtin. */

struct builtin {
  char *name;
  sh_builtin_func_t *function;
  int flags;
  char * const *long_doc;
  const char *short_doc;
  char *handle;
};

struct variable;
typedef intmax_t arrayind_t;

typedef struct variable *sh_var_value_func_t(struct variable *);
typedef struct variable *sh_var_assign_func_t(struct variable *, char *, arrayind_t);

typedef struct variable {
  char *name;
  char *value;
  char *exportstr;
  sh_var_value_func_t *dynamic_value;
  sh_var_assign_func_t *assign_func;
  int attributes;
  int context;
} SHELL_VAR;

extern SHELL_VAR* find_variable(const char *);
extern SHELL_VAR* bind_variable(const char *, const char *);
#define value_cell(var) ((var)->value)

extern int num_shell_builtins;	/* Number of shell builtins. */
extern struct builtin static_shell_builtins[];
extern struct builtin* shell_builtins;
extern void initialize_shell_builtins __P((void));
extern struct builtin* builtin_address_internal __P((char *, int));


extern void add_alias __P((const char *, const char *));


#ifdef DO_DYNAMIC_REGISTRATION

/* dynamic registration, not needed anymore.
 * want to keep that code, one never knows if we might need it again!
 *
 * Valentin.
 */

static int inject_new_builtin (struct builtin* b)
{
  struct builtin* old_builtin;

  b->flags |= STATIC_BUILTIN;
  /*if (flags & SPECIAL)
    b->flags |= SPECIAL_BUILTIN;*/
   
  if ( (old_builtin = builtin_address_internal (b->name, 1)) != 0 ) {
    memcpy ((void*) old_builtin, b, sizeof (struct builtin));
  } else {
    int total = num_shell_builtins + 1;
    int size = (total + 1) * sizeof (struct builtin);

    struct builtin* new_shell_builtins = (struct builtin*) malloc (size);
    memcpy ((void*) new_shell_builtins, (void*) shell_builtins,
	    num_shell_builtins * sizeof (struct builtin));
    memcpy ((void*) &new_shell_builtins[num_shell_builtins], (void*)b, sizeof (struct builtin));
    new_shell_builtins[total].name = (char *)0;
    new_shell_builtins[total].function = (sh_builtin_func_t *)0;
    new_shell_builtins[total].flags = 0;
      
    if (shell_builtins != static_shell_builtins)
      free (shell_builtins);

    shell_builtins = new_shell_builtins;
    num_shell_builtins = total;
    initialize_shell_builtins ();
  }

  return EXECUTION_SUCCESS;
}

#endif

/* helpers to work with variables, thanks to clifford */

static const char *getvar(const char *name)
{
	SHELL_VAR *var;
	var = find_variable(name);
	return var ? value_cell(var) : 0;
}

#define setvar(a,b) bind_variable(a,b)




/* lua bash wrapper */

#define LUABASH_VERSION "lua bash wrapper version 0.0.1; (C) 2006 Valentin Ziegler."

#define LUA_ERRMSG fprintf(stderr, "lua bash error: %s\n", lua_tostring(L, -1))
#define LUA_ERRMSG_FAIL {LUA_ERRMSG; return EXECUTION_FAILURE;}

char* luabash_doc[] = {
  LUABASH_VERSION,
  "usage:",
  "\tinit",
  "\tload <lua chunk>",
  "\tcall <lua function> [arguments]",
  (char*) 0
};

static int initialized=0;
static lua_State* L;

static void print_usage()
{
  int i=0;
  while(luabash_doc[i])
    fprintf(stderr, "%s\n", luabash_doc[i++]);
}

static int register_function (lua_State *L)
{
  const char* fmt="luabash call %s ";
  const char* fnname = luaL_checkstring(L, 1);
  char* fullname=(char*) malloc(strlen(fmt)+strlen(fnname));
  sprintf(fullname, fmt, fnname);
  add_alias(fnname, fullname);
  return 0;
}

static int get_variable (lua_State *L)
{
  const char* vname = luaL_checkstring(L, 1);
  lua_pushstring(L, getvar(vname));
  return 1;
}

static int set_variable (lua_State *L)
{
  const char* vname = luaL_checkstring(L, 1);
  const char* vvalue = luaL_checkstring(L, 2);
  setvar(vname, vvalue);
  return 0;
}


static const luaL_Reg bashlib[] = {
  {"register", register_function},
  {"getVariable",get_variable},
  {"setVariable",set_variable},
  {NULL, NULL}
};

static int init_luabash()
{
  if (!initialized) {
    L=luaL_newstate ();
    if (!L) {
      fprintf(stderr, "lua bash error: failed to initialize lua state\n");
      return EXECUTION_FAILURE;     
    }

    luaL_openlibs(L);
    luaL_register(L, "bash", bashlib);
    
    initialized=1;
  }

  return EXECUTION_SUCCESS;
}

static int load_chunk(const char* filename)
{
  int result=init_luabash();
  if (result != EXECUTION_SUCCESS)
    return result;

  if (luaL_loadfile(L, filename) || lua_pcall(L, 0, 0, 0))
    LUA_ERRMSG_FAIL;

  return EXECUTION_SUCCESS;
}

static int call_function(const char* func, WORD_LIST *args)
{
  if (!initialized) {
    fprintf(stderr, "lua bash error: not initialized yet!\n");
    return EXECUTION_FAILURE;
  }

  lua_getfield(L, LUA_GLOBALSINDEX, func);
  int no_args=0;
  while (args) {
    if (args->word->word) {
      lua_pushstring(L, args->word->word);
      no_args++;
    }
    args=args -> next;
  }

  if (lua_pcall(L, no_args, 0, 0))
    LUA_ERRMSG_FAIL;

  return EXECUTION_SUCCESS;
}


int luabash_builtin(WORD_LIST *list)
{
  if (list  && (list->word->word)) {
    char* command=list->word->word;
    if (strcmp(command, "init") == 0) {
      return init_luabash();
    } else if (strcmp(command, "load") == 0) {
      list=list->next;
      if (list && (list->word->word))
	return load_chunk(list->word->word);
    } else if (strcmp(command, "call") == 0) {
      list=list->next;
      if (list && (list->word->word))
	return call_function(list->word->word, list->next);
    }
  }

  print_usage();
  return EXECUTION_FAILURE;
}



struct builtin luabash_struct = {
	"luabash",
	&luabash_builtin,
	BUILTIN_ENABLED,
	luabash_doc,
	LUABASH_VERSION,
	0
};

